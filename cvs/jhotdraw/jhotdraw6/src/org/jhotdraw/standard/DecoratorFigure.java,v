head	1.9;
access;
symbols
	jhotdraw60b1-release:1.9
	package_rename:1.9
	directory_rename:1.8
	reorg_6x_split_initial:1.8
	MVC_PHASE1:1.8.0.4
	NEW_ATTRIBUTES:1.8.0.2
	DNOYEB1_ALPHA-2:1.7.4.7
	release_JHD54b1:1.8
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7.4.6
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.6
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.22.08.58.22;	author mrfloppy;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.7.4.1
date	2003.01.14.18.25.12;	author dnoyeb;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.01.15.21.04.21;	author dnoyeb;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.01.16.15.59.18;	author dnoyeb;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.01.18.04.49.05;	author dnoyeb;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2003.01.20.18.23.31;	author dnoyeb;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2003.01.21.00.04.38;	author dnoyeb;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2003.01.26.00.51.15;	author dnoyeb;	state Exp;
branches;
next	1.7.4.8;

1.7.4.8
date	2003.02.02.16.54.09;	author dnoyeb;	state Exp;
branches;
next	1.7.4.9;

1.7.4.9
date	2003.02.03.19.23.24;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.9
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)DecoratorFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import org.jhotdraw.util.*;
import org.jhotdraw.framework.*;

import java.awt.*;
import java.io.*;

/**
 * DecoratorFigure can be used to decorate other figures with
 * decorations like borders. Decorator forwards all the
 * methods to their contained figure. Subclasses can selectively
 * override these methods to extend and filter their behavior.
 * <hr>
 * <b>Design Patterns</b><P>
 * <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
 * <b><a href=../pattlets/sld014.htm>Decorator</a></b><br>
 * DecoratorFigure is a decorator.
 *
 * @@see Figure
 *
 * @@version <$CURRENT_VERSION$>
 */

public abstract class DecoratorFigure
				extends AbstractFigure
				implements FigureChangeListener {

	/**
	 * The decorated figure.
	 */
	private Figure myDecoratedFigure;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = 8993011151564573288L;
	private int decoratorFigureSerializedDataVersion = 1;

	public DecoratorFigure() {
		initialize();
	}

	/**
	 * Constructs a DecoratorFigure and decorates the passed in figure.
	 */
	public DecoratorFigure(Figure figure) {
		initialize();
		decorate(figure);
	}

	/**
	 * Performs additional initialization code before the figure is decorated.
	 * Subclasses may override this method.
	 */
	protected void initialize() {
	}

	/**
	 * Forwards the connection insets to its contained figure..
	 */
	public Insets connectionInsets() {
		return getDecoratedFigure().connectionInsets();
	}

	/**
	 * Forwards the canConnect to its contained figure..
	 */
	public boolean canConnect() {
		return getDecoratedFigure().canConnect();
	}

	/**
	 * Forwards containsPoint to its contained figure.
	 */
	public boolean containsPoint(int x, int y) {
		return getDecoratedFigure().containsPoint(x, y);
	}

	/**
	 * Decorates the given figure.
	 */
	public void decorate(Figure figure) {
		setDecoratedFigure(figure);
		getDecoratedFigure().addToContainer(this);
		//addDependendFigure(getDecoratedFigure());
	}

	/**
	 * Removes the decoration from the contained figure.
	 */
	public Figure peelDecoration() {
		getDecoratedFigure().removeFromContainer(this); //??? set the container to the listener()?
		removeDependendFigure(getDecoratedFigure());
		return getDecoratedFigure();
	}

	public void setDecoratedFigure(Figure newDecoratedFigure) {
		myDecoratedFigure = newDecoratedFigure;
	}

	public Figure getDecoratedFigure() {
		return myDecoratedFigure;
	}

	/**
	 * Forwards displayBox to its contained figure.
	 */
	public Rectangle displayBox() {
		return getDecoratedFigure().displayBox();
	}

	/**
	 * Forwards basicDisplayBox to its contained figure.
	 */
	public void basicDisplayBox(Point origin, Point corner) {
		getDecoratedFigure().basicDisplayBox(origin, corner);
	}

	/**
	 * Forwards draw to its contained figure.
	 */
	public void draw(Graphics g) {
		getDecoratedFigure().draw(g);
	}

	/**
	 * Forwards findFigureInside to its contained figure.
	 */
	public Figure findFigureInside(int x, int y) {
		Figure foundFigure = getDecoratedFigure().findFigureInside(x, y);
		// if the found figure is the same as the one the DecoratorFigure decorates
		// then do not peel of the decoration
		if ((foundFigure != null) && (foundFigure == getDecoratedFigure())) {
			return this;
		}
		else {
			return foundFigure;
		}
	}

	/**
	 * Forwards handles to its contained figure.
	 */
	public HandleEnumeration handles() {
		return getDecoratedFigure().handles();
	}

	/**
	 * Forwards includes to its contained figure.
	 */
	public boolean includes(Figure figure) {
		return (super.includes(figure) || getDecoratedFigure().includes(figure));
	}

	/**
	 * Forwards moveBy to its contained figure.
	 */
	public void moveBy(int x, int y) {
		getDecoratedFigure().moveBy(x, y);
	}

	/**
	 * Forwards basicMoveBy to its contained figure.
	 */
	protected void basicMoveBy(int x, int y) {
		// this will never be called
	}

	/**
	 * Releases itself and the contained figure.
	 */
	public void release() {
		super.release();
		getDecoratedFigure().removeFromContainer(this);
		getDecoratedFigure().release();
	}

	/**
	 * Propagates invalidate up the container chain.
	 * @@see FigureChangeListener
	 */
	public void figureInvalidated(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureInvalidated(e);
		}
	}

	public void figureChanged(FigureChangeEvent e) {
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	/**
	 * Propagates figureRequestUpdate up the container chain.
	 * @@see FigureChangeListener
	 */
	public  void figureRequestUpdate(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureRequestUpdate(e);
		}
	}

	/**
	 * Propagates the removeFromDrawing request up to the container.
	 * @@see FigureChangeListener
	 */
	public void figureRequestRemove(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureRequestRemove(new FigureChangeEvent(this));
		}
	}

	/**
	 * Forwards figures to its contained figure.
	 */
	public FigureEnumeration figures() {
		return getDecoratedFigure().figures();
	}

	/**
	 * Forwards decompose to its contained figure.
	 */
	public FigureEnumeration decompose() {
		return getDecoratedFigure().decompose();
	}

	/**
	 * Forwards setAttribute to its contained figure.
	 *
	 * @@deprecated use setAttribute(FigureAttributeConstant, Object) instead
	 */
	public void setAttribute(String name, Object value) {
		getDecoratedFigure().setAttribute(name, value);
	}

	/**
	 * Forwards setAttribute to its contained figure.
	 */
	public void setAttribute(FigureAttributeConstant attributeConstant, Object value) {
		getDecoratedFigure().setAttribute(attributeConstant, value);
	}

	/**
	 * Forwards getAttribute to its contained figure.
	 *
	 * @@deprecated use getAttribute(FigureAttributeConstant) instead
	 */
	public Object getAttribute(String name) {
		return getDecoratedFigure().getAttribute(name);
	}

	/**
	 * Forwards getAttribute to its contained figure.
	 */
	public Object getAttribute(FigureAttributeConstant attributeConstant) {
		return getDecoratedFigure().getAttribute(attributeConstant);
	}

	/**
	 * Returns the locator used to located connected text.
	 */
	public Locator connectedTextLocator(Figure text) {
		return getDecoratedFigure().connectedTextLocator(text);
	}

	/**
	 * Returns the Connector for the given location.
	 */
	public Connector connectorAt(int x, int y) {
		return getDecoratedFigure().connectorAt(x, y);
	}

	/**
	 * Forwards the connector visibility request to its component.
	 */
	public void connectorVisibility(boolean isVisible, ConnectionFigure courtingConnection) {
		getDecoratedFigure().connectorVisibility(isVisible, null);
	}

	/**
	 * Writes itself and the contained figure to the StorableOutput.
	 */
	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(getDecoratedFigure());
	}

	/**
	 * Reads itself and the contained figure from the StorableInput.
	 */
	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		decorate((Figure)dr.readStorable());
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		getDecoratedFigure().addToContainer(this);
	}
/*
	public void visit(FigureVisitor visitor) {
		super.visit(visitor);
//		getDecoratedFigure().visit(visitor);
	}
*/
	public TextHolder getTextHolder() {
		return getDecoratedFigure().getTextHolder();
	}

	public synchronized FigureEnumeration getDependendFigures() {
		return getDecoratedFigure().getDependendFigures();
	}

	public synchronized void addDependendFigure(Figure newDependendFigure) {
		getDecoratedFigure().addDependendFigure(newDependendFigure);
	}

	public synchronized void removeDependendFigure(Figure oldDependendFigure) {
		getDecoratedFigure().removeDependendFigure(oldDependendFigure);
	}
}
@


1.8
log
@prepare for 5.4 release: various bug fixes
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d14 2
a15 2
import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;
@


1.7
log
@introduce FigureVisitor for paste/delete commands
@
text
@d43 1
a43 1
	private Figure fComponent;
d95 3
a97 3
		fComponent = figure;
		fComponent.addToContainer(this);
		addDependendFigure(fComponent);
d109 4
d114 1
a114 1
		return fComponent;
d142 9
a150 1
		return getDecoratedFigure().findFigureInside(x, y);
d316 1
a316 1

d321 1
a321 1

d324 12
@


1.7.4.1
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d96 2
a97 2
		getDecoratedFigure().addFigureChangeListener( this );
		//addDependendFigure( getDecoratedFigure() );
d104 2
a105 2
		getDecoratedFigure().removeFigureChangeListener( this );
		//removeDependendFigure(getDecoratedFigure());
d170 1
a170 2
	 * Releases itself. removes then releases its containees.
	 * 
d173 2
a174 1
		getDecoratedFigure().remove();
a175 7
		super.release();
	}
	/**
	 * Do not remove containees in response to this event.
	 */
	public void remove(){
		super.remove();
d177 1
d184 1
a184 1
			listener().figureInvalidated( new FigureChangeEvent(this,e.getInvalidatedRectangle()));
d195 1
a195 3
     * Informs our container that we need to be updated.  We request this on 
	 * behalf of the decorated figure.
	 *
d200 1
a200 1
			listener().figureRequestUpdate(new FigureChangeEvent(this));
a205 6
	 * This is the only justified propagation of a request remove event.  This is
	 * also implemented correctly by repackaging the event so it appears to come
	 * from this figure.
	 * The decorator figure requests removal on behalf of the figure it is
	 * decorating.  the decorator figure is not allowed to exist without its
	 * decorated figure.
a208 2
		e.getFigure().removeFigureChangeListener(this);
		removeDependendFigure( e.getFigure() );
d302 1
a302 1
		getDecoratedFigure().addFigureChangeListener(this);
d307 1
a307 1
//		getDecoratedFigure().visit(visitor); !!!dnoyeb!!! this is a must right?
@


1.7.4.2
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@a30 14
 * The main problem is DecoratorFigure's inability to decorate a figure without
 * knowing all the methods that figure implements.  If it does not know all of
 * the decorated figures methods, it can not forward all the calls.  This hides
 * the internal figure from those <code>Tool</code>s and <code>Command</code>s
 * that would like to work on it.  It forces every <code>Tool</code> and <code>
 * Command</code> to check for its presence, and when found, query <code>
 * DecoratorFigure</code> for its decorated figure.  This is only a problem for
 * <code>Tool</code>s and <code>Command</code>s that have a particular class of
 * <code>Figure</code> they are able to work on.  This constitutes quite a few
 * of the <code>Tool</code>s and <code>Command</code>s.  Therefore, this pattern
 * does not integrate well with its intended role.  dnoyeb 1/15/03
 * 
 * @@deprecated For example of new implementation strategies see {@@link
 *             CH.ifa.draw.figures.BorderDecorator BorderDecorator}
@


1.7.4.3
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d195 2
a196 2
	public FigureChangeListener remove(){
		return super.remove();
@


1.7.4.4
log
@Decorator Figure returns...To apease the brave hearted :-)
Its not very well integrated with the current state of affairs.  It works as well as it always
has though.
@
text
@d16 1
a16 2
import java.util.List;
import java.util.Iterator;
d43 2
a44 4
 * Trying to ressurect with better methodology.
 *
 *
 *
d51 2
a52 29
				implements Figure, FigureChangeListener {
	/**
	 * The listeners for a figure's changes.
	 * It is only one listener but this one can be a (chained) MultiCastFigureChangeListener
	 *
	 * Need to figure out who restores this connection when the figure is reloaded !!!dnoyeb!!!
	 *
	 * @@see #invalidate
	 * @@see #changed
	 * @@see #willChange
	 */
	private transient FigureChangeListener fListener;
	
	/**
	 * The container of this figure.  Used to prevent a figure from being added
	 * to more than one container at a time.
	 */
	private transient FigureChangeListener container;
	
	/**
	 * The dependent figures which have been added to this container.
	 * This is an ordered collection.  The figures should be stored in the order
	 * in which they were added.  The figures should be loaded in the order in
	 * which they were stored.
	 * do dependent figures depend on us, or do we depend on them? ???dnoyeb???
	 * @@see #read
	 * @@see #write
	 */
	private List myDependentFigures;
a53 3
	private List fFigureManipulators;

	private List fFigureDecorators;
d73 1
a73 1
		this();
a81 3
		myDependentFigures = CollectionsFactory.current().createList();
		fFigureManipulators = CollectionsFactory.current().createList();
		fFigureDecorators = CollectionsFactory.current().createList();		
d111 1
a111 1
		addDependendFigure( getDecoratedFigure() );
a115 1
	 * The actual remove takes place from the removeRequestEvent.
d118 2
a119 1
		getDecoratedFigure().remove();
d166 1
a166 1
		return ((figure == this) || getDecoratedFigure().includes(figure));
d188 3
a190 6
		//getDecoratedFigure().release(); //decorator is dependent, it will be released by the architecture
		if( getContainer() != null ) {
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
			throw new JHotDrawRuntimeException("Figure can note be released, it has not been removed yet.");
		}
d193 1
a193 4
	 * We must remove containees, in case someone is dependent upon one of them
	 * and needs removal as well.
	 * Architecture automatically removes dependent figures for us. no need to remove them
	 * here.
d196 1
a196 10
		if( getContainer() == null ) {
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
			throw new JHotDrawRuntimeException("Figure can note be removed, it is not contained.");
		}			
		FigureChangeListener fcl =  getContainer();
		if(listener() != null) {
			listener().figureRequestRemove( new FigureChangeEvent(this));
		}
		return fcl;
a208 3
		if(listener() != null) {
			listener().figureChanged( new FigureChangeEvent(this));
		}
d239 3
a241 1
		remove();
d315 1
a315 18
		dw.writeInt( getZValue() );
		//store dependentFigures
		int size = myDependentFigures.size();
		FigureEnumeration fe = getDependendFigures();
		dw.writeInt( size );
		while (fe.hasNextFigure()) {
			dw.writeStorable(fe.nextFigure());
		}
		//store figuremanipulators
		dw.writeInt( fFigureManipulators.size() );
		for(Iterator it= fFigureManipulators.iterator();it.hasNext();) {
			dw.writeStorable( (FigureManipulator)it.next() );
		}
		//store figuredecorators
		dw.writeInt( fFigureDecorators.size() );
		for(Iterator it= fFigureDecorators.iterator();it.hasNext();) {
			dw.writeStorable( (Figure)it.next() );
		}	
d323 1
a323 20
		setZValue( dr.readInt() );
		//load dependentFigures
		int size = dr.readInt();
		myDependentFigures = CollectionsFactory.current().createList(size);
		for (int i=0; i<size; i++) {
			myDependentFigures.add( (Figure)dr.readStorable()) ;
		}

		//load figureManipulators
		int manipSize = dr.readInt();
		fFigureManipulators = CollectionsFactory.current().createList(manipSize);
		for (int i=0; i<manipSize; i++) {
			fFigureManipulators.add( (FigureManipulator)dr.readStorable()) ;
		}
		//load figureDecorators
		int decSize = dr.readInt();
		fFigureDecorators = CollectionsFactory.current().createList(decSize);
		for (int i=0; i<decSize; i++) {
			fFigureDecorators.add( (Figure)dr.readStorable()) ;
		}
d330 2
a331 3
		//since dependent figures are not transient, they get deserialized here
		//since FigureManipulators are not transient, they get deserialized here
		s.defaultReadObject();//Read the non-static and non-transient fields of the current class from this stream.
d334 1
a334 7
	/**
	 * @@todo Verify implementation.
	 */
	private void writeObject(ObjectOutputStream s) throws IOException {
		s.defaultWriteObject();
	}
	
d336 2
a337 31
		
		
		
		// remember original listener as listeners might be changed by a visitor
		// (e.g. by calling addToContainer() or removeFromContainer())
		//FigureChangeListener originalListener = listener();
		FigureEnumeration fe = getDependendFigures();

		visitor.visitFigure(this);

		FigureEnumeration visitFigures = figures();
		while (visitFigures.hasNextFigure()) {
			visitFigures.nextFigure().visit(visitor);
		}

		HandleEnumeration visitHandles = handles();
		while (visitHandles.hasNextHandle()) {
			visitor.visitHandle(visitHandles.nextHandle());
		}
/*
		originalListener = listener();
		if (originalListener != null) {
			visitor.visitFigureChangeListener(originalListener);
		}
*/

		while (fe.hasNextFigure()) {
			//fe.nextFigure().visit(visitor);
			visitor.visitDependendFigure(fe.nextFigure());
		}
		//getDecoratedFigure().visit(visitor); !!!dnoyeb!!! this is a must right?
a342 336

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * needs cloning unless the z order is preserved in the context/order of
	 * the saved figures somehow.
	 */
	private int _nZ;

	/**
	 * Changes the display box of a figure. Clients usually
	 * call this method. It changes the display box
	 * and announces the corresponding change.
	 * @@param origin the new origin
	 * @@param corner the new corner
	 * @@see #displayBox
	 */
	public void displayBox(Point origin, Point corner) {
		willChange();
		basicDisplayBox(origin, corner);
		changed();
	}

	/**
	 * Gets the size of the figure. A convenience method.
	 */
	public Dimension size() {
		return new Dimension(displayBox().width, displayBox().height);
	}

	/**
	 * Checks if the figure is empty. The default implementation returns
	 * true if the width or height of its display box is < 3
	 * @@see Figure#isEmpty
	 */
	public boolean isEmpty() {
		return (size().width < 3) || (size().height < 3);
	}


	/**
	 * Changes the display box of a figure. This is a
	 * convenience method. Implementors should only
	 * have to override basicDisplayBox
	 * @@see #displayBox
	 */
	public void displayBox(Rectangle r) {
		displayBox(new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height));
	}

	/**
	 * Sets the Figure's container and registers the container
	 * as a figure change listener. A figure's container can be
	 * any kind of FigureChangeListener. A figure may have only a single container.
	 *
	 * @@see Figure
	 */
	public void addToContainer(FigureChangeListener c) {
		if(getContainer() != null){
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.
			throw new JHotDrawRuntimeException("This figure is already contained.");
		}
		if(c == null){
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.
			throw new JHotDrawRuntimeException("Container parameter can not be null.");
		}
		setContainer( c );
		addFigureChangeListener(getContainer());
		invalidate();		
	}

	/**
	 * A callback from the container in response to the event fired by {@@link
	 * #remove remove}.  This method does the actual removal from the container.
	 * Do not fire <code>figureRequestRemove</code> from this method.
	 *
	 * @@see Figure#removeFromContainer
	 */
	public void removeFromContainer(FigureChangeListener c) {
		if( getContainer() == null ) {
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
			throw new JHotDrawRuntimeException("This figure is not contained.");
		}
		if(c == null){
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.
			throw new JHotDrawRuntimeException("Container parameter can not be null.");
		}
		invalidate();
		removeFigureChangeListener( getContainer() );
		setContainer( null );
	}

	/**
	 * Adds a listener for this figure.
	 */
	public synchronized void addFigureChangeListener(FigureChangeListener l) {
		fListener = FigureChangeEventMulticaster.add(listener(), l);
	}

	/**
	 * Removes a listener for this figure.
	 */
	public synchronized void removeFigureChangeListener(FigureChangeListener l) {
		fListener = FigureChangeEventMulticaster.remove(listener(), l);
	}

	/**
	 * Gets the figure's listners.
	 */
	protected synchronized FigureChangeListener listener() {
		return fListener;
	}

	/**
	 * Invalidates the figure. This method informs the listeners
	 * that the figure's current display box is invalid and should be
	 * refreshed.
	 */
	public void invalidate() {
		if (listener() != null) {
			Rectangle r = invalidateRectangle(displayBox());
			listener().figureInvalidated(new FigureChangeEvent(this, r));
		}
	}

	public void update() {
		invalidate();
		if (listener() != null) {
			listener().figureRequestUpdate(new FigureChangeEvent(this));
		}		
	}
	/**
	 * Hook method to change the rectangle that will be invalidated
	 */
	protected Rectangle invalidateRectangle(Rectangle r) {
		r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);
		return r;
	}

	/**
	 * Informes that a figure is about to change something that
	 * affects the contents of its display box.
	 * Causes the current display box to be marked as dirty and in need of
	 * redraw.  The redraw does not occur as a result of this method call.
	 *
	 * @@see Figure#willChange
	 * @@see Figure#invalidate
	 */
	public void willChange() {
		invalidate();
	}

	/**
	 * Informs that a figure changed the area of its display box.
	 * Causes the current display box to be marked as dirty and in need of
	 * redraw.  The redraw does not occur as a result of this method call.
	 *
	 * @@see FigureChangeEvent
	 * @@see FigureChangeListener
	 * @@see Figure#changed
	 * @@see Figure#invalidate
	 */
	public void changed() {
		invalidate();
		if (listener() != null) {
			listener().figureChanged(new FigureChangeEvent(this));
		}
	}

	/**
	 * Gets the center of a figure. A convenice
	 * method that is rarely overridden.
	 */
	public Point center() {
		return Geom.center(displayBox());
	}

	/**
	 * Clones a figure. Creates a clone by using the storable
	 * mechanism to flatten the Figure to stream followed by
	 * resurrecting it from the same stream.
	 *
	 * @@see Figure#clone
	 */
	public Object clone() {
		Object clone = null;
		ByteArrayOutputStream output = new ByteArrayOutputStream(200);
		try {
			ObjectOutput writer = new ObjectOutputStream(output);
			writer.writeObject(this);
			writer.close();
		}
		catch (IOException e) {
			System.err.println("Class not found: " + e);
		}

		InputStream input = new ByteArrayInputStream(output.toByteArray());
		try {
			ObjectInput reader = new ObjectInputStream(input);
			clone = reader.readObject();
		}
		catch (IOException e) {
			System.err.println(e.toString());
		}
		catch (ClassNotFoundException e) {
			System.err.println("Class not found: " + e);
		}
		return clone;
	}




	/**
	 * Gets the z value (back-to-front ordering) of this figure.
	 */
	public int getZValue() {
	  return _nZ;
	}

	/**
	 * Sets the z value (back-to-front ordering) of this figure.
	 */
	public void setZValue(int z) {
	  _nZ = z;
	}

	public FigureEnumeration getDependendFigures() {
		synchronized(myDependentFigures){
			return new FigureEnumerator(myDependentFigures);
		}
	}

	public void addDependendFigure(Figure newDependendFigure) {
		synchronized(myDependentFigures){
			myDependentFigures.add(newDependendFigure);
		}
	}

	public synchronized void removeDependendFigure(Figure oldDependentFigure) {
		synchronized(myDependentFigures){
			myDependentFigures.remove(oldDependentFigure);
		}
	}

	protected FigureChangeListener getContainer() {
		return container;
	}
	protected void setContainer(FigureChangeListener container){
		this.container = container;
	}
	
	public void addFigureManipulator(FigureManipulator fm) {
		synchronized(fFigureManipulators) {		
			fm.AttachFigure(this);
			fFigureManipulators.add( fm );
		}
	}
	
	public void removeFigureManipulator(FigureManipulator fm) {
		synchronized(fFigureManipulators) {
			fFigureManipulators.remove( fm );
			fm.DetachFigure(this);
		}
	}
	
	public void addFigureDecorator(FigureDecorator fd){
		synchronized(fFigureDecorators){
			fFigureDecorators.add( fd );
			fd.decorateFigure( this );
		}
		invalidate();
	}
	public void removeFigureDecorator(FigureDecorator fd){
		synchronized(fFigureDecorators){
			fd.undecorateFigure( this );
			fFigureDecorators.remove( fd );
		}
		invalidate();		
	}
	/**
	 * The returned iterator needs to be fail fast or something !?!dnoyeb!?!
	 */
	public java.util.Iterator figureDecorators(){
		return fFigureDecorators.iterator();
	}
	public void drawAll(Graphics g){
		draw(g);
		drawDecorators(g);
	}
	public void drawDecorators(Graphics g){
		for(Iterator it= fFigureDecorators.iterator();it.hasNext();) {
			((FigureDecorator)it.next()).draw(g);
		}		
	}	
@


1.7.4.5
log
@More cleanups for DecoratorFigure.  Its going to cause problems till the architecture changes.
Added a few needed methods to expose private variables of StandardDrawingView to make it more
override friendly.
@
text
@d43 3
a46 6
 * I have currently made DecoratorFigure implement Figure as opposed to extending
 * AbstractFigure.  This way AbstractFigure's implementation can not hide new
 * methods added to the Figure interface from being properly added to 
 * DecoratorFigure and forwarded to the decorated figure.  This solves part of
 * the problem.  I think the rest will actually be solved if document-view
 * seperation is implemented. 1/20/03
d146 1
a146 1
		getDecoratedFigure().addToContainer(this);
d152 1
d155 1
a155 2
		removeDependendFigure( getDecoratedFigure() );
		getDecoratedFigure().removeFromContainer( this );
d221 1
a221 2
	 * This is broken.  peel does not set contained figure to null.  unsure how
	 * to fix that.
a229 5
		if(getDecoratedFigure() != null){
			removeDependendFigure( getDecoratedFigure() );
			getDecoratedFigure().removeFromContainer( this ); //this is of course not notifying any listeners. improper.
			getDecoratedFigure().release();
		}
d285 3
a287 3
	 * The decorated figure gets removed because it is a dependent figure. Do not
	 * remove it here or the undo architecture will not know about it.
	 *
d291 2
@


1.7.4.6
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@a145 3
	 * Note the decorated figure is not a dependent figure.  it is a contained
	 * figure.  dependent figures are figures <i>outside</i> of the figure that
	 * they depend upon.
d436 1
a436 4
	/**
	 * Make sure all dependent figures get visited.  Make sure all contained
	 * figures get visited.
	 */
a445 1
		//visit this figure.
d450 1
a450 1
			visitFigures.nextFigure().visit(visitor);//visitor now visits the contained figures
d455 1
a455 1
			visitor.visitHandle(visitHandles.nextHandle()); //visiting handles
d465 2
a466 1
			fe.nextFigure().visit(visitor);
d468 1
a468 1
		//getDecoratedFigure().visit(visitor);
@


1.7.4.7
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d243 18
a260 1
	
d277 3
d293 14
d444 1
a444 6
		//if we are already deleted, do not allow visit.
		if(visitor instanceof DeleteFromDrawingVisitor){
			if(getContainer() == null){
				return;
			}
		}
d454 1
a454 6
		//do not visit dependencies on insert
		if(visitor instanceof InsertIntoDrawingVisitor){
			return;
		}
		
		
d593 1
a593 1
	 * 
@


1.7.4.8
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d231 1
d235 1
a235 1
			throw new JHotDrawRuntimeException("Figure can not be released, it has not been removed yet.");
d368 1
a368 1
		_nZ = dr.readInt();
@


1.7.4.9
log
@Dependent figures should not be stored by the dependee, the link is stored
by the dependent figure itself.
@
text
@d343 7
d368 7
@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@a17 1
import java.util.*;
d97 1
d105 1
d303 9
@


1.5
log
@no message
@
text
@d143 1
a143 1
	public Vector handles() {
d276 2
a277 2
	public void connectorVisibility(boolean isVisible) {
		getDecoratedFigure().connectorVisibility(isVisible);
@


1.4
log
@merge dnd (before 5.3)
@
text
@d70 1
a70 1
	
d229 2
d237 7
d245 2
d250 7
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d38 2
a39 2
                extends AbstractFigure
                implements FigureChangeListener {
d41 29
a69 29
    /**
     * The decorated figure.
     */
    private Figure fComponent;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = 8993011151564573288L;
    private int decoratorFigureSerializedDataVersion = 1;

    public DecoratorFigure() {
        initialize();
    }

    /**
     * Constructs a DecoratorFigure and decorates the passed in figure.
     */
    public DecoratorFigure(Figure figure) {
    	initialize();
        decorate(figure);
    }

    /**
     * Performs additional initialization code before the figure is decorated.
     * Subclasses may override this method.
     */
    protected void initialize() {
    }
d71 36
a106 36
    /**
     * Forwards the connection insets to its contained figure..
     */
    public Insets connectionInsets() {
        return getDecoratedFigure().connectionInsets();
    }

    /**
     * Forwards the canConnect to its contained figure..
     */
    public boolean canConnect() {
        return getDecoratedFigure().canConnect();
    }

    /**
     * Forwards containsPoint to its contained figure.
     */
    public boolean containsPoint(int x, int y) {
        return getDecoratedFigure().containsPoint(x, y);
    }

    /**
     * Decorates the given figure.
     */
    public void decorate(Figure figure) {
        fComponent = figure;
        fComponent.addToContainer(this);
    }

    /**
     * Removes the decoration from the contained figure.
     */
    public Figure peelDecoration() {
        getDecoratedFigure().removeFromContainer(this); //??? set the container to the listener()?
        return getDecoratedFigure();
    }
d109 2
a110 2
        return fComponent;
    }
d112 165
a276 165
    /**
     * Forwards displayBox to its contained figure.
     */
    public Rectangle displayBox() {
        return getDecoratedFigure().displayBox();
    }

    /**
     * Forwards basicDisplayBox to its contained figure.
     */
    public void basicDisplayBox(Point origin, Point corner) {
        getDecoratedFigure().basicDisplayBox(origin, corner);
    }

    /**
     * Forwards draw to its contained figure.
     */
    public void draw(Graphics g) {
        getDecoratedFigure().draw(g);
    }

    /**
     * Forwards findFigureInside to its contained figure.
     */
    public Figure findFigureInside(int x, int y) {
        return getDecoratedFigure().findFigureInside(x, y);
    }

    /**
     * Forwards handles to its contained figure.
     */
    public Vector handles() {
        return getDecoratedFigure().handles();
    }

    /**
     * Forwards includes to its contained figure.
     */
    public boolean includes(Figure figure) {
        return (super.includes(figure) || getDecoratedFigure().includes(figure));
    }

    /**
     * Forwards moveBy to its contained figure.
     */
    public void moveBy(int x, int y) {
        getDecoratedFigure().moveBy(x, y);
    }

    /**
     * Forwards basicMoveBy to its contained figure.
     */
    protected void basicMoveBy(int x, int y) {
        // this will never be called
    }

    /**
     * Releases itself and the contained figure.
     */
    public void release() {
        super.release();
        getDecoratedFigure().removeFromContainer(this);
        getDecoratedFigure().release();
    }

    /**
     * Propagates invalidate up the container chain.
     * @@see FigureChangeListener
     */
    public void figureInvalidated(FigureChangeEvent e) {
        if (listener() != null) {
            listener().figureInvalidated(e);
        }
    }

    public void figureChanged(FigureChangeEvent e) {
    }

    public void figureRemoved(FigureChangeEvent e) {
    }

    /**
     * Propagates figureRequestUpdate up the container chain.
     * @@see FigureChangeListener
     */
    public  void figureRequestUpdate(FigureChangeEvent e) {
        if (listener() != null) {
            listener().figureRequestUpdate(e);
        }
    }

    /**
     * Propagates the removeFromDrawing request up to the container.
     * @@see FigureChangeListener
     */
    public void figureRequestRemove(FigureChangeEvent e) {
        if (listener() != null) {
            listener().figureRequestRemove(new FigureChangeEvent(this));
        }
    }

    /**
     * Forwards figures to its contained figure.
     */
    public FigureEnumeration figures() {
        return getDecoratedFigure().figures();
    }

    /**
     * Forwards decompose to its contained figure.
     */
    public FigureEnumeration decompose() {
        return getDecoratedFigure().decompose();
    }

    /**
     * Forwards setAttribute to its contained figure.
     */
    public void setAttribute(String name, Object value) {
        getDecoratedFigure().setAttribute(name, value);
    }

    /**
     * Forwards getAttribute to its contained figure.
     */
    public Object getAttribute(String name) {
        return getDecoratedFigure().getAttribute(name);
    }

    /**
     * Returns the locator used to located connected text.
     */
    public Locator connectedTextLocator(Figure text) {
        return getDecoratedFigure().connectedTextLocator(text);
    }

    /**
     * Returns the Connector for the given location.
     */
    public Connector connectorAt(int x, int y) {
        return getDecoratedFigure().connectorAt(x, y);
    }

    /**
     * Forwards the connector visibility request to its component.
     */
    public void connectorVisibility(boolean isVisible) {
        getDecoratedFigure().connectorVisibility(isVisible);
    }

    /**
     * Writes itself and the contained figure to the StorableOutput.
     */
    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeStorable(getDecoratedFigure());
    }

    /**
     * Reads itself and the contained figure from the StorableInput.
     */
    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        decorate((Figure)dr.readStorable());
    }
d278 2
a279 2
    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {
d281 1
a281 1
        s.defaultReadObject();
d283 2
a284 2
        getDecoratedFigure().addToContainer(this);
    }
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)DecoratorFigure.java 5.2
d4 6
d33 2
d44 1
a44 1
    protected Figure fComponent;
d75 1
a75 1
        return fComponent.connectionInsets();
d82 1
a82 1
        return fComponent.canConnect();
d89 1
a89 1
        return fComponent.containsPoint(x, y);
d104 5
a108 1
        fComponent.removeFromContainer(this); //??? set the container to the listener()?
d116 1
a116 1
        return fComponent.displayBox();
d123 1
a123 1
        fComponent.basicDisplayBox(origin, corner);
d130 1
a130 1
        fComponent.draw(g);
d137 1
a137 1
        return fComponent.findFigureInside(x, y);
d144 1
a144 1
        return fComponent.handles();
d151 1
a151 1
        return (super.includes(figure) || fComponent.includes(figure));
d158 1
a158 1
        fComponent.moveBy(x, y);
d173 2
a174 2
        fComponent.removeFromContainer(this);
        fComponent.release();
d182 1
a182 1
        if (listener() != null)
d184 1
d198 1
a198 1
        if (listener() != null)
d200 1
d208 1
a208 1
        if (listener() != null)
d210 1
d217 1
a217 1
        return fComponent.figures();
d224 1
a224 1
        return fComponent.decompose();
d231 1
a231 1
        fComponent.setAttribute(name, value);
d238 1
a238 1
        return fComponent.getAttribute(name);
d245 1
a245 1
        return fComponent.connectedTextLocator(text);
d252 1
a252 1
        return fComponent.connectorAt(x, y);
d259 1
a259 1
        fComponent.connectorVisibility(isVisible);
d267 1
a267 1
        dw.writeStorable(fComponent);
d283 1
a283 1
        fComponent.addToContainer(this);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)DecoratorFigure.java 5.1
d44 3
a46 1
    public DecoratorFigure() { }
d52 1
d56 7
@


1.1.1.1
log
@
Initial revision.
@
text
@@
