head	1.16;
access;
symbols
	jhotdraw60b1-release:1.16
	package_rename:1.16
	directory_rename:1.15
	reorg_6x_split_initial:1.15
	MVC_PHASE1:1.15.0.4
	NEW_ATTRIBUTES:1.15.0.2
	DNOYEB1_ALPHA-2:1.11.4.5
	release_JHD54b1:1.15
	BUGFIX_670992:1.13.0.2
	DNOYEB1_ALPHA-1:1.11.4.4
	dnoyeb1:1.11.0.4
	repack:1.11.0.2
	Root_repack:1.11
	Before_FigureVisitor:1.9
	JHotDraw_5-3:1.7
	JHotDraw_5-2_merged:1.3
	JHotDraw_5-1_initial:1.2
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.26.01.14.05;	author dnoyeb;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.12.20.21.17;	author dnoyeb;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.03.00.55.32;	author dnoyeb;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.23.07.47.26;	author mrfloppy;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2002.09.22.08.58.22;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.20.19.57.59;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.25.13;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.29.13.42.14;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.12.16.16.29;	author jeckel;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.11.4.1
date	2003.01.03.16.04.00;	author dnoyeb;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.01.08.22.13.04;	author dnoyeb;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2003.01.13.03.14.03;	author dnoyeb;	state Exp;
branches;
next	1.11.4.4;

1.11.4.4
date	2003.01.14.18.26.16;	author dnoyeb;	state Exp;
branches;
next	1.11.4.5;

1.11.4.5
date	2003.01.26.00.51.19;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.16
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)StandardDrawing.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import org.jhotdraw.framework.*;
import org.jhotdraw.util.CollectionsFactory;

import java.awt.*;
import java.util.*;
import java.util.List;
import java.io.*;

/**
 * The standard implementation of the Drawing interface.
 *
 * @@see Drawing
 *
 * @@version <$CURRENT_VERSION$>
 */

public class StandardDrawing extends CompositeFigure implements Drawing {


	/**
	 * the registered listeners
	 */
	private transient List              fListeners;

	/**
	 * boolean that serves as a condition variable
	 * to lock the access to the drawing.
	 * The lock is recursive and we keep track of the current
	 * lock holder.
	 */
	private transient Thread    fDrawingLockHolder = null;
	private String				myTitle;

	/*
	 * Serialization support
	 */
	private static final long serialVersionUID = -2602151437447962046L;
	private int drawingSerializedDataVersion = 1;

	/**
	 * Constructs the Drawing.
	 */
	public StandardDrawing() {
		super();
		fListeners = CollectionsFactory.current().createList(2);
		init(new Rectangle(-500, -500, 2000, 2000));
	}

	/**
	 * Adds a listener for this drawing.
	 */
	public void addDrawingChangeListener(DrawingChangeListener listener) {
		if (fListeners == null) {
			fListeners = CollectionsFactory.current().createList(2);
		}
		fListeners.add(listener);
	}

	/**
	 * Removes a listener from this drawing.
	 */
	public void removeDrawingChangeListener(DrawingChangeListener listener) {
		fListeners.remove(listener);
	}

	/**
	 * Gets an enumeration with all listener for this drawing.
	 */
	public Iterator drawingChangeListeners() {
		return fListeners.iterator();
	}

	/**
	 * Removes a figure from the figure list, but
	 * doesn't release it. Use this method to temporarily
	 * manipulate a figure outside of the drawing.
	 *
	 * @@param figure that is part of the drawing and should be added
	 */
	public synchronized Figure orphan(Figure figure) {
		Figure orphanedFigure = super.orphan(figure);
		// ensure that we remove the top level figure in a drawing
		if (orphanedFigure.listener() != null) {
			Rectangle rect = invalidateRectangle(displayBox());
			orphanedFigure.listener().figureRequestRemove(new FigureChangeEvent(orphanedFigure, rect));
		}
		return orphanedFigure;
	}

	public synchronized Figure add(Figure figure) {
		Figure addedFigure = super.add(figure);
		if (addedFigure.listener() != null) {
			Rectangle rect = invalidateRectangle(displayBox());
			addedFigure.listener().figureRequestUpdate(new FigureChangeEvent(figure, rect));
			return addedFigure;
		}
		return addedFigure;
	}

	/**
	 * Invalidates a rectangle and merges it with the
	 * existing damaged area.
	 * @@see FigureChangeListener
	 */
	public void figureInvalidated(FigureChangeEvent e) {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.get(i);
				l.drawingInvalidated(new DrawingChangeEvent(this, e.getInvalidatedRectangle()));
			}
		}
	}

	/**
	 * Forces an update of the drawing change listeners.
	 */
	public void fireDrawingTitleChanged() {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.get(i);
				l.drawingTitleChanged(new DrawingChangeEvent(this, null));
			}
		}
	}

	/**
	 * Forces an update of the drawing change listeners.
	 */
	public void figureRequestUpdate(FigureChangeEvent e) {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.get(i);
				l.drawingRequestUpdate(new DrawingChangeEvent(this, null));
			}
		}
	}

	/**
	 * Return's the figure's handles. This is only used when a drawing
	 * is nested inside another drawing.
	 */
	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList();
		handles.add(new NullHandle(this, RelativeLocator.northWest()));
		handles.add(new NullHandle(this, RelativeLocator.northEast()));
		handles.add(new NullHandle(this, RelativeLocator.southWest()));
		handles.add(new NullHandle(this, RelativeLocator.southEast()));
		return new HandleEnumerator(handles);
	}

	/**
	 * Gets the display box. This is the union of all figures.
	 */
	public Rectangle displayBox() {
		if (fFigures.size() > 0) {
			FigureEnumeration fe = figures();

			Rectangle r = fe.nextFigure().displayBox();

			while (fe.hasNextFigure()) {
				r.add(fe.nextFigure().displayBox());
			}
			return r;
		}
		return new Rectangle(0, 0, 0, 0);
	}

	public void basicDisplayBox(Point p1, Point p2) {
	}

	/**
	 * Acquires the drawing lock.
	 */
	public synchronized void lock() {
		// recursive lock
		Thread current = Thread.currentThread();
		if (fDrawingLockHolder == current) {
			return;
		}
		while (fDrawingLockHolder != null) {
			try {
				wait();
			}
			catch (InterruptedException ex) { }
		}
		fDrawingLockHolder = current;
	}

	/**
	 * Releases the drawing lock.
	 */
	public synchronized void unlock() {
		if (fDrawingLockHolder != null) {
			fDrawingLockHolder = null;
			notify();
		}
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fListeners = CollectionsFactory.current().createList(2);
	}

	public String getTitle() {
		return myTitle;
	}

	public void setTitle(String newTitle) {
		myTitle = newTitle;
	}
}
@


1.15
log
@prepare for 5.4 release: various bug fixes
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d14 2
a15 2
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.CollectionsFactory;
@


1.14
log
@[ 666090 ] unlock should call notify
@
text
@d130 12
@


1.13
log
@Clean up head to be what it was before i mistakenly committed my changes to it.
My changes should have been committed to a branch, and let mrfloppy merge to the trunk.
This will happen from now on.
@
text
@d196 1
a196 1
			notifyAll();
@


1.12
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d126 1
a126 11
	/**
	 * Forces an update of the drawing change listeners.
	 */
	public void fireDrawingTitleChanged() {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.get(i);
				l.drawingTitleChanged(new DrawingChangeEvent(this, null));
			}
		}
	}
a213 1
        fireDrawingTitleChanged();
@


1.11
log
@Fixed problem with TextArea figures + cascading FigureChangeEvent
@
text
@d126 11
a136 1

d224 1
@


1.11.4.1
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d126 1
a126 11
	/**
	 * Forces an update of the drawing change listeners.
	 */
	public void fireDrawingTitleChanged() {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.get(i);
				l.drawingTitleChanged(new DrawingChangeEvent(this, null));
			}
		}
	}
a213 1
        fireDrawingTitleChanged();
@


1.11.4.2
log
@1.  Encapsulated the useage of FigureChangeListener on ContainerFigure.  ContainerFigure does no longer implement
    FigureChangeListener, but has an inner class for that.  All of the FigureChangeListener methods on
    the CompositeFigure class are now protected.  Subclasses as well.

2.  Drawing no longer implements FigureChangeListener.  defers to implementatations to subclass or implement that.

3.  FindFigureInside fixed.  waiting on better fix with Strategy Pattern from mrfloppy.
@
text
@d97 1
a97 1
			Rectangle rect = invalidateRectangle(displayBox());//shouldnt we be invalidating the size of the removed figure?
d106 1
a106 1
			Rectangle rect = invalidateRectangle(displayBox());//why not just the rect of the added figure?
d118 1
a118 1
	protected void figureInvalidated(FigureChangeEvent e) {
d140 1
a140 1
	protected void figureRequestUpdate(FigureChangeEvent e) {
@


1.11.4.3
log
@1. javadoc comments and corrections and clarifications
2. Drawing no longer exposes its drawing change listener, but has a method for those who want the drawing to request all views of it to be updated.
3. all removeAll() methods in CompositeFigure now have single consistent implementation.
4. standardDrawing unlock calls notify instead of notifyAll since only 1 can grab the lock anyway.
@
text
@d82 1
a82 1
	protected Iterator drawingChangeListeners() {
d107 1
a107 1
			addedFigure.listener().figureRequestUpdate(new FigureChangeEvent(figure, rect));  //shouldnt composite figure be handling this?
a111 6
	/**
	 * Causes the drawing to requestUpdate
	 */
	public void update() {
		fireDrawingRequestUpdate();
	}
a118 22
		//super.figureInvalidated(e);
		fireDrawingInvalidated(e.getInvalidatedRectangle());
	}
	
	/**
	 * Forces an update of the drawing change listeners.
	 * this is error? its overriding the compositeFigure basic behavior.
	 * should leave composite figure basic behavior alone, and fire drawingrequestupdate
	 * as well as.
	 *
	 * this is fired when the figures we are listening to change.
	 * so if we move a selection of figures
	 * 
	 */
	protected void figureRequestUpdate(FigureChangeEvent e) {
		//super.figureRequestUpdate(e);
		fireDrawingRequestUpdate(); //this will cause the drawing to be redrawn 
	}	
	/**
	 * 
	 */
	protected void fireDrawingInvalidated(Rectangle invalidRectangle) {
d122 1
a122 1
				l.drawingInvalidated(new DrawingChangeEvent(this, invalidRectangle));
a125 1

d129 1
a129 1
	protected void fireDrawingTitleChanged() {
a136 1

d138 1
a138 1
	 *  Sent when the drawing wants to be refreshed
d140 1
a140 1
	protected void fireDrawingRequestUpdate() {
d206 1
a206 1
			notify();
@


1.11.4.4
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@a23 1
 * Fix this to aggregrate CompositeFigure instead of extending it.
d93 9
a101 3
/*	public synchronized Figure orphan(Figure figure) {
		return super.orphan(figure);
	}*/
d103 1
a103 1
/*	public synchronized Figure add(Figure figure) {
d105 5
a109 1
		addedFigure.update();
d111 1
a111 2
	}*/
	
a115 1
		//super.update(); //nobody is expecting us to behave like a CompositeFigure so this is ok to mask.
d120 2
a121 4
	 * One of the contained figures is announcing that part of it has been
	 * invalidated.  We announce to our listeners that this same part of us has
	 * been invalidated.
	 *
a122 1
	 * @@see DrawingChangeListener
d136 1
d196 1
a196 1
		if (figureCount() > 0) {
@


1.11.4.5
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d46 1
a46 1
	private String				myTitle;//probably should be transient.
d240 1
a240 1
		fListeners = CollectionsFactory.current().createList(2); //why is this needed??? ???dnoyeb???
@


1.10
log
@introduce FigureVisitor for paste/delete commands
@
text
@d97 2
a98 1
			orphanedFigure.listener().figureRequestRemove(new FigureChangeEvent(orphanedFigure, null));
d106 2
a107 1
			addedFigure.listener().figureRequestUpdate(new FigureChangeEvent(figure, null));
@


1.9
log
@after variou merges... (before 5.4 release)
@
text
@d87 5
a91 1
	 * Removes the figure from the drawing and releases it.
d93 2
a94 2

	public synchronized Figure remove(Figure figure) {
d96 2
a97 3
		if (figure.listener() != null) {
			figure.listener().figureRequestRemove(new FigureChangeEvent(figure, null));
			return figure;
d99 1
a99 1
		return null;
d102 5
a106 16
	/**
	 * Handles a removeFromDrawing request that
	 * is passed up the figure container hierarchy.
	 * @@see FigureChangeListener
	 */
	public void figureRequestRemove(FigureChangeEvent e) {
		Figure figure = e.getFigure();
		if (fFigures.contains(figure)) {
			// Bugfix: This call will cleans up the quad-tree as well [JY]
			super.remove(figure);
			//fFigures.removeElement(figure);
			//figure.removeFromContainer(this);   // will invalidate figure
			figure.release();
		}
		else {
			System.err.println("Attempt to remove non-existing figure");
d108 1
d126 1
a126 1
	 * Forces an update
@


1.8
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@a13 1
import CH.ifa.draw.util.*;
d15 2
d19 1
d36 1
a36 1
	private transient Vector              fListeners;
d58 1
a58 1
		fListeners = new Vector(2);
d67 1
a67 1
			fListeners = new Vector(2);
d69 1
a69 1
		fListeners.addElement(listener);
d76 1
a76 1
		fListeners.removeElement(listener);
d82 2
a83 2
	public Enumeration drawingChangeListeners() {
		return fListeners.elements();
d126 1
a126 1
				DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
d138 1
a138 1
				DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
d148 7
a154 7
	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		return handles;
d162 1
a162 1
			FigureEnumeration k = figures();
d164 1
a164 1
			Rectangle r = k.nextFigure().displayBox();
d166 2
a167 2
			while (k.hasMoreElements()) {
				r.add(k.nextFigure().displayBox());
d210 1
a210 1
		fListeners = new Vector(2);
@


1.7
log
@merge dnd (before 5.3)
@
text
@d105 4
a108 2
			fFigures.removeElement(figure);
			figure.removeFromContainer(this);   // will invalidate figure
@


1.6
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d31 185
a215 176
    /**
     * the registered listeners
     */
    private transient Vector              fListeners;

    /**
     * boolean that serves as a condition variable
     * to lock the access to the drawing.
     * The lock is recursive and we keep track of the current
     * lock holder.
     */
    private transient Thread    fDrawingLockHolder = null;

    /*
     * Serialization support
     */
    private static final long serialVersionUID = -2602151437447962046L;
    private int drawingSerializedDataVersion = 1;

    /**
     * Constructs the Drawing.
     */
    public StandardDrawing() {
        super();
        fListeners = new Vector(2);
        init(new Rectangle(-500, -500, 2000, 2000));
    }

    /**
     * Adds a listener for this drawing.
     */
    public void addDrawingChangeListener(DrawingChangeListener listener) {
    	if (fListeners == null) {
    		fListeners = new Vector(2);
    	}
        fListeners.addElement(listener);
    }

    /**
     * Removes a listener from this drawing.
     */
    public void removeDrawingChangeListener(DrawingChangeListener listener) {
        fListeners.removeElement(listener);
    }

    /**
     * Gets an enumeration with all listener for this drawing.
     */
    public Enumeration drawingChangeListeners() {
        return fListeners.elements();
    }

    /**
     * Removes the figure from the drawing and releases it.
     */

    public synchronized Figure remove(Figure figure) {
        // ensure that we remove the top level figure in a drawing
        if (figure.listener() != null) {
            figure.listener().figureRequestRemove(new FigureChangeEvent(figure, null));
            return figure;
        }
        return null;
    }

    /**
     * Handles a removeFromDrawing request that
     * is passed up the figure container hierarchy.
     * @@see FigureChangeListener
     */
    public void figureRequestRemove(FigureChangeEvent e) {
        Figure figure = e.getFigure();
        if (fFigures.contains(figure)) {
            fFigures.removeElement(figure);
            figure.removeFromContainer(this);   // will invalidate figure
            figure.release();
        }
        else {
            System.out.println("Attempt to remove non-existing figure");
        }
    }

    /**
     * Invalidates a rectangle and merges it with the
     * existing damaged area.
     * @@see FigureChangeListener
     */
    public void figureInvalidated(FigureChangeEvent e) {
        if (fListeners != null) {
            for (int i = 0; i < fListeners.size(); i++) {
                DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
                l.drawingInvalidated(new DrawingChangeEvent(this, e.getInvalidatedRectangle()));
            }
        }
    }

    /**
     * Forces an update
     */
    public void figureRequestUpdate(FigureChangeEvent e) {
        if (fListeners != null) {
            for (int i = 0; i < fListeners.size(); i++) {
                DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
                l.drawingRequestUpdate(new DrawingChangeEvent(this, null));
            }
        }
    }

    /**
     * Return's the figure's handles. This is only used when a drawing
     * is nested inside another drawing.
     */
    public Vector handles() {
        Vector handles = new Vector();
        handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
        handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
        handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
        handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
        return handles;
    }

    /**
     * Gets the display box. This is the union of all figures.
     */
    public Rectangle displayBox() {
        if (fFigures.size() > 0) {
            FigureEnumeration k = figures();

            Rectangle r = k.nextFigure().displayBox();

            while (k.hasMoreElements()) {
                r.add(k.nextFigure().displayBox());
            }
            return r;
        }
        return new Rectangle(0, 0, 0, 0);
    }

    public void basicDisplayBox(Point p1, Point p2) {
    }

    /**
     * Acquires the drawing lock.
     */
    public synchronized void lock() {
        // recursive lock
        Thread current = Thread.currentThread();
        if (fDrawingLockHolder == current) {
            return;
        }
        while (fDrawingLockHolder != null) {
            try {
            	wait();
            }
            catch (InterruptedException ex) { }
        }
        fDrawingLockHolder = current;
    }

    /**
     * Releases the drawing lock.
     */
    public synchronized void unlock() {
        if (fDrawingLockHolder != null) {
            fDrawingLockHolder = null;
            notifyAll();
        }
    }

    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();

        fListeners = new Vector(2);
    }
@


1.5
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)StandardDrawing.java 5.2
d4 6
d24 2
a58 1

d77 1
a77 1
     * Adds a listener for this drawing.
a95 1

d107 2
a108 1
        } else
d110 1
d161 1
a161 1
            while (k.hasMoreElements())
d163 1
d178 1
a178 1
        if (fDrawingLockHolder == current)
d180 1
d182 4
a185 1
            try { wait(); } catch (InterruptedException ex) { }
@


1.4
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d51 1
d70 1
a70 1
     * Gets an enumeration with all listener for this drawing.
d88 1
@


1.3
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@a50 1

d69 1
a69 1
     * Adds a listener for this drawing.
a86 1

@


1.2
log
@adjusted for changed Drawing class: call init()
@
text
@d2 1
a2 1
 * @@(#)StandardDrawing.java 5.1
d56 3
@


1.1
log
@Initial revision
@
text
@d48 1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
