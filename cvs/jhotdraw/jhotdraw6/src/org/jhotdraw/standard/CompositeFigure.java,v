head	1.12;
access;
symbols
	jhotdraw60b1-release:1.12
	package_rename:1.12
	directory_rename:1.11
	reorg_6x_split_initial:1.11
	MVC_PHASE1:1.11.0.4
	NEW_ATTRIBUTES:1.11.0.2
	DNOYEB1_ALPHA-2:1.9.4.16
	release_JHD54b1:1.11
	BUGFIX_670992:1.9.0.6
	DNOYEB1_ALPHA-1:1.9.4.13
	dnoyeb1:1.9.0.4
	repack:1.9.0.2
	Root_repack:1.9
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.5
	JHotDraw_5-2_merged:1.3
	JHotDraw_5-1_initial:1.2
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.26.01.18.36;	author dnoyeb;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.23.07.47.26;	author mrfloppy;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.09.22.08.58.22;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.12.16.14.42;	author jeckel;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.9.4.1
date	2003.01.04.15.20.51;	author dnoyeb;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.01.08.22.13.01;	author dnoyeb;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.01.13.03.14.03;	author dnoyeb;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.01.14.18.24.32;	author dnoyeb;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.01.14.20.32.58;	author dnoyeb;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.01.15.21.04.21;	author dnoyeb;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.01.16.06.03.53;	author dnoyeb;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2003.01.16.17.13.56;	author dnoyeb;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2003.01.17.17.40.45;	author dnoyeb;	state Exp;
branches;
next	1.9.4.10;

1.9.4.10
date	2003.01.17.21.56.03;	author dnoyeb;	state Exp;
branches;
next	1.9.4.11;

1.9.4.11
date	2003.01.18.04.49.05;	author dnoyeb;	state Exp;
branches;
next	1.9.4.12;

1.9.4.12
date	2003.01.20.18.23.30;	author dnoyeb;	state Exp;
branches;
next	1.9.4.13;

1.9.4.13
date	2003.01.21.00.04.34;	author dnoyeb;	state Exp;
branches;
next	1.9.4.14;

1.9.4.14
date	2003.01.26.00.51.07;	author dnoyeb;	state Exp;
branches;
next	1.9.4.15;

1.9.4.15
date	2003.01.26.15.58.49;	author dnoyeb;	state Exp;
branches;
next	1.9.4.16;

1.9.4.16
date	2003.01.27.18.06.41;	author dnoyeb;	state Exp;
branches;
next	1.9.4.17;

1.9.4.17
date	2003.02.02.16.54.09;	author dnoyeb;	state Exp;
branches;
next	1.9.4.18;

1.9.4.18
date	2003.02.03.18.12.41;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.12
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)CompositeFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import org.jhotdraw.util.*;
import org.jhotdraw.framework.*;
import java.awt.*;
import java.util.*;
import java.util.List;
import java.io.*;

/**
 * A Figure that is composed of several figures. A CompositeFigure
 * doesn't define any layout behavior. It is up to subclassers to
 * arrange the contained figures.
 * <hr>
 * <b>Design Patterns</b><P>
 * <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
 * <b><a href=../pattlets/sld012.htm>Composite</a></b><br>
 * CompositeFigure enables to treat a composition of figures like
 * a single figure.<br>
 *
 * @@see Figure
 *
 * @@version <$CURRENT_VERSION$>
 */

public abstract class CompositeFigure
				extends AbstractFigure
				implements FigureChangeListener {

	/**
	 * The figures that this figure is composed of
	 * @@see #add
	 * @@see #remove
	 */
	protected List fFigures;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = 7408153435700021866L;
	private int compositeFigureSerializedDataVersion = 1;
	private transient QuadTree  _theQuadTree;
	protected int _nLowestZ;
	protected int _nHighestZ;

	protected CompositeFigure() {
		fFigures = CollectionsFactory.current().createList();
		_nLowestZ = 0;
		_nHighestZ = 0;
	}

	/**
	 * Adds a figure to the list of figures. Initializes the
	 * the figure's container.
	 *
	 * @@param figure to be added to the drawing
	 * @@return the figure that was inserted (might be different from the figure specified).
	 */
	public Figure add(Figure figure) {
		if (!containsFigure(figure)) {
			figure.setZValue(++_nHighestZ);
			fFigures.add(figure);
			figure.addToContainer(this);
			_addToQuadTree(figure);
		}
		return figure;
	}

	/**
	 * Adds a list of figures.
	 *
	 * @@see #add
	 * @@deprecated use addAll(FigureEnumeration) instead
	 */
	public void addAll(List newFigures) {
		addAll(new FigureEnumerator(newFigures));
	}

	/**
	 * Adds a FigureEnumeration of figures.
	 *
	 * @@see #add
	 * @@param fe (unused) enumeration containing all figures to be added
	 */
	public void addAll(FigureEnumeration fe) {
		while (fe.hasNextFigure()) {
			add(fe.nextFigure());
		}
	}

	/**
	 * Removes a figure from the composite.
	 *
	 * @@param figure that is part of the drawing and should be removed
	 * @@return the figure that has been removed (might be different from the figure specified)
	 * @@see #removeAll
	 */
	public Figure remove(Figure figure) {
		Figure orphanedFigure = orphan(figure);
		if (orphanedFigure != null) {
			orphanedFigure.release();
		}
		return orphanedFigure;
	}

	/**
	 * Removes a list of figures.
	 *
	 * @@see #remove
	 * @@deprecated use removeAll(FigureEnumeration) instead
	 */
	public void removeAll(List figures) {
		removeAll(new FigureEnumerator(figures));
	}

	/**
	 * Removes a FigureEnumeration of figures.
	 * @@see #remove
	 */
	public void removeAll(FigureEnumeration fe) {
		while (fe.hasNextFigure()) {
			remove(fe.nextFigure());
		}
	}

	/**
	 * Removes all children.
	 * @@see #remove
	 */
	public void removeAll() {
		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			figure.removeFromContainer(this);
		}
		fFigures.clear();

		_clearQuadTree();
		_nLowestZ = 0;
		_nHighestZ = 0;
	}

	/**
	 * Removes a figure from the figure list, but
	 * doesn't release it. Use this method to temporarily
	 * manipulate a figure outside of the drawing.
	 *
	 * @@param figure that is part of the drawing and should be added
	 */
	public synchronized Figure orphan(Figure figure) {
		figure.removeFromContainer(this);
		fFigures.remove(figure);
		_removeFromQuadTree(figure);
		return figure;
	}

	/**
	 * Removes a list of figures from the figure's list
	 * without releasing the figures.
	 *
	 * @@see #orphan
	 * @@deprecated use orphanAll(FigureEnumeration) instead
	 */
	public void orphanAll(List newFigures) {
		orphanAll(new FigureEnumerator(newFigures));
	}

	public void orphanAll(FigureEnumeration fe) {
		while (fe.hasNextFigure()) {
			orphan(fe.nextFigure());
		}
	}

	/**
	 * Replaces a figure in the drawing without
	 * removing it from the drawing.
	 *
	 * @@param figure figure to be replaced
	 * @@param replacement figure that should replace the specified figure
	 * @@return the figure that has been inserted (might be different from the figure specified)
	 */
	public synchronized Figure replace(Figure figure, Figure replacement) {
		int index = fFigures.indexOf(figure);
		if (index != -1) {
			replacement.setZValue(figure.getZValue());
			replacement.addToContainer(this);   // will invalidate figure
			figure.removeFromContainer(this);
			fFigures.set(index, replacement);
			figure.changed();
			replacement.changed();
		}
		return replacement;
	}

	/**
	 * Sends a figure to the back of the drawing.
	 *
	 * @@param figure that is part of the drawing
	 */
	public synchronized void sendToBack(Figure figure) {
		if (containsFigure(figure)) {
			fFigures.remove(figure);
			fFigures.add(0, figure);
			_nLowestZ--;
			figure.setZValue(_nLowestZ);
			figure.changed();
		}
	}

	/**
	 * Brings a figure to the front.
	 *
	 * @@param figure that is part of the drawing
	 */
	public synchronized void bringToFront(Figure figure) {
		if (containsFigure(figure)) {
			fFigures.remove(figure);
			fFigures.add(figure);
			_nHighestZ++;
			figure.setZValue(_nHighestZ);
			figure.changed();
		}
	}

	/**
	 * Sends a figure to a certain layer within a drawing. Each figure
	 * lays in a unique layer and the layering order decides which
	 * figure is drawn on top of another figure. Figures with a higher
	 * layer number have usually been added later and may overlay
	 * figures in lower layers. Layers are counted from to (the number
	 * of figures - 1).
	 * The figure is removed from its current layer (if it has been already
	 * part of this drawing) and is transferred to the specified layers after
	 * all figures between the original layer and the new layer are shifted to
	 * one layer below to fill the layer sequence. It is not possible to skip a
	 * layer number and if the figure is sent to a layer beyond the latest layer
	 * it will be added as the last figure to the drawing and its layer number
	 * will be set to the be the one beyond the latest layer so far.
	 *
	 * @@param figure figure to be sent to a certain layer
	 * @@param layerNr target layer of the figure
	 */
	public void sendToLayer(Figure figure, int layerNr) {
		if (containsFigure(figure)) {
			if (layerNr >= fFigures.size()) {
				layerNr = fFigures.size() - 1;
			}
			Figure layerFigure = getFigureFromLayer(layerNr);
			int layerFigureZValue = layerFigure.getZValue();
			int figureLayer = getLayer(figure);
			// move figure forward
			if (figureLayer < layerNr) {
				assignFiguresToPredecessorZValue(figureLayer + 1, layerNr);
			}
			else if (figureLayer > layerNr) {
				assignFiguresToSuccessorZValue(layerNr, figureLayer - 1);
			}

			fFigures.remove(figure);
			fFigures.add(layerNr, figure);
			figure.setZValue(layerFigureZValue);
			figure.changed();
		}
	}

	private void assignFiguresToPredecessorZValue(int lowerBound, int upperBound) {
		// cannot shift figures to a lower layer if the lower bound is
		// already the first layer.
		if (upperBound >= fFigures.size()) {
			upperBound = fFigures.size() - 1;
		}

		for (int i = upperBound; i >= lowerBound; i--) {
			Figure currentFigure = (Figure)fFigures.get(i);
			Figure predecessorFigure = (Figure)fFigures.get(i - 1);
			currentFigure.setZValue(predecessorFigure.getZValue());
		}
	}

	private void assignFiguresToSuccessorZValue(int lowerBound, int upperBound) {
		if (upperBound >= fFigures.size()) {
			upperBound = fFigures.size() - 1;
		}

		for (int i = upperBound; i >= lowerBound; i--) {
			Figure currentFigure = (Figure)fFigures.get(i);
			Figure successorFigure = (Figure)fFigures.get(i + 1);
			currentFigure.setZValue(successorFigure.getZValue());
		}
	}

	/**
	 * Gets the layer for a certain figure (first occurrence). The number
	 * returned is the number of the layer in which the figure is placed.
	 *
	 * @@param figure figure to be queried for its layering place
	 * @@return number of the layer in which the figure is placed and -1 if the
	 *			figure could not be found.
	 * @@see #sendToLayer
	 */
	public int getLayer(Figure figure) {
		if (!containsFigure(figure)) {
			return -1;
		}
		else {
			return fFigures.indexOf(figure);
		}
	}

	/**
	 * Gets the figure from a certain layer.
	 *
	 * @@param layerNr number of the layer which figure should be returned
	 * @@return figure from the layer specified, null, if the layer nr was outside
	 *			the number of possible layer (0...(number of figures - 1))
	 * @@see #sendToLayer
	 */
	public Figure getFigureFromLayer(int layerNr) {
		if ((layerNr >= 0) && (layerNr < fFigures.size())) {
			return (Figure)fFigures.get(layerNr);
		}
		else {
			return null;
		}
	}

	/**
	 * Draws all the contained figures
	 * @@see Figure#draw
	 */
	public void draw(Graphics g) {
		draw(g, figures());
	}

	/**
	 * Draws only the given figures
	 * @@see Figure#draw
	 */
	public void draw(Graphics g, FigureEnumeration fe) {
		while (fe.hasNextFigure()) {
			fe.nextFigure().draw(g);
		}
	}

	/**
	 * Gets a figure at the given index.
	 */
	public Figure figureAt(int i) {
		return (Figure)fFigures.get(i);
	}

	/**
	 * Returns an Enumeration for accessing the contained figures.
     * The enumeration is a snapshot of the current contained figures
     * and is not a "live" enumeration and does not take subsequent
     * changes of the CompositeFigure into account.
	 * The figures are returned in the drawing order.
	 */
	public FigureEnumeration figures() {
		return new FigureEnumerator(CollectionsFactory.current().createList(fFigures));
	}

	/**
	 * Returns an enumeration to iterate in
	 * Z-order back to front over the figures
	 * that lie within the given bounds.
	 */
	public FigureEnumeration figures(Rectangle viewRectangle) {
		if (_theQuadTree != null) {

			FigureEnumeration fe =
				_theQuadTree.getAllWithin(new Bounds(viewRectangle).asRectangle2D());

			List l2 = CollectionsFactory.current().createList();

			while (fe.hasNextFigure()) {
				Figure f = fe.nextFigure();
				//int z = fFigures.indexOf(f);
				l2.add(new OrderedFigureElement(f, f.getZValue()));
			}

			Collections.sort(l2);

			List l3 = CollectionsFactory.current().createList();

			for (Iterator iter = l2.iterator(); iter.hasNext(); ) {
				OrderedFigureElement ofe = (OrderedFigureElement)iter.next();
				l3.add(ofe.getFigure());
			}

			return new FigureEnumerator(l3);
		}

		return figures();
	}

	/**
	 * Gets number of child figures.
	 */
	public int figureCount() {
		return fFigures.size();
	}

	/**
	 * Check whether a given figure is a child figure of this CompositeFigure.
	 */
	public boolean containsFigure(Figure checkFigure) {
		return fFigures.contains(checkFigure);
	}

    /**
	 * Returns an Enumeration for accessing the contained figures
	 * in the reverse drawing order.
	 */
	public final FigureEnumeration figuresReverse() {
		return new ReverseFigureEnumerator(CollectionsFactory.current().createList(fFigures));
	}

	/**
	 * Finds a top level Figure. Use this call for hit detection that
	 * should not descend into the figure's children.
	 */
	public Figure findFigure(int x, int y) {
		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			if (figure.containsPoint(x, y)) {
				return figure;
			}
		}
		return null;
	}

	/**
	 * Finds a top level Figure that intersects the given rectangle.
	 */
	public Figure findFigure(Rectangle r) {
		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			Rectangle fr = figure.displayBox();
			if (r.intersects(fr)) {
				return figure;
			}
		}
		return null;
	}

	/**
	 * Finds a top level Figure, but supresses the passed
	 * in figure. Use this method to ignore a figure
	 * that is temporarily inserted into the drawing.
	 * @@param x the x coordinate
	 * @@param y the y coordinate
	 * @@param without the figure to be ignored during
	 * the find.
	 */
	public Figure findFigureWithout(int x, int y, Figure without) {
		if (without == null) {
			return findFigure(x, y);
		}

		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			if (figure.containsPoint(x, y) && !figure.includes(without)) {
				return figure;
			}
		}
		return null;
	}

	/**
	 * Finds a top level Figure that intersects the given rectangle.
	 * It supresses the passed
	 * in figure. Use this method to ignore a figure
	 * that is temporarily inserted into the drawing.
	 */
	public Figure findFigure(Rectangle r, Figure without) {
		if (without == null) {
			return findFigure(r);
		}

		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			Rectangle fr = figure.displayBox();
			if (r.intersects(fr) && !figure.includes(without)) {
				return figure;
			}
		}
		return null;
	}

	/**
	 * Finds a figure but descends into a figure's
	 * children. Use this method to implement <i>click-through</i>
	 * hit detection, that is, you want to detect the inner most
	 * figure containing the given point.
	 */
	public Figure findFigureInside(int x, int y) {
		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure().findFigureInside(x, y);
			if (figure != null) {
				return figure;
			}
		}

		// bug-fix: 661878
		if (containsPoint(x, y)) {
			return this;
		}
		else {
			return null;
		}
	}

	/**
	 * Finds a figure but descends into a figure's
	 * children. It supresses the passed
	 * in figure. Use this method to ignore a figure
	 * that is temporarily inserted into the drawing.
	 */
	public Figure findFigureInsideWithout(int x, int y, Figure without) {
		if (without == null) {
			return findFigureInside(x, y);
		}

		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			if (figure != without) {
				Figure found = figure.findFigureInside(x, y);
				if ((found != null) &&  !figure.includes(without)) {
					return found;
				}
			}
		}

		if (containsPoint(x, y)) {
			return this;
		}
		else {
			return null;
		}
	}

	/**
	 * Checks if the composite figure has the argument as one of
	 * its children.
	 * @@return true if the figure is part of this CompositeFigure, else otherwise
	 */
	public boolean includes(Figure figure) {
		if (super.includes(figure)) {
			return true;
		}

		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure f = fe.nextFigure();
			if (f.includes(figure)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Moves all the given figures by x and y. Doesn't announce
	 * any changes. Subclassers override
	 * basicMoveBy. Clients usually call moveBy.
	 * @@see #moveBy
	 */
	protected void basicMoveBy(int x, int y) {
		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			fe.nextFigure().moveBy(x,y);
		}
	}

	/**
	 * Releases the figure and all its children.
	 */
	public void release() {
		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			figure.release();
		}
		// bug-fix: 661879 (CompositeFigure.release releasing itself before containees)
		super.release();
	}

	/**
	 * Propagates the figureInvalidated event to my listener.
	 * @@see FigureChangeListener
	 */
	public void figureInvalidated(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureInvalidated(e);
		}
	}

	/**
	 * Propagates the removeFromDrawing request up to the container.
	 * @@see FigureChangeListener
	 */
	public void figureRequestRemove(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureRequestRemove(new FigureChangeEvent(this));
		}
	}

	/**
	 * Propagates the requestUpdate request up to the container.
	 * @@see FigureChangeListener
	 */
	public void figureRequestUpdate(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureRequestUpdate(e);
		}
	}

	public void figureChanged(FigureChangeEvent e) {
		_removeFromQuadTree(e.getFigure());
		_addToQuadTree(e.getFigure());
	}

	public void figureRemoved(FigureChangeEvent e) {
		if (listener() != null) {
			listener().figureRemoved(e);
		}
	}

	/**
	 * Writes the contained figures to the StorableOutput.
	 */
	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(figureCount());
		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			dw.writeStorable(fe.nextFigure());
		}
	}

	/**
	 * Reads the contained figures from StorableInput.
	 */
	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		int size = dr.readInt();
		fFigures = CollectionsFactory.current().createList(size);
		for (int i=0; i<size; i++) {
			add((Figure)dr.readStorable());
		}
		init(displayBox());
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			figure.addToContainer(this);
		}

		init(new Rectangle(0, 0));
	}

	/**
	 * Used to optimize rendering.  Rendering of many objects may
	 * be slow until this method is called.  The view rectangle
	 * should at least approximately enclose the CompositeFigure.
	 * If the view rectangle is too small or too large, performance
	 * may suffer.
	 *
	 * Don't forget to call this after loading or creating a
	 * new CompositeFigure.  If you forget, drawing performance may
	 * suffer.
	 */
	public void init(Rectangle viewRectangle) {
		_theQuadTree = new QuadTree(new Bounds(viewRectangle).asRectangle2D());

		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			_addToQuadTree(fe.nextFigure());
		}
	}

	private void _addToQuadTree(Figure f) {
		if (_theQuadTree != null) {
			// Bugfix: Make sure the rectangle is not zero width or height.
			// Otherwise, the quadTree search in this.figures(Rectangle)
			// will be incorrect. [John Yu, 2002/05/23]
			Rectangle r = f.displayBox();
			if (r.height == 0) {
				r.grow(0, 1);
			}
			if (r.width == 0) {
				r.grow(1, 0);
			}

			_theQuadTree.add(f, new Bounds(r).asRectangle2D());
		}
	}

	private void _removeFromQuadTree(Figure f) {
		if (_theQuadTree != null) {
			_theQuadTree.remove(f);
		}
	}

	private void _clearQuadTree() {
		if (_theQuadTree != null) {
			_theQuadTree.clear();
		}
	}
}
@


1.11
log
@prepare for 5.4 release: various bug fixes
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d14 2
a15 2
import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;
@


1.10
log
@[ 661878 ] CompositeFigure.findFigureInside broken?
fixed
@
text
@d370 1
a370 1
	public final FigureEnumeration figures() {
d470 1
a470 1
		if (without == null)
d472 2
d491 1
a491 1
		if (without == null)
d493 2
d513 5
a517 5
		Figure figure = findFigure(x,y);
		if(figure instanceof CompositeFigure){
			Figure figure2 = figure.findFigureInside(x,y);
			if(figure2 != null) {
				figure = figure2;
d520 8
a527 1
		return figure;
d537 4
d546 1
a546 1
				if (found != null) {
d551 7
a557 1
		return null;
a596 1
		super.release();
d602 2
@


1.9
log
@Fixed problem with TextArea figures + cascading FigureChangeEvent
@
text
@d509 5
a513 5
		FigureEnumeration fe = figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure().findFigureInside(x, y);
			if (figure != null) {
				return figure;
d516 1
a516 1
		return null;
@


1.9.4.1
log
@improved functionality of CompositeFigureCreationTool
added comments to some files.(probably overdid it)
@
text
@a31 4
 * Orphan removes a figure but does not release it.  We need a description of what that means
 * and what the implications of that are.
 *
 *
d347 3
a349 7
	* Draws only the given figures
	* @@todo mrfloppy to ensure that only figures contained within this
	*  <b>CompositeFigure</b> get drawn.  dnoyeb's opinion is that this 
	*  method is unnecessary and if used is a symptom of some other issue.
	*  Likely {@@link #draw(Graphics) draw} is enough.
	* @@see Figure#draw
	*/
d364 6
a369 7
	* Returns an enumeration for accessing the contained figures.
	* The enumeration is a snapshot of the current contained <b>Figure</b>s
	* and is not a "live" enumeration and does not take subsequent
	* changes of the <b>CompositeFigure</b> into account.
	* The figures are returned in the drawing order.
	*
	*/
d376 1
a376 1
	 * Z-order back to front over the {@@link Figure Figure}s
d409 1
a409 1
	 * Gets number of contained {@@link Figure Figure}s.
d416 1
a416 1
	 * Check whether a given <b>figure</b> is contained within this <b>CompositeFigure.</b>
d423 2
a424 2
	 * Returns an enumeration for accessing the contained {@@link Figure Figure}s
	 * in the reverse {@@link Drawing Drawing} order.
d432 1
a432 1
	 * should not descend into the contained <b>Figure</b>s.
d446 1
a446 2
	 * Finds a top level <b>Figure</b> that intersects the given rectangle.
	 * @@return	Returns the found <b>Figure</b>, or <b>null</b> if not found.
d461 2
a462 2
	 * Finds a top level <b>Figure</b>, but supresses the passed
	 * in <b>Figure</b>. Use this method to ignore a figure
d466 1
a466 1
	 * @@param without the <b>Figure</b> to be ignored during
a506 11
	 *
	 * This seems broken!!!  A figure does not seem to be able to find "itself."
	 * It will pass its call recursively onto the figures it contains, until a
	 * figure that contains no figures is found.  At which point that figure will
	 * return null.  This null will trickly all the way back up the heirarchy.
	 *
	 * My opinion is that you should first check {@@link #findFigure(int, int) findFigure(int x, int y)}.
	 * If that hits, call {@@link #findFigureInside(int, int) findFigureInside(int x, int y)}.
	 * on the found Figure.  If that returns null <i>then</i> return the found figure.
	 * dnoyeb@@users.sourceforge.net
	 *
a523 1
	 * @@see #fingFigureInside for my error comments.
d540 2
a541 2
	 * Checks if the composite figure has the argument as one of its contained
	 * figures.
d573 1
a573 4
	 * Releases the figure and all its contained figures.
	 * Should we release the figures in the order they were added?
	 * i.e. should we first release the contained figures, THEN call super.release()??
	 * !!!dnoyeb@@users.sourceforge.net
a595 3
	 * Why does a contained figures remove request end up being the compositeFigures
	 * remove request? can we not remove just the contained figure?
	 * This seems bizarre!!! dnoyeb
@


1.9.4.2
log
@1.  Encapsulated the useage of FigureChangeListener on ContainerFigure.  ContainerFigure does no longer implement
    FigureChangeListener, but has an inner class for that.  All of the FigureChangeListener methods on
    the CompositeFigure class are now protected.  Subclasses as well.

2.  Drawing no longer implements FigureChangeListener.  defers to implementatations to subclass or implement that.

3.  FindFigureInside fixed.  waiting on better fix with Strategy Pattern from mrfloppy.
@
text
@d41 3
a43 1
public abstract class CompositeFigure extends AbstractFigure {
a59 24
	
	/**
	 * Encapsulate the FigureChangeListener implementation
	 */
	
	private FigureChangeListener figureChangeListener = new innerFigureChangeListener();

	private class innerFigureChangeListener implements FigureChangeListener, java.io.Serializable, Cloneable {
		public void figureInvalidated(FigureChangeEvent e){
			CompositeFigure.this.figureInvalidated(e);
		}
		public void figureChanged(FigureChangeEvent e){
			CompositeFigure.this.figureChanged(e);
		}
		public void figureRemoved(FigureChangeEvent e){
			CompositeFigure.this.figureRemoved(e);
		}
		public void figureRequestRemove(FigureChangeEvent e){
			CompositeFigure.this.figureRequestRemove(e);
		}
		public void figureRequestUpdate(FigureChangeEvent e){
			CompositeFigure.this.figureRequestUpdate(e);
		}
	};
d66 1
a66 1
	
d78 1
a78 1
			figure.addToContainer(figureChangeListener);
d88 1
a88 2
	 * @@deprecated use {@@link #addAll(FigureEnumeration) 
	 * addAll(FigureEnumeration fe)} instead.
d98 1
a98 1
	 * @@param fe An enumeration containing all figures to be added.
d125 1
a125 2
	 * @@deprecated use {@@link #removeAll(FigureEnumeration) 
	 *             removeAll(FigureEnumeration fe)} instead.
d132 1
a132 1
	 * Removes a <b>FigureEnumeration</b> of figures.
d142 1
a142 1
	 * Removes all contained figures.
d149 1
a149 1
			figure.removeFromContainer(figureChangeListener);
a162 3
	 * I think this is a good place to throw a runtime exception if the Figure
	 * is not part of the drawing, dnoyeb!!! BadParameterException
	 *
d166 1
a166 1
		figure.removeFromContainer(figureChangeListener);
d177 1
a177 2
	 * @@deprecated use {@@link #orphanAll(FigureEnumeration)
	 *             orphanAll(FigureEnumeration fe)} instead
d201 2
a202 2
			replacement.addToContainer(figureChangeListener);   // will invalidate figure
			figure.removeFromContainer(figureChangeListener);
d211 1
a211 3
	 * Sends a figure to the back of the drawing.  
	 * I think this is a good place to throw a runtime exception if the Figure
	 * is not part of the drawing, dnoyeb!!! BadParameterException
a226 4
	 * I think this is a good place to throw a runtime exception if the Figure
	 * is not part of the drawing, dnoyeb!!! BadParameterException
	 * I have spoken on BadParameterException several times, I won't mention it
	 * all the way through the file...
d255 1
a255 1
	 * @@param figure Figure to be sent to a certain layer
d353 3
a355 6
	*        <b>CompositeFigure</b> get drawn.  dnoyeb's opinion is that this 
	*         method is unnecessary and if used is a symptom of some other issue.
	* Likely {@@link #draw(Graphics) draw} is enough and we don't need this.
	*
	* if we are asked to draw figures that we do not contain, Exception?
	*
d379 1
a379 1
	public FigureEnumeration figures() {
d518 8
a525 8
	 * This is improved but still <b>broken.</b>  Its achiles heel is the evil
	 * {@@link CH.ifa.draw.standard.DecoratorFigure DecoratorFigure} that is
	 * "decorating" (read masking) the <b>CompositeFigures</b> it decorates.
	 * mrfloppy is working on a "Strategy pattern" fix for this.  Still I
	 * believe it would be better all around if {@@link 
	 * CH.ifa.draw.standard.DecoratorFigure DecoratorFigure} actually used the
	 * "Decorator pattern." 
	 * Currently this method can not dig inside decorator figures.
d527 1
d530 4
a533 6
		Figure figure = findFigure(x,y);
		if(figure instanceof CompositeFigure){
			Figure figure2 = figure.findFigureInside(x,y);
			if(figure2 != null)
				return figure2;
			else
d535 1
d537 1
a537 5
		else if(figure instanceof DecoratorFigure){
			return getFigureWithoutDecoration(figure).findFigureInside(x,y);
		}
		else
			return figure;
d539 1
a539 10
	
	protected Figure getFigureWithoutDecoration(Figure peelFigure) {
		if (peelFigure instanceof DecoratorFigure) {
			return getFigureWithoutDecoration(((DecoratorFigure)peelFigure).getDecoratedFigure());
		}
		else {
			return peelFigure;
		}
	}
	
d545 1
a545 1
	 * @@see #findFigureInside for my error comments.
d613 1
a613 1
	protected void figureInvalidated(FigureChangeEvent e) {
a623 2
	 * It seems liek if a contained figure wants out, the whole compositefigure
	 * ends up requesting removal from its container too.
d626 1
a626 1
	protected void figureRequestRemove(FigureChangeEvent e) {
d628 1
a628 1
			listener().figureRequestRemove(new FigureChangeEvent(CompositeFigure.this));
d636 1
a636 1
	protected void figureRequestUpdate(FigureChangeEvent e) {
d642 1
a642 1
	protected void figureChanged(FigureChangeEvent e) {
d647 1
a647 1
	protected void figureRemoved(FigureChangeEvent e) {
d686 1
a686 1
			figure.addToContainer(figureChangeListener);
@


1.9.4.3
log
@1. javadoc comments and corrections and clarifications
2. Drawing no longer exposes its drawing change listener, but has a method for those who want the drawing to request all views of it to be updated.
3. all removeAll() methods in CompositeFigure now have single consistent implementation.
4. standardDrawing unlock calls notify instead of notifyAll since only 1 can grab the lock anyway.
@
text
@a162 3
		_clearQuadTree();
		_nLowestZ = 0;
		_nHighestZ = 0;
d171 9
a179 2
		removeAll(fe);
//		fFigures.clear();
d648 1
a648 1
	 * !!!dnoyeb!!!
a651 1
		//removeAll
d673 1
a673 1
	 * This seems bizarre !!!dnoyeb!!!
a675 7
	 * I think those listening to this event should know who wants to be removed
	 * by querying the <code>FigureChangeEvent</code>.
	 * Still sees wrong here.
	 *
	 * Certainly this is wrong, we must handle our containees.
	 *
	 * 
a685 7
	 * This is a refiring of the event fired on the figures we are listening to.
	 * This passes this event onto those who are listening to us.
	 * we shouldnt pass it on.  those we are passing too never registered to hear
	 * events on the figure we are passing them.
	 * We should be repackaging this, since as far as our listeners are concerned
	 * we are firing it.
	 *
a723 1
		//what about z value reset?
@


1.9.4.4
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d48 1
a48 1
	private List fFigures;
a60 3
	 * Warning, this is the reference the figures will refer to for their
	 * container.  This is what they will store with then when they are stored.
	 * we must store this as well.
d62 1
d65 1
a65 1
	private class innerFigureChangeListener implements FigureChangeListener, java.io.Serializable,Cloneable {
d84 1
a84 1
		setFigures( CollectionsFactory.current().createList() );
d88 1
a88 8

	protected List getFigures(){
		return fFigures;
	}

	protected void setFigures(List figures){
		fFigures = figures;
	}
d96 1
a96 1
	public void add(Figure figure) {
d99 2
a100 2
			getFigures().add(figure);
			figure.addToContainer(figureChangeListener);  //add a figure to this CompositeFigure
d103 1
d110 2
a111 2
	 * @@deprecated use {@@link #addAll(FigureEnumeration)
	 *             addAll(FigureEnumeration fe)} instead.
d128 1
a128 1
	
d130 2
a131 13
	 * Removes a figure from the figure list and releases it.  Use this method
	 * if you do not wish to support undo/redo.  An alternate way to achieve the
	 * same effect is to handle removal through the Figure with
	 * <code>
	 * figure.remove();
	 * figure.release();
	 * </code>
	 *
	 * If you wish to support undo/redo use {@@link #orphan orphan} instead.
	 * @@see Figure#remove
	 * @@see Figure#release
	 * @@see FigureChangeListener#figureRequestRemove
	 * @@see FigureChangeListener#figureRemoved
d133 2
d136 4
a139 3
	public void remove(Figure figure) {
		if(!containsFigure(figure)){
			throw new JHotDrawRuntimeException("Figure is not part of this CompositeFigure.");
d141 1
a141 2
		figure.remove();
		figure.release();
d145 1
a145 2
	 * Removes a list of figures from the CompositeFigure.
	 * <b>You</b> are responsible for their release.
d148 1
a148 1
	 * @@deprecated use {@@link #removeAll(FigureEnumeration fe) 
d156 1
a156 3
	 * Removes all figures from this container and releases it from the undo/redo
	 * architecture.
	 *
d161 1
a161 1
			remove( fe.nextFigure());
d163 3
d169 1
a169 3
	 * Removes all figures from this container and releases it from the undo/redo
	 * architecture.
	 *
d173 3
a175 1
		removeAll(  figures() );
d179 6
a184 8
	 * Orphans a figure from the container, but doesn't release it. Use this 
	 * method to temporarily manipulate a figure outside of the drawing.  This
	 * method is to be used to support the undo/redo architecture.  This method
	 * will be executed in response to a figureRequestRemove event.  Alternately
	 * one can orphan the Figure with
	 * <code>
	 * figure.remove();
	 * </code>
d186 1
a186 3
	 * @@see Figure#remove
	 * @@see FigureChangeListener#figureRequestRemove
	 * @@param figure that is part of the drawing and should be removed
d188 5
a192 2
	public synchronized void orphan(Figure figure) {
		figure.remove();
d196 9
a204 5
	 * @@deprecated use {@@link #orphanAll(FigureEnumeration fe) 
	 *             orphanAll(FigureEnumeration fe)} instead.
	 */	
	public void orphanAll(List figures) {
		orphanAll( new FigureEnumerator(figures) );
a206 5
	/**
	 * Orphans a FigureEnumeration of figures.
	 * @@see #orphan
	 * @@see Figure#remove
	 */	
a210 3
		_clearQuadTree();
		_nLowestZ = 0;
		_nHighestZ = 0;
a219 1
	 * @@todo determine what we are doign here.  is this an orphan with an add or what?
d222 1
a222 1
		int index = getFigures().indexOf(figure);
d227 1
a227 1
			getFigures().set(index, replacement);
d243 2
a244 2
			getFigures().remove(figure);
			getFigures().add(0, figure);
d262 2
a263 2
			getFigures().remove(figure);
			getFigures().add(figure);
d290 2
a291 2
			if (layerNr >= getFigures().size()) {
				layerNr = getFigures().size() - 1;
d304 2
a305 2
			getFigures().remove(figure);
			getFigures().add(layerNr, figure);
d314 2
a315 2
		if (upperBound >= getFigures().size()) {
			upperBound = getFigures().size() - 1;
d319 2
a320 2
			Figure currentFigure = (Figure)getFigures().get(i);
			Figure predecessorFigure = (Figure)getFigures().get(i - 1);
d326 2
a327 2
		if (upperBound >= getFigures().size()) {
			upperBound = getFigures().size() - 1;
d331 2
a332 2
			Figure currentFigure = (Figure)getFigures().get(i);
			Figure successorFigure = (Figure)getFigures().get(i + 1);
d351 1
a351 1
			return getFigures().indexOf(figure);
d364 2
a365 2
		if ((layerNr >= 0) && (layerNr < getFigures().size())) {
			return (Figure)getFigures().get(layerNr);
d401 1
a401 1
		return (Figure)getFigures().get(i);
d413 1
a413 1
		return new FigureEnumerator(CollectionsFactory.current().createList(getFigures()));
d431 1
a431 1
				//int z = getFigures().indexOf(f);
d454 1
a454 1
		return getFigures().size();
d461 1
a461 1
		return getFigures().contains(checkFigure);
d469 1
a469 1
		return new ReverseFigureEnumerator(CollectionsFactory.current().createList(getFigures()));
d641 4
a644 4
	 * Removes all contained figures from this container.
	 * Releases all contained figures from this container.
	 * Releases itself.
	 * @@see #remove
a646 1
		removeAll();
d648 6
d657 1
a657 2
	 * Called when one of the contained figures has been invalidated.  As a 
	 * result, we will invalidate this rectangle on our container.
d662 1
a662 1
			listener().figureInvalidated( new FigureChangeEvent(this,e.getInvalidatedRectangle()));
d667 14
a680 1
	 * Responds to a contained figure requesting to be removed from the component.
a682 6
		Figure f = e.getFigure();
		Rectangle r = f.displayBox();
		f.removeFromContainer( figureChangeListener ); //removes the figure from being contained in this CompositeFigure
		getFigures().remove(f);
		_removeFromQuadTree(f);
		//need to do something here to repaint the removed area.
d684 1
a684 4
			listener().figureInvalidated(new FigureChangeEvent( this, r ));
			listener().figureRequestUpdate(new FigureChangeEvent(this));
			//preferably whoever ordered the remove should order the update so 
			//we dont redraw too frequently and unnecessarily
d689 7
a695 3
	 * Called when one of the contained figures is requesting to be redrawn.
	 * As a result, we will request to be redrawn from our container in order
	 * to satisfy the request of our containee.
d701 1
a701 1
			listener().figureRequestUpdate(new FigureChangeEvent(this));
a704 3
	/**
	 * This event is handled internally by the container !?!dnoyeb!?!
	 */
d709 1
a709 3
	/**
	 *
	 */
d711 3
a713 1

a717 3
	 *
	 * gotta write the new innerlistener since this is who figures think we are.
	 * !!!dnoyeb!!!
a729 3
	 * @@todo evaluate readding to container.  Shouldnt we just save them already IN
	 *       the container. the z values are being redone unless they were stored
	 *       in z order.  ???dnoyeb???
d734 1
a734 1
		setFigures( CollectionsFactory.current().createList(size) );
a735 1
		//this add is redundant ???dnoyeb??? figurea already set, just need to get the stored listener
a741 3
	/**
	 * used for what? clone?
	 */
d750 1
a750 1
			figure.addToContainer(figureChangeListener);//this should be stored in the file right? ???dnoyeb???
@


1.9.4.5
log
@File IO corrections.
@
text
@a737 1
		//store figures
a743 8
	
	/**
	 * @@todo implement this.
	 */
	private void writeObject(ObjectOutputStream s) throws IOException {
		//s.defaultWriteObject();
		throw new IOException("writeObject not implemented for CompositeFigure.");
	}
d747 3
a752 1
		//
d756 1
d764 1
a764 2
	 * Used for the cloning mechanism.
	 * @@todo Implement this.
a767 1
		throw new IOException("readObject not implemented for CompositeFigure.");
d769 9
a777 7
//		FigureEnumeration fe = figures();
//		while (fe.hasNextFigure()) {
//			Figure figure = fe.nextFigure();
//			figure.addToContainer(figureChangeListener);
//		}
//
//		init(new Rectangle(0, 0));
@


1.9.4.6
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@d61 3
a63 1
	 * is this created when cloned???dnoyeb???
d65 2
a66 2
	private transient FigureChangeListener figureChangeListener = new innerFigureChangeListener();
	
d74 3
a79 3
		public void figureRemoved(FigureChangeEvent e){
			CompositeFigure.this.figureRemoved(e);
		}
a151 1
	 * @@deprecated use figure.remove();figure.release();
d154 3
a159 5
	
	protected void removeImpl(Figure figure){
		if(!containsFigure(figure)){
			throw new JHotDrawRuntimeException("Figure is not part of this CompositeFigure.");
		}
a160 12
		Rectangle r = figure.displayBox();
		figure.removeFromContainer( figureChangeListener ); //removes the figure from being contained in this CompositeFigure
		getFigures().remove(figure);
		_removeFromQuadTree(figure);
		//need to do something here to repaint the removed area.
		if (listener() != null) {
			listener().figureInvalidated(new FigureChangeEvent( this, r ));
			listener().figureRequestUpdate(new FigureChangeEvent(this));
			//preferably whoever ordered the remove should order the update so 
			//we dont redraw too frequently and unnecessarily
		}		
	}
a176 1
	 * @@deprecated see {@@link #remove remove}
a206 1
	 * @@deprecated use figure.remove()
a222 1
	 * @@deprecated use figure.remove();
d261 1
a261 1
	 * This needs work.  perhaps a will change?
d574 9
d593 3
d600 9
d689 12
a700 4
		removeImpl(e.getFigure());
	}
	public void figureRemoved(FigureChangeEvent e){
		//useless
d723 6
d732 3
a734 1
	 * The storing process is assumed to be serial and not in need of synchronization.
d747 1
a747 1
	 * Shallow serialization of the object and the figures it contains
d750 2
a751 1
		s.defaultWriteObject();
a755 1
	 * The loading process is assumed to be serial and not in need of synchronization.
d771 1
a771 3
	 * Seems to be a copy of those within us, but nothing to do with those we
	 * connect to. 
	 * @@todo Verify and specify the functionality to be here.
d775 1
d777 7
a783 12
		//the figures are not transient so they get deserialized here
		s.defaultReadObject();

		//the listener is transient and not deserialized
		//so we need to establish listening to our new figures
		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			figure.addToContainer(figureChangeListener);
		}

		init(new Rectangle(0, 0));
@


1.9.4.7
log
@New FigureDecorator using decorator pattern now installed.
A few other minor cleanups.
@
text
@d432 1
a432 1
			fe.nextFigure().drawAll(g);
@


1.9.4.8
log
@Debugging exceptions added / cleanedup
@
text
@d104 6
a109 5
		DEBUG_validateContainment(figure,false);
		figure.setZValue(++_nHighestZ);
		getFigures().add(figure);
		figure.addToContainer(figureChangeListener);  //add a figure to this CompositeFigure
		_addToQuadTree(figure);
a152 1
		DEBUG_validateContainment(figure,true);		
d157 5
a161 1
	protected void basicOrphan(Figure figure){
a224 1
		DEBUG_validateContainment(figure,true);		
a260 1
		DEBUG_validateContainment(figure,true);		
d275 3
d281 7
a287 6
		DEBUG_validateContainment(figure,true);		
		getFigures().remove(figure);
		getFigures().add(0, figure);
		_nLowestZ--;
		figure.setZValue(_nLowestZ);
		figure.changed();
d292 4
d300 7
a306 6
		DEBUG_validateContainment(figure,true);		
		getFigures().remove(figure);
		getFigures().add(figure);
		_nHighestZ++;
		figure.setZValue(_nHighestZ);
		figure.changed();
d328 19
a346 10
		DEBUG_validateContainment(figure,true);
		if (layerNr >= getFigures().size()) {
			layerNr = getFigures().size() - 1;
		}
		Figure layerFigure = getFigureFromLayer(layerNr);
		int layerFigureZValue = layerFigure.getZValue();
		int figureLayer = getLayer(figure);
		// move figure forward
		if (figureLayer < layerNr) {
			assignFiguresToPredecessorZValue(figureLayer + 1, layerNr);
a347 8
		else if (figureLayer > layerNr) {
			assignFiguresToSuccessorZValue(layerNr, figureLayer - 1);
		}

		getFigures().remove(figure);
		getFigures().add(layerNr, figure);
		figure.setZValue(layerFigureZValue);
		figure.changed();
a551 1
		DEBUG_validateContainment(without,true);		
a570 1
		DEBUG_validateContainment(without,true);		
a611 1
		DEBUG_validateContainment(without,true);		
d684 1
a684 1
		basicOrphan(e.getFigure());
d686 2
a687 2
	protected void figureRemoved(FigureChangeEvent e){
		//useless to us
a816 19
		}
	}
	/**
	 * This is development level code that should not be released in a non
	 * development edition.  Don't know how to accomplish this.  ASSERT seems
	 * like a good way in JDK1.4
	 */
	protected void DEBUG_validateContainment(Figure figure, boolean want){
		//This will become ASSERT in JDK 1.4
		//This represents an avoidable error on the programmers part.
		if(want == true){
			if(!containsFigure(figure)){
				throw new JHotDrawRuntimeException("Figure is not part of this CompositeFigure.");
			}
		}
		else{
			if(containsFigure(figure)){
				throw new JHotDrawRuntimeException("Figure is already part of this CompositeFigure.");
			}			
@


1.9.4.9
log
@More containment state validation
CompositeFigure serilization fix for bug introduced by myself lately.
@
text
@d63 1
a63 1
	private transient FigureChangeListener figureChangeListener;
a84 1
		figureChangeListener = new innerFigureChangeListener();
d105 1
a105 1
		figure.setZValue(++_nHighestZ); //no need to increment.  draw order insures subsequent on top.
a699 3
		if (listener() != null) {
			listener().figureChanged(new FigureChangeEvent(this));
		}
a729 1
		figureChangeListener = new innerFigureChangeListener();
a751 1
		figureChangeListener = new innerFigureChangeListener();
@


1.9.4.10
log
@view addToSelection used drawing.includes(figure) but selectionZOrdered uses figures()
these are 2 different sets of figures.  changed addToSelection to use containsFigure()
Added some experimental copy constructors that are not being used.
some trivial comments.
@
text
@d106 1
a106 1
		figure.setZValue(++_nHighestZ);
d443 1
a443 19
	protected List basicIncludedFigures(){
		List figures = CollectionsFactory.current().createList();
		FigureEnumeration fe = figures();
		while(fe.hasNextFigure()){
			Figure f = fe.nextFigure();
			figures.add( f );
			if(f instanceof CompositeFigure) {
				List innerFigures = ((CompositeFigure)f).basicIncludedFigures();
				if(innerFigures.size() > 0){
					figures.addAll( innerFigures );
					continue;
				}
			}
		}
		return figures;
	}
	public FigureEnumeration includedFigures() {
		return new FigureEnumerator(basicIncludedFigures());
	}
d586 1
a586 1
			if(figure2 != null) {
d588 2
a589 1
			}
d591 2
a592 1
		return figure;
a833 11
	}
	/**
	 * Experimental copy constructor.
	 */
	protected CompositeFigure(CompositeFigure cf){
		super(cf);
		cf.fFigures = fFigures;
		cf._nLowestZ = _nLowestZ;
		cf._nHighestZ = _nHighestZ;
		cf.figureChangeListener = figureChangeListener;
		cf.init(new Rectangle(0, 0));	
@


1.9.4.11
log
@Decorator Figure returns...To apease the brave hearted :-)
Its not very well integrated with the current state of affairs.  It works as well as it always
has though.
@
text
@d90 1
a90 1
	protected final List getFigures(){
d203 1
a203 1
		removeAll(  new FigureEnumerator(getFigures()) );
d405 1
a405 1
		draw(g, new FigureEnumerator(getFigures()));
a497 1
	 * should use figures()
a504 1
	 * Should use figures()
a512 1
	 * Should use figures()
a636 1
	 * should
d660 1
a660 1
		FigureEnumeration fe = new FigureEnumerator(getFigures());
d730 1
a730 1
		FigureEnumeration fe = new FigureEnumerator(getFigures());
d775 1
a775 1
		FigureEnumeration fe = new FigureEnumerator(getFigures());
d798 1
a798 1
		FigureEnumeration fe = new FigureEnumerator(getFigures());
@


1.9.4.12
log
@More cleanups for DecoratorFigure.  Its going to cause problems till the architecture changes.
Added a few needed methods to expose private variables of StandardDrawingView to make it more
override friendly.
@
text
@d506 1
a506 1
	 * Should use figures()?
@


1.9.4.13
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d104 1
a104 1
	public Figure add(Figure figure) {
a109 1
		return figure;
d129 1
a129 2
	public FigureEnumeration addAll(FigureEnumeration fe) {
		List l = CollectionsFactory.current().createList();
d131 1
a131 1
			l.add(add(fe.nextFigure()));
a132 1
		return new FigureEnumerator(l);
d150 1
d152 1
a152 1
	public Figure remove(Figure figure) {
a155 1
		return figure;
d190 1
a190 2
	public FigureEnumeration removeAll(FigureEnumeration fe) {
		List l = CollectionsFactory.current().createList();
d192 1
a192 1
			l.add(remove( fe.nextFigure()));
a193 1
		return new FigureEnumerator(l);
d218 1
d236 1
d401 1
a401 2
	 * Draws all the contained figures.
	 * @@todo Make this respect Z values in some way.
d410 5
a415 1
	* maybe this should be protected?
@


1.9.4.14
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@a15 1
import CH.ifa.draw.figures.NullFigure;
d49 1
a49 1
	private Map orphanMap;
d72 6
d84 1
a84 2
		fFigures = CollectionsFactory.current().createList();
		orphanMap = CollectionsFactory.current().createMap();
d94 1
a94 1
	protected final void setFigures(List figures){
d104 1
a104 1
	public void add(Figure figure) {
d110 1
d130 2
a131 1
	public void addAll(FigureEnumeration fe) {
d133 1
a133 1
			add(fe.nextFigure());
d135 1
d139 7
a145 3
	 * This will orphan and release a figure
	 * if orphan has not been called on the figure, it will be called as a result
	 * of this method.  The figure can not be used any further.
d147 5
d154 5
a158 28
	public void remove(Figure figure) {
		//figure must be orphaned already
		if(!orphanMap.containsKey(figure)){
			orphan(figure);
		}
		Figure nf = (Figure)orphanMap.remove(figure);
		getFigures().remove(nf);
		figure.release();//gives figure advance alert of its pending GC.
	}
	/**
	 * Puts a figure back into the CompositeFigure in its old place.
	 * Figure must have already been orphaned.
	 */
	public void restore(Figure figure){
		if(orphanMap.containsKey(figure)){
			Rectangle r = figure.displayBox();
			Figure nf = (Figure) orphanMap.remove(figure);
			int index = getFigures().indexOf(nf);
			getFigures().set(index,figure);
			figure.addToContainer( this.figureChangeListener );
			//need to do something here to repaint the removed area.
			if (listener() != null) {
				listener().figureInvalidated(new FigureChangeEvent( this, r ));
				listener().figureRequestUpdate(new FigureChangeEvent(this));
				//preferably whoever ordered the remove should order the update so 
				//we dont redraw too frequently and unnecessarily
			}
		}
d161 13
d176 1
a176 1
	 * calls orphan first if necessary.
d188 1
a188 1
	 * architecture.  calls orphan on the figures first if necessary
d193 2
a194 1
	public void removeAll(FigureEnumeration fe) {
d196 1
a196 1
			remove( fe.nextFigure());
d198 1
d202 3
a204 2
	 * Removes all figures from this container.  calls orphan on the figures first
	 * if necessary.  Ignores any currently orphaned figures.
d208 1
a208 1
		removeAll( new FigureEnumerator(getFigures()));
d214 6
a219 1
	 * method is to be used to support the undo/redo architecture.  
d221 2
d227 1
a227 21
		Rectangle r = figure.displayBox();
		figure.removeFromContainer( figureChangeListener ); //removes the figure from being contained in this CompositeFigure
		//replace the figure with a null figure
		int index = getFigures().indexOf(figure);
		Figure nf = new NullFigure();
		getFigures().set(index,nf);
		//store a reference to the NullFfigure and the actual figure
		orphanMap.put(figure,nf);
		//remove figure from quad tree
		_removeFromQuadTree(figure);

		
//		figure.remove();//fire the figure orphaned event?
		
		//need to do something here to repaint the removed area.
		if (listener() != null) {
			listener().figureInvalidated(new FigureChangeEvent( this, r ));
			listener().figureRequestUpdate(new FigureChangeEvent(this));
			//preferably whoever ordered the remove should order the update so 
			//we dont redraw too frequently and unnecessarily
		}
a442 1

a458 20
	protected List basicIncludedFigures(int uptoDepth, boolean exclusive){
		List figures = CollectionsFactory.current().createList();
		FigureEnumeration fe = figures();
		while(fe.hasNextFigure()){
			Figure f = fe.nextFigure();
			if(exclusive == false) {
				figures.add( f );
			}
			if(uptoDepth > 0){
				if(f instanceof CompositeFigure) {
					List innerFigures = ((CompositeFigure)f).basicIncludedFigures(uptoDepth - 1,exclusive);
					if(innerFigures.size() > 0){
						figures.addAll( innerFigures );
						continue;
					}
				}
			}
		}
		return figures;
	}
a461 13

	/**
	 * Returns all figures upto the specified depth, with 0 being only the topmost
	 * level.  if exclusive is true, it only returns figures present at the depth
	 * specified.  This is used for tools that work on figures within figures.
	 *
	 */
	public FigureEnumeration includedFigures(int depth, boolean exclusive){
		return new FigureEnumerator(basicIncludedFigures(depth,exclusive));
	}
	
	
	
a555 3
	 *
	 * final because it relies on findFigure.  change that to change behavior.
	 *
d693 10
a756 1
		orphanMap = CollectionsFactory.current().createMap(); 
@


1.9.4.15
log
@hack for [ 674973 ] Context Sensitive menu updates
add used instead of restore since its easier for the CompositeFigure to decide wether to add or
to restore.
@
text
@d50 1
a50 1
	private transient Map orphanMap;
d62 1
d98 1
d101 5
a105 11
		if(orphanMap.containsKey(figure)){
			System.out.println("Figure restored to " + this);
			restore(figure);
		}
		else {
			DEBUG_validateContainment(figure,false);
			figure.setZValue(++_nHighestZ);
			getFigures().add(figure);
			figure.addToContainer(figureChangeListener);  //add a figure to this CompositeFigure
			_addToQuadTree(figure);
		}
d151 1
a151 1
	protected void restore(Figure figure){
a157 1
			_addToQuadTree(figure);
d184 1
d222 3
d807 1
a807 1
		orphanMap = CollectionsFactory.current().createMap(); 
@


1.9.4.16
log
@Figure.release() no longer used.  No one but figure ever qualified to call it.
overrideable method should not be called during construction or initialization
more work needed on that.  init needs to be private if its going to be called.
experimental copy constructor removed.
@
text
@d149 1
a149 1
		//figure.release();//who is qualified to call this? who can know if figure is contained elsewhere...
a153 2
	 * @@todo investigate removing the event firing from here, that way we can use add
	 * to add to container and quadtree
d163 1
a163 1
			//need to do something here to repaint the restored area? probably unnecessary, just behave like add does
d788 1
a788 1
		fFigures = CollectionsFactory.current().createList(size);
d887 11
@


1.9.4.17
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d136 3
a138 3
	 * This will remove a figure.  orphan will be called first if necessary.
	 * It is the removers responsibility to call {@@link Figure#release release()}
	 * if disposing the figure.
d149 1
a201 2
	 * 
	 *
a202 4
	 * @@deprecated This method does not release the figures as required for
	 *             removed figures.  It also does not return them so the caller
	 *             has no way of knowing the list of figures that now require
	 *             release.
a212 4
	 * An orphaned figure may only be added back to the container it was orphaned
	 * from.  If you need to add the figure to a different container, first 
	 * remove it from the container it has been orphaned from.
	 *
d246 1
a246 4
	 * Orphans a FigureEnumeration of figures.  These figures must be removed
	 * before they are eligible for release.
	 *
	 * @@see #removeAll
d248 1
d716 1
a716 1
	 * Releases all contained figures.
a717 2
	 * This figure can not be released until its orphans are removed.
	 *
a718 1
	 * @@see Figure#release
d721 1
a721 14
		if( getContainer() != null ) {
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
			throw new JHotDrawRuntimeException("Figure can not be released, it has not been removed yet.");
		}
		if(orphanMap.size() > 0){
			throw new JHotDrawRuntimeException("Figure can not be released until its orphans are removed.");
		}
		FigureEnumeration feRemove = figures();
		FigureEnumeration feRelease = figures();
		removeAll(feRemove);
		while(feRelease.hasNextFigure()){
			feRelease.nextFigure().release();
		}
d770 1
a770 5
			Figure f = fe.nextFigure();
			if(f instanceof NullFigure){
				System.err.println("Warning, writing NullFigure " + f);
			}
			dw.writeStorable(f);
d794 1
a794 5
			Figure f = (Figure)dr.readStorable();
			if(f instanceof NullFigure){
				System.err.println("Warning, reading NullFigure." + f);
			}
			add(f);
d796 1
a796 1
		init(displayBox()); //this is a bad call.  calling unitialized subclasses possible here.
@


1.9.4.18
log
@pragmatic fix for [ 679266 ] Dependent figure calling non final methods during loading
it really requires an architecture change in some respects.
@
text
@a828 3
			else if(f instanceof ConnectionFigure){
				((ConnectionFigure)f).updateConnection();
			}
@


1.8
log
@introduce FigureVisitor for paste/delete commands
@
text
@d615 2
a616 2
	  _removeFromQuadTree(e.getFigure());
	  _addToQuadTree(e.getFigure());
d620 3
@


1.7
log
@after variou merges... (before 5.4 release)
@
text
@d110 5
a114 1
		return orphan(figure);
a124 1

d162 3
a164 5
		if (containsFigure(figure)) {
			figure.removeFromContainer(this);
			fFigures.remove(figure);
			_removeFromQuadTree(figure);
		}
d644 1
d657 2
@


1.6
log
@no message
@
text
@d18 1
d46 1
a46 1
	protected Vector fFigures;
d58 1
a58 1
		fFigures = new Vector();
d73 1
a73 1
			fFigures.addElement(figure);
d81 1
a81 1
	 * Adds a vector of figures.
d86 1
a86 1
	public void addAll(Vector newFigures) {
d97 1
a97 1
		while (fe.hasMoreElements()) {
d114 1
a114 1
	 * Removes a vector of figures.
d119 1
a119 1
	public void removeAll(Vector figures) {
d129 1
a129 1
		while (fe.hasMoreElements()) {
d140 1
a140 1
		while (fe.hasMoreElements()) {
d144 1
a144 1
		fFigures.removeAllElements();
d161 1
a161 1
			fFigures.removeElement(figure);
d168 1
a168 1
	 * Removes a vector of figures from the figure's list
d174 1
a174 1
	public void orphanAll(Vector newFigures) {
d179 1
a179 1
		while (fe.hasMoreElements()) {
d198 1
a198 1
			fFigures.setElementAt(replacement, index);
d212 2
a213 2
			fFigures.removeElement(figure);
			fFigures.insertElementAt(figure,0);
d227 2
a228 2
			fFigures.removeElement(figure);
			fFigures.addElement(figure);
d269 2
a270 2
			fFigures.removeElement(figure);
			fFigures.insertElementAt(figure, layerNr);
d284 2
a285 2
			Figure currentFigure = (Figure)fFigures.elementAt(i);
			Figure predecessorFigure = (Figure)fFigures.elementAt(i - 1);
d296 2
a297 2
			Figure currentFigure = (Figure)fFigures.elementAt(i);
			Figure successorFigure = (Figure)fFigures.elementAt(i + 1);
d330 1
a330 1
			return (Figure)fFigures.elementAt(layerNr);
d342 1
a342 4
		FigureEnumeration fe = figures();
		while (fe.hasMoreElements()) {
			fe.nextFigure().draw(g);
		}
d350 1
a350 1
		while (fe.hasMoreElements()) {
d359 1
a359 1
		return (Figure)fFigures.elementAt(i);
d370 1
a370 1
		return new FigureEnumerator((Vector)fFigures.clone());
d381 1
a381 1
			Vector v =
d384 1
a384 1
			Vector v2 = new Vector();
d386 2
a387 2
			for (Enumeration e=v.elements(); e.hasMoreElements(); ) {
				Figure f = (Figure) e.nextElement();
d389 1
a389 1
				v2.addElement(new OrderedFigureElement(f, f.getZValue()));
d392 1
a392 1
			Collections.sort(v2);
d394 1
a394 1
			Vector v3 = new Vector();
d396 3
a398 4
			for (Enumeration e=v2.elements(); e.hasMoreElements(); ) {
				OrderedFigureElement ofe = (OrderedFigureElement)
				e.nextElement();
				v3.addElement(ofe.getFigure());
d401 1
a401 1
			return new FigureEnumerator(v3);
d426 1
a426 1
		return new ReverseFigureEnumerator((Vector)fFigures.clone());
d434 3
a436 3
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
d448 3
a450 3
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
d471 3
a473 3
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
d490 3
a492 3
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
d508 3
a510 3
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure().findFigureInside(x, y);
d525 3
a527 3
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
d549 1
a549 1
		while (fe.hasMoreElements()) {
d566 1
a566 1
		while (fe.hasMoreElements()) {
d577 1
a577 1
		while (fe.hasMoreElements()) {
d628 1
a628 1
		while (fe.hasMoreElements()) {
d639 1
a639 1
		fFigures = new Vector(size);
d651 1
a651 1
		while (fe.hasMoreElements()) {
d672 1
a672 1
		while (fe.hasMoreElements()) {
d679 12
a690 1
			_theQuadTree.add(f, new Bounds(f.displayBox()).asRectangle2D());
@


1.5
log
@merge dnd (before 5.3)
@
text
@d52 1
a52 1
	private QuadTree  _theQuadTree;
d70 1
a70 1
		if (!fFigures.contains(figure)) {
d132 1
a132 1
	
d144 1
a144 1
		
d158 1
a158 1
		if (fFigures.contains(figure)) {
d182 1
a182 1
	
d210 1
a210 1
		if (fFigures.contains(figure)) {
d225 1
a225 1
		if (fFigures.contains(figure)) {
d241 1
a241 1
	 * The figure is removed from its current layer (if it has been already 
d244 1
a244 1
	 * one layer below to fill the layer sequence. It is not possible to skip a 
d253 1
a253 1
		if (fFigures.contains(figure)) {
d267 1
a267 1
			
d281 1
a281 1
		
d293 1
a293 1
		
d302 1
a302 1
	 * Gets the layer for a certain figure (first occurrence). The number 
d311 1
a311 1
		if (!fFigures.contains(figure)) {
d318 1
a318 1
	
d335 1
a335 1
	
d366 3
d418 7
@


1.4
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@a254 1
System.out.println("original layerNr: " + layerNr);
a260 1
System.out.println("figureLayer: "+figureLayer + " layerNr: " + layerNr);
a271 1
System.out.println("figureLayer(2): "+ figure.getZValue());
a277 11
/*
		if (lowerBound <= 0) {
			return;
		}
		
		if (upperBound >= fFigures.size()) {
			upperBound = fFigures.size() - 1;
		}
		
		for (int i = lowerBound; i <= upperBound; i++) {
*/
a284 1
System.out.println("AssignPredeccessor " + i + " -> " + (i-1) + " with z: " + currentFigure.getZValue() + " -> " + predecessorFigure.getZValue());
a296 1
System.out.println("AssignSuccessor " + i + " -> " + (i+1) + " with z: " + currentFigure.getZValue() + " -> " + successorFigure.getZValue());
@


1.3
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)CompositeFigure.java 5.2
d4 6
d30 1
d32 2
d37 2
a38 2
                extends AbstractFigure
                implements FigureChangeListener {
d40 663
a702 488
    /**
     * The figures that this figure is composed of
     * @@see #add
     * @@see #remove
     */
    protected Vector fFigures;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = 7408153435700021866L;
    private int compositeFigureSerializedDataVersion = 1;
    private QuadTree  _theQuadTree;
    protected int _nLowestZ;
    protected int _nHighestZ;

    protected CompositeFigure() {
        fFigures = new Vector();
        _nLowestZ = 0;
        _nHighestZ = 0;
    }

    /**
     * Adds a figure to the list of figures. Initializes the
     * the figure's container.
     */
    public Figure add(Figure figure) {
        if (!fFigures.contains(figure)) {
            figure.setZValue(++_nHighestZ);
            fFigures.addElement(figure);
            figure.addToContainer(this);
            _addToQuadTree(figure);
        }
        return figure;
    }

    /**
     * Adds a vector of figures.
     * @@see #add
     */
    public void addAll(Vector newFigures) {
        Enumeration k = newFigures.elements();
        while (k.hasMoreElements())
            add((Figure) k.nextElement());
    }

    /**
     * Removes a figure from the composite.
     * @@see #removeAll
     */
    public Figure remove(Figure figure) {
        if (fFigures.contains(figure)) {
            figure.removeFromContainer(this);
            fFigures.removeElement(figure);
            _removeFromQuadTree(figure);
        }
        return figure;
    }

    /**
     * Removes a vector of figures.
     * @@see #remove
     */
    public void removeAll(Vector figures) {
        Enumeration k = figures.elements();
        while (k.hasMoreElements()) {
            remove((Figure) k.nextElement());
        }
    }

    /**
     * Removes all children.
     * @@see #remove
     */
    public void removeAll() {
        FigureEnumeration k = figures();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            figure.removeFromContainer(this);
        }
        fFigures.removeAllElements();
        
        _clearQuadTree();
        _nLowestZ = 0;
        _nHighestZ = 0;
    }

    /**
     * Removes a figure from the figure list, but
     * doesn't release it. Use this method to temporarily
     * manipulate a figure outside of the drawing.
     */
    public synchronized Figure orphan(Figure figure) {
        fFigures.removeElement(figure);
        _removeFromQuadTree(figure);
        return figure;
    }

    /**
     * Removes a vector of figures from the figure's list
     * without releasing the figures.
     * @@see #orphan
     */
    public void orphanAll(Vector newFigures) {
        Enumeration k = newFigures.elements();
        while (k.hasMoreElements())
            orphan((Figure) k.nextElement());
    }

    /**
     * Replaces a figure in the drawing without
     * removing it from the drawing.
     */
    public synchronized void replace(Figure figure, Figure replacement) {
        int index = fFigures.indexOf(figure);
        if (index != -1) {
            replacement.setZValue(figure.getZValue());
            replacement.addToContainer(this);   // will invalidate figure
            figure.changed();
            fFigures.setElementAt(replacement, index);
        }
    }

    /**
     * Sends a figure to the back of the drawing.
     */
    public synchronized void sendToBack(Figure figure) {
        if (fFigures.contains(figure)) {
            fFigures.removeElement(figure);
            fFigures.insertElementAt(figure,0);
            figure.setZValue(--_nLowestZ);
            figure.changed();
        }
    }

    /**
     * Brings a figure to the front.
     */
    public synchronized void bringToFront(Figure figure) {
        if (fFigures.contains(figure)) {
            fFigures.removeElement(figure);
            fFigures.addElement(figure);
            figure.setZValue(++_nHighestZ);
            figure.changed();
        }
    }

    /**
     * Draws all the contained figures
     * @@see Figure#draw
     */
    public void draw(Graphics g) {
        FigureEnumeration k = figures();
        while (k.hasMoreElements())
            k.nextFigure().draw(g);
    }

    /**
     * Draws only the given figures
     * @@see Figure#draw
     */
    public void draw(Graphics g, FigureEnumeration fe) {
      while (fe.hasMoreElements())
        fe.nextFigure().draw(g);
    }

    /**
     * Gets a figure at the given index.
     */
    public Figure figureAt(int i) {
        return (Figure)fFigures.elementAt(i);
    }

    /**
     * Returns an Enumeration for accessing the contained figures.
     * The figures are returned in the drawing order.
     */
    public final FigureEnumeration figures() {
        return new FigureEnumerator(fFigures);
    }

    /**
     * Returns an enumeration to iterate in
     * Z-order back to front over the figures
     * that lie within the given bounds.
     */
    public FigureEnumeration figures(Rectangle
     viewRectangle) {

      if (_theQuadTree != null) {

        Vector v =
         _theQuadTree.getAllWithin(new Bounds(viewRectangle).asRectangle2D());

        Vector v2 = new Vector();

        for(Enumeration e=v.elements(); e.hasMoreElements(); ) {
          Figure f = (Figure) e.nextElement();
          //int z = fFigures.indexOf(f);
          v2.addElement(new OrderedFigureElement(f, f.getZValue()));
        }

        Collections.sort(v2);

        Vector v3 = new Vector();

        for(Enumeration e=v2.elements(); e.hasMoreElements(); ) {
          OrderedFigureElement ofe = (OrderedFigureElement)
           e.nextElement();
          v3.addElement(ofe.getFigure());
        }

        return new FigureEnumerator(v3);

      }

      return figures();

    }

    /**
     * Gets number of child figures.
     */
    public int figureCount() {
        return fFigures.size();
    }

    /**
     * Returns an Enumeration for accessing the contained figures
     * in the reverse drawing order.
     */
    public final FigureEnumeration figuresReverse() {
        return new ReverseFigureEnumerator(fFigures);
    }

    /**
     * Finds a top level Figure. Use this call for hit detection that
     * should not descend into the figure's children.
     */
    public Figure findFigure(int x, int y) {
        FigureEnumeration k = figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            if (figure.containsPoint(x, y))
                return figure;
        }
        return null;
    }

    /**
     * Finds a top level Figure that intersects the given rectangle.
     */
    public Figure findFigure(Rectangle r) {
        FigureEnumeration k = figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            Rectangle fr = figure.displayBox();
            if (r.intersects(fr))
                return figure;
        }
        return null;
    }

    /**
     * Finds a top level Figure, but supresses the passed
     * in figure. Use this method to ignore a figure
     * that is temporarily inserted into the drawing.
     * @@param x the x coordinate
     * @@param y the y coordinate
     * @@param without the figure to be ignored during
     * the find.
     */
    public Figure findFigureWithout(int x, int y, Figure without) {
        if (without == null)
            return findFigure(x, y);
        FigureEnumeration k = figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            if (figure.containsPoint(x, y) && !figure.includes(without))
                return figure;
        }
        return null;
    }

    /**
     * Finds a top level Figure that intersects the given rectangle.
     * It supresses the passed
     * in figure. Use this method to ignore a figure
     * that is temporarily inserted into the drawing.
     */
    public Figure findFigure(Rectangle r, Figure without) {
        if (without == null)
            return findFigure(r);
        FigureEnumeration k = figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            Rectangle fr = figure.displayBox();
            if (r.intersects(fr) && !figure.includes(without))
                return figure;
        }
        return null;
    }

    /**
     * Finds a figure but descends into a figure's
     * children. Use this method to implement <i>click-through</i>
     * hit detection, that is, you want to detect the inner most
     * figure containing the given point.
     */
    public Figure findFigureInside(int x, int y) {
        FigureEnumeration k = figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure().findFigureInside(x, y);
            if (figure != null)
                return figure;
        }
        return null;
    }

    /**
     * Finds a figure but descends into a figure's
     * children. It supresses the passed
     * in figure. Use this method to ignore a figure
     * that is temporarily inserted into the drawing.
     */
    public Figure findFigureInsideWithout(int x, int y, Figure without) {
        FigureEnumeration k = figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            if (figure != without) {
                Figure found = figure.findFigureInside(x, y);
                if (found != null)
                    return found;
            }
        }
        return null;
    }

    /**
     * Checks if the composite figure has the argument as one of
     * its children.
     */
    public boolean includes(Figure figure) {
        if (super.includes(figure))
            return true;

        FigureEnumeration k = figures();
        while (k.hasMoreElements()) {
            Figure f = k.nextFigure();
            if (f.includes(figure))
                return true;
        }
        return false;
    }

    /**
     * Moves all the given figures by x and y. Doesn't announce
     * any changes. Subclassers override
     * basicMoveBy. Clients usually call moveBy.
     * @@see #moveBy
     */
    protected void basicMoveBy(int x, int y) {
        FigureEnumeration k = figures();
        while (k.hasMoreElements())
            k.nextFigure().moveBy(x,y);
    }

    /**
     * Releases the figure and all its children.
     */
    public void release() {
        super.release();
        FigureEnumeration k = figures();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            figure.release();
        }
    }

    /**
     * Propagates the figureInvalidated event to my listener.
     * @@see FigureChangeListener
     */
    public void figureInvalidated(FigureChangeEvent e) {
        if (listener() != null)
            listener().figureInvalidated(e);
    }

    /**
     * Propagates the removeFromDrawing request up to the container.
     * @@see FigureChangeListener
     */
    public void figureRequestRemove(FigureChangeEvent e) {
        if (listener() != null)
            listener().figureRequestRemove(new FigureChangeEvent(this));
    }

    /**
     * Propagates the requestUpdate request up to the container.
     * @@see FigureChangeListener
     */
    public void figureRequestUpdate(FigureChangeEvent e) {
        if (listener() != null)
            listener().figureRequestUpdate(e);
    }

    public void figureChanged(FigureChangeEvent e) {
      _removeFromQuadTree(e.getFigure());
      _addToQuadTree(e.getFigure());
    }

    public void figureRemoved(FigureChangeEvent e) {
    }

    /**
     * Writes the contained figures to the StorableOutput.
     */
    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeInt(fFigures.size());
        Enumeration k = fFigures.elements();
        while (k.hasMoreElements())
            dw.writeStorable((Storable) k.nextElement());
    }

    /**
     * Reads the contained figures from StorableInput.
     */
    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        int size = dr.readInt();
        fFigures = new Vector(size);
        for (int i=0; i<size; i++)
            add((Figure)dr.readStorable());
    }

    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();

        FigureEnumeration k = figures();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            figure.addToContainer(this);
        }
    }

    /**
     * Used to optimize rendering.  Rendering of many objects may
     * be slow until this method is called.  The view rectangle
     * should at least approximately enclose the CompositeFigure.
     * If the view rectangle is too small or too large, performance
     * may suffer.
     *
     * Don't forget to call this after loading or creating a
     * new CompositeFigure.  If you forget, drawing performance may
     * suffer.
     */
    public void init(Rectangle viewRectangle) {
      _theQuadTree = new QuadTree(new Bounds(viewRectangle).asRectangle2D());

      for(Enumeration e=fFigures.elements(); e.hasMoreElements(); ) {
        Figure f = (Figure) e.nextElement();
        _addToQuadTree(f);
      }

    }

    private void _addToQuadTree(Figure f) {
      if (_theQuadTree != null) {
        _theQuadTree.add(f, new Bounds(f.displayBox()).asRectangle2D());
      }

    }

    private void _removeFromQuadTree(Figure f) {
      if (_theQuadTree != null) {
        _theQuadTree.remove(f);
      }

    }

    private void _clearQuadTree() {
        if (_theQuadTree != null) {
          _theQuadTree.clear();
        }
    }
@


1.2
log
@now uses QuadTree to optimize drawing
@
text
@d2 1
a2 1
 * @@(#)CompositeFigure.java 5.1
d44 2
a45 3
    protected int _nLowestZ = 0;
    protected int _nHighestZ = 0;

d48 3
a50 1
      fFigures = new Vector();
d54 1
a54 1
     * Adds a figure to the list of figures. Initializes
d96 1
a96 1
        while (k.hasMoreElements())
d98 1
d112 2
a113 3
        if (_theQuadTree != null) {
          _theQuadTree.clear();
        }
d132 1
a132 1
     * @@see orphan
a250 2


d390 1
a390 1
     * @@see moveBy
a478 11

    /**
     * Invalidates the figure. This method informs the listeners
     * that the figure's current display box is invalid and should be
     * refreshed.
     */
    public void invalidate() {
      super.invalidate();
    }


a490 1

a499 2


a500 1

a506 1

a507 1

d514 5
a518 2


@


1.1
log
@Initial revision
@
text
@d43 4
d49 1
a49 1
        fFigures = new Vector();
d53 1
a53 1
     * Adds a figure to the list of figures. Initializes the
d58 1
d61 1
d84 1
d110 5
d124 1
d146 1
d160 1
d172 1
d188 9
d212 41
d439 2
d479 55
@


1.1.1.1
log
@
Initial revision.
@
text
@@
