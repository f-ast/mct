head	1.14;
access;
symbols
	jhotdraw60b1-release:1.14
	package_rename:1.14
	directory_rename:1.13
	reorg_6x_split_initial:1.13
	MVC_PHASE1:1.12.0.2
	NEW_ATTRIBUTES:1.11.0.2
	DNOYEB1_ALPHA-2:1.9.4.4
	release_JHD54b1:1.10
	BUGFIX_670992:1.9.0.6
	DNOYEB1_ALPHA-1:1.9.4.4
	dnoyeb1:1.9.0.4
	repack:1.9.0.2
	Root_repack:1.9
	Before_FigureVisitor:1.9
	JHotDraw_5-3:1.7
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.08.15.41.23;	author ricardo_padilha;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.23.00.29.35;	author mrfloppy;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.15.58.33;	author dnoyeb;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.04.30.20.40.07;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.19.18.31.31;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.13;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.14;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches;
next	;

1.9.4.1
date	2003.01.04.15.38.01;	author dnoyeb;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.01.04.16.23.22;	author dnoyeb;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.01.07.21.23.20;	author dnoyeb;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.01.10.04.54.45;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.14
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)AbstractTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.EventObject;
import java.util.Iterator;
import java.util.List;

import org.jhotdraw.framework.*;
import org.jhotdraw.util.CollectionsFactory;
import org.jhotdraw.util.Undoable;

/**
 * Default implementation support for Tools.
 *
 * @@see DrawingView
 * @@see Tool
 *
 * @@version <$CURRENT_VERSION$>
 */

public abstract class AbstractTool implements Tool {

	private DrawingEditor     myDrawingEditor;

	/**
	 * The position of the initial mouse down.
	 * The anchor point is usually the first mouse click performed with this tool.
	 */
    private int myAnchorX;
    private int myAnchorY;

	/**
	 * A tool can have a drawing view on which it operates
	 * independingly of the currently active drawing view.
	 * For example, if a tool can be used
	 */
	private DrawingView     myDrawingView;

	private Undoable myUndoActivity;
	private AbstractTool.EventDispatcher myEventDispatcher;

	private boolean myIsUsable;

	/**
	 * Flag to indicate whether to perform usable checks or not
	 */
	private boolean myIsEnabled;

	/**
	 * Constructs a tool for the given view.
	 */
	public AbstractTool(DrawingEditor newDrawingEditor) {
		setEditor(newDrawingEditor);
		setEventDispatcher(createEventDispatcher());
		setEnabled(true);
		checkUsable();
		editor().addViewChangeListener(createViewChangeListener());
	}

	/**
	 * Activates the tool for use on the given view. This method is called
	 * whenever the user switches to this tool. Use this method to
	 * reinitialize a tool.
	 * Since tools will be disabled unless it is useable, there will always
	 * be an active view when this is called. based on isUsable()
	 * Tool should never be activated if the view is null.
	 * Ideally, the dditor should take care of that.
	 */
	public void activate() {
		if (getActiveView() != null) {
			getActiveView().clearSelection();
			getActiveView().checkDamage();
			getEventDispatcher().fireToolActivatedEvent();
		}
	}

	/**
	 * Deactivates the tool. This method is called whenever the user
	 * switches to another tool. Use this method to do some clean-up
	 * when the tool is switched. Subclassers should always call
	 * super.deactivate.
	 * An inactive tool should never be deactivated
	 */
	public void deactivate() {
		if (isActive()) {
			if (getActiveView() != null) {
				getActiveView().setCursor(new AWTCursor(java.awt.Cursor.DEFAULT_CURSOR));
			}
			getEventDispatcher().fireToolDeactivatedEvent();
		}
	}

	/**
	 * Fired when the selected view changes.
	 * Subclasses should always call super.  ViewSelectionChanged() this allows
	 * the tools state to be updated and referenced to the new view.
	 */
	protected void viewSelectionChanged(DrawingView oldView, DrawingView newView) {
		if (isActive()) {
			deactivate();
			activate();
		}

		checkUsable();
	}

	/**
	 * Sent when a new view is created
	 */
	protected void viewCreated(DrawingView view) {
	}

	/**
	 * Send when an existing view is about to be destroyed.
	 */
	protected void viewDestroying(DrawingView view) {
	}

	/**
	 * Handles mouse down events in the drawing view.
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
        setAnchorX(x);
        setAnchorY(y);
		setView((DrawingView)e.getSource());
	}

	/**
	 * Handles mouse drag events in the drawing view.
	 */
	public void mouseDrag(MouseEvent e, int x, int y) {
	}

	/**
	 * Handles mouse up in the drawing view.
	 */
	public void mouseUp(MouseEvent e, int x, int y) {
//		setView(null);//This must be fixed!!! the view should not be held onto after mouse up??
//unlike super.mousedown which is usually called immediately after a sub classes mouse down
//method starts, super.mouseup should probably be called last before the method ends?
//it must if its going to set the view to null.  getting messy.
	}

	/**
	 * Handles mouse moves (if the mouse button is up).
	 */
	public void mouseMove(MouseEvent evt, int x, int y) {
	}

	/**
	 * Handles key down events in the drawing view.
	 */
	public void keyDown(KeyEvent evt, int key) {
	}

	/**
	 * Gets the tool's drawing.
	 */
	public Drawing drawing() {
		return view().drawing();
	}

	public Drawing getActiveDrawing() {
	    return getActiveView().drawing();
	}

	/**
	 * Gets the tool's editor.
	 */
	public DrawingEditor editor() {
		return myDrawingEditor;
	}

	protected void setEditor(DrawingEditor newDrawingEditor) {
		myDrawingEditor = newDrawingEditor;
	}

	/**
	 * Gets the tool's view (convienence method).
	 */
	public DrawingView view() {
		return myDrawingView;
	}

	protected void setView(DrawingView newDrawingView) {
		myDrawingView = newDrawingView;
	}

	public DrawingView getActiveView() {
		return editor().view();
	}

	/**
	 * Tests if the tool can be used or "executed."
	 */
	public boolean isUsable() {
		return isEnabled() && myIsUsable;
	}

	public void setUsable(boolean newIsUsable) {
		// perform notification only if the usable state of the tool has changed
		if (isUsable() != newIsUsable) {
			myIsUsable = newIsUsable;
			if (isUsable()) {
				getEventDispatcher().fireToolUsableEvent();
			}
			else {
				getEventDispatcher().fireToolUnusableEvent();
			}
		}
	}

	public void setEnabled(boolean newIsEnabled) {
		// perform notification only if the usable state of the tool has changed
		if (isEnabled() != newIsEnabled) {
			myIsEnabled = newIsEnabled;
			if (isEnabled()) {
				getEventDispatcher().fireToolEnabledEvent();
			}
			else {
				getEventDispatcher().fireToolDisabledEvent();
				setUsable(false);
				deactivate();
			}
		}
	}

	public boolean isEnabled() {
		return myIsEnabled;
	}

	/**
	 * The anchor point is usually the first mouse click performed with this tool.
	 * @@see #mouseDown
	 */
	protected void setAnchorX(int newAnchorX) {
		myAnchorX = newAnchorX;
	}

	/**
	 * The anchor point is usually the first mouse click performed with this tool.
	 *
	 * @@return the anchor X coordinate for the interaction
	 * @@see #mouseDown
	 */
	protected int getAnchorX() {
		return myAnchorX;
	}

	/**
	 * The anchor point is usually the first mouse click performed with this tool.
	 * @@see #mouseDown
	 */
	protected void setAnchorY(int newAnchorY) {
		myAnchorY = newAnchorY;
	}

	/**
	 * The anchor point is usually the first mouse click performed with this tool.
	 *
	 * @@return the anchor Y coordinate for the interaction
	 * @@see #mouseDown
	 */
	protected int getAnchorY() {
		return myAnchorY;
	}

	public Undoable getUndoActivity() {
		return myUndoActivity;
	}

	public void setUndoActivity(Undoable newUndoActivity) {
		myUndoActivity = newUndoActivity;
	}

	public boolean isActive() {
		return (editor().tool() == this) && isUsable();
	}

	public void addToolListener(ToolListener newToolListener) {
		getEventDispatcher().addToolListener(newToolListener);
	}

	public void removeToolListener(ToolListener oldToolListener) {
		getEventDispatcher().removeToolListener(oldToolListener);
	}

	private void setEventDispatcher(AbstractTool.EventDispatcher newEventDispatcher) {
		myEventDispatcher = newEventDispatcher;
	}

	protected AbstractTool.EventDispatcher getEventDispatcher() {
		return myEventDispatcher;
	}

	protected AbstractTool.EventDispatcher createEventDispatcher() {
		return new AbstractTool.EventDispatcher(this);
	}

    protected ViewChangeListener createViewChangeListener() {
        return new ViewChangeListener() {
            public void viewSelectionChanged(DrawingView oldView, DrawingView newView){
	    		AbstractTool.this.viewSelectionChanged(oldView, newView);
		    }
    		public void viewCreated(DrawingView view){
	    		AbstractTool.this.viewCreated(view);
		    }
    		public void viewDestroying(DrawingView view){
	    		AbstractTool.this.viewDestroying(view);
		    }
        };
    }

	protected void checkUsable() {
		if (isEnabled()) {
			setUsable((getActiveView() != null) && getActiveView().isInteractive());
		}
	}

	public static class EventDispatcher {
		private List myRegisteredListeners;
		private Tool myObservedTool;

		public EventDispatcher(Tool newObservedTool) {
			myRegisteredListeners = CollectionsFactory.current().createList();
			myObservedTool = newObservedTool;
		}

		public void fireToolUsableEvent() {
			Iterator iter = myRegisteredListeners.iterator();
			while (iter.hasNext()) {
				((ToolListener)iter.next()).toolUsable(new EventObject(myObservedTool));
			}
		}

		public void fireToolUnusableEvent() {
			Iterator iter = myRegisteredListeners.iterator();
			while (iter.hasNext()) {
				((ToolListener)iter.next()).toolUnusable(new EventObject(myObservedTool));
			}
		}

		public void fireToolActivatedEvent() {
			Iterator iter = myRegisteredListeners.iterator();
			while (iter.hasNext()) {
				((ToolListener)iter.next()).toolActivated(new EventObject(myObservedTool));
			}
		}

		public void fireToolDeactivatedEvent() {
			Iterator iter = myRegisteredListeners.iterator();
			while (iter.hasNext()) {
				((ToolListener)iter.next()).toolDeactivated(new EventObject(myObservedTool));
			}
		}

		public void fireToolEnabledEvent() {
			Iterator iter = myRegisteredListeners.iterator();
			while (iter.hasNext()) {
				((ToolListener)iter.next()).toolEnabled(new EventObject(myObservedTool));
			}
		}

		public void fireToolDisabledEvent() {
			Iterator iter = myRegisteredListeners.iterator();
			while (iter.hasNext()) {
				((ToolListener)iter.next()).toolDisabled(new EventObject(myObservedTool));
			}
		}

		public void addToolListener(ToolListener newToolListener) {
			if (!myRegisteredListeners.contains(newToolListener)) {
				myRegisteredListeners.add(newToolListener);
			}
		}

		public void removeToolListener(ToolListener oldToolListener) {
			if (myRegisteredListeners.contains(oldToolListener)) {
				myRegisteredListeners.remove(oldToolListener);
			}
		}
	}
}
@


1.13
log
@Refactoring of Cursor:
- java.awt.Cursor (class) has been sistematically replaced with CH.ifa.draw.contrib.framework.Cursor (interface)
- a new default implementation of Cursor (interface) has been added: CH.ifa.draw.contrib.standard.AWTCursor
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d20 3
a22 3
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Undoable;
@


1.12
log
@no message
@
text
@d14 6
d21 1
a22 7
import CH.ifa.draw.util.CollectionsFactory;

import java.util.*;
import java.util.List;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.KeyEvent;
d99 1
a99 1
				getActiveView().setCursor(Cursor.getDefaultCursor());
@


1.11
log
@
Aggregrating as opposed to extending the ViewChangeListener
changed inherited methods to protected as opposed to public.  Adds a level of
safety.

CH\ifa\draw/contrib/dnd/DragNDropTool.java
CH\ifa\draw/standard/AbstractCommand.java
CH\ifa\draw/standard/AbstractTool.java
@
text
@a60 12
	private final ViewChangeListener myViewChangeListener = new ViewChangeListener() {
		public void viewSelectionChanged(DrawingView oldView, DrawingView newView){
			AbstractTool.this.viewSelectionChanged(oldView, newView);
		}
		public void viewCreated(DrawingView view){
			AbstractTool.this.viewCreated(view);
		}
		public void viewDestroying(DrawingView view){
			AbstractTool.this.viewDestroying(view);
		}
	};
		
d65 1
a65 1
		myDrawingEditor = newDrawingEditor;
d69 1
a69 1
		editor().addViewChangeListener(myViewChangeListener);
d308 1
a308 1
	public AbstractTool.EventDispatcher createEventDispatcher() {
d311 14
@


1.10
log
@prepare for 5.4 release: various bug fixes
@
text
@d33 1
a33 1
public abstract class AbstractTool implements Tool, ViewChangeListener {
d61 12
d81 1
a81 1
		editor().addViewChangeListener(this);
d122 1
a122 1
	public void viewSelectionChanged(DrawingView oldView, DrawingView newView) {
d134 1
a134 1
	public void viewCreated(DrawingView view) {
d140 1
a140 1
	public void viewDestroying(DrawingView view) {
@


1.9
log
@after variou merges... (before 5.4 release)
@
text
@d39 1
d244 4
d252 6
d262 4
d270 6
@


1.9.4.1
log
@Modified ViewChangeListener
ViewCreated -> ViewActivated
ViewDestroying -> ViewDeactivated
@
text
@d121 1
a121 1
	public void viewActivated(DrawingView view) {
d127 1
a127 1
	public void viewDeactivated(DrawingView view) {
@


1.9.4.2
log
@AbstractTool now contains as opposed to inherits ViewChangeListener
So the ViewChangeListener methods are not exposed as public from AbstractTool.
Methods of the same name exist, but they are now protected.
@
text
@d33 1
a33 1
public abstract class AbstractTool implements Tool {
a59 13
	private final ViewChangeListener myViewChangeListener = new ViewChangeListener() {
		public void viewSelectionChanged(DrawingView oldView, DrawingView newView){
			AbstractTool.this.viewSelectionChanged(oldView, newView);
		}
		public void viewActivated(DrawingView view){
			AbstractTool.this.viewActivated(view);
		}
		public void viewDeactivated(DrawingView view){
			AbstractTool.this.viewDeactivated(view);
		}
	};
		
		
d68 1
a68 1
		editor().addViewChangeListener(myViewChangeListener);
d109 1
a109 1
	protected void viewSelectionChanged(DrawingView oldView, DrawingView newView) {
d119 1
a119 1
	 * Sent when a new view is added
d121 1
a121 1
	protected void viewActivated(DrawingView view) {
d125 1
a125 8
	 * Send when an existing view is about to be removed.
	 * there is no getting away from the strange order here.
	 * if you add something after the view is activated, you tend to want to 
	 * remove it <i>before</i> the view is deactivated.  it will cause funny
	 * naming of the methods. such as viewActvated and viewDeactivating.
	 * C'est la vie...dnoyeb
	 * point of fact, this is called <i>after</i> the view is deactivated but it
	 * is ok unless we make all instances of this situation funnily named.
d127 1
a127 1
	protected void viewDeactivated(DrawingView view) {
a152 2
		//well this means we want the default action of mouseUP to be to release the 
		//tool so to speak.  all tools may not want this.  dnoyeb. 1/4/02
@


1.9.4.3
log
@1. Added getDesktop to the DrawingEditor.  added null returns to all Classes that dont fully support
   the Desktop architecture yet, like the applets.

2. Added a figureSelection listener to the DrawingEditor so one can register with the DrawingEditor to
   hear figure selection events.  You can still register with the individual DrawingViews if you wish.
   The DrawingEditor will guarantee that it only fires this event on the active view, so it saves a listener
   from having to register and unregister with views to hear this event each time the activeView changes.
   All Commands were doing this register/unregister dance.

3. AbstractCommand now registers for figureSelectionEvents with the drawingEditor as opposed to the
   DrawingView.

4. Went back to viewCreated and viewDestroying naming.  flip flopping.  Its actually more accurate.  the
   real issue is that 2 events are missing, viewDestroyed and viewCreating.  dont need them yet, but
   they may materialize in the future.

5. Went back to Tool CompositeTool being enabled even when no figure is selected.

6. FigureSelectionListener now extends java.util.EventListener now because I am too lazy to write
   an event handler just yet.

7. implemented new findFigureInside() fix.  needs testing.

8. standardDrawingView selectionZordered now returns figures in the proper order(not reversed).
@
text
@d64 2
a65 2
		public void viewCreated(DrawingView view){
			AbstractTool.this.viewCreated(view);
d67 2
a68 2
		public void viewDestroying(DrawingView view){
			AbstractTool.this.viewDestroying(view);
d134 1
a134 1
	protected void viewCreated(DrawingView view) {
d147 1
a147 1
	protected void viewDestroying(DrawingView view) {
d170 5
a174 2
		//this should be called.  but if all else is coded properly
		//it will not matter.
@


1.9.4.4
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d21 1
a21 1

d153 4
a156 4
	public void mouseDown(DrawingViewMouseEvent dvme) {
        setAnchorX(dvme.getX()); //constrained value
        setAnchorY(dvme.getY()); //constrained value
		setView( dvme.getDrawingView() );
d162 1
a162 1
	public void mouseDrag(DrawingViewMouseEvent dvme) {
a166 3
	 * Standard behavior is for the tool to deactivate and the view to be 
	 * released.  Override this method if you need to use the {@@link DrawingView
	 * DrawingView} after mouseUp.
d168 4
a171 2
	public void mouseUp(DrawingViewMouseEvent dvme) {
		setView(null);
d175 1
a175 1
	 * Handles mouse moves (when the mouse button is up).
d177 1
a177 1
	public void mouseMove(DrawingViewMouseEvent dvme) {
@


1.8
log
@no message
@
text
@d16 2
d19 1
d43 7
d72 1
a72 1
     * Activates the tool for the given view. This method is called
d75 4
a78 2
	 * Since tools will be disabled unless they are useable, there will always
	 * be an active view when this method is called. based on isUsable()
d81 3
a83 3
		if (view() != null) {
			view().clearSelection();
			view().checkDamage();
d93 1
d97 2
a98 2
			if (view() != null) {
				view().setCursor(Cursor.getDefaultCursor());
d136 1
d149 4
d174 4
d185 4
d193 8
d293 1
a293 1
			setUsable((view() != null) && view().isInteractive());
d298 1
a298 1
		private Vector myRegisteredListeners;
d302 1
a302 1
			myRegisteredListeners = new Vector();
d307 3
a309 3
			Enumeration le = myRegisteredListeners.elements();
			while (le.hasMoreElements()) {
				((ToolListener)le.nextElement()).toolUsable(new EventObject(myObservedTool));
d314 3
a316 3
			Enumeration le = myRegisteredListeners.elements();
			while (le.hasMoreElements()) {
				((ToolListener)le.nextElement()).toolUnusable(new EventObject(myObservedTool));
d321 3
a323 3
			Enumeration le = myRegisteredListeners.elements();
			while (le.hasMoreElements()) {
				((ToolListener)le.nextElement()).toolActivated(new EventObject(myObservedTool));
d328 3
a330 3
			Enumeration le = myRegisteredListeners.elements();
			while (le.hasMoreElements()) {
				((ToolListener)le.nextElement()).toolDeactivated(new EventObject(myObservedTool));
d335 3
a337 3
			Enumeration le = myRegisteredListeners.elements();
			while (le.hasMoreElements()) {
				((ToolListener)le.nextElement()).toolEnabled(new EventObject(myObservedTool));
d342 3
a344 3
			Enumeration le = myRegisteredListeners.elements();
			while (le.hasMoreElements()) {
				((ToolListener)le.nextElement()).toolDisabled(new EventObject(myObservedTool));
@


1.7
log
@no message
@
text
@a19 2
import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
d37 2
a38 1
	protected int     fAnchorX, fAnchorY;
d57 1
d62 1
a62 1
	 * Activates the tool for use on the given view. This method is called
d65 2
a66 2
	 * Since tools will be disabled unless it is useable, there will always
	 * be an active view when this is called. based on isUsable()
d71 1
d121 2
a122 2
		fAnchorX = x;
		fAnchorY = y;
d207 16
@


1.6
log
@merge dnd (before 5.3)
@
text
@d44 7
d57 1
d82 4
a85 2
		if ((isActive() == true) && (view() != null)) {
			view().setCursor(Cursor.getDefaultCursor());
d96 1
a96 1
		if (isActive() == true) {
d100 1
d173 33
a205 1
		return (view() != null) && (view().isInteractive());
d215 1
a215 1
	
d217 1
a217 1
		return editor().tool() == this;
d223 1
a223 1
	
d241 2
a242 5
		if (isUsable()) {
			getEventDispatcher().fireToolUsableEvent();
		}
		else {
			getEventDispatcher().fireToolUnusableEvent();
d245 1
a245 1
		
d249 1
a249 1
		
d254 1
a254 1
		
d261 1
a261 1
		
d283 14
d302 1
a302 1
		
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d16 1
d20 2
d32 1
a32 1
public abstract class AbstractTool implements Tool {
d34 1
a34 1
    protected DrawingView  fView;
d36 4
a39 4
    /**
     * The position of the initial mouse down.
     */
    protected int     fAnchorX, fAnchorY;
d42 122
a163 79
	
    /**
     * Constructs a tool for the given view.
     */
    public AbstractTool(DrawingView itsView) {
        fView = itsView;
    }

    /**
     * Activates the tool for the given view. This method is called
     * whenever the user switches to this tool. Use this method to
     * reinitialize a tool.
     */
    public void activate() {
        view().clearSelection();
    }

    /**
     * Deactivates the tool. This method is called whenever the user
     * switches to another tool. Use this method to do some clean-up
     * when the tool is switched. Subclassers should always call
     * super.deactivate.
     */
    public void deactivate() {
        view().setCursor(Cursor.getDefaultCursor());
    }

    /**
     * Handles mouse down events in the drawing view.
     */
    public void mouseDown(MouseEvent e, int x, int y) {
        fAnchorX = x;
        fAnchorY = y;
    }

    /**
     * Handles mouse drag events in the drawing view.
     */
    public void mouseDrag(MouseEvent e, int x, int y) {
    }

    /**
     * Handles mouse up in the drawing view.
     */
    public void mouseUp(MouseEvent e, int x, int y) {
    }

    /**
     * Handles mouse moves (if the mouse button is up).
     */
    public void mouseMove(MouseEvent evt, int x, int y) {
    }

    /**
     * Handles key down events in the drawing view.
     */
    public void keyDown(KeyEvent evt, int key) {
    }

    /**
     * Gets the tool's drawing.
     */
    public Drawing drawing() {
        return view().drawing();
    }

    /**
     * Gets the tool's editor (convenience method).
     */
    public DrawingEditor editor() {
        return view().editor();
    }

    /**
     * Gets the tool's view.
     */
    public DrawingView view() {
        return fView;
    }
d171 83
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)AbstractTool.java 5.2
d4 6
d14 2
a18 1
import CH.ifa.draw.framework.*;
d25 2
d29 1
a29 1
public class AbstractTool implements Tool {
d38 2
d106 1
a106 1
     * Gets the tool's editor.
d118 8
@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d20 1
a20 1
public abstract class AbstractTool implements Tool {
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d20 1
a20 1
public class AbstractTool implements Tool {
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)AbstractTool.java 5.1
d42 1
a42 1
        fView.clearSelection();
d52 1
a52 1
        fView.setCursor(Cursor.getDefaultCursor());
d91 1
a91 1
        return fView.drawing();
d98 1
a98 1
        return fView.editor();
@


1.1.1.1
log
@
Initial revision.
@
text
@@
