head	1.10;
access;
symbols
	jhotdraw60b1-release:1.10
	package_rename:1.10
	directory_rename:1.9
	reorg_6x_split_initial:1.9
	MVC_PHASE1:1.8.0.10
	NEW_ATTRIBUTES:1.8.0.8
	DNOYEB1_ALPHA-2:1.8.4.2
	release_JHD54b1:1.8
	BUGFIX_670992:1.8.0.6
	DNOYEB1_ALPHA-1:1.8.4.2
	dnoyeb1:1.8.0.4
	repack:1.8.0.2
	Root_repack:1.8
	Before_FigureVisitor:1.8
	JHotDraw_5-3:1.6
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.05.18.30.34;	author ricardo_padilha;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.13;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.14;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.8.4.1
date	2003.01.16.15.59.18;	author dnoyeb;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2003.01.17.02.33.40;	author dnoyeb;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.02.02.16.54.09;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.10
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)CutCommand.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import java.util.List;

import org.jhotdraw.framework.*;
import org.jhotdraw.util.CollectionsFactory;
import org.jhotdraw.util.Undoable;
import org.jhotdraw.util.UndoableAdapter;

/**
 * Delete the selection and move the selected figures to
 * the clipboard.
 *
 * @@see org.jhotdraw.util.Clipboard
 *
 * @@version <$CURRENT_VERSION$>
 */
public class CutCommand extends FigureTransferCommand {

	/**
	 * Constructs a cut command.
	 * @@param name the command name
	 * @@param newDrawingEditor the DrawingEditor which manages the views
	 */
	public CutCommand(String name, DrawingEditor newDrawingEditor) {
		super(name, newDrawingEditor);
	}

	/**
	 * @@see org.jhotdraw.util.Command#execute()
	 */
	public void execute() {
		super.execute();
		setUndoActivity(createUndoActivity());
		/* ricardo_padilha: bugfix for correct delete/undelete behavior
		 * When enumerating the affected figures we must not forget the dependent
		 * figures, since they are deleted as well! 
		 */
		FigureEnumeration fe = view().selection();
		List affected = CollectionsFactory.current().createList();
		Figure f;
		FigureEnumeration dfe;
		while (fe.hasNextFigure()) {
			f = fe.nextFigure();
			affected.add(0, f);
			dfe = f.getDependendFigures();
			if (dfe != null) {
				while (dfe.hasNextFigure()) {
					affected.add(0, dfe.nextFigure());
				}
			}
		}
		fe = new FigureEnumerator(affected);
		getUndoActivity().setAffectedFigures(fe);
		UndoActivity ua = (UndoActivity) getUndoActivity();
		ua.setSelectedFigures(view().selection());
		copyFigures(ua.getSelectedFigures(), ua.getSelectedFiguresCount());
		/* ricardo_padilha: end of bugfix */
		deleteFigures(getUndoActivity().getAffectedFigures());
		view().checkDamage();
	}

	/**
	 * @@see org.jhotdraw.standard.AbstractCommand#isExecutableWithView()
	 */
	public boolean isExecutableWithView() {
		return view().selectionCount() > 0;
	}

	/**
	 * Factory method for undo activity
	 * @@return Undoable
	 */
	protected Undoable createUndoActivity() {
		return new CutCommand.UndoActivity(this);
	}

	public static class UndoActivity extends UndoableAdapter {

		private FigureTransferCommand myCommand;
		private List mySelectedFigures;

		/**
		 * Constructor for <code>UndoActivity</code>.
		 * @@param newCommand
		 */
		public UndoActivity(FigureTransferCommand newCommand) {
			super(newCommand.view());
			myCommand = newCommand;
			setUndoable(true);
			setRedoable(true);
		}

		/**
		 * @@see org.jhotdraw.util.Undoable#undo()
		 */
		public boolean undo() {
			if (super.undo() && getAffectedFigures().hasNextFigure()) {
				getDrawingView().clearSelection();
				myCommand.insertFigures(getAffectedFiguresReversed(), 0, 0);
				return true;
			}
			return false;
		}

		/**
		 * @@see org.jhotdraw.util.Undoable#redo()
		 */
		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (isRedoable()) {
				myCommand.copyFigures(getSelectedFigures(), getSelectedFiguresCount());
				myCommand.deleteFigures(getAffectedFigures());
				return true;
			}

			return false;
		}

		/**
		 * Preserve the selection of figures the moment the command was executed.
		 * @@param newSelectedFigures
		 */
		public void setSelectedFigures(FigureEnumeration newSelectedFigures) {
			// the enumeration is not reusable therefore a copy is made
			// to be able to undo-redo the command several time
			rememberSelectedFigures(newSelectedFigures);
		}

		/**
		 * Preserve a copy of the enumeration in a private list.
		 * @@param toBeRemembered
		 */
		protected void rememberSelectedFigures(FigureEnumeration toBeRemembered) {
			mySelectedFigures = CollectionsFactory.current().createList();
			while (toBeRemembered.hasNextFigure()) {
				mySelectedFigures.add(toBeRemembered.nextFigure());
			}
		}
	
		/**
		 * Returns the selection of figures to perform the command on.
		 * @@return
		 */
		public FigureEnumeration getSelectedFigures() {
			return new FigureEnumerator(
				CollectionsFactory.current().createList(mySelectedFigures));
		}

		/**
		 * Returns the size of the selection.
		 * @@return
		 */
		public int getSelectedFiguresCount() {
			return mySelectedFigures.size();
		}

		/**
		 * @@see org.jhotdraw.util.UndoableAdapter#release()
		 */
		public void release() {
			super.release();
			FigureEnumeration fe = getSelectedFigures();
			while (fe.hasNextFigure()) {
				fe.nextFigure().release();
			}
			setSelectedFigures(FigureEnumerator.getEmptyEnumeration());
		}
	}
}
@


1.9
log
@Bugfix for CutCommand and DeleteCommand.
Both work now properly and their UndoActivity's work as expected.
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d16 4
a19 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Undoable;
import CH.ifa.draw.util.UndoableAdapter;
d25 1
a25 1
 * @@see CH.ifa.draw.util.Clipboard
d41 1
a41 1
	 * @@see CH.ifa.draw.util.Command#execute()
d75 1
a75 1
	 * @@see CH.ifa.draw.standard.AbstractCommand#isExecutableWithView()
d106 1
a106 1
		 * @@see CH.ifa.draw.util.Undoable#undo()
d118 1
a118 1
		 * @@see CH.ifa.draw.util.Undoable#redo()
d170 1
a170 1
		 * @@see CH.ifa.draw.util.UndoableAdapter#release()
@


1.8
log
@after variou merges... (before 5.4 release)
@
text
@d14 2
d17 1
d40 3
d46 24
a69 3
		getUndoActivity().setAffectedFigures(view().selection());
		copyFigures(getUndoActivity().getAffectedFigures(),
			view().selectionCount());
d74 3
d83 1
d90 1
d92 1
d94 4
d105 3
d111 1
a111 4

				setAffectedFigures(myCommand.insertFigures(
					getAffectedFigures(), 0, 0));

a113 1

d117 3
d123 1
a123 1
				myCommand.copyFigures(getAffectedFigures(), getDrawingView().selectionCount());
d129 50
@


1.8.4.1
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d44 1
a44 1
		view().drawing().update();
@


1.8.4.2
log
@Fix: [ 622363 ] UndoableAdapter.release() is broken
Only deleting-type undoable actions release figures.
+ DND grabs figures from the visitor now. others need to do the same.
@
text
@a90 10
		/**
		 * Releases all resources related to an undoable activity
		 */
		public void release() {
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				fe.nextFigure().release();
			}
			setAffectedFigures(FigureEnumerator.getEmptyEnumeration());
		}			
@


1.8.4.3
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d60 1
a60 1
		private boolean undone = false;
d74 1
a74 1
				undone = true;
a85 1
				undone = false;
a92 3
		 * Since cut duplicates the figures, it is ok to release the originals
		 * because the pasted figures are completely new objects.
		 * But we can only release if the action has not been undone.
d95 3
a97 7
			if(undone == false){
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					Figure f = fe.nextFigure();
					getDrawingView().drawing().remove(f);
					f.release();
				}
d99 1
a99 1
			super.release();
@


1.7
log
@no message
@
text
@d22 1
a22 1
 * @@see Clipboard
d40 1
a40 1
		getUndoActivity().setAffectedFigures(view().selectionElements());
d69 1
a69 1
			if (super.undo() && getAffectedFigures().hasMoreElements()) {
@


1.6
log
@merge dnd (before 5.3)
@
text
@d15 2
a16 1
import CH.ifa.draw.util.*;
d60 1
a60 1
		
d67 1
a67 1
		
d71 1
a71 1
	
d74 1
a74 1
	
d77 1
a77 1
			
d80 1
a80 1
	
d88 1
a88 1
			
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d27 8
a34 8
   /**
    * Constructs a cut command.
    * @@param name the command name
    * @@param view the target view
    */
    public CutCommand(String name, DrawingView view) {
        super(name, view);
    }
d36 9
a44 8
    public void execute() {
    	setUndoActivity(createUndoActivity());
    	getUndoActivity().setAffectedFigures(view().selectionElements());
        copyFigures(getUndoActivity().getAffectedFigures(),
        	view().selectionCount());
        deleteFigures(getUndoActivity().getAffectedFigures());
        view().checkDamage();
    }
d46 3
a48 3
    public boolean isExecutable() {
        return view().selectionCount() > 0;
    }
d71 2
a72 2
		        setAffectedFigures(myCommand.insertFigures(
		        	getAffectedFigures(), 0, 0));
d74 1
a74 1
			    return true;
d77 1
a77 1
	        return false;
d83 2
a84 2
	        	myCommand.copyFigures(getAffectedFigures(), getDrawingView().selectionCount());
	        	myCommand.deleteFigures(getAffectedFigures());
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)CutCommand.java 5.2
d4 6
d14 1
a15 1
import CH.ifa.draw.framework.*;
d20 1
d22 2
d37 6
a42 3
        copySelection();
        deleteSelection();
        fView.checkDamage();
d46 1
a46 1
        return fView.selectionCount() > 0;
d49 41
a90 2


@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d30 1
a30 1
        view().checkDamage();
d34 1
a34 1
        return view().selectionCount() > 0;
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d30 1
a30 1
        fView.checkDamage();
d34 1
a34 1
        return fView.selectionCount() > 0;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)CutCommand.java 5.1
a7 2
import java.util.*;
import java.awt.*;
@


1.1.1.1
log
@
Initial revision.
@
text
@@
