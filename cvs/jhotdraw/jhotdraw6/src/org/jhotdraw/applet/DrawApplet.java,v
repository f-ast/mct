head	1.17;
access;
symbols
	jhotdraw60b1-release:1.17
	package_rename:1.15
	directory_rename:1.14
	reorg_6x_split_initial:1.14
	MVC_PHASE1:1.14.0.2
	NEW_ATTRIBUTES:1.13.0.2
	DNOYEB1_ALPHA-2:1.11.4.2
	release_JHD54b1:1.11
	BUGFIX_670992:1.11.0.6
	DNOYEB1_ALPHA-1:1.11.4.2
	dnoyeb1:1.11.0.4
	repack:1.11.0.2
	Root_repack:1.11
	Before_FigureVisitor:1.10
	JHotDraw_5-3:1.6
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.17
date	2004.02.01.14.35.11;	author mrfloppy;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.27.16.27.25;	author mtnygard;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.09.22.53.43;	author mrfloppy;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.22.23.58.42;	author mrfloppy;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.12.17.22.41;	author ricardo_padilha;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.10.18.55.34;	author ricardo_padilha;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.16.22.30.19;	author mrfloppy;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2002.09.07.12.27.28;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.04.22.33.09;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.31.59;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.12;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.13;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.30.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.07;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.07;	author jeckel;	state Exp;
branches;
next	;

1.11.4.1
date	2003.01.07.21.22.16;	author dnoyeb;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.01.17.05.30.53;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.17
log
@removing references to CH.ifa.draw-package
@
text
@/*
 * @@(#)DrawApplet.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.applet;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;
import java.net.*;
import org.jhotdraw.framework.*;
import org.jhotdraw.standard.*;
import org.jhotdraw.figures.*;
import org.jhotdraw.util.*;

/**
 * DrawApplication defines a standard presentation for
 * a drawing editor that is run as an applet. The presentation is
 * customized in subclasses.<p>
 * Supported applet parameters: <br>
 * <i>DRAWINGS</i>: a blank separated list of drawing names that is
 *           shown in the drawings choice.
 *
 * @@version <$CURRENT_VERSION$>
 */
public class DrawApplet
		extends JApplet
		implements DrawingEditor, PaletteListener, VersionRequester {

	private transient Drawing         fDrawing;
	private transient Tool            fTool;

	private transient DrawingView     fView;
	private transient ToolButton      fDefaultToolButton;
	private transient ToolButton      fSelectedToolButton;

	private transient boolean         fSimpleUpdate;
	private transient JButton          fUpdateButton;

	private transient JComboBox          fFrameColor;
	private transient JComboBox          fFillColor;
	private transient JComboBox          fTextColor;
	private transient JComboBox          fArrowChoice;
	private transient JComboBox          fFontChoice;

	private transient 			UndoManager myUndoManager;

	static String                     fgUntitled = "untitled";

	private static final String       fgDrawPath = "/org/jhotdraw/";
	public static final String        IMAGES = fgDrawPath+"images/";

	/**
	 * Initializes the applet and creates its contents.
	 */
	public void init() {
		createIconkit();
		getVersionControlStrategy().assertCompatibleVersion();
		setUndoManager(new UndoManager());

		getContentPane().setLayout(new BorderLayout());

		fView = createDrawingView();

		JPanel attributes = createAttributesPanel();
		createAttributeChoices(attributes);
		getContentPane().add("North", attributes);

		JPanel toolPanel = createToolPalette();
		createTools(toolPanel);
		getContentPane().add("West", toolPanel);

		getContentPane().add("Center", (Component)view());
		JPanel buttonPalette = createButtonPanel();
		createButtons(buttonPalette);
		getContentPane().add("South", buttonPalette);

		initDrawing();
		// JFC should have its own internal double buffering...
		//setBufferedDisplayUpdate();
		setupAttributes();
	}

	public void addViewChangeListener(ViewChangeListener vsl) {
	}

	public void removeViewChangeListener(ViewChangeListener vsl) {
	}

	protected Iconkit createIconkit() {
		return new Iconkit(this);
	}

	/**
	 * Creates the attributes panel.
	 */
	protected JPanel createAttributesPanel() {
		JPanel panel = new JPanel();
		panel.setLayout(new PaletteLayout(2, new Point(2,2), false));
		return panel;
	}

	/**
	 * Creates the attribute choices. Override to add additional
	 * choices.
	 */
	protected void createAttributeChoices(JPanel panel) {
		panel.add(new JLabel("Fill"));
		fFillColor = createColorChoice(FigureAttributeConstant.FILL_COLOR);
		panel.add(fFillColor);

		panel.add(new JLabel("Text"));
		fTextColor = createColorChoice(FigureAttributeConstant.TEXT_COLOR);
		panel.add(fTextColor);

		panel.add(new JLabel("Pen"));
		fFrameColor = createColorChoice(FigureAttributeConstant.FRAME_COLOR);
		panel.add(fFrameColor);

		panel.add(new JLabel("Arrow"));
		CommandChoice choice = new CommandChoice();
		fArrowChoice = choice;
		FigureAttributeConstant arrowMode = FigureAttributeConstant.ARROW_MODE;
		choice.addItem(new ChangeAttributeCommand("none",     arrowMode, new Integer(PolyLineFigure.ARROW_TIP_NONE),  this));
		choice.addItem(new ChangeAttributeCommand("at Start", arrowMode, new Integer(PolyLineFigure.ARROW_TIP_START), this));
		choice.addItem(new ChangeAttributeCommand("at End",   arrowMode, new Integer(PolyLineFigure.ARROW_TIP_END),   this));
		choice.addItem(new ChangeAttributeCommand("at Both",  arrowMode, new Integer(PolyLineFigure.ARROW_TIP_BOTH),  this));
		panel.add(fArrowChoice);

		panel.add(new JLabel("Font"));
		fFontChoice = createFontChoice();
		panel.add(fFontChoice);
	}

	/**
	 * Creates the color choice for the given attribute.
	 */
	protected JComboBox createColorChoice(FigureAttributeConstant attribute) {
		CommandChoice choice = new CommandChoice();
		for (int i = 0; i < ColorMap.size(); i++)
			choice.addItem(
				new ChangeAttributeCommand(
					ColorMap.name(i),
					attribute,
					ColorMap.color(i),
					this
				)
			);
		return choice;
	}

	/**
	 * Creates the font choice. The choice is filled with
	 * all the fonts supported by the toolkit.
	 */
	protected JComboBox createFontChoice() {
		CommandChoice choice = new CommandChoice();
		String fonts[] = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
		for (int i = 0; i < fonts.length; i++) {
			choice.addItem(new ChangeAttributeCommand(fonts[i], FigureAttributeConstant.FONT_NAME, fonts[i],  this));
		}
		return choice;
	}

	/**
	 * Creates the buttons panel.
	 */
	protected JPanel createButtonPanel() {
		JPanel panel = new JPanel();
		panel.setLayout(new PaletteLayout(2, new Point(2,2), false));
		return panel;
	}

	/**
	 * Creates the buttons shown in the buttons panel. Override to
	 * add additional buttons.
	 * @@param panel the buttons panel.
	 */
	protected void createButtons(JPanel panel) {
		panel.add(new Filler(24,20));

		JComboBox drawingChoice = new JComboBox();
		drawingChoice.addItem(fgUntitled);

		String param = getParameter("DRAWINGS");
		if (param == null) {
			param = "";
		}
		StringTokenizer st = new StringTokenizer(param);
		while (st.hasMoreTokens()) {
			drawingChoice.addItem(st.nextToken());
		}
		// offer choice only if more than one
		if (drawingChoice.getItemCount() > 1) {
			panel.add(drawingChoice);
		}
		else {
			panel.add(new JLabel(fgUntitled));
		}

		drawingChoice.addItemListener(
			new ItemListener() {
				public void itemStateChanged(ItemEvent e) {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						loadDrawing((String)e.getItem());
					}
				}
			}
		);

		panel.add(new Filler(6,20));

		JButton button;
		button = new CommandButton(new DeleteCommand("Delete", this));
		panel.add(button);

		button = new CommandButton(new DuplicateCommand("Duplicate", this));
		panel.add(button);

		button = new CommandButton(new GroupCommand("Group", this));
		panel.add(button);

		button = new CommandButton(new UngroupCommand("Ungroup", this));
		panel.add(button);

		button = new JButton("Help");
		button.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					showHelp();
				}
			}
		);
		panel.add(button);

		fUpdateButton = new JButton("Simple Update");
		fUpdateButton.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					if (fSimpleUpdate) {
						setBufferedDisplayUpdate();
					}
					else {
						setSimpleDisplayUpdate();
					}
				}
			}
		);

		// panel.add(fUpdateButton); // not shown currently
	}

	/**
	 * Creates the tools palette.
	 */
	protected JPanel createToolPalette() {
		JPanel palette = new JPanel();
		palette.setLayout(new PaletteLayout(2,new Point(2,2)));
		return palette;
	}

	/**
	 * Creates the tools. By default only the selection tool is added.
	 * Override this method to add additional tools.
	 * Call the inherited method to include the selection tool.
	 * @@param palette the palette where the tools are added.
	 */
	protected void createTools(JPanel palette) {
		Tool tool = createSelectionTool();

		fDefaultToolButton = createToolButton(IMAGES + "SEL", "Selection Tool", tool);
		palette.add(fDefaultToolButton);
	}

	/**
	 * Creates the selection tool used in this editor. Override to use
	 * a custom selection tool.
	 */
	protected Tool createSelectionTool() {
		return new SelectionTool(this);
	}

	/**
	 * Creates a tool button with the given image, tool, and text
	 */
	protected ToolButton createToolButton(String iconName, String toolName, Tool tool) {
		return new ToolButton(this, iconName, toolName, tool);
	}

	/**
	 * Creates the drawing used in this application.
	 * You need to override this method to use a Drawing
	 * subclass in your application. By default a standard
	 * Drawing is returned.
	 */
	protected Drawing createDrawing() {
		return new StandardDrawing();
	}

	/**
	 * Creates the drawing view used in this application.
	 * You need to override this method to use a DrawingView
	 * subclass in your application. By default a standard
	 * DrawingView is returned.
	 */
	protected DrawingView createDrawingView() {
		return new StandardDrawingView(this, 410, 370);
	}

	/**
	 * Handles a user selection in the palette.
	 * @@see PaletteListener
	 */
	public void paletteUserSelected(PaletteButton button) {
		ToolButton toolButton = (ToolButton) button;
		setTool(toolButton.tool(), toolButton.name());
		setSelected(toolButton);
	}

	/**
	 * Handles when the mouse enters or leaves a palette button.
	 * @@see PaletteListener
	 */
	public void paletteUserOver(PaletteButton button, boolean inside) {
		if (inside) {
			showStatus(button.name());
		}
		else if (fSelectedToolButton != null) {
			showStatus(fSelectedToolButton.name());
		}
	}

	/**
	 * Gets the current drawing.
	 * @@see DrawingEditor
	 */
	public Drawing drawing() {
		return fDrawing;
	}

	/**
	 * Gets the current tool.
	 * @@see DrawingEditor
	 */
	public Tool tool() {
		return fTool;
	}

	/**
	 * Gets the current drawing view.
	 * @@see DrawingEditor
	 */
	public DrawingView view() {
		return fView;
	}

	public DrawingView[] views() {
		return new DrawingView[] { view() } ;
	}

	/**
	 * Sets the default tool of the editor.
	 * @@see DrawingEditor
	 */
	public void toolDone() {
		setTool(fDefaultToolButton.tool(), fDefaultToolButton.name());
		setSelected(fDefaultToolButton);
	}

	/**
	 * Handles a change of the current selection. Updates all
	 * menu items that are selection sensitive.
	 * @@see DrawingEditor
	 */
	public void figureSelectionChanged(DrawingView view) {
		setupAttributes();
	}

	public void viewSelectionChanged(DrawingView oldView, DrawingView newView) {
	}

	private void initDrawing() {
		fDrawing = createDrawing();
		view().setDrawing(fDrawing);
		toolDone();
	}

	private void setTool(Tool t, String name) {
		if (fTool != null) {
			fTool.deactivate();
		}
		fTool = t;
		if (fTool != null) {
			showStatus(name);
			fTool.activate();
		}
	}

	private void setSelected(ToolButton button) {
		if (fSelectedToolButton != null) {
			fSelectedToolButton.reset();
		}
		fSelectedToolButton = button;
		if (fSelectedToolButton != null) {
			fSelectedToolButton.select();
		}
	}

	protected void loadDrawing(String param) {
		if (param == fgUntitled) {
			fDrawing.release();
			initDrawing();
			return;
		}

		String filename = getParameter(param);
		if (filename != null) {
			readDrawing(filename);
		}
	}

	private void readDrawing(String filename) {
		toolDone();
		String type = guessType(filename);
		if (type.equals("storable")) {
			readFromStorableInput(filename);
		}
		else if (type.equals("serialized")) {
			readFromObjectInput(filename);
		}
		else {
			showStatus("Unknown file type");
		}
	}

	private void readFromStorableInput(String filename) {
		try {
			URL url = new URL(getCodeBase(), filename);
			InputStream stream = url.openStream();
			StorableInput input = new StorableInput(stream);
			fDrawing.release();

			fDrawing = (Drawing)input.readStorable();
			view().setDrawing(fDrawing);
		}
		catch (IOException e) {
			initDrawing();
			showStatus("Error:" + e);
		}
	}

	private void readFromObjectInput(String filename) {
		try {
			URL url = new URL(getCodeBase(), filename);
			InputStream stream = url.openStream();
			ObjectInput input = new ObjectInputStream(stream);
			fDrawing.release();
			fDrawing = (Drawing)input.readObject();
			view().setDrawing(fDrawing);
		}
		catch (IOException e) {
			initDrawing();
			showStatus("Error: " + e);
		}
		catch (ClassNotFoundException e) {
			initDrawing();
			showStatus("Class not found: " + e);
		}
	}

	private String guessType(String file) {
		if (file.endsWith(".draw")) {
			return "storable";
		}
		if (file.endsWith(".ser")) {
			return "serialized";
		}
		return "unknown";
	}

	private void setupAttributes() {
		Color   frameColor = (Color)   AttributeFigure.getDefaultAttribute(FigureAttributeConstant.FRAME_COLOR);
		Color   fillColor  = (Color)   AttributeFigure.getDefaultAttribute(FigureAttributeConstant.FILL_COLOR);
		//Color   textColor  = (Color)   AttributeFigure.getDefaultAttribute(FigureAttributeConstant.TEXT_COLOR);
		Integer arrowMode  = (Integer) AttributeFigure.getDefaultAttribute(FigureAttributeConstant.ARROW_MODE);
		String  fontName   = (String)  AttributeFigure.getDefaultAttribute(FigureAttributeConstant.FONT_NAME);

		FigureEnumeration fe = view().selection();
		while (fe.hasNextFigure()) {
			Figure f = fe.nextFigure();
			frameColor = (Color) f.getAttribute(FigureAttributeConstant.FRAME_COLOR);
			fillColor  = (Color) f.getAttribute(FigureAttributeConstant.FILL_COLOR);
			//textColor  = (Color) f.getAttribute(FigureAttributeConstant.TEXT_COLOR);
			arrowMode  = (Integer) f.getAttribute(FigureAttributeConstant.ARROW_MODE);
			fontName   = (String) f.getAttribute(FigureAttributeConstant.FONT_NAME);
		}

		fFrameColor.setSelectedIndex(ColorMap.colorIndex(frameColor));
		fFillColor.setSelectedIndex(ColorMap.colorIndex(fillColor));
		//fTextColor.select(ColorMap.colorIndex(textColor));
		if (arrowMode != null) {
			fArrowChoice.setSelectedIndex(arrowMode.intValue());
		}
		if (fontName != null) {
			fFontChoice.setSelectedItem(fontName);
		}
	}

	protected void setSimpleDisplayUpdate() {
		view().setDisplayUpdate(new SimpleUpdateStrategy());
		fUpdateButton.setText("Simple Update");
		fSimpleUpdate = true;
	}

	protected void setBufferedDisplayUpdate() {
		view().setDisplayUpdate(new BufferedUpdateStrategy());
		fUpdateButton.setText("Buffered Update");
		fSimpleUpdate = false;
	}

	/**
	 * Shows a help page for the applet. The URL of the help
	 * page is derived as follows: codeBase+appletClassname+Help.html"
	 */
	protected void showHelp() {
		try {
			String appletPath = getClass().getName().replace('.', '/');
			URL url = new URL(getCodeBase(), appletPath + "Help.html");
			getAppletContext().showDocument(url, "Help");
		}
		catch (IOException e) {
			showStatus("Help file not found");
		}

	}

	protected void setUndoManager(UndoManager newUndoManager) {
		myUndoManager = newUndoManager;
	}

	public UndoManager getUndoManager() {
		return myUndoManager;
	}

	protected VersionControlStrategy getVersionControlStrategy() {
		return new StandardVersionControlStrategy(this);
	}

	/**
	 * Subclasses should override this method to specify to which versions of
	 * JHotDraw they are compatible. A string array is returned so it is possible
	 * to specify several version numbers of JHotDraw to which the application
	 * is compatible with.
	 *
	 * @@return all versions number of JHotDraw the application is compatible with.
	 */
	public String[] getRequiredVersions() {
		String[] requiredVersions = new String[1];
		// return the version of the package we are in
		requiredVersions[0] = VersionManagement.getPackageVersion(DrawApplet.class.getPackage());
		return requiredVersions;
	}
}

@


1.16
log
@Fix deprecation warnings about getFontList().
@
text
@d7 1
a7 1
 * Copyright:	? by the original author(s) and all contributors
d59 1
a59 1
	private static final String       fgDrawPath = "/CH/ifa/draw/";
@


1.15
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@d7 1
a7 1
 * Copyright:	© by the original author(s) and all contributors
d167 1
a167 1
		String fonts[] = Toolkit.getDefaultToolkit().getFontList();
@


1.14
log
@no message
@
text
@d12 1
a12 1
package CH.ifa.draw.applet;
d20 4
a23 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;
@


1.13
log
@Removed all code related to Sleeper thread (deprecated and unused code).
@
text
@d572 1
a573 1
}
@


1.12
log
@Removed an unused Thread field that only generated compiler warnings about use of deprecated API.
@
text
@a54 1
	//private transient Thread          fSleeper;
a102 15
	/*
	 * Gets the iconkit to be used in the applet.
	 */

	 /**** not sure whether this will still be needed on 1.1 enabled browsers
	 protected Iconkit iconkit() {
		if (fIconkit == null) {

			startSleeper();
			loadAllImages(this); // blocks until images loaded
			stopSleeper();
		}
		return fIconkit;
	} */

a572 15
	/**
	 * *** netscape browser work around ***
	 */
	/*private void startSleeper() {
		if (fSleeper == null) {
			fSleeper = new SleeperThread(this);
		}
		fSleeper.start();
	}*/

	/*private void stopSleeper() {
		if (fSleeper != null) {
			fSleeper.stop();
		}
	}*/
a573 24


class SleeperThread extends Thread {

	JApplet  fApplet;

	SleeperThread(JApplet applet) {
		fApplet = applet;
	}

	public void run() {
		try {
			for (;;) {
				fApplet.showStatus("loading icons...");
				sleep(50);
			}
		}
		catch (InterruptedException e) {
			return;
		}
	}

}

@


1.11
log
@no message
@
text
@d55 1
a55 1
	private transient Thread          fSleeper;
d509 1
a509 1
		Color   textColor  = (Color)   AttributeFigure.getDefaultAttribute(FigureAttributeConstant.TEXT_COLOR);
d518 1
a518 1
			textColor  = (Color) f.getAttribute(FigureAttributeConstant.TEXT_COLOR);
d592 1
a592 1
	private void startSleeper() {
d597 1
a597 1
	}
d599 1
a599 1
	private void stopSleeper() {
d603 1
a603 1
	}
@


1.11.4.1
log
@1. Added getDesktop to the DrawingEditor.  added null returns to all Classes that dont fully support
   the Desktop architecture yet, like the applets.

2. Added a figureSelection listener to the DrawingEditor so one can register with the DrawingEditor to
   hear figure selection events.  You can still register with the individual DrawingViews if you wish.
   The DrawingEditor will guarantee that it only fires this event on the active view, so it saves a listener
   from having to register and unregister with views to hear this event each time the activeView changes.
   All Commands were doing this register/unregister dance.

3. AbstractCommand now registers for figureSelectionEvents with the drawingEditor as opposed to the
   DrawingView.

4. Went back to viewCreated and viewDestroying naming.  flip flopping.  Its actually more accurate.  the
   real issue is that 2 events are missing, viewDestroyed and viewCreating.  dont need them yet, but
   they may materialize in the future.

5. Went back to Tool CompositeTool being enabled even when no figure is selected.

6. FigureSelectionListener now extends java.util.EventListener now because I am too lazy to write
   an event handler just yet.

7. implemented new findFigureInside() fix.  needs testing.

8. standardDrawingView selectionZordered now returns figures in the proper order(not reversed).
@
text
@a23 1
import CH.ifa.draw.contrib.Desktop;
a32 1
 * @@todo add {@@link Desktop Desktop} functionality to this class to bring it upto date.
d93 1
a93 6
	/**
	 * @@todo implement <b>Desktop</b> functionality here
	 */
	public Desktop getDesktop() {
		return null;
	}
a97 6
	}

	public void addFigureSelectionListener(FigureSelectionListener fsl){
	}

	public void removeFigureSelectionListener(FigureSelectionListener fsl){
@


1.11.4.2
log
@proper way to end thread.
@
text
@d57 1
a57 1
	private transient SleeperThread      fSleeper;
d614 1
a614 1
			fSleeper.endThread();
d623 1
a623 1
	boolean endthread;
a625 1
		endthread = false;
d630 1
a630 1
			for (;endthread == false;) {
a637 3
	}
	public void endThread(){
		endthread = true;
@


1.10
log
@removed remains of FigureAttributeConstant.getName() and some code-clean up
@
text
@d67 1
d98 4
@


1.9
log
@after variou merges... (before 5.4 release)
@
text
@d129 1
a129 1
		fFillColor = createColorChoice(FigureAttributeConstant.FILL_COLOR.getName());
d133 1
a133 1
		fTextColor = createColorChoice(FigureAttributeConstant.TEXT_COLOR.getName());
d137 1
a137 1
		fFrameColor = createColorChoice(FigureAttributeConstant.FRAME_COLOR.getName());
d143 5
a147 5
		String arrowModeStr = FigureAttributeConstant.ARROW_MODE.getName();
		choice.addItem(new ChangeAttributeCommand("none",     arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_NONE),  this));
		choice.addItem(new ChangeAttributeCommand("at Start", arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_START), this));
		choice.addItem(new ChangeAttributeCommand("at End",   arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_END),   this));
		choice.addItem(new ChangeAttributeCommand("at Both",  arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_BOTH),  this));
d158 1
a158 1
	protected JComboBox createColorChoice(String attribute) {
d180 1
a180 1
			choice.addItem(new ChangeAttributeCommand(fonts[i], FigureAttributeConstant.FONT_NAME.getName(), fonts[i],  this));
d346 1
a346 1
			showStatus(((ToolButton) button).name());
@


1.8
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@a55 1
	private Iconkit                   fIconkit;
a69 2
		fIconkit = new Iconkit(this);

d508 3
a510 3
		FigureEnumeration k = view().selectionElements();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
@


1.7
log
@no message
@
text
@d351 1
a351 1
		else {
@


1.6
log
@merge dnd (before 5.3)
@
text
@a14 1
import java.applet.Applet;
d58 1
a58 1
	
d70 1
a70 1
		
d76 1
a76 1
		
d132 1
a132 1
		fFillColor = createColorChoice("FillColor");
d136 1
a136 1
		fTextColor = createColorChoice("TextColor");
d140 1
a140 1
		fFrameColor = createColorChoice("FrameColor");
d146 5
a150 4
		choice.addItem(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  this));
		choice.addItem(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), this));
		choice.addItem(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   this));
		choice.addItem(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  this));
d183 1
a183 1
			choice.addItem(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  this));
d505 5
a509 5
		Color   frameColor = (Color)   AttributeFigure.getDefaultAttribute("FrameColor");
		Color   fillColor  = (Color)   AttributeFigure.getDefaultAttribute("FillColor");
		Color   textColor  = (Color)   AttributeFigure.getDefaultAttribute("TextColor");
		Integer arrowMode  = (Integer) AttributeFigure.getDefaultAttribute("ArrowMode");
		String  fontName   = (String)  AttributeFigure.getDefaultAttribute("FontName");
d514 5
a518 5
			frameColor = (Color) f.getAttribute("FrameColor");
			fillColor  = (Color) f.getAttribute("FillColor");
			textColor  = (Color) f.getAttribute("TextColor");
			arrowMode  = (Integer) f.getAttribute("ArrowMode");
			fontName   = (String) f.getAttribute("FontName");
d563 1
a563 1
	
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d38 1
a38 1
		implements DrawingEditor, PaletteListener {
d40 2
a41 2
	transient private Drawing         fDrawing;
	transient private Tool            fTool;
d43 3
a45 3
	transient private DrawingView     fView;
	transient private ToolButton      fDefaultToolButton;
	transient private ToolButton      fSelectedToolButton;
d47 2
a48 2
	transient private boolean         fSimpleUpdate;
	transient private JButton          fUpdateButton;
d50 5
a54 5
	transient private JComboBox          fFrameColor;
	transient private JComboBox          fFillColor;
	transient private JComboBox          fTextColor;
	transient private JComboBox          fArrowChoice;
	transient private JComboBox          fFontChoice;
d56 1
a56 1
	transient private Thread          fSleeper;
d58 2
a59 1

d69 3
d97 6
d147 4
a150 4
		choice.addItem(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  view()));
		choice.addItem(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), view()));
		choice.addItem(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   view()));
		choice.addItem(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  view()));
d169 1
a169 1
					view()
d183 1
a183 1
			choice.addItem(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  view()));
d237 1
a237 1
		button = new CommandButton(new DeleteCommand("Delete", view()));
d240 1
a240 1
		button = new CommandButton(new DuplicateCommand("Duplicate", view()));
d243 1
a243 1
		button = new CommandButton(new GroupCommand("Group", view()));
d246 1
a246 1
		button = new CommandButton(new UngroupCommand("Ungroup", view()));
d303 1
a303 1
		return new SelectionTool(view());
d380 4
d402 3
d558 27
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)DrawApplet.java 5.2
d4 6
a25 1

d33 2
a35 1

d37 2
a38 2
        extends JApplet
	    implements DrawingEditor, PaletteListener {
d40 2
a41 2
    transient private Drawing         fDrawing;
    transient private Tool            fTool;
d43 26
a68 26
    transient private StandardDrawingView fView;
    transient private ToolButton      fDefaultToolButton;
    transient private ToolButton      fSelectedToolButton;

    transient private boolean         fSimpleUpdate;
    transient private JButton          fUpdateButton;

    transient private JComboBox          fFrameColor;
    transient private JComboBox          fFillColor;
    transient private JComboBox          fTextColor;
    transient private JComboBox          fArrowChoice;
    transient private JComboBox          fFontChoice;

    transient private Thread          fSleeper;
    private Iconkit                   fIconkit;

    static String                     fgUntitled = "untitled";

    private static final String       fgDrawPath = "/CH/ifa/draw/";
    public static final String        IMAGES = fgDrawPath+"images/";

    /**
     * Initializes the applet and creates its contents.
     */
    public void init() {
        fIconkit = new Iconkit(this);
d72 141
a212 136
        fView = createDrawingView();
        
        JPanel attributes = createAttributesPanel();
        createAttributeChoices(attributes);
        getContentPane().add("North", attributes);

        JPanel toolPanel = createToolPalette();
        createTools(toolPanel);
        getContentPane().add("West", toolPanel);

        getContentPane().add("Center", fView);
        JPanel buttonPalette = createButtonPanel();
        createButtons(buttonPalette);
        getContentPane().add("South", buttonPalette);

        initDrawing();
        // JFC should have its own internal double buffering...
        //setBufferedDisplayUpdate();
        setupAttributes();
    }

    /*
     * Gets the iconkit to be used in the applet.
     */

     /**** not sure whether this will still be needed on 1.1 enabled browsers
     protected Iconkit iconkit() {
        if (fIconkit == null) {

            startSleeper();
            loadAllImages(this); // blocks until images loaded
            stopSleeper();
        }
        return fIconkit;
    } */

    /**
     * Creates the attributes panel.
     */
    protected JPanel createAttributesPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new PaletteLayout(2, new Point(2,2), false));
        return panel;
    }

    /**
     * Creates the attribute choices. Override to add additional
     * choices.
     */
    protected void createAttributeChoices(JPanel panel) {
        panel.add(new JLabel("Fill"));
        fFillColor = createColorChoice("FillColor");
        panel.add(fFillColor);

        panel.add(new JLabel("Text"));
        fTextColor = createColorChoice("TextColor");
        panel.add(fTextColor);

        panel.add(new JLabel("Pen"));
        fFrameColor = createColorChoice("FrameColor");
        panel.add(fFrameColor);

        panel.add(new JLabel("Arrow"));
        CommandChoice choice = new CommandChoice();
        fArrowChoice = choice;
        choice.addItem(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  fView));
        choice.addItem(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), fView));
        choice.addItem(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   fView));
        choice.addItem(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  fView));
        panel.add(fArrowChoice);

        panel.add(new JLabel("Font"));
        fFontChoice = createFontChoice();
        panel.add(fFontChoice);
    }

    /**
     * Creates the color choice for the given attribute.
     */
    protected JComboBox createColorChoice(String attribute) {
        CommandChoice choice = new CommandChoice();
        for (int i=0; i<ColorMap.size(); i++)
            choice.addItem(
                new ChangeAttributeCommand(
                    ColorMap.name(i),
                    attribute,
                    ColorMap.color(i),
                    fView
                )
            );
        return choice;
    }

    /**
     * Creates the font choice. The choice is filled with
     * all the fonts supported by the toolkit.
     */
    protected JComboBox createFontChoice() {
        CommandChoice choice = new CommandChoice();
        String fonts[] = Toolkit.getDefaultToolkit().getFontList();
        for (int i = 0; i < fonts.length; i++)
            choice.addItem(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  fView));
        return choice;
    }

    /**
     * Creates the buttons panel.
     */
    protected JPanel createButtonPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new PaletteLayout(2, new Point(2,2), false));
        return panel;
    }

    /**
     * Creates the buttons shown in the buttons panel. Override to
     * add additional buttons.
     * @@param panel the buttons panel.
     */
    protected void createButtons(JPanel panel) {
        panel.add(new Filler(24,20));

        JComboBox drawingChoice = new JComboBox();
        drawingChoice.addItem(fgUntitled);

	    String param = getParameter("DRAWINGS");
	    if (param == null)
	        param = "";
       	StringTokenizer st = new StringTokenizer(param);
        while (st.hasMoreTokens())
            drawingChoice.addItem(st.nextToken());
        // offer choice only if more than one
        if (drawingChoice.getItemCount() > 1)
            panel.add(drawingChoice);
        else
            panel.add(new JLabel(fgUntitled));
d215 7
a221 7
		    new ItemListener() {
		        public void itemStateChanged(ItemEvent e) {
		            if (e.getStateChange() == ItemEvent.SELECTED) {
		                loadDrawing((String)e.getItem());
		            }
		        }
		    }
d224 1
a224 1
        panel.add(new Filler(6,20));
d226 3
a228 3
        JButton button;
        button = new CommandButton(new DeleteCommand("Delete", fView));
        panel.add(button);
d230 2
a231 2
        button = new CommandButton(new DuplicateCommand("Duplicate", fView));
        panel.add(button);
d233 2
a234 2
        button = new CommandButton(new GroupCommand("Group", fView));
        panel.add(button);
d236 2
a237 2
        button = new CommandButton(new UngroupCommand("Ungroup", fView));
        panel.add(button);
d239 1
a239 1
        button = new JButton("Help");
d241 5
a245 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            showHelp();
		        }
		    }
d247 1
a247 1
        panel.add(button);
d249 1
a249 1
        fUpdateButton = new JButton("Simple Update");
d251 10
a260 8
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
                    if (fSimpleUpdate)
                        setBufferedDisplayUpdate();
                    else
                        setSimpleDisplayUpdate();
		        }
		    }
d263 2
a264 2
        // panel.add(fUpdateButton); // not shown currently
    }
d266 292
a557 273
    /**
     * Creates the tools palette.
     */
    protected JPanel createToolPalette() {
        JPanel palette = new JPanel();
        palette.setLayout(new PaletteLayout(2,new Point(2,2)));
        return palette;
    }

    /**
     * Creates the tools. By default only the selection tool is added.
     * Override this method to add additional tools.
     * Call the inherited method to include the selection tool.
     * @@param palette the palette where the tools are added.
     */
    protected void createTools(JPanel palette) {
        Tool tool = createSelectionTool();

        fDefaultToolButton = createToolButton(IMAGES+"SEL", "Selection Tool", tool);
        palette.add(fDefaultToolButton);
    }

    /**
     * Creates the selection tool used in this editor. Override to use
     * a custom selection tool.
     */
    protected Tool createSelectionTool() {
        return new SelectionTool(view());
    }

    /**
     * Creates a tool button with the given image, tool, and text
     */
    protected ToolButton createToolButton(String iconName, String toolName, Tool tool) {
        return new ToolButton(this, iconName, toolName, tool);
    }

    /**
     * Creates the drawing used in this application.
     * You need to override this method to use a Drawing
     * subclass in your application. By default a standard
     * Drawing is returned.
     */
    protected Drawing createDrawing() {
        return new StandardDrawing();
    }

    /**
     * Creates the drawing view used in this application.
     * You need to override this method to use a DrawingView
     * subclass in your application. By default a standard
     * DrawingView is returned.
     */
    protected StandardDrawingView createDrawingView() {
        return new StandardDrawingView(this, 410, 370);
    }

    /**
     * Handles a user selection in the palette.
     * @@see PaletteListener
     */
    public void paletteUserSelected(PaletteButton button) {
        ToolButton toolButton = (ToolButton) button;
        setTool(toolButton.tool(), toolButton.name());
        setSelected(toolButton);
    }

    /**
     * Handles when the mouse enters or leaves a palette button.
     * @@see PaletteListener
     */
    public void paletteUserOver(PaletteButton button, boolean inside) {
        if (inside)
            showStatus(((ToolButton) button).name());
        else
            showStatus(fSelectedToolButton.name());
    }

    /**
     * Gets the current drawing.
     * @@see DrawingEditor
     */
    public Drawing drawing() {
        return fDrawing;
    }

    /**
     * Gets the current tool.
     * @@see DrawingEditor
     */
    public Tool tool() {
        return fTool;
    }

    /**
     * Gets the current drawing view.
     * @@see DrawingEditor
     */
    public DrawingView view() {
        return fView;
    }

    /**
     * Sets the default tool of the editor.
     * @@see DrawingEditor
     */
    public void toolDone() {
        setTool(fDefaultToolButton.tool(), fDefaultToolButton.name());
        setSelected(fDefaultToolButton);
    }

    /**
     * Handles a change of the current selection. Updates all
     * menu items that are selection sensitive.
     * @@see DrawingEditor
     */
    public void selectionChanged(DrawingView view) {
        setupAttributes();
    }

    private void initDrawing() {
        fDrawing = createDrawing();
        fView.setDrawing(fDrawing);
        toolDone();
    }

    private void setTool(Tool t, String name) {
        if (fTool != null)
            fTool.deactivate();
        fTool = t;
        if (fTool != null) {
            showStatus(name);
            fTool.activate();
        }
    }

    private void setSelected(ToolButton button) {
        if (fSelectedToolButton != null)
            fSelectedToolButton.reset();
        fSelectedToolButton = button;
        if (fSelectedToolButton != null)
            fSelectedToolButton.select();
    }

    protected void loadDrawing(String param) {
        if (param == fgUntitled) {
            fDrawing.release();
            initDrawing();
            return;
        }

        String filename = getParameter(param);
        if (filename != null)
            readDrawing(filename);
    }

    private void readDrawing(String filename) {
        toolDone();
        String type = guessType(filename);
        if (type.equals("storable"))
            readFromStorableInput(filename);
        else if (type.equals("serialized"))
            readFromObjectInput(filename);
        else
            showStatus("Unknown file type");
    }

    private void readFromStorableInput(String filename) {
        try {
            URL url = new URL(getCodeBase(), filename);
            InputStream stream = url.openStream();
            StorableInput input = new StorableInput(stream);
            fDrawing.release();

            fDrawing = (Drawing)input.readStorable();
            fView.setDrawing(fDrawing);
        } catch (IOException e) {
            initDrawing();
            showStatus("Error:"+e);
        }
    }

    private void readFromObjectInput(String filename) {
        try {
            URL url = new URL(getCodeBase(), filename);
            InputStream stream = url.openStream();
            ObjectInput input = new ObjectInputStream(stream);
            fDrawing.release();
            fDrawing = (Drawing)input.readObject();
            fView.setDrawing(fDrawing);
        } catch (IOException e) {
            initDrawing();
            showStatus("Error: " + e);
        } catch (ClassNotFoundException e) {
            initDrawing();
            showStatus("Class not found: " + e);
        }
    }

    private String guessType(String file) {
        if (file.endsWith(".draw"))
            return "storable";
        if (file.endsWith(".ser"))
            return "serialized";
        return "unknown";
    }

    private void setupAttributes() {
        Color   frameColor = (Color)   AttributeFigure.getDefaultAttribute("FrameColor");
        Color   fillColor  = (Color)   AttributeFigure.getDefaultAttribute("FillColor");
        Color   textColor  = (Color)   AttributeFigure.getDefaultAttribute("TextColor");
        Integer arrowMode  = (Integer) AttributeFigure.getDefaultAttribute("ArrowMode");
        String  fontName   = (String)  AttributeFigure.getDefaultAttribute("FontName");

        FigureEnumeration k = fView.selectionElements();
        while (k.hasMoreElements()) {
            Figure f = k.nextFigure();
            frameColor = (Color) f.getAttribute("FrameColor");
            fillColor  = (Color) f.getAttribute("FillColor");
            textColor  = (Color) f.getAttribute("TextColor");
            arrowMode  = (Integer) f.getAttribute("ArrowMode");
            fontName   = (String) f.getAttribute("FontName");
        }

        fFrameColor.setSelectedIndex(ColorMap.colorIndex(frameColor));
        fFillColor.setSelectedIndex(ColorMap.colorIndex(fillColor));
        //fTextColor.select(ColorMap.colorIndex(textColor));
        if (arrowMode != null)
            fArrowChoice.setSelectedIndex(arrowMode.intValue());
        if (fontName != null)
            fFontChoice.setSelectedItem(fontName);
    }

    protected void setSimpleDisplayUpdate() {
        fView.setDisplayUpdate(new SimpleUpdateStrategy());
        fUpdateButton.setText("Simple Update");
        fSimpleUpdate = true;
    }

    protected void setBufferedDisplayUpdate() {
        fView.setDisplayUpdate(new BufferedUpdateStrategy());
        fUpdateButton.setText("Buffered Update");
        fSimpleUpdate = false;
    }

    /**
     * Shows a help page for the applet. The URL of the help
     * page is derived as follows: codeBase+appletClassname+Help.html"
     */
    protected void showHelp() {
        try {
            String appletPath = getClass().getName().replace('.', '/');
            URL url = new URL(getCodeBase(), appletPath+"Help.html");
            getAppletContext().showDocument(url, "Help");
        } catch (IOException e) {
            showStatus("Help file not found");
        }

    }

    /**
     * *** netscape browser work around ***
     */
    private void startSleeper() {
        if (fSleeper == null)
            fSleeper = new SleeperThread(this);
        fSleeper.start();
    }

    private void stopSleeper() {
        if (fSleeper != null)
            fSleeper.stop();
    }
d563 1
a563 1
    JApplet  fApplet;
d565 15
a579 14
    SleeperThread(JApplet applet) {
        fApplet = applet;
    }

    public void run() {
        try {
            for (;;) {
                fApplet.showStatus("loading icons...");
                sleep(50);
            }
        } catch (InterruptedException e) {
            return;
        }
    }
@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d37 1
a37 1
    transient private DrawingView     fView;
d76 1
a76 1
        getContentPane().add("Center", (Component)view());
d131 4
a134 4
        choice.addItem(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  view()));
        choice.addItem(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), view()));
        choice.addItem(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   view()));
        choice.addItem(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  view()));
d153 1
a153 1
                    view()
d167 1
a167 1
            choice.addItem(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  view()));
d216 1
a216 1
        button = new CommandButton(new DeleteCommand("Delete", view()));
d219 1
a219 1
        button = new CommandButton(new DuplicateCommand("Duplicate", view()));
d222 1
a222 1
        button = new CommandButton(new GroupCommand("Group", view()));
d225 1
a225 1
        button = new CommandButton(new UngroupCommand("Ungroup", view()));
d306 1
a306 1
    protected DrawingView createDrawingView() {
d325 1
a325 1
        if (inside) {
d327 1
a327 2
        }
        else {
a328 1
        }
d369 1
a369 1
    public void figureSelectionChanged(DrawingView view) {
d375 1
a375 1
        view().setDrawing(fDrawing);
d428 1
a428 1
            view().setDrawing(fDrawing);
d442 1
a442 1
            view().setDrawing(fDrawing);
d467 1
a467 1
        FigureEnumeration k = view().selectionElements();
d487 1
a487 1
        view().setDisplayUpdate(new SimpleUpdateStrategy());
d493 1
a493 1
        view().setDisplayUpdate(new BufferedUpdateStrategy());
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d37 1
a37 1
    transient private StandardDrawingView fView;
d76 1
a76 1
        getContentPane().add("Center", fView);
d131 4
a134 4
        choice.addItem(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  fView));
        choice.addItem(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), fView));
        choice.addItem(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   fView));
        choice.addItem(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  fView));
d153 1
a153 1
                    fView
d167 1
a167 1
            choice.addItem(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  fView));
d216 1
a216 1
        button = new CommandButton(new DeleteCommand("Delete", fView));
d219 1
a219 1
        button = new CommandButton(new DuplicateCommand("Duplicate", fView));
d222 1
a222 1
        button = new CommandButton(new GroupCommand("Group", fView));
d225 1
a225 1
        button = new CommandButton(new UngroupCommand("Ungroup", fView));
d306 1
a306 1
    protected StandardDrawingView createDrawingView() {
d325 1
a325 1
        if (inside)
d327 2
a328 1
        else
d330 1
d371 1
a371 1
    public void selectionChanged(DrawingView view) {
d377 1
a377 1
        fView.setDrawing(fDrawing);
d430 1
a430 1
            fView.setDrawing(fDrawing);
d444 1
a444 1
            fView.setDrawing(fDrawing);
d469 1
a469 1
        FigureEnumeration k = fView.selectionElements();
d489 1
a489 1
        fView.setDisplayUpdate(new SimpleUpdateStrategy());
d495 1
a495 1
        fView.setDisplayUpdate(new BufferedUpdateStrategy());
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)DrawApplet.java 5.1
d8 1
d31 1
a31 1
        extends Applet
d42 1
a42 1
    transient private Button          fUpdateButton;
d44 5
a48 5
    transient private Choice          fFrameColor;
    transient private Choice          fFillColor;
    //transient private Choice          fTextColor;
    transient private Choice          fArrowChoice;
    transient private Choice          fFontChoice;
d64 1
a64 1
		setLayout(new BorderLayout());
d67 2
a68 2

        Panel attributes = createAttributesPanel();
d70 1
a70 1
        add("North", attributes);
d72 1
a72 1
        Panel toolPanel = createToolPalette();
d74 1
a74 1
        add("West", toolPanel);
d76 2
a77 2
        add("Center", fView);
        Panel buttonPalette = createButtonPanel();
d79 1
a79 1
        add("South", buttonPalette);
d82 2
a83 1
        setBufferedDisplayUpdate();
d105 2
a106 2
    protected Panel createAttributesPanel() {
        Panel panel = new Panel();
d115 2
a116 2
    protected void createAttributeChoices(Panel panel) {
        panel.add(new Label("Fill"));
d120 3
a122 3
        //panel.add(new Label("Text"));
        //fTextColor = createColorChoice("TextColor");
        //panel.add(fTextColor);
d124 1
a124 1
        panel.add(new Label("Pen"));
d128 1
a128 1
        panel.add(new Label("Arrow"));
d137 1
a137 1
        panel.add(new Label("Font"));
d145 1
a145 1
    protected Choice createColorChoice(String attribute) {
d163 1
a163 1
    protected Choice createFontChoice() {
d174 2
a175 2
    protected Panel createButtonPanel() {
        Panel panel = new Panel();
d185 1
a185 1
    protected void createButtons(Panel panel) {
d188 1
a188 1
        Choice drawingChoice = new Choice();
d201 1
a201 1
            panel.add(new Label(fgUntitled));
d215 1
a215 1
        Button button;
d228 1
a228 1
        button = new Button("Help");
d238 1
a238 1
        fUpdateButton = new Button("Simple Update");
d256 2
a257 2
    protected Panel createToolPalette() {
        Panel palette = new Panel();
d268 1
a268 1
    protected void createTools(Panel palette) {
d477 2
a478 2
        fFrameColor.select(ColorMap.colorIndex(frameColor));
        fFillColor.select(ColorMap.colorIndex(fillColor));
d481 1
a481 1
            fArrowChoice.select(arrowMode.intValue());
d483 1
a483 1
            fFontChoice.select(fontName);
d488 1
a488 1
        fUpdateButton.setLabel("Simple Update");
d494 1
a494 1
        fUpdateButton.setLabel("Buffered Update");
d531 1
a531 1
    Applet  fApplet;
d533 1
a533 1
    SleeperThread(Applet applet) {
@


1.1.1.1
log
@
Initial revision.
@
text
@@
