64a65,68
> // Revision 1.27  2001/12/06 14:51:04  gorban
> // Bug in LSR[0] is fixed.
> // All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
> //
235a240,240
> reg [7:0] 								scratch; // UART scratch register
304,304c309,309
< always @(/*AUTOSENSE*/dl or dlab or ier or iir
---
> always @(dl or dlab or ier or iir or scratch
307,312d311
<    if (wb_rst_i)
<    begin
< 		wb_dat_o <= #1 8'b0;
<    end
<    else
< 		if (wb_re_i)   //if (we're not writing)
314,314c313,313
< 				`UART_REG_RB   : wb_dat_o <= #1 dlab ? dl[`UART_DL1] : rf_data_out[10:3];
---
> 		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
315,315c314,314
< 				`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
---
> 		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
316,316c315,315
< 				`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
---
> 		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
316a316,319
> 		`UART_REG_LC	: wb_dat_o = lcr;
> 		`UART_REG_LS	: wb_dat_o = lsr;
> 		`UART_REG_MS	: wb_dat_o = msr;
> 		`UART_REG_SR	: wb_dat_o = scratch;
317,319d315
< 				`UART_REG_LC	: wb_dat_o <= #1 lcr;
< 				`UART_REG_LS	: wb_dat_o <= #1 lsr;
< 				`UART_REG_MS	: wb_dat_o <= #1 msr;
320,320c320,320
< 				default:  wb_dat_o <= #1 8'b0; // ??
---
> 		default:  wb_dat_o = 8'b0; // ??
321a322,323
> end // always @ (dl or dlab or ier or iir or scratch...
> 
322,324d321
< 		else
< 			wb_dat_o <= #1 8'b0;
< end // always @ (posedge clk or posedge wb_rst_i)
428a428,436
> // Scratch register
> // Line Control Register
> always @(posedge clk or posedge wb_rst_i)
> 	if (wb_rst_i)
> 		scratch <= #1 0; // 8n1 setting
> 	else
> 	if (wb_we_i && wb_addr_i==`UART_REG_SR)
> 		scratch <= #1 wb_dat_i;
> 
