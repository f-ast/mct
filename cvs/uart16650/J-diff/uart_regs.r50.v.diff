64a65,73
> // Revision 1.26  2001/12/03 21:44:29  gorban
> // Updated specification documentation.
> // Added full 32-bit data bus interface, now as default.
> // Address is 5-bit wide in 32-bit data bus mode.
> // Added wb_sel_i input to the core. It's used in the 32-bit mode.
> // Added debug interface with two 32-bit read-only registers in 32-bit mode.
> // Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
> // My small test bench is modified to work with 32-bit mode.
> //
291c300
< 	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate);
---
> 	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
367,380d375
< /*
< // threi_clear signal handling
< always @(posedge clk or posedge wb_rst_i)
< begin
< 	if (wb_rst_i)
< 		threi_clear <= #1 0;
< 	else
< 	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
< 		threi_clear <= #1 0;
< 	else
< 	if (wb_re_i && wb_addr_i == `UART_REG_II)
< 		threi_clear <= #1 1;
< end
< */
489c484
< assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
---
> assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
556,557d550
< wire tx_fifo_write;
< assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
565c558
< 	else lsr5r <= #1 (tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
---
> 	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
576c569
< 	else lsr6r <= #1 (tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
---
> 	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
