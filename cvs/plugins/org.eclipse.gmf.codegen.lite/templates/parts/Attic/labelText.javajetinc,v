head	1.8;
access;
symbols
	v20080910-1520:1.8
	v20070403-1500:1.7
	v20070330-1300:1.7
	v20060330-1300:1.7
	v20070322-1100:1.7
	v20060316-0600:1.7
	v20070307-0700:1.6
	v20070228-2000:1.6
	v20070221-1500:1.6
	v20070208-1800:1.6
	v20070103-0300:1.5
	M4_20:1.5
	v20061222-1800:1.5
	v20061214-0000:1.4
	v20061120-1300:1.4
	M3_20:1.4
	v20061117-0800:1.4
	v20061013-1330:1.3
	v20061005-1700:1.1
	M1_20:1.2
	v20060904-1500:1.2
	v20060824-1600:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060626-1420:1.1
	v20060620-0400:1.1
	v20060616-1400:1.1
	v20060616-1200:1.1
	v20060609-1400:1.1
	v20060531-1730:1.1
	v20060530-1930:1.1
	v20060526-1200:1.1
	v20060519-1300:1.1
	v20060519-0800:1.1
	v20060512-1000:1.1
	I20060512-1000:1.1
	I20060505-1400:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2007.04.04.11.04.48;	author bblajer;	state dead;
branches;
next	1.7;
commitid	18c54613864d4567;

1.7
date	2007.03.15.16.43.30;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	617845f977b04567;

1.6
date	2007.01.19.17.15.18;	author bblajer;	state Exp;
branches;
next	1.5;
commitid	781645b0fca44567;

1.5
date	2006.12.19.19.11.42;	author bblajer;	state Exp;
branches;
next	1.4;
commitid	733e4588396c4567;

1.4
date	2006.10.18.16.29.03;	author bblajer;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.11.15.45.01;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.04.17.05.48;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.13.21.20.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@	/**
	 * @@generated
	 */
	private static <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelTextDisplayer")%> createLabelTextDisplayer() {
<%
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	String viewPattern = featureLabelModelFacet.getViewPattern();
	if (viewPattern == null || viewPattern.length() == 0) {
		StringBuffer patternBuffer = new StringBuffer();
		for(int i = 0; i < featureLabelModelFacet.getMetaFeatures().size(); i++) {
			patternBuffer.append("{").append(i).append("} ");
		}
		viewPattern = patternBuffer.toString().trim();
	}
	String editPattern = null;
	if (!isReadOnly) {
		editPattern = featureLabelModelFacet.getEditPattern();
		if (editPattern == null || editPattern.length() == 0) {
			StringBuffer patternBuffer = new StringBuffer();
			for(int i = 0; i < featureLabelModelFacet.getMetaFeatures().size(); i++) {
				patternBuffer.append("{").append(i).append("} ");
			}
			editPattern = patternBuffer.toString().trim();
		}
	}
%>
		return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.SimpleLabelTextDisplayer")%>("<%=viewPattern%>"<%if (!isReadOnly) {%>, "<%=editPattern%>"<%}%>, 
			new <%=importManager.getImportedName("org.eclipse.emf.ecore.EStructuralFeature")%>[] {
<%
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
		<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>()<%if (it.hasNext()) {%>,<%}
%>
<%
	}
%>});
<%
} else {
%>
		// TODO: implement this method
		// Ensure that you remove @@generated or mark it @@generated NOT
		return null;
<%
}
%>
	}

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelTextDisplayer")%> getLabelTextDisplayer() {
		return LABEL_DISPLAYER;
	}

	/**
	 * @@generated
	 */
	public void setLabelText(String text) {
		getLabel().setText(text);
	}

	/**
	 * @@generated
	 */
	protected String getLabelText() {
		<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> element = <%=primaryView%>.getElement();
		if (element == null) {
			return defaultText;
		}
		String result = getLabelTextDisplayer().getDisplayText(element);
		if (result == null || result.length() == 0) {
			return defaultText;
		}
		return result;
	}
@


1.7
log
@[164018] Command generation seperated from Parts for commands that operate with labels;
API to display label text, apply modifications and update after (external) modifications isolated from generated code;
Moved as much common generated code as possible to BaseTreeEditPart;
[165700] Support diagrams in read-only mode: all EMF commands that are not composed of standard EMF commands, but modify EMF models directly should query the editing domain for read-onliness of the resource they operate on.
@
text
@@


1.6
log
@Default label text should be displayed instead of the "null" string when the corresponding feature is not set;
It should be possible to unset the value of a feature using a diagram label;
Fixed compilation errors when a label is not feature-based
@
text
@d1 4
a5 12
/*genFeature.getObjectType() throws NPE on primitive types. This is a workaround. */
HashMap primitiveTypeToWrapperClassName = new HashMap();
primitiveTypeToWrapperClassName.put(Boolean.TYPE, "Boolean");
primitiveTypeToWrapperClassName.put(Byte.TYPE, "Byte");
primitiveTypeToWrapperClassName.put(Character.TYPE, "Character");
primitiveTypeToWrapperClassName.put(Double.TYPE, "Double");
primitiveTypeToWrapperClassName.put(Float.TYPE, "Float");
primitiveTypeToWrapperClassName.put(Integer.TYPE, "Integer");
primitiveTypeToWrapperClassName.put(Long.TYPE, "Long");
primitiveTypeToWrapperClassName.put(Short.TYPE, "Short");
String viewPattern = null;
String editPattern = null;
d8 1
a8 1
	viewPattern = featureLabelModelFacet.getViewPattern();
d16 9
a24 5
	editPattern = featureLabelModelFacet.getEditPattern();
	if (editPattern == null || editPattern.length() == 0) {
		StringBuffer patternBuffer = new StringBuffer();
		for(int i = 0; i < featureLabelModelFacet.getMetaFeatures().size(); i++) {
			patternBuffer.append("{").append(i).append("} ");
a25 1
		editPattern = patternBuffer.toString().trim();
d27 19
d48 2
d53 3
a55 1
	public static final String VIEW_PATTERN = "<%=viewPattern%>";
d60 3
a62 1
	public static final String EDIT_PATTERN = "<%=editPattern%>";
d68 1
a68 1
		<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%> element = <%=resolvedSemanticElement%>;
d72 1
a72 1
		String result = buildTextByPattern(element, VIEW_PATTERN);
a77 55

	/**
	 * @@generated
	 */
	protected String getLabelEditText() {
		<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%> element = <%=resolvedSemanticElement%>;
		if (element == null) {
			return "";	//$NON-NLS-1$
		}
		String result = buildTextByPattern(element, EDIT_PATTERN);
		if (result == null) {
			return "";	//$NON-NLS-1$
		}
		return result;
	}

	/**
	 * @@generated
	 */
	public static String buildTextByPattern(<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%> element, String pattern) {
<%
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
%>
		return <%=importManager.getImportedName("java.text.MessageFormat")%>.format(pattern, new Object[] {
<%
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
		if (next.isPrimitiveType()) {
%>
			new <%=primitiveTypeToWrapperClassName.get(next.getTypeGenClassifier().getEcoreClassifier().getInstanceClass())%>(<%
		}
		myFeatureGetAccessorHelper.appendFeatureValueGetter("element", next, underlyingMetaClass, false);
		if (next.isPrimitiveType()) {
%>)<%
		} else {
			if (String.class.equals(next.getEcoreFeature().getEType().getInstanceClass())) {
%> == null ? "" : <%
				myFeatureGetAccessorHelper.appendFeatureValueGetter("element", next, underlyingMetaClass, false);
			}
		}
		if (it.hasNext()) {%>,<%}%>
<%
	}
%>
		});
<%
} else {
%>
		//XXX: unexpected model facet.
		return null;
<%
}
%>
	}
@


1.5
log
@Generate support for Navigator
@
text
@d53 1
a53 1
		if (result == null) {
d65 1
a65 1
			return defaultText;
d69 1
a69 1
			return defaultText;
d93 5
@


1.4
log
@Fix compilation problems introduced by recent fix of https://bugs.eclipse.org/bugs/show_bug.cgi?id=161380
@
text
@d37 1
a37 1
	private static final String VIEW_PATTERN = "<%=viewPattern%>";
d52 5
a56 1
		return buildTextByPattern(element, VIEW_PATTERN);
d67 5
a71 1
		return buildTextByPattern(element, EDIT_PATTERN);
d77 1
a77 1
	protected String buildTextByPattern(<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%> element, String pattern) {
d103 1
a103 1
		return defaultText;
@


1.3
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@a17 10
		viewPattern = "{0}";
	}
	editPattern = featureLabelModelFacet.getEditPattern();
	if (editPattern == null || editPattern.length() == 0) {
		editPattern = "{0}";
	}
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
	viewPattern = compositeFeatureLabelModelFacet.getViewPattern();
	if (viewPattern == null || viewPattern.length() == 0) {
d19 1
a19 1
		for(int i = 0; i < compositeFeatureLabelModelFacet.getMetaFeatures().size(); i++) {
d24 1
a24 1
	editPattern = compositeFeatureLabelModelFacet.getEditPattern();
d27 1
a27 1
		for(int i = 0; i < compositeFeatureLabelModelFacet.getMetaFeatures().size(); i++) {
a72 24
	GenFeature feature = featureLabelModelFacet.getMetaFeature();
	if (!feature.isPrimitiveType()) {
%>
		if (<%myFeatureGetAccessorHelper.appendFeatureValueGetter("element", feature, underlyingMetaClass, false);%> == null) {
			return defaultText;
		}
<%
	}
%>
		return <%=importManager.getImportedName("java.text.MessageFormat")%>.format(pattern, new Object[] {
<%
		if (feature.isPrimitiveType()) {
%>
			new <%=primitiveTypeToWrapperClassName.get(feature.getTypeGenClassifier().getEcoreClassifier().getInstanceClass())%>(<%
		}
		myFeatureGetAccessorHelper.appendFeatureValueGetter("element", feature, underlyingMetaClass, false);
		if (feature.isPrimitiveType()) {
%>)<%
		}
%>
		});
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
d76 1
a76 1
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
@


1.2
log
@[bblajer] #152774 Compilable code when EClass has instance class attribute set
@
text
@d52 1
a52 1
	private static final String EDIT_PATTERN = "<%=editPattern%>";
@


1.1
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
@
text
@d86 1
a86 1
		if (element.get<%=feature.getCapName()%>() == null) {
a93 1
		String value = "element.get" + feature.getCapName() + "()";	/*XXX: getTypedKey is not a part of public API!*/
d95 6
a100 1
			value = "new " + primitiveTypeToWrapperClassName.get(feature.getTypeGenClassifier().getEcoreClassifier().getInstanceClass()) + "(" + value + ")";
a102 1
			<%=value%>
a111 1
		String value = "element.get" + next.getCapName() + "()";	/*XXX: getTypedKey is not a part of public API!*/
d113 2
a114 1
			value = "new " + primitiveTypeToWrapperClassName.get(next.getTypeGenClassifier().getEcoreClassifier().getInstanceClass()) + "(" + value + ")";
d116 5
a120 2
%>
		<%=value%><%if (it.hasNext()) {%>,<%}%>
@

