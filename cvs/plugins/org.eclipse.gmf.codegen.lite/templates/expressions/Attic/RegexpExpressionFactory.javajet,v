head	1.4;
access;
symbols
	v20080910-1520:1.4
	v20070427-0600:1.2
	v20070420-1000:1.2
	v20070413-1300:1.2
	v20070405-1100:1.2
	v20070403-1500:1.2
	v20070330-1300:1.2
	v20060330-1300:1.2
	v20070322-1100:1.2
	v20060316-0600:1.2
	v20070307-0700:1.2
	v20070228-2000:1.2
	v20070221-1500:1.2
	v20070208-1800:1.2
	v20070103-0300:1.2
	M4_20:1.2
	v20061222-1800:1.2
	v20061214-0000:1.2
	v20061120-1300:1.2
	M3_20:1.2
	v20061117-0800:1.2
	v20061013-1330:1.2
	v20061005-1700:1.2
	M1_20:1.2
	v20060904-1500:1.2
	v20060824-1600:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060626-1420:1.2
	v20060620-0400:1.2
	v20060616-1400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.4
date	2007.05.03.15.23.43;	author bblajer;	state dead;
branches;
next	1.3;
commitid	4f2e4639fe7e4567;

1.3
date	2007.05.03.14.45.19;	author bblajer;	state Exp;
branches;
next	1.2;
commitid	510b4639f57c4567;

1.2
date	2006.06.06.16.22.12;	author radvorak;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.31.15.54.57;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Reuse templates from full RT
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.lite.expressions" class="RegexpExpressionFactoryGenerator"
    imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenExpressionInterpreter genInterpreter = (GenExpressionInterpreter) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
final GenDiagram genDiagram = genInterpreter.getContainer().getEditorGen().getDiagram();
final String factoryClassName = genInterpreter.getClassName();
final String abstractExpressionClass = genInterpreter.getContainer().getAbstractExpressionQualifiedClassName();
final boolean isNegationRegexp = !GenLanguage.REGEXP_LITERAL.equals(genInterpreter.getLanguage());
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%importManager.markImportLocation(stringBuffer);
importManager.registerInnerClass("Expression");

importManager.addImport("java.util.Collections");
importManager.addImport("java.util.Map");
importManager.addImport("java.util.regex.Matcher");
importManager.addImport("java.util.regex.Pattern");
importManager.addImport("java.util.regex.PatternSyntaxException");
importManager.addImport("org.eclipse.core.runtime.IStatus");
importManager.addImport("org.eclipse.emf.ecore.EClassifier");
importManager.addImport("org.eclipse.emf.ecore.EDataType");
importManager.addImport("org.eclipse.emf.ecore.util.EcoreUtil");
%>

/**
 * @@generated 
 */
public class <%=factoryClassName%> {
	/**
	 * @@generated 
	 */
	private <%=factoryClassName%>() {
	}

	/**
	 * @@generated 
	 */
	public static <%=importManager.getImportedName(abstractExpressionClass)%> getExpression(String body,
			EClassifier context, Map environment) {
		return new Expression(body, context, environment);
	}

	/**
	 * @@generated 
	 */
	public static <%=importManager.getImportedName(abstractExpressionClass)%> getExpression(String body,
			EClassifier context) {
		return getExpression(body, context, Collections.EMPTY_MAP);
	}

	/**
	 * @@generated 
	 */
	private static class Expression extends <%=importManager.getImportedName(abstractExpressionClass)%> {
		/**
		 * @@generated 
		 */
		private final Pattern pattern;

		/**
		 * @@generated 
		 */
		public Expression(String body, EClassifier context, Map environment) {
			super(body, context);
			Pattern p;
			try {
				p = Pattern.compile(body);
			} catch (PatternSyntaxException e) {
				setStatus(IStatus.ERROR, e.getMessage(), e);
				p = null;
			}
			this.pattern = p;
		}

		/**
		 * @@generated 
		 */
		protected Object doEvaluate(Object contextInstance, Map env) {
			if (pattern == null) {
				return null;
			}
			
			if(context() instanceof EDataType) {
				contextInstance = EcoreUtil.convertToString((EDataType)context(), contextInstance);
			}
			
			Matcher matcher = this.pattern.matcher(String.valueOf(contextInstance));
			return Boolean.valueOf(<%=isNegationRegexp ? "!" : ""%>matcher.matches());
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.3
log
@eliminate compilation problems in tests
@
text
@@


1.2
log
@#145042 Introduce expression Language enumeration into gmfmap, gfmgen models  instead of plain text attribute
@
text
@d61 1
a61 1
		private Pattern pattern;
d67 2
a68 1
			super(body, context, environment);
d70 1
a70 1
				this.pattern = Pattern.compile(body);
d73 1
d75 1
@


1.1
log
@[bblajer] #144412 Allow non-OCL-based FeatureSeqInitializers, constraints and selectors
@
text
@d9 1
a9 1
final boolean isNegationRegexp = !"regexp".equals(genInterpreter.getLanguage());
@

