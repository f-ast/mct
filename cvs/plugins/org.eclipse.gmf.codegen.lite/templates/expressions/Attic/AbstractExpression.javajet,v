head	1.6;
access;
symbols
	v20080910-1520:1.6
	v20070427-0600:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070405-1100:1.4
	v20070403-1500:1.4
	v20070330-1300:1.4
	v20060330-1300:1.4
	v20070322-1100:1.4
	v20060316-0600:1.4
	v20070307-0700:1.4
	v20070228-2000:1.4
	v20070221-1500:1.4
	v20070208-1800:1.4
	v20070103-0300:1.4
	M4_20:1.4
	v20061222-1800:1.4
	v20061214-0000:1.4
	v20061120-1300:1.4
	M3_20:1.4
	v20061117-0800:1.4
	v20061013-1330:1.3
	v20061005-1700:1.3
	M1_20:1.3
	v20060904-1500:1.3
	v20060824-1600:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060626-1420:1.3
	v20060620-0400:1.3
	v20060616-1400:1.3
	v20060616-1200:1.3
	v20060609-1400:1.2
	v20060531-1730:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2007.05.03.15.23.43;	author bblajer;	state dead;
branches;
next	1.5;
commitid	4f2e4639fe7e4567;

1.5
date	2007.05.03.14.45.19;	author bblajer;	state Exp;
branches;
next	1.4;
commitid	510b4639f57c4567;

1.4
date	2006.11.16.16.41.34;	author radvorak;	state Exp;
branches;
next	1.3;
commitid	617e455c94bd4567;

1.3
date	2006.06.13.12.53.40;	author radvorak;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.05.21.08.32;	author radvorak;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.31.15.54.57;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Reuse templates from full RT
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.lite.expressions" class="AbstractExpressionGenerator"
    imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
final GenExpressionProviderContainer providerContainer = genDiagram.getEditorGen().getExpressionProviders();
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%importManager.markImportLocation(stringBuffer);%>

<%
importManager.registerInnerClass("NoImplException");
importManager.addImport("java.math.BigDecimal");
importManager.addImport("java.math.BigInteger");
importManager.addImport("java.util.Collection");
importManager.addImport("java.util.Collections");
importManager.addImport("java.util.Iterator");
importManager.addImport("java.util.Map");
importManager.addImport("org.eclipse.core.runtime.IStatus");
importManager.addImport("org.eclipse.core.runtime.Status");
importManager.addImport("org.eclipse.emf.ecore.EObject");
importManager.addImport("org.eclipse.emf.ecore.EStructuralFeature");
importManager.addImport("org.eclipse.emf.ecore.ETypedElement");
importManager.addImport("org.eclipse.emf.ecore.EClassifier");
importManager.addImport("org.eclipse.emf.ecore.util.EcoreUtil");
importManager.addImport("org.eclipse.core.runtime.Platform");
%>

/**
 * @@generated
 */
public abstract class <%=providerContainer.getAbstractExpressionClassName()%> {		
	/**
	 * @@generated
	 */
	private static final boolean DISABLED_NO_IMPL_EXCEPTION_LOG = Boolean.valueOf(Platform.getDebugOption(<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getBundle().getSymbolicName() + "/debug/disableNoExprImplExceptionLog")).booleanValue();
	/**
	 * @@generated
	 */
	private final String body;
	/**
	 * @@generated
	 */
	private final EClassifier context;

	/**
	 * @@generated
	 */	
	private IStatus status = Status.OK_STATUS;	

	/**
	 * @@generated
	 */
	protected <%=providerContainer.getAbstractExpressionClassName()%>(EClassifier context) {
		this(null, context);
	}
	
	/**
	 * @@generated
	 */	
	protected <%=providerContainer.getAbstractExpressionClassName()%>(String body, EClassifier context) {
		this.body = body;
		this.context = context;
	}
	
	/**
	 * @@generated
	 */	
	protected void setStatus(int severity, String message, Throwable throwable) {		
		String pluginID = <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.ID;
		this.status = new Status(severity, pluginID, -1, (message != null) ? message : "", throwable); //$NON-NLS-1$
		if(!this.status.isOK()) {
			<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>
					.getInstance().logError("Expression problem:" + message + "body:"+ body, throwable); //$NON-NLS-1$ //$NON-NLS-2$
		
		}
	}
	
	/**
	 * @@generated
	 */	
	protected abstract Object doEvaluate(Object context, Map env);

	/**
	 * @@generated
	 */	
	public Object evaluate(Object context) {
		return evaluate(context, Collections.EMPTY_MAP);
	}
	
	/**
	 * @@generated
	 */	
	public Object evaluate(Object context, Map env) {
		if(context().isInstance(context)) {
			try {
				return doEvaluate(context, env);
			} catch(Exception e) {
				if(DISABLED_NO_IMPL_EXCEPTION_LOG && e instanceof NoImplException) {
					return null;
				}
				<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>
					.getInstance().logError("Expression evaluation failure: " + body, e);
			}
		}
		return null;
	}

	/**
	 * @@generated
	 */	
	public IStatus getStatus() {
		return status;
	}
	
	/**
	 * @@generated
	 */	
	public String body() {
		return body;
	}

	/**
	 * @@generated
	 */
	public EClassifier context() {
		return context;
	}
	
	/**
	 * @@generated
	 */	
	public void assignTo(EStructuralFeature feature, EObject target) {
		Object value = evaluate(target);
		value = (value != null) ? performCast(value, feature) : null;
		if (feature.isMany()) {
			Collection destCollection = (Collection) target.eGet(feature);
			destCollection.clear();
			if(value instanceof Collection) {
				Collection valueCollection = (Collection) value;
				for (Iterator it = valueCollection.iterator(); it.hasNext();) {
					destCollection.add(performCast(it.next(), feature));
				}
			} else {
				destCollection.add(value);
			}
			return;
		}
		target.eSet(feature, value);
	}
	
	/**
	 * @@generated
	 */	
	protected Object performCast(Object value, ETypedElement targetType) {
		if(targetType.getEType() == null || targetType.getEType().getInstanceClass() == null) {
			return value;
		}
		Class targetClass = targetType.getEType().getInstanceClass();	
		if(value != null && value instanceof Number) {
			Number num = (Number)value;
			Class valClass = value.getClass();			
			Class targetWrapperClass = targetClass;
			if(targetClass.isPrimitive()) {
				targetWrapperClass = EcoreUtil.wrapperClassFor(targetClass);
			}			
			if(valClass.equals(targetWrapperClass)) {
				return value;				
			}
			if(Number.class.isAssignableFrom(targetWrapperClass)) {
				if(targetWrapperClass.equals(Byte.class)) return new Byte(num.byteValue());
				if(targetWrapperClass.equals(Integer.class)) return new Integer(num.intValue());
				if(targetWrapperClass.equals(Short.class)) return new Short(num.shortValue());
				if(targetWrapperClass.equals(Long.class)) return new Long(num.longValue());					
				if(targetWrapperClass.equals(BigInteger.class)) return BigInteger.valueOf(num.longValue());
				if(targetWrapperClass.equals(Float.class)) return new Float(num.floatValue());
				if(targetWrapperClass.equals(Double.class)) return new Double(num.doubleValue());
				if(targetWrapperClass.equals(BigDecimal.class)) return new BigDecimal(num.doubleValue());
			}
		}
		return value;
	}	
	
	/**
	 * @@generated
	 */	
	public static final <%=providerContainer.getAbstractExpressionClassName()%> createNullExpression(EClassifier context) {
		return new <%=providerContainer.getAbstractExpressionClassName()%>(context) {
			protected Object doEvaluate(Object context, Map env) {
				// TODO - log entry about not provider available for this expression
				return null;
			}
		};
	}
	
	/**
	 * @@generated
	 */	
	public static class NoImplException extends RuntimeException {
		/**
		 * @@generated
		 */	
		public NoImplException(String message) {
			super(message);
		}
	}	
}
<%importManager.emitSortedImports();%>
@


1.5
log
@eliminate compilation problems in tests
@
text
@@


1.4
log
@[151719] ...ExpressionFactory templates should implement weakref caching of re-parseable expressions
@
text
@d42 1
a42 1
	private String body;
d46 2
a47 5
	private EClassifier context;
	/**
	 * @@generated
	 */
	private Map env;	
d57 1
a57 1
		this.context = context;
d63 1
a63 1
	protected <%=providerContainer.getAbstractExpressionClassName()%>(String body, EClassifier context, Map env) {
a65 1
		this.env = env;
a134 7
	public Map environment() {
		return env;
	}	

	/**
	 * @@generated
	 */
@


1.3
log
@#145753 Suppress exceptions logged from unimplemented methods of JavaAudits during tests execution
@
text
@d49 4
d69 1
d135 7
a221 1
    @


1.2
log
@#145337 Move element initializer's assignment of expressions to features into expression templates
@
text
@d14 1
d28 1
d38 4
d100 3
a104 1
				return null;
d196 12
@


1.1
log
@[bblajer] #144412 Allow non-OCL-based FeatureSeqInitializers, constraints and selectors
@
text
@d14 3
d18 1
d22 3
d26 1
d122 54
d190 1
@

