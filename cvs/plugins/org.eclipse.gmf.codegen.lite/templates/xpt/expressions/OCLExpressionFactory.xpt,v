head	1.3;
access;
symbols
	v20080910-1520:1.3
	v20080722-1827:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.2
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080507-1326:1.3
	v20080501-1739:1.1
	v20080425-1959:1.1
	v20080322-0000:1.1
	v20071108-0000:1.1
	v20071003-0000:1.1
	v20070921-0000:1.1.2.2
	R2_0_maintenance:1.1.0.2
	v20070903-0000:1.1;
locks; strict;
comment	@# @;


1.3
date	2008.05.07.13.55.39;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	388c4821b4d44567;

1.2
date	2008.05.05.11.22.38;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	2e57481eedfe4567;

1.1
date	2007.07.04.13.22.26;	author bblajer;	state Exp;
branches
	1.1.2.1;
next	;
commitid	405d468b9f0f4567;

1.1.2.1
date	2007.07.04.13.22.26;	author bblajer;	state dead;
branches;
next	1.1.2.2;
commitid	7b9846eea5004567;

1.1.2.2
date	2007.09.17.16.02.13;	author bblajer;	state Exp;
branches;
next	;
commitid	7b9846eea5004567;


desc
@@


1.3
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«EXTENSION xpt::GenModelUtils»

«DEFINE OCLExpressionFactory FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::copyright FOR container.editorGen»
package «container.expressionsPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «className» «EXPAND supertypes» {
	«EXPAND ctor-»

	«EXPAND getExpression-»

	«EXPAND additions-»

	«EXPAND ExpressionClass-»
}
«ENDDEFINE»

«DEFINE supertypes FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»

«DEFINE ctor FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private «className»() {
}
«ENDDEFINE»

«DEFINE getExpression FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
public static «container.getAbstractExpressionQualifiedClassName()» getExpression(String body, org.eclipse.emf.ecore.EClassifier context, java.util.Map environment) {
	return new «EXPAND ExpressionClassName»(body, context, environment);
}

«EXPAND xpt::Common::generatedMemberComment»
public static «container.getAbstractExpressionQualifiedClassName()» getExpression(String body, org.eclipse.emf.ecore.EClassifier context) {
	return getExpression(body, context, java.util.Collections.EMPTY_MAP);
}
«ENDDEFINE»

«DEFINE ExpressionClassName FOR gmfgen::GenExpressionInterpreter»Expression«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»
«DEFINE ExpressionClass FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedClassComment»
private static class «EXPAND ExpressionClassName» «EXPAND ExpressionClass_supertypes» {
	«EXPAND ExpressionClass_oclInstance-»

	«EXPAND ExpressionClass_ctor-»

	«EXPAND ExpressionClass_query-»

	«EXPAND ExpressionClass_doEvaluate-»

	«EXPAND ExpressionClass_initExtentMap-»

	«EXPAND ExpressionClass_initCustomEnv-»

	«EXPAND ExpressionClass_createVar-»

	«EXPAND ExpressionClass_additions-»
}
«ENDDEFINE»

«DEFINE ExpressionClass_supertypes FOR gmfgen::GenExpressionInterpreter»extends «container.getAbstractExpressionQualifiedClassName()»«ENDDEFINE»

«DEFINE ExpressionClass_oclInstance FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private final org.eclipse.ocl.ecore.OCL oclInstance;
«ENDDEFINE»

«DEFINE ExpressionClass_ctor FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
public «EXPAND ExpressionClassName»(String body, org.eclipse.emf.ecore.EClassifier context, java.util.Map environment) {
	super(body, context);
	oclInstance = org.eclipse.ocl.ecore.OCL.newInstance();
	initCustomEnv(oclInstance.getEnvironment(), environment);
}
«ENDDEFINE»

«DEFINE ExpressionClass_query FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private java.lang.ref.WeakReference queryRef;

«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.ocl.Query getQuery() {
	org.eclipse.ocl.Query oclQuery = null;
	if(this.queryRef != null) {
		oclQuery = (org.eclipse.ocl.Query)this.queryRef.get();
	}
	if(oclQuery == null) {
		org.eclipse.ocl.helper.OCLHelper oclHelper = oclInstance.createOCLHelper();
		oclHelper.setContext(context());
		try {
			org.eclipse.ocl.expressions.OCLExpression oclExpression = oclHelper.createQuery(body());
			oclQuery = oclInstance.createQuery(oclExpression);
			this.queryRef = new java.lang.ref.WeakReference(oclQuery);
			setStatus(org.eclipse.core.runtime.IStatus.OK, null, null);
		} catch (org.eclipse.ocl.ParserException e) {
			setStatus(org.eclipse.core.runtime.IStatus.ERROR, e.getMessage(), e);
		}
	}
	return oclQuery;
}
«ENDDEFINE»

«DEFINE ExpressionClass_doEvaluate FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
protected Object doEvaluate(Object context, java.util.Map env) {
	org.eclipse.ocl.Query oclQuery = getQuery();
	if (oclQuery == null) {
		return null;
	}
	org.eclipse.ocl.EvaluationEnvironment evalEnv = oclQuery.getEvaluationEnvironment();
	// init environment
	for (java.util.Iterator it = env.entrySet().iterator(); it.hasNext();) {
		java.util.Map.Entry nextEntry = (java.util.Map.Entry) it.next();
		evalEnv.replace((String)nextEntry.getKey(), nextEntry.getValue());
	}

	try {
		initExtentMap(context);
		Object result = oclQuery.evaluate(context);
		return (result != oclInstance.getEnvironment().getOCLStandardLibrary().getOclInvalid()) ? result : null;
	} finally {
		evalEnv.clear();
		oclQuery.getExtentMap().clear();
	}
}
«ENDDEFINE»

«DEFINE ExpressionClass_initExtentMap FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private void initExtentMap(Object context) {
	if (!getStatus().isOK() || context == null) {
		return;
	}
	final org.eclipse.ocl.Query queryToInit = getQuery();
	final Object extentContext = context;

	queryToInit.getExtentMap().clear();
	if (queryToInit.queryText() != null && queryToInit.queryText().indexOf(org.eclipse.ocl.utilities.PredefinedType.ALL_INSTANCES_NAME) >= 0) {
		org.eclipse.ocl.utilities.AbstractVisitor visitior = new org.eclipse.ocl.utilities.AbstractVisitor() {
			private boolean usesAllInstances  = false;

			public Object visitOperationCallExp(org.eclipse.ocl.expressions.OperationCallExp oc) {
				if(!usesAllInstances) {
					usesAllInstances = org.eclipse.ocl.utilities.PredefinedType.ALL_INSTANCES == oc.getOperationCode();
					if(usesAllInstances) {
						queryToInit.getExtentMap().putAll(oclInstance.getEvaluationEnvironment().createExtentMap(extentContext));
					}
				}
				return super.visitOperationCallExp(oc);
			}
		};
		queryToInit.getExpression().accept(visitior);
	}
}
«ENDDEFINE»

«DEFINE ExpressionClass_initCustomEnv FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private static void initCustomEnv(org.eclipse.ocl.Environment ecoreEnv, java.util.Map environment) {
	for (java.util.Iterator it = environment.keySet().iterator(); it.hasNext();) {
				String varName = (String)it.next();
		org.eclipse.emf.ecore.EClassifier varType = (org.eclipse.emf.ecore.EClassifier) environment.get(varName);
		ecoreEnv.addElement(varName, createVar(ecoreEnv, varName, varType), false);
	}
}
«ENDDEFINE»

«DEFINE ExpressionClass_createVar FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private static org.eclipse.ocl.expressions.Variable createVar(org.eclipse.ocl.Environment ecoreEnv, String name, org.eclipse.emf.ecore.EClassifier type) {
	org.eclipse.ocl.expressions.Variable var = org.eclipse.ocl.ecore.EcoreFactory.eINSTANCE.createVariable(); // or ecoreEnv.getOCLFactory().createVariable()?
	var.setName(name);
	var.setType(ecoreEnv.getUMLReflection().getOCLType(type));
	return var;
}
«ENDDEFINE»

«DEFINE ExpressionClass_additions FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»
@


1.2
log
@[226725] Refactor AbstractExpression to be used in Lite RT
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.1
log
@Eliminated Jet templates in lite version;
i18n in lite RT;
For generated classes whose names are not directly modifiable via gmfgen file, consistent className/qualifiedClassName template is exposed (and used throughout the generation process, including the Generator);
Link labels and external node labels are not selectable, but movable;
Inner elements are not selectable with marquee tool;
Fixed copyright statements throughout the lite RT.
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
a67 2
	«EXPAND ExpressionClass_performCast-»

a144 13
«DEFINE ExpressionClass_performCast FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
protected Object performCast(Object value, org.eclipse.emf.ecore.ETypedElement targetType) {
	if (targetType.getEType() instanceof org.eclipse.emf.ecore.EEnum) {
		if(value instanceof org.eclipse.emf.ecore.EEnumLiteral) {
			org.eclipse.emf.ecore.EEnumLiteral literal = (org.eclipse.emf.ecore.EEnumLiteral)value;
			return (literal.getInstance() != null) ? literal.getInstance() : literal;
		}
	}
	return super.performCast(value, targetType);
}
«ENDDEFINE»

@


1.1.2.1
log
@file OCLExpressionFactory.xpt was added on branch R2_0_maintenance on 2007-09-17 16:02:13 +0000
@
text
@d1 210
@


1.1.2.2
log
@Eliminated Jet templates in lite version;
i18n in lite RT;
For generated classes whose names are not directly modifiable via gmfgen file, consistent className/qualifiedClassName template is exposed (and used throughout the generation process, including the Generator)
@
text
@a0 210
/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«EXTENSION xpt::GenModelUtils»

«DEFINE OCLExpressionFactory FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::copyright FOR container.editorGen»
package «container.expressionsPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «className» «EXPAND supertypes» {
	«EXPAND ctor-»

	«EXPAND getExpression-»

	«EXPAND additions-»

	«EXPAND ExpressionClass-»
}
«ENDDEFINE»

«DEFINE supertypes FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»

«DEFINE ctor FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private «className»() {
}
«ENDDEFINE»

«DEFINE getExpression FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
public static «container.getAbstractExpressionQualifiedClassName()» getExpression(String body, org.eclipse.emf.ecore.EClassifier context, java.util.Map environment) {
	return new «EXPAND ExpressionClassName»(body, context, environment);
}

«EXPAND xpt::Common::generatedMemberComment»
public static «container.getAbstractExpressionQualifiedClassName()» getExpression(String body, org.eclipse.emf.ecore.EClassifier context) {
	return getExpression(body, context, java.util.Collections.EMPTY_MAP);
}
«ENDDEFINE»

«DEFINE ExpressionClassName FOR gmfgen::GenExpressionInterpreter»Expression«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»
«DEFINE ExpressionClass FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedClassComment»
private static class «EXPAND ExpressionClassName» «EXPAND ExpressionClass_supertypes» {
	«EXPAND ExpressionClass_oclInstance-»

	«EXPAND ExpressionClass_ctor-»

	«EXPAND ExpressionClass_query-»

	«EXPAND ExpressionClass_doEvaluate-»

	«EXPAND ExpressionClass_performCast-»

	«EXPAND ExpressionClass_initExtentMap-»

	«EXPAND ExpressionClass_initCustomEnv-»

	«EXPAND ExpressionClass_createVar-»

	«EXPAND ExpressionClass_additions-»
}
«ENDDEFINE»

«DEFINE ExpressionClass_supertypes FOR gmfgen::GenExpressionInterpreter»extends «container.getAbstractExpressionQualifiedClassName()»«ENDDEFINE»

«DEFINE ExpressionClass_oclInstance FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private final org.eclipse.ocl.ecore.OCL oclInstance;
«ENDDEFINE»

«DEFINE ExpressionClass_ctor FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
public «EXPAND ExpressionClassName»(String body, org.eclipse.emf.ecore.EClassifier context, java.util.Map environment) {
	super(body, context);
	oclInstance = org.eclipse.ocl.ecore.OCL.newInstance();
	initCustomEnv(oclInstance.getEnvironment(), environment);
}
«ENDDEFINE»

«DEFINE ExpressionClass_query FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private java.lang.ref.WeakReference queryRef;

«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.ocl.Query getQuery() {
	org.eclipse.ocl.Query oclQuery = null;
	if(this.queryRef != null) {
		oclQuery = (org.eclipse.ocl.Query)this.queryRef.get();
	}
	if(oclQuery == null) {
		org.eclipse.ocl.helper.OCLHelper oclHelper = oclInstance.createOCLHelper();
		oclHelper.setContext(context());
		try {
			org.eclipse.ocl.expressions.OCLExpression oclExpression = oclHelper.createQuery(body());
			oclQuery = oclInstance.createQuery(oclExpression);
			this.queryRef = new java.lang.ref.WeakReference(oclQuery);
			setStatus(org.eclipse.core.runtime.IStatus.OK, null, null);
		} catch (org.eclipse.ocl.ParserException e) {
			setStatus(org.eclipse.core.runtime.IStatus.ERROR, e.getMessage(), e);
		}
	}
	return oclQuery;
}
«ENDDEFINE»

«DEFINE ExpressionClass_doEvaluate FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
protected Object doEvaluate(Object context, java.util.Map env) {
	org.eclipse.ocl.Query oclQuery = getQuery();
	if (oclQuery == null) {
		return null;
	}
	org.eclipse.ocl.EvaluationEnvironment evalEnv = oclQuery.getEvaluationEnvironment();
	// init environment
	for (java.util.Iterator it = env.entrySet().iterator(); it.hasNext();) {
		java.util.Map.Entry nextEntry = (java.util.Map.Entry) it.next();
		evalEnv.replace((String)nextEntry.getKey(), nextEntry.getValue());
	}

	try {
		initExtentMap(context);
		Object result = oclQuery.evaluate(context);
		return (result != oclInstance.getEnvironment().getOCLStandardLibrary().getOclInvalid()) ? result : null;
	} finally {
		evalEnv.clear();
		oclQuery.getExtentMap().clear();
	}
}
«ENDDEFINE»

«DEFINE ExpressionClass_performCast FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
protected Object performCast(Object value, org.eclipse.emf.ecore.ETypedElement targetType) {
	if (targetType.getEType() instanceof org.eclipse.emf.ecore.EEnum) {
		if(value instanceof org.eclipse.emf.ecore.EEnumLiteral) {
			org.eclipse.emf.ecore.EEnumLiteral literal = (org.eclipse.emf.ecore.EEnumLiteral)value;
			return (literal.getInstance() != null) ? literal.getInstance() : literal;
		}
	}
	return super.performCast(value, targetType);
}
«ENDDEFINE»

«DEFINE ExpressionClass_initExtentMap FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private void initExtentMap(Object context) {
	if (!getStatus().isOK() || context == null) {
		return;
	}
	final org.eclipse.ocl.Query queryToInit = getQuery();
	final Object extentContext = context;

	queryToInit.getExtentMap().clear();
	if (queryToInit.queryText() != null && queryToInit.queryText().indexOf(org.eclipse.ocl.utilities.PredefinedType.ALL_INSTANCES_NAME) >= 0) {
		org.eclipse.ocl.utilities.AbstractVisitor visitior = new org.eclipse.ocl.utilities.AbstractVisitor() {
			private boolean usesAllInstances  = false;

			public Object visitOperationCallExp(org.eclipse.ocl.expressions.OperationCallExp oc) {
				if(!usesAllInstances) {
					usesAllInstances = org.eclipse.ocl.utilities.PredefinedType.ALL_INSTANCES == oc.getOperationCode();
					if(usesAllInstances) {
						queryToInit.getExtentMap().putAll(oclInstance.getEvaluationEnvironment().createExtentMap(extentContext));
					}
				}
				return super.visitOperationCallExp(oc);
			}
		};
		queryToInit.getExpression().accept(visitior);
	}
}
«ENDDEFINE»

«DEFINE ExpressionClass_initCustomEnv FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private static void initCustomEnv(org.eclipse.ocl.Environment ecoreEnv, java.util.Map environment) {
	for (java.util.Iterator it = environment.keySet().iterator(); it.hasNext();) {
				String varName = (String)it.next();
		org.eclipse.emf.ecore.EClassifier varType = (org.eclipse.emf.ecore.EClassifier) environment.get(varName);
		ecoreEnv.addElement(varName, createVar(ecoreEnv, varName, varType), false);
	}
}
«ENDDEFINE»

«DEFINE ExpressionClass_createVar FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private static org.eclipse.ocl.expressions.Variable createVar(org.eclipse.ocl.Environment ecoreEnv, String name, org.eclipse.emf.ecore.EClassifier type) {
	org.eclipse.ocl.expressions.Variable var = org.eclipse.ocl.ecore.EcoreFactory.eINSTANCE.createVariable(); // or ecoreEnv.getOCLFactory().createVariable()?
	var.setName(name);
	var.setType(ecoreEnv.getUMLReflection().getOCLType(type));
	return var;
}
«ENDDEFINE»

«DEFINE ExpressionClass_additions FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»
@


