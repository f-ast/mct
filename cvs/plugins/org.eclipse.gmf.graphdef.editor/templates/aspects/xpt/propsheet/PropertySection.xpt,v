head	1.13;
access;
symbols
	v20080722-1827:1.13
	v20080718-1700:1.13
	v20080718-1731:1.13
	v20080716-1642:1.13
	R2_1_maintenance:1.13.0.2
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080610-1132:1.13
	v20080603-1553:1.13
	v20080528-1052:1.13
	v20080521:1.13
	v20080516-1143:1.13
	v20080512-1200:1.12
	v20080510-0100:1.12
	v20080507-1326:1.12
	v20080501-1739:1.12
	v20080425-1959:1.12
	v20080114-2222:1.8
	v20071214-1111:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	v20070621-0000:1.8
	RC3_20:1.7
	v20070605-1400:1.7
	v20070601-1400:1.7
	v20070520-1200:1.6
	v20070420-1000:1.5
	v20070405-2000:1.5
	v20070405-1100:1.4
	v20070330-1300:1.2
	v20070307-0700:1.2
	v20070221-1500:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.13
date	2008.05.14.11.16.58;	author ashatalin;	state Exp;
branches;
next	1.12;
commitid	377e482aca274567;

1.12
date	2008.04.21.14.42.09;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	6f82480ca7c04567;

1.11
date	2008.04.17.16.55.08;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	784e480780eb4567;

1.10
date	2008.04.11.12.46.37;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	174247ff5dac4567;

1.9
date	2008.03.07.11.35.54;	author ashatalin;	state dead;
branches;
next	1.8;
commitid	5ab247d128944567;

1.8
date	2007.06.18.17.06.15;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	54d14676bb824567;

1.7
date	2007.05.31.15.52.32;	author ashatalin;	state Exp;
branches;
next	1.6;
commitid	49f1465eef2c4567;

1.6
date	2007.05.18.21.38.09;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	2f76464e1cbf4567;

1.5
date	2007.04.05.19.55.25;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	7f1461554204567;

1.4
date	2007.04.05.10.54.08;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	54d24614d54e4567;

1.3
date	2007.04.04.20.23.27;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	ade461409204567;

1.2
date	2007.03.02.15.39.20;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	717a45e845234567;

1.1
date	2007.02.09.20.08.32;	author atikhomirov;	state Exp;
branches;
next	;
commitid	179c45ccd4b34567;


desc
@@


1.13
log
@- Migrating to new .gmfgen model
- Using (0,0) as a minimum size for DefaultNode to make resize feedback minimum size == (0,0)
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Anna Karjakina (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - cleaned and simplified outcome 
 */
«IMPORT "http://www.eclipse.org/gmf/2008/GmfGraph/PropSheet"»
«IMPORT "http://www.eclipse.org/gmf/2006/GraphicalDefinition"»
«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«EXTENSION xpt::EMFUtils»
«EXTENSION xpt::GenModelUtils»
«EXTENSION aspects::xpt::propsheet::Utils»

«AROUND extendsList FOR gmfgen::GenCustomPropertyTab»«IF isProxyTab()»«getProxyTabSuperClassName()»«ELSE»«targetDef.proceed()»«ENDIF»«ENDAROUND»

«AROUND implementsClause FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»

«AROUND getPropertySourceMethod FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»
«AROUND createReadonlyControlsMethod FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»
«AROUND getPropertySourceProviderMethod FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»
«AROUND transfromSelectionMethod FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»
«AROUND setInputMethod FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»
«AROUND getAdapterFactoryMethod FOR gmfgen::GenCustomPropertyTab»«IF !isProxyTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»

«AROUND additions FOR gmfgen::GenCustomPropertyTab-»
«IF isProxyTab()-»

	«EXPAND commit-»

	«EXPAND unwrap-»
	
	«EXPAND filterClass-»
«ENDIF-»
«ENDAROUND»

«DEFINE commit FOR gmfgen::GenCustomPropertyTab-»
	«EXPAND xpt::Common::generatedMemberComment»
	protected void commit() {
		final java.util.List<org.eclipse.core.resources.IFile> files = java.util.Collections.singletonList(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(getInput().eResource()));
		org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand cmd = new org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand(org.eclipse.emf.transaction.util.TransactionUtil.getEditingDomain(getInput()), "", files) {
			@@Override
			protected org.eclipse.gmf.runtime.common.core.command.CommandResult doExecuteWithResult(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
				«className».super.commit();
				return org.eclipse.gmf.runtime.common.core.command.CommandResult.newOKCommandResult();
			}
		};
		try {
			org.eclipse.core.commands.operations.OperationHistoryFactory.getOperationHistory().execute(cmd, new org.eclipse.core.runtime.NullProgressMonitor(), null);
		} catch (org.eclipse.core.commands.ExecutionException ex) {
			ex.printStackTrace();
		}
	}
«ENDDEFINE»

«DEFINE unwrap FOR gmfgen::GenCustomPropertyTab-»
	«EXPAND xpt::Common::generatedMemberComment»
	protected Object unwrap(Object element) {
		Object rv = org.eclipse.gmf.graphdef.editor.part.PropertySectionFilters.transformSelection(element);
		if («EXPAND checkInstanceOfDomainElement("rv")») {
			return rv;
		}
		return null;
	}
«ENDDEFINE»

«DEFINE filterClass FOR gmfgen::GenCustomPropertyTab-»
	«EXPAND xpt::Common::generatedClassComment»
	public static class «EXPAND filterClassName» implements org.eclipse.jface.viewers.IFilter {

		«EXPAND FC_select-»
	
	}
«ENDDEFINE»

«DEFINE filterClassName FOR gmfgen::GenCustomPropertyTab»Filter«ENDDEFINE»

«DEFINE FC_select FOR gmfgen::GenCustomPropertyTab-»
	«EXPAND xpt::Common::generatedMemberComment»
	public boolean select(Object toTest) {
		Object transformed = org.eclipse.gmf.graphdef.editor.part.PropertySectionFilters.transformSelection(toTest);
		return «EXPAND checkInstanceOfDomainElement("transformed")»;
	}
«ENDDEFINE»

«DEFINE checkInstanceOfDomainElement(String varName) FOR gmfgen::GenCustomPropertyTab-»
«EXPAND MetaModel::IsInstance(varName) FOREACH getCustomPropertySection(this).nodes.collect(n|n.modelFacet.metaClass).toSet().typeSelect(genmodel::GenClass) SEPARATOR " || "»«ENDDEFINE»@


1.12
log
@Migrating to dynamic model usage.
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d15 1
a15 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.11
log
@Generating commit/unwrap methods + Filters for formTK-based properties sections.
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2007/GmfGraph/PropSheet"»
@


1.10
log
@Registering generated property tabs as GenCustomPropertyTabs
@
text
@d33 63
@


1.9
log
@Migrating to new templates from .codegen plugin.
@
text
@d23 1
a23 2
«AROUND extendsList FOR gmfgen::GenCustomPropertyTab»«IF isGeneratedTab()»org.eclipse.gmf.graphdef.editor.sheet.AbstractCustomSectionParent
«ELSE»«targetDef.proceed()»«ENDIF»«ENDAROUND»
d25 1
a25 1
«AROUND implementsClause FOR gmfgen::GenCustomPropertyTab»«IF !isGeneratedTab()»«targetDef.proceed()»«ENDIF»«ENDAROUND»
d27 6
a32 1074
«AROUND transfromSelectionMethod FOR gmfgen::GenCustomPropertyTab»
«IF isPointTab()-»
	«EXPAND xpt::Common::generatedMemberComment("Modify/unwrap selection.")»
	protected Object transformSelection(Object selected) {
		«EXPAND xpt::propsheet::PropertySection::transfromSelectionMethodBodyDefault-»
		return selected;
	}
«ELSEIF !isGeneratedTab()»«targetDef.proceed()»«ENDIF-»
«ENDAROUND»

«AROUND getPropertySourceMethod FOR gmfgen::GenCustomPropertyTab-»
«IF isPointTab()»
	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.ui.views.properties.IPropertySource getPropertySource(Object object) {
		«EXPAND createTemplatePointSources»
	}
«ELSEIF !isGeneratedTab()»
«targetDef.proceed()»
«ENDIF-»
«ENDAROUND»

«AROUND getPropertySourceProviderMethod FOR gmfgen::GenCustomPropertyTab»
«IF !isGeneratedTab()»«targetDef.proceed()»«ENDIF-»
«ENDAROUND»

«AROUND getAdapterFactoryMethod FOR gmfgen::GenCustomPropertyTab»
«IF isPointTab() || !isGeneratedTab()»«targetDef.proceed()»«ENDIF-»
«ENDAROUND»

«DEFINE createTemplatePointSources FOR gmfgen::GenCustomPropertyTab-»
if (object instanceof org.eclipse.gmf.gmfgraph.Polyline) {
	org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource compositeSource = new org.eclipse.gmf.runtime.common.ui.services.properties.descriptors.CompositePropertySource(object);

	int counter = 1;
	for (java.util.Iterator it = ((org.eclipse.gmf.gmfgraph.Polyline) object).getTemplate().iterator(); it.hasNext(); counter++) {
		org.eclipse.gmf.gmfgraph.Point nextPoint = (org.eclipse.gmf.gmfgraph.Point) it.next();
		final String titleX = "Point " + counter + " X";
		org.eclipse.emf.edit.provider.IItemPropertyDescriptor nextPointPropertyDescriptorX = new org.eclipse.emf.edit.provider.ItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), titleX, titleX, org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getPoint_X(), true, "Template");
		compositeSource.addPropertySource(new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(nextPoint, new SingleDescriptorPropertySource(nextPointPropertyDescriptorX), "EMF") {
			protected org.eclipse.ui.views.properties.IPropertyDescriptor newPropertyDescriptor(org.eclipse.emf.edit.provider.IItemPropertyDescriptor itemPropertyDescriptor) {
				return new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor(object, itemPropertyDescriptor, getCategory()) {
					public Object getId() {
						return titleX;
					}
				};
			}
		});

		final String titleY = "Point " + counter + " Y";
		org.eclipse.emf.edit.provider.IItemPropertyDescriptor nextPointPropertyDescriptorY = new org.eclipse.emf.edit.provider.ItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), titleY, titleY, org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getPoint_Y(), true, "Template");
		compositeSource.addPropertySource(new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(nextPoint, new SingleDescriptorPropertySource(nextPointPropertyDescriptorY), "EMF") {
			protected org.eclipse.ui.views.properties.IPropertyDescriptor newPropertyDescriptor(org.eclipse.emf.edit.provider.IItemPropertyDescriptor itemPropertyDescriptor) {
				return new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor(object, itemPropertyDescriptor, getCategory()) {
					public Object getId() {
						return titleY;
					}
				};
			}
		});
	}
	
	return compositeSource;
}
return null;
«ENDDEFINE»

«AROUND additions FOR gmfgen::GenCustomPropertyTab-»
	«IF isPointTab()»
		«EXPAND SingleDescriptorPropertySourceClass-»
	«ELSEIF isGeneratedTab()»
	«ELSE»
		«EXPAND createPropertySource»
	«ENDIF»
	«EXPAND modelExtensionExample-»
«ENDAROUND»

«DEFINE createPropertySource FOR gmfgen::GenCustomPropertyTab-»
«EXPAND xpt::Common::generatedMemberComment»
    protected org.eclipse.ui.views.properties.IPropertySource createPropertySource(Object object, org.eclipse.emf.edit.provider.IItemPropertySource itemPropertySource) {
        return new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(object, itemPropertySource, "EMF");
    }
«ENDDEFINE»

«DEFINE SingleDescriptorPropertySourceClass FOR gmfgen::GenCustomPropertyTab»
«EXPAND xpt::Common::generatedMemberComment»
private static class SingleDescriptorPropertySource implements org.eclipse.emf.edit.provider.IItemPropertySource {

	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.emf.edit.provider.IItemPropertyDescriptor myPropertyDescriptor;
	
	«EXPAND xpt::Common::generatedMemberComment»
	private java.util.List myDescriptors = new java.util.LinkedList();

	«EXPAND xpt::Common::generatedMemberComment»
	SingleDescriptorPropertySource(org.eclipse.emf.edit.provider.IItemPropertyDescriptor propertyDescriptor) {
		myPropertyDescriptor = propertyDescriptor;
		myDescriptors.add(myPropertyDescriptor);
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
	public java.util.List getPropertyDescriptors(Object object) {
		return myDescriptors;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.edit.provider.IItemPropertyDescriptor getPropertyDescriptor(Object object, Object propertyID) {
		return myPropertyDescriptor;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public Object getEditableValue(Object object) {
		return object;
	}
}
«ENDDEFINE»

«AROUND setInputMethod FOR gmfgen::GenCustomPropertyTab»
«IF !isGeneratedTab()»«targetDef.proceed()»«ENDIF-»
«ENDAROUND»

«REM»
///////////////////////////////// Model Customization Example /////////////////////////////////
«ENDREM»

«DEFINE modelExtensionExample FOR gmfgen::GenCustomPropertyTab-»
	«EXPAND processModelExtensionExample FOREACH getReferencingObjects(this).typeSelect(propsheet::CustomPropertySection)»
«ENDDEFINE»

«DEFINE processModelExtensionExample FOR propsheet::CustomPropertySection-»
	«EXPAND xpt::Common::generatedMemberComment»
	private ModelHelper myModelHelper;
	
	«EXPAND initVars FOREACH contents-»

	«EXPAND xpt::Common::generatedMemberComment»
	public void doCreateControls(org.eclipse.swt.widgets.Composite parent, org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage tabbedPropertySheetPage) {
		org.eclipse.swt.widgets.Composite mainComposite = createMainWidget(parent);
		«EXPAND createControls("mainComposite") FOREACH contents-»
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public void doDispose() {
		«EXPAND disposeControl FOREACH contents-»
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public void refresh() {
		getListener().startNonUserChange();
		for (java.util.Iterator it = getSavedSelection().iterator(); it.hasNext();) {
			Object next = it.next();
			if (next instanceof «getTarget().getQualifiedInterfaceName()») {
				final «getTarget().getQualifiedInterfaceName()» target = («getTarget().getQualifiedInterfaceName()»)next;
				executeAsReadAction(new Runnable() {

					public void run() {
						updateFromModel(target);
					}
				});
			}
		}
		getListener().finishNonUserChange();
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
	public void updateFromModel(«getTarget().getQualifiedInterfaceName()» target) {
		boolean needToRelayoutExpandBar = false;
		«EXPAND updateFromModel("target") FOREACH contents-»
		if (needToRelayoutExpandBar) {
			relayoutExpandBar(null);
		}
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
	public ModelUpdater createModelUpdater() {
		return new ModelUpdater() {

			public void applyChangesFrom(org.eclipse.swt.widgets.Widget widget) {
				«genTab.className».this.applyChangesFrom(widget);
			}
		};
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public void applyChangesFrom(final org.eclipse.swt.widgets.Widget widget) {
		final String commandName = "Modifying model with ui data from "+widget.toString();
		java.util.ArrayList commands = new java.util.ArrayList(getSavedSelection().size());
		for (java.util.Iterator it = getSavedSelection().iterator(); it.hasNext();) {
			Object next = it.next();
			if (next instanceof «getTarget().getQualifiedInterfaceName()») {
				final «getTarget().getQualifiedInterfaceName()» target = («getTarget().getQualifiedInterfaceName()»)next;
				final java.util.List files = java.util.Collections.singletonList(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(target.eResource()));
				org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand command = new org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand(getEditingDomain(), commandName, files) {

		            protected org.eclipse.gmf.runtime.common.core.command.CommandResult doExecuteWithResult(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
		            	// XXX perhaps, should pass collection of targets instead of multiple commands?
		            	applyModelModifier(target, widget);
		            	return org.eclipse.gmf.runtime.common.core.command.CommandResult.newOKCommandResult();
					}
				};

				commands.add(command);
			}
		}
		executeAsCompositeCommand(commandName, commands);
		//refresh();
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
	void applyModelModifier(final «getTarget().getQualifiedInterfaceName()» target, final org.eclipse.swt.widgets.Widget widget) {
		«EXPAND applyModelChangesHelper("target", "widget") FOREACH contents-»
	}


	«EXPAND xpt::Common::generatedMemberComment»
	protected ModelHelper getModelHelper() {
		if (myModelHelper == null) {
			myModelHelper = new ModelHelper();
		}
		return myModelHelper;
	}
	
	«EXPAND modelHelperInnerClass»
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Radio-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.Button «name()»;
«IF null != iconPath»«EXPAND initImage»«ENDIF»
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Checkbox-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.Button «name()»;
«IF null != iconPath»«EXPAND initImage»«ENDIF»
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Spin-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.Spinner «name()»;
«ENDDEFINE»

«DEFINE initVars FOR propsheet::TextField-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.Text «name()»;
«ENDDEFINE»

«DEFINE initVars FOR propsheet::TextArea-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.Text «name()»;
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Date-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.DateTime «name()»;
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Time-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.widgets.DateTime «name()»;
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Combo-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.custom.CCombo «name()»;
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Label-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.custom.CLabel «name()»;
«IF null != iconPath»«EXPAND initImage»«ENDIF»
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Group-»
«EXPAND xpt::Common::generatedMemberComment»
private «IF createLabel()»«IF isExpandable()»org.eclipse.ui.forms.widgets.ExpandableComposite«ELSE»org.eclipse.swt.widgets.Group«ENDIF»«ELSE»org.eclipse.swt.widgets.Composite«ENDIF» «name()»;
«EXPAND initVars FOREACH contents-»
«ENDDEFINE»

«DEFINE initVars FOR propsheet::Sectionable-»
«ERROR "Unsupported Graphical Control"»
«ENDDEFINE»

«DEFINE initImage FOR propsheet::Sectionable-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.graphics.Image «name()»_image;
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Group-»
«IF createLabel()-»
	«IF isExpandable()-»
«name()» = createExpandableComposite(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
org.eclipse.swt.widgets.Composite «name()»Control = createCompositeWidget(«name()», "", «EXPAND layoutArgs»);
	«ELSE-»
«name()» = createGroupWidget(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
	«ENDIF»
«ELSE-»
«name()» = createCompositeWidget(«parentVar», "", «EXPAND layoutArgs»);
«ENDIF»
«IF createLabel() && isExpandable()-»
	«EXPAND createControls(name()+"Control") FOREACH contents-»
	«name()».setClient(«name()»Control);
	«name()».addExpansionListener(getExpansionListener(«parentVar»));
«ELSE-»
	«EXPAND createControls(name()) FOREACH contents-»
«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Radio-»
«name()» = createRadioButton(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != iconPath»«EXPAND createImage(iconPath)»«ENDIF»
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Checkbox-»
«name()» = createCheckboxButton(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != iconPath»«EXPAND createImage(iconPath)»«ENDIF»
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Spin-»
«name()» = createSpinnerWidget(«parentVar», «EXPAND createLabel», «min», «max», «inc», 100, «EXPAND layoutArgs»);
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::TextField-»
«name()» = createTextWidget(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::TextArea-»
«name()» = createExtendedTextWidget(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Date-»
«name()» = createDateWidget(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Time-»
«name()» = createTimeWidget(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != modelElement»«EXPAND installListener»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Combo-»
«name()» = createComboBox(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != getModelElement()»«EXPAND installListener»«ENDIF-»
«EXPAND addComboItems(name())-»
«ENDDEFINE»

«DEFINE addComboItems(String comboboxInstanceVar) FOR propsheet::Combo-»
«ERROR "Unknown type of Combo box values for "+comboboxInstanceVar»
«ENDDEFINE»

«DEFINE addComboItems(String comboboxInstanceVar) FOR propsheet::StringCombo-»
«FOREACH values AS value»«comboboxInstanceVar».add("«value»");
«ENDFOREACH»
«ENDDEFINE»

«DEFINE addComboItems(String comboboxInstanceVar) FOR propsheet::IntCombo-»
«FOREACH values AS value»«comboboxInstanceVar».add("«value»");
«ENDFOREACH»
«ENDDEFINE»

«DEFINE addComboItems(String comboboxInstanceVar) FOR propsheet::BooleanCombo-»
«comboboxInstanceVar».add(String.valueOf(true));
«comboboxInstanceVar».add(String.valueOf(false));

«ENDDEFINE»

«DEFINE addComboItems(String comboboxInstanceVar) FOR propsheet::CustomCombo-»
«FOREACH values AS value»
«comboboxInstanceVar».add(«IF null != modelElement»getModelHelper().extractComboValueFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«value»)«ELSE»"«value»"«ENDIF»);
«ENDFOREACH»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Label-»
«name()» = createLabelWidget(«parentVar», «EXPAND createLabel», «EXPAND layoutArgs»);
«IF null != iconPath»«EXPAND createImage(iconPath)»«ENDIF»
«ENDDEFINE»

«DEFINE createControls(String parentVar) FOR propsheet::Sectionable-»
«ERROR "Cannot create Abstract Graphical Control"»
«ENDDEFINE»

«DEFINE createLabel FOR propsheet::Labeled-»
«IF createLabel()»«IF null != text && null != text.overridedItemProviderText && "" != text.overridedItemProviderText»"«text.overridedItemProviderText»"«ELSE»«EXPAND callStringsAccessor»«ENDIF»«ELSE»""«ENDIF»«ENDDEFINE»

«DEFINE createImage(String iconPath) FOR propsheet::Sectionable-»
«name()»_image = «getCustomPropertySection().genTab.sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("«iconPath»").createImage();
«name()».setImage(«name()»_image);
«ENDDEFINE»

«DEFINE installListener FOR propsheet::Sectionable-»
getListener().startListeningTo(«name()»);
«ENDDEFINE»

«DEFINE layoutArgs FOR Sectionable-»
«IF null != layoutConstraints-»
«EXPAND processLeftAndTopLayoutConstraints FOR layoutConstraints-»
«ELSE-»
null, null, null, null, true, true, false, false
«ENDIF-»
«ENDDEFINE»

«DEFINE processLeftAndTopLayoutConstraints FOR propsheet::LayoutConstraints-»
«ERROR "Abstract definition"»
«ENDDEFINE»

«DEFINE processLeftAndTopLayoutConstraints FOR propsheet::FormLayoutConstraints-»
«IF null != anchorControl-»
	«IF Positions::LEFT.value == relativePosition.value-»
«anchorControl.name()», null, null, null, true, false, «lowermost», «rightmost»
	«ELSEIF Positions::RIGHT.value == relativePosition.value-»
null, null, «anchorControl.name()», null, false, false, «lowermost», «rightmost»
	«ELSEIF Positions::TOP.value == relativePosition.value-»
null, «anchorControl.name()», null, null, false, true, «lowermost», «rightmost»
	«ELSEIF Positions::BOTTOM.value == relativePosition.value-»
null, null, null, «anchorControl.name()», false, false, «lowermost», «rightmost»
	«ENDIF-»
«ELSE-»
null, null, null, null, true, true, «lowermost», «rightmost»
«ENDIF-»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Group-»
«EXPAND disposeControl FOREACH contents-»
«IF createLabel() && isExpandable()-»
«name()».removeExpansionListener(getExpansionListener(null));«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Radio-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«IF null != iconPath-»«EXPAND disposeImage»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Checkbox-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«IF null != iconPath-»«EXPAND disposeImage»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Spin-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::TextField-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::TextArea-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Date-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Time-»
«IF null != modelElement»«EXPAND deinstallListener»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Combo-»
«IF null != getModelElement()»«EXPAND deinstallListener»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Label-»
«IF null != iconPath-»«EXPAND disposeImage»«ENDIF»
«ENDDEFINE»

«DEFINE disposeControl FOR propsheet::Sectionable-»
«ERROR "Cannot dispose Abstract Graphical Control"»
«ENDDEFINE»

«DEFINE disposeImage FOR propsheet::Sectionable-»
«name()»_image.dispose();
«name()»_image = null;
«ENDDEFINE»

«DEFINE deinstallListener FOR propsheet::Sectionable-»
getListener().stopListeningTo(«name()»);
«ENDDEFINE»

«DEFINE applyModelChangesHelper(String modelVar, String widgetVar) FOR propsheet::Sectionable-»
«IF null != getModelElement()-»
if («widgetVar» == «name()» && «name()».isVisible()) {
	«EXPAND applyChanges(modelVar, widgetVar)-»
	return;
}
«ENDIF-»
«ENDDEFINE»

«DEFINE applyModelChangesHelper(String modelVar, String widgetVar) FOR propsheet::Group-»
«EXPAND applyModelChangesHelper(modelVar, widgetVar) FOREACH contents-»«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Sectionable-»
«ERROR "Cannot make appliance of changes for Abstract control"»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Group-»
«EXPAND applyChanges(modelVar, widgetVar) FOREACH contents-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Label-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Radio-»
if («name()».getSelection()) {
	«EXPAND callSetterForModelProperty(modelVar, "true")»;
}
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Checkbox-»
«LET name() + ".getSelection()" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Spin-»
«LET name() + ".getSelection()" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::TextField-»
«LET name() + ".getText()" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::TextArea-»
«LET name() + ".getText()" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Date-»
«LET "getModelHelper().produce"+modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()+"ForDate(" + name() + ".getYear(), " + name() + ".getMonth(), " + name() + ".getDay())" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::Time-»
«LET "getModelHelper().produce"+modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()+"ForTime(" + name() + ".getHours(), " + name() + ".getMinutes(), " + name() + ".getSeconds())" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::StringCombo-»
«LET name() + ".getText()" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::IntCombo-»
«LET "Integer.parseInt(" + name() + ".getText())" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::BooleanCombo-»
«LET "Boolean.getBoolean(" + name() + ".getText())" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE applyChanges(String modelVar, String widgetVar) FOR propsheet::CustomCombo-»
«LET "getModelHelper().produce"+modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()+"ForCombo(" + name() + ".getText())" AS value-»
«EXPAND callSetterForModelProperty(modelVar, value)»;
«ENDLET-»
«ENDDEFINE»

«DEFINE callSetterForModelProperty(String targetVar, String valueVar) FOR propsheet::Sectionable»getModelHelper().setValueFor«name().toFirstUpper()»(«targetVar», «valueVar»)«ENDDEFINE»

«DEFINE callGetterForModelProperty(String targetVar) FOR propsheet::Sectionable»getModelHelper().getValueFor«name().toFirstUpper()»(«targetVar»)«ENDDEFINE»

«DEFINE callVisibilityTester(String targetVar) FOR propsheet::Group»getModelHelper().isVisible«name().toFirstUpper()»(«targetVar»)«ENDDEFINE»

«DEFINE callStringsAccessor FOR propsheet::Labeled»getModelHelper().getName«name().toFirstUpper()»FromMetamodel()«ENDDEFINE»

«DEFINE updateFromModel(String targetVar) FOR propsheet::Sectionable-»
	«EXPAND updateUIValue(targetVar)-»
«ENDDEFINE»

«DEFINE updateFromModel(String targetVar) FOR propsheet::Group»
«IF isVisibleOnlyForTargets()-»
boolean is«name().toFirstUpper()»Visible = «EXPAND callVisibilityTester(targetVar)»;
«IF expandable-»
if («name()».isExpanded() != is«name().toFirstUpper()»Visible) {
	needToRelayoutExpandBar = true;
}
«ENDIF»
«name()».«IF expandable»setExpanded«ELSE»setVisible«ENDIF»(is«name().toFirstUpper()»Visible);
if (is«name().toFirstUpper()»Visible)«ENDIF» {
	«EXPAND updateUIValue(targetVar)-»
}«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Group-»
«EXPAND updateFromModel(targetVar) FOREACH contents-»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Radio-»
«IF null != modelElement-»
«name()».setSelection(«EXPAND callGetterForModelProperty(targetVar)»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Checkbox-»
«IF null != modelElement-»
«name()».setSelection(«EXPAND callGetterForModelProperty(targetVar)»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Spin-»
«IF null != modelElement-»
«name()».setSelection(«EXPAND callGetterForModelProperty(targetVar)»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::TextField-»
«IF null != modelElement-»
«name()».setText(«EXPAND callGetterForModelProperty(targetVar)»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::TextArea-»
«IF null != modelElement-»
«name()».setText(«EXPAND callGetterForModelProperty(targetVar)»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Date-»
«IF null != modelElement-»
«name()».setYear(getModelHelper().extractYearFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));
«name()».setMonth(getModelHelper().extractMonthFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));
«name()».setDay(getModelHelper().extractDayFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Time-»
«IF null != modelElement-»
«name()».setHours(getModelHelper().extractHoursFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));
«name()».setMinutes(getModelHelper().extractMinutesFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));
«name()».setSeconds(getModelHelper().extractSecondsFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::StringCombo-»
«IF null != modelElement-»
«name()».setText(«EXPAND callGetterForModelProperty(targetVar)»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::IntCombo-»
«IF null != modelElement-»
«name()».setText(String.valueOf(«EXPAND callGetterForModelProperty(targetVar)»));«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::BooleanCombo-»
«IF null != modelElement-»
«name()».setText(String.valueOf(«EXPAND callGetterForModelProperty(targetVar)»));«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::CustomCombo-»
«IF null != modelElement-»
«name()».setText(getModelHelper().extractComboValueFrom«modelElement.feature.getFeatureTargetType().getUnqualifiedTypeName()»(«EXPAND callGetterForModelProperty(targetVar)»));«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Label-»
«IF createLabel()-»
«name()».setText(«EXPAND createLabel»);«ENDIF»
«ENDDEFINE»

«DEFINE updateUIValue(String targetVar) FOR propsheet::Sectionable»
«ERROR "Cannot update Abstract UI Definition"»
«ENDDEFINE»

«DEFINE modelHelperInnerClass FOR propsheet::CustomPropertySection-»
«EXPAND xpt::Common::generatedMemberComment»
public final class ModelHelper {
«EXPAND createAccessors-»
«EXPAND dataAdaptationAdditions-»
«EXPAND modelHelperAdditions-»
}
«ENDDEFINE»

«DEFINE modelHelperAdditions FOR propsheet::CustomPropertySection-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.emf.ecore.EObject cloneVars(org.eclipse.emf.ecore.EObject target) {
	return target;
}
«ENDDEFINE»

«DEFINE dataAdaptationAdditions FOR propsheet::CustomPropertySection»
«EXPAND dateDataAdaptationAdditions FOREACH getUniqueQualifiedTargetTypeNamesUsed(collectAllDates(this, {}))»
«EXPAND timeDataAdaptationAdditions FOREACH getUniqueQualifiedTargetTypeNamesUsed(collectAllTimes(this, {}))»
«EXPAND comboDataAdaptationAdditions FOREACH getUniqueQualifiedTargetTypeNamesUsed(collectAllCustomCombos(this, {}))»
«ENDDEFINE»

«DEFINE comboDataAdaptationAdditions FOR String»
public «this» produce«split("\\.").last()»ForCombo(String value) {
	«this» result = null;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public String extractComboValueFrom«split("\\.").last()»(«this» value) {
	String result = "---";
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}
«ENDDEFINE»

«DEFINE timeDataAdaptationAdditions FOR String»
«EXPAND xpt::Common::generatedMemberComment»
public «this» produce«split("\\.").last()»ForTime(int hours, int minutes, int seconds) {
	«this» result = null;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public int extractHoursFrom«split("\\.").last()»(«this» value) {
	int result = 0;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public int extractMinutesFrom«split("\\.").last()»(«this» value) {
	int result = 0;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public int extractSecondsFrom«split("\\.").last()»(«this» value) {
	int result = 0;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}
«ENDDEFINE»

«DEFINE dateDataAdaptationAdditions FOR String»
«EXPAND xpt::Common::generatedMemberComment»
public «this» produce«split("\\.").last()»ForDate(int year, int month, int day) {
	«this» result = null;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public int extractYearFrom«split("\\.").last()»(«this» value) {
	int result = 0;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public int extractMonthFrom«split("\\.").last()»(«this» value) {
	int result = 0;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}

«EXPAND xpt::Common::generatedMemberComment»
public int extractDayFrom«split("\\.").last()»(«this» value) {
	int result = 0;
	// TODO: Auto-generated method stub. Please, mark as @@generated NOT and implement yourself!
	return result;
}
«ENDDEFINE»

«DEFINE createAccessors FOR propsheet::Group-»
«IF isVisibleOnlyForTargets()»«EXPAND createVisibilityTesters»«ENDIF-»
«EXPAND createMetamodelNameGetter(this) FOR getModelElement()-»
«EXPAND createAccessors FOREACH contents-»
«ENDDEFINE»

«DEFINE createAccessors FOR propsheet::Sectionable-»
«EXPAND createGetterForModelProperty(this) FOR getModelElement()-»
«EXPAND createSetterForModelProperty(this) FOR getModelElement()-»
«ENDDEFINE»

«DEFINE createAccessors FOR propsheet::Labeled-»
«EXPAND createGetterForModelProperty(this) FOR getModelElement()-»
«EXPAND createSetterForModelProperty(this) FOR getModelElement()-»
«EXPAND createMetamodelNameGetter(this) FOR getModelElement()-»
«ENDDEFINE»

«DEFINE createVisibilityTesters FOR propsheet::Group-»
«EXPAND xpt::Common::generatedMemberComment»
public boolean isVisible«name().toFirstUpper()»(«getCustomPropertySection().getTarget().getQualifiedInterfaceName()» targetVar) {
	boolean value = false;
	«EXPAND isVisibleModelElement("targetVar", "value")-»
	return value;
}
«ENDDEFINE»

«DEFINE createMetamodelNameGetter(propsheet::Labeled sectionable) FOR propsheet::FeatureReference-»
«IF createLabel(sectionable) && (null == sectionable.text || null == sectionable.text.overridedItemProviderText || "" == sectionable.text.overridedItemProviderText)»
«EXPAND xpt::Common::generatedMemberComment»
public String getName«sectionable.name().toFirstUpper()»FromMetamodel() {
	return "«EXPAND createNameFromMetamodelElement(sectionable)»";
}
«ENDIF»
«ENDDEFINE»

«DEFINE createNameFromMetamodelElement(propsheet::Sectionable sectionable) FOR propsheet::FeatureReference-»
«getFormattedName(feature)»«ENDDEFINE»

«DEFINE createNameFromMetamodelElement(propsheet::Sectionable sectionable) FOR propsheet::IsFeatureIsOfKindReference-»
«getEnumLiteralFriendlyName(isOfValue)»«ENDDEFINE»

«DEFINE createNameFromMetamodelElement(propsheet::Sectionable sectionable) FOR propsheet::IsFeatureOfTypeReference-»
«getFormattedName(isOfType)»«ENDDEFINE»

«DEFINE createNameFromMetamodelElement(propsheet::Sectionable sectionable) FOR propsheet::ModelMediatorFeature-»
«IF null != cast»«getFormattedName(cast)»«ELSEIF null != feature»«getFormattedName(feature)»«ENDIF»«ENDDEFINE»

«DEFINE createGetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::FeatureReference-»
«ERROR "Unexpected getter model reference kind"»
«ENDDEFINE»

«DEFINE createSetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::FeatureReference-»
«ERROR "Unexpected setter model reference kind"»
«ENDDEFINE»

«DEFINE createGetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::CustomFeatureValue-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public «feature.getFeatureTargetType()» getValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar») {
	«feature.getFeatureTargetType()» value;
	«EXPAND extractModelElement(targetVar, "value") FOR sectionable-»
	return value;
}
«ENDLET»
«ENDDEFINE»

«DEFINE createSetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::CustomFeatureValue-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public void setValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar», «feature.getFeatureTargetType()» value) {
	«EXPAND intractModelElement(targetVar, "value") FOR sectionable-»
}
«ENDLET»
«ENDDEFINE»

«DEFINE createGetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::BooleanCondition-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public boolean getValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar») {
	boolean value = false;
	«EXPAND extractModelElement(targetVar, "value") FOR sectionable-»
	return value;
}
«ENDLET»
«ENDDEFINE»

«DEFINE createSetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::BooleanCondition-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public void setValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar», boolean value) {
	«EXPAND intractModelElement(targetVar, "value") FOR sectionable-»
}
«ENDLET»
«ENDDEFINE»

«DEFINE createGetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::IntValue-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public int getValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar») {
	int value = 0;
	«EXPAND extractModelElement(targetVar, "value") FOR sectionable-»
	return value;
}
«ENDLET»
«ENDDEFINE»

«DEFINE createSetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::IntValue-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public void setValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar», int value) {
	«EXPAND intractModelElement(targetVar, "value") FOR sectionable-»
}
«ENDLET»
«ENDDEFINE»

«DEFINE createGetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::StringValue-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public String getValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar») {
	String value = EMPTY_STRING;
	«EXPAND extractModelElement(targetVar, "value") FOR sectionable-»
	if (value != null) {
		return value;
	}
	return EMPTY_STRING;
}
«ENDLET»
«ENDDEFINE»

«DEFINE createSetterForModelProperty(propsheet::Sectionable sectionable) FOR propsheet::StringValue-»
«LET sectionable.getCustomPropertySection().getTarget().getName().toFirstLower() AS targetVar-»
«EXPAND xpt::Common::generatedMemberComment»
public void setValueFor«sectionable.name().toFirstUpper()»(«sectionable.getCustomPropertySection().getTarget().getQualifiedInterfaceName()» «targetVar», String value) {
	«EXPAND intractModelElement(targetVar, "value") FOR sectionable-»
}
«ENDLET»
«ENDDEFINE»

«DEFINE	isVisibleModelElement(String varName, String valueVarName) FOR propsheet::Group-»
«EXPAND isVisibleModelVar(varName, valueVarName, this) FOR collectAllParentGroups().select(e| e.modelMediator != null)-»
«ENDDEFINE»

«DEFINE isVisibleModelVar(String varName, String valueVarName, propsheet::Sectionable sectionable) FOR List[propsheet::Group]-»
«LET sectionable.getModelElement() AS valueElement-»
«IF size() == 1 && null == valueElement»
	«EXPAND makeModelCall(varName, valueVarName) FOR ((propsheet::Group)get(0)).modelMediator-»
«ELSEIF size() > 0-»
	«LET ((propsheet::Group)get(0)).modelMediator AS modelElement-»
	if («EXPAND instanceofOrNullCheck(varName) FOR modelElement») {
		«EXPAND castedVarDeclaration(varName, modelElement.expectedTypeVar()) FOR modelElement-»
		«EXPAND isVisibleModelVar(modelElement.expectedTypeVar(), valueVarName, sectionable) FOR (List[propsheet::Group])withoutFirst()-»
	}
	«ENDLET»
«ELSE-»
	«EXPAND makeModelCall(varName, valueVarName) FOR valueElement-»
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE	extractModelElement(String varName, String valueVarName) FOR propsheet::Sectionable-»
«EXPAND extractModelVar(varName, valueVarName, this) FOR collectAllParentGroups().select(e| e.modelMediator != null)-»
«ENDDEFINE»

«DEFINE extractModelVar(String varName, String valueVarName, propsheet::Sectionable sectionable) FOR List[propsheet::Group]-»
«IF size() > 0-»
	«LET ((propsheet::Group)get(0)).modelMediator AS modelElement-»
	«IF size() == 1 && isNullCheck(sectionable.getModelElement())»«ELSE-»
	if («EXPAND instanceofOrNullCheck(varName) FOR modelElement») {	«ENDIF»
		«EXPAND castedVarDeclaration(varName, modelElement.expectedTypeVar()) FOR modelElement-»
		«EXPAND extractModelVar(modelElement.expectedTypeVar(), valueVarName, sectionable) FOR (List[propsheet::Group])withoutFirst()-»
	«IF size() == 1 && isNullCheck(sectionable.getModelElement())»«ELSE-»
	}«ENDIF»
	«ENDLET»
«ELSE-»
	«LET sectionable.getModelElement() AS valueElement-»
	«IF null != valueElement-»
		«EXPAND makeModelCall(varName, valueVarName) FOR valueElement-»
	«ELSE-»
		«ERROR "Cannot make a model call for abstract Sectionable item"»
	«ENDIF»
	«ENDLET»
«ENDIF»
«ENDDEFINE»

«DEFINE castedVarDeclaration(String varName, String newVarName) FOR propsheet::ModelMediatorFeature-»
«expectedTypeName()» «newVarName» = «castedVarCall(varName)»«addFeatureCall()»;
«ENDDEFINE»

«DEFINE castedVarModification(String elementName, String newVarName) FOR propsheet::ModelMediatorFeature-»
«IF null != feature-»
«elementName».«feature.getSetterAccessor()»((«expectedTypeName()»)cloneVars(«newVarName»))»);«ENDIF»
«ENDDEFINE»

«DEFINE instanceofOrNullCheck(String varName) FOR propsheet::ModelMediatorFeature-»
«varName»«addFeatureCall()» «IF null != cast»instanceof «cast.getQualifiedInterfaceName()»«ELSEIF feature != null»!= null«ELSE»== null«ENDIF»
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::FeatureReference-»
«ERROR "Cannot make a model call for this type of FeatureReference"»
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::CustomFeatureValue-»
«valueVarName» = «varName».«feature.getGetAccessor()»();
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::ModelMediatorFeature-»
«valueVarName» = («varName»«addFeatureCall()» «IF null != cast»instanceof «cast.getQualifiedInterfaceName()»«ELSE»!= null«ENDIF»);
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::IntValue-»
«valueVarName» = «varName».«feature.getGetAccessor()»();
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::StringValue-»
«valueVarName» = «varName».«feature.getGetAccessor()»();
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::BooleanCondition-»
«valueVarName» = «IF null != feature»«varName».«feature.getGetAccessor()»()«ELSE»«varName»«ENDIF»;
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::IsFeatureOfTypeReference-»
«valueVarName» = («varName»«addFeatureCall()» «IF null != isOfType» instanceof «isOfType.getQualifiedInterfaceName()»«ELSE» == null«ENDIF»);
«ENDDEFINE»

«DEFINE makeModelCall(String varName, String valueVarName) FOR propsheet::IsFeatureIsOfKindReference-»
«valueVarName» = («varName»«addFeatureCall()» «IF null != isOfValue» == «getQualifiedInterfaceName(isOfValue.genEnum)».«isOfValue.ecoreEnumLiteral.name»«ELSE»«ERROR "Found no type definition for model element reference of "+varName»«ENDIF»);
«ENDDEFINE»

«DEFINE	intractModelElement(String elementName, String valueName) FOR propsheet::Sectionable-»
«EXPAND intractModelVar(elementName, valueName, this) FOR collectAllParentGroups().select(e| e.modelMediator != null)-»
«ENDDEFINE»

«DEFINE intractModelVar(String elementName, String valueName, propsheet::Sectionable sectionable) FOR List[propsheet::Group]-»
«IF size() > 1-»
	«LET (propsheet::Group)first() AS element»
	«LET element.modelMediator AS modelElement-»
	if («EXPAND instanceofOrNullCheck(elementName) FOR modelElement») {
		«EXPAND castedVarDeclaration(elementName, modelElement.expectedTypeVar()) FOR modelElement-»
		«EXPAND intractModelVar(modelElement.expectedTypeVar(), valueName, sectionable) FOR (List[propsheet::Group])withoutFirst()-»
	}
	«ENDLET»
	«ENDLET»
«ELSE-»
	«IF null != sectionable.getModelElement()-»
		«EXPAND prepareModelCall(elementName, valueName, (propsheet::Group)get(0)) FOR sectionable.getModelElement()-»
	«ELSE-»
		«ERROR "Cannot make a model call for abstract Sectionable item"»
	«ENDIF»
«ENDIF»
«ENDDEFINE»

«DEFINE prepareModelCall(String elementName, String valueName, propsheet::Group parent) FOR propsheet::FeatureReference»
«LET parent.getModelMediator() AS modelElement-»
	«IF null != modelElement.feature-»
		if («elementName».«modelElement.feature.getGetAccessor()»() == null) {
			«elementName».«modelElement.feature.getSetterAccessor()»(«modelElement.expectedType().getQualifiedClassifierCreaterName()»);
		}
	«ENDIF-»
	«IF parent != parent.getCustomPropertySection()-»
	if («EXPAND instanceofOrNullCheck(elementName) FOR modelElement») {
		«EXPAND castedVarDeclaration(elementName, modelElement.expectedTypeVar()) FOR modelElement-»
		«EXPAND saveModelCall(modelElement.expectedTypeVar(), valueName, modelElement)-»
		«EXPAND castedVarModification(elementName, modelElement.expectedTypeVar()) FOR modelElement-»
	}«ELSE-»
	«EXPAND saveModelCall(elementName, valueName, modelElement)-»
	«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE prepareModelCall(String elementName, String valueName, propsheet::Group parent) FOR propsheet::IsFeatureIsOfKindReference-»
«EXPAND saveModelCall(elementName, valueName, parent.getModelMediator())-»
«ENDDEFINE»

«DEFINE prepareModelCall(String elementName, String valueName, propsheet::Group parent) FOR propsheet::IsFeatureOfTypeReference-»
«EXPAND saveModelCall(elementName, valueName, parent.getModelMediator())-»
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::FeatureReference-»
«ERROR "Cannot make a model call for this type of FeatureReference"»
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::CustomFeatureValue-»
«elementName».«feature.getSetterAccessor()»(«valueName»);
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::IntValue-»
«elementName».«feature.getSetterAccessor()»(«valueName»);
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::StringValue-»
«elementName».«feature.getSetterAccessor()»(«valueName»);
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::BooleanCondition-»
«elementName».«feature.getSetterAccessor()»(«valueName»);
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::IsFeatureOfTypeReference-»
«IF null != isOfType-»
	«elementName».«parentModelElement.feature.getSetterAccessor()»(«isOfType.getQualifiedClassifierCreaterName()»);
«ELSE-»
	«elementName».«parentModelElement.feature.getSetterAccessor()»(null);
«ENDIF-»
«ENDDEFINE»

«DEFINE saveModelCall(String elementName, String valueName, propsheet::ModelMediatorFeature parentModelElement) FOR propsheet::IsFeatureIsOfKindReference-»
«elementName».«parentModelElement.feature.getSetterAccessor()»(«isOfValue.genEnum.getQualifiedInterfaceName()».«getEnumLiteralInstanceConstantName(isOfValue)»);
«ENDDEFINE»
@


1.8
log
@[191661] akarjakina - Improve GMFGraph Editor's propsheet model/codegen with TextArea, Combo and Date/Time support
@
text
@@


1.7
log
@[190196] akarjakina - Adjust GMFGraph Editor according recent gmfgraph metamodel with support for FigureDescriptor introduced
@
text
@d204 2
a205 2
			public void applyChangesFrom(org.eclipse.swt.widgets.Widget widget, int kind) {
				«genTab.className».this.applyChangesFrom(widget, kind);
d211 1
a211 1
	public void applyChangesFrom(final org.eclipse.swt.widgets.Widget widget, final int kindP) {
a212 1
		final int kind = kindP; // just to overcome jmerge limitation
d223 1
a223 1
		            	applyModelModifier(target, widget, kind);
d236 1
a236 1
	void applyModelModifier(final «getTarget().getQualifiedInterfaceName()» target, final org.eclipse.swt.widgets.Widget widget, int kind) {
d274 20
d357 47
d449 1
a449 1
null, null, null, null, false, false, «lowermost», «rightmost»
d477 16
d557 42
d648 39
d700 1
d712 81
d848 20
d994 4
d1075 4
@


1.6
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d14 1
a14 1
«IMPORT "http://www.eclipse.org/gmf/2005/GraphicalDefinition"»
@


1.5
log
@kiss; cleaner and bit more simple
@
text
@d15 1
a15 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.4
log
@cleanup
@
text
@d11 1
d181 1
d203 1
d211 3
a213 2
	public void applyChangesFrom(final org.eclipse.swt.widgets.Widget widget, int kind) {
		String commandName = "Modifying model with ui data from "+widget.toString();
d219 11
a229 1
				commands.add(createCommand(commandName, target, getModelModifierFor(target, widget, kind)));
d237 2
a238 8
	public Runnable getModelModifierFor(final «getTarget().getQualifiedInterfaceName()» target, final org.eclipse.swt.widgets.Widget widget, int kind) {
		«EXPAND wrapModelHelperWithRunnable("target", "widget") FOREACH contents-»
		// default:
		return new Runnable() {
			public void run() {
				// does nothing
			}
		};
d428 1
a428 1
«DEFINE wrapModelHelperWithRunnable(String modelVar, String widgetVar) FOR propsheet::Sectionable-»
d431 2
a432 5
	return new Runnable() {
		public void run() {
			«EXPAND applyChanges(modelVar, widgetVar)-»
		}
	};
d434 1
a434 1
«ENDIF»
d437 2
a438 2
«DEFINE wrapModelHelperWithRunnable(String modelVar, String widgetVar) FOR propsheet::Group-»
«EXPAND wrapModelHelperWithRunnable(modelVar, widgetVar) FOREACH contents-»«ENDDEFINE»
d452 2
a453 3
final boolean value = «name()».getSelection();
if (value) {
	«EXPAND callSetterForModelProperty(modelVar, "value")»;
d458 3
a460 2
final boolean value = «name()».getSelection();
«EXPAND callSetterForModelProperty(modelVar, "value")»;
d464 3
a466 2
final int value = «name()».getSelection();
«EXPAND callSetterForModelProperty(modelVar, "value")»;
d470 3
a472 2
final String value = «name()».getText();
«EXPAND callSetterForModelProperty(modelVar, "value")»;
a483 1
{
d485 1
a485 1
}«ENDDEFINE»
d521 1
a521 5
String modelText = «EXPAND callGetterForModelProperty(targetVar)»;
if (modelText == null) {
	modelText = EMPTY_STRING;
}
«name()».setText(modelText);«ENDIF»
d526 1
a526 5
String modelText = «EXPAND createLabel»;
if (modelText == null) {
	modelText = EMPTY_STRING;
}
«name()».setText(modelText);«ENDIF»
d649 4
a652 1
	return value;
d777 2
a778 2
«LET parent.getModelMediator() AS modelElement»
	«IF null != modelElement.feature»
d782 1
a782 1
	«ENDIF»
d790 2
a791 2
	«ENDIF»
«ENDLET»
d794 1
a794 1
«DEFINE prepareModelCall(String elementName, String valueName, propsheet::Group parent) FOR propsheet::IsFeatureIsOfKindReference»
d798 1
a798 1
«DEFINE prepareModelCall(String elementName, String valueName, propsheet::Group parent) FOR propsheet::IsFeatureOfTypeReference»
d820 1
a820 2
	«isOfType.getQualifiedInterfaceName()» newInstance = «isOfType.getQualifiedClassifierCreaterName()»;
	«elementName».«parentModelElement.feature.getSetterAccessor()»(newInstance);
d823 1
a823 1
«ENDIF»
@


1.3
log
@[173499] akarjakina - Enhance graphdef.editor with properties - use custom model to describe property sheet and generate PropertyTab code from that model
@
text
@d275 1
a275 1
private «IF createLabel(text)»«IF isExpandable()»org.eclipse.ui.forms.widgets.ExpandableComposite«ELSE»org.eclipse.swt.widgets.Group«ENDIF»«ELSE»org.eclipse.swt.widgets.Composite«ENDIF» «name()»;
d289 1
a289 1
«IF createLabel(text)-»
d299 1
a299 1
«IF createLabel(text) && isExpandable()-»
d340 1
a340 1
«IF createLabel(text)»«IF null != text && null != text.overridedItemProviderText && "" != text.overridedItemProviderText»"«text.overridedItemProviderText»"«ELSE»«EXPAND callStringsAccessor»«ENDIF»«ELSE»""«ENDIF»«ENDDEFINE»
d381 1
a381 1
«IF createLabel(text) && isExpandable()-»
d523 1
a523 1
«IF createLabel(text)-»
d577 1
a577 1
«IF createLabel(sectionable.text) && (null == sectionable.text || null == sectionable.text.overridedItemProviderText || "" == sectionable.text.overridedItemProviderText)»
@


1.2
log
@[176026] akarjakina - Fix notation background and foreground colors update
[173499] akarjakina - Add custom form-based property sections fro figure attributes
@
text
@d12 2
d15 1
d18 2
d22 2
a23 1
«AROUND extendsList FOR gmfgen::GenCustomPropertyTab»«IF isCustomTab()»org.eclipse.gmf.graphdef.editor.sheet.AbstractCustomPropertySection«ELSE»«targetDef.proceed()»«ENDIF»«ENDAROUND»
d25 1
a25 1
«AROUND implementsClause FOR gmfgen::GenCustomPropertyTab»«IF isCustomTab()»«ELSE»«targetDef.proceed()»«ENDIF»«ENDAROUND»
d28 1
a28 1
«IF isLayoutTab() || isViewTab() || isPointTab() || isCustomTab()»
d31 1
a31 28
«IF isViewTab() -»
		if (selected instanceof org.eclipse.gef.EditPart) {
			return ((org.eclipse.gef.EditPart) selected).getModel();
		}
		if (selected instanceof org.eclipse.gmf.runtime.notation.View || selected instanceof org.eclipse.gmf.runtime.notation.Style) {
			return selected;
		}
		if (selected instanceof org.eclipse.core.runtime.IAdaptable) {
			org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) ((org.eclipse.core.runtime.IAdaptable) selected).getAdapter(org.eclipse.gmf.runtime.notation.View.class);
			if (view != null) {
				return view;
			}
		}
«ELSE-»
		if (selected instanceof org.eclipse.gef.EditPart) {
			Object model = ((org.eclipse.gef.EditPart) selected).getModel();
			return model instanceof org.eclipse.gmf.runtime.notation.View ? ((org.eclipse.gmf.runtime.notation.View) model).getElement() : null;
		}
		if (selected instanceof org.eclipse.gmf.runtime.notation.View) {
			return ((org.eclipse.gmf.runtime.notation.View) selected).getElement();
		}
		if (selected instanceof org.eclipse.core.runtime.IAdaptable) {
			org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) ((org.eclipse.core.runtime.IAdaptable) selected).getAdapter(org.eclipse.gmf.runtime.notation.View.class);
			if (view != null) {
				return view.getElement();
			}
		}
«ENDIF-»
d34 1
a34 3
«ELSE-»
«targetDef.proceed()»
«ENDIF-»
d38 1
a38 1
«IF isLayoutTab() || isViewTab() || isPointTab()»
a40 3
		«IF isLayoutTab()-»
		«EXPAND createLayoutSources»
		«ELSEIF isPointTab()-»
a41 16
		«ELSE-»
		if (object instanceof org.eclipse.ui.views.properties.IPropertySource) {
			return (org.eclipse.ui.views.properties.IPropertySource) object;
		}
		org.eclipse.emf.common.notify.AdapterFactory af = getAdapterFactory(object);
		if (af != null) {
			org.eclipse.emf.edit.provider.IItemPropertySource ips = (org.eclipse.emf.edit.provider.IItemPropertySource) af.adapt(object, org.eclipse.emf.edit.provider.IItemPropertySource.class);
			if (ips != null) {
				return createPropertySource(object, ips);
			}
		}
		if (object instanceof org.eclipse.core.runtime.IAdaptable) {
			return (org.eclipse.ui.views.properties.IPropertySource) ((org.eclipse.core.runtime.IAdaptable) object).getAdapter(org.eclipse.ui.views.properties.IPropertySource.class);
		}
		return null;
		«ENDIF-»
d43 1
a43 2
«ELSEIF isCustomTab()»
«ELSE-»
d49 1
a49 4
«IF isCustomTab()»
«ELSE-»
«targetDef.proceed()»
«ENDIF-»
d53 1
a53 16
«IF isLayoutTab() || isViewTab() || isPointTab()»
	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.emf.common.notify.AdapterFactory getAdapterFactory(Object object) {
		if (getEditingDomain() instanceof org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain) {
			return ((org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain) getEditingDomain()).getAdapterFactory();
		}
		org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain = org.eclipse.emf.transaction.util.TransactionUtil.getEditingDomain(object);
		if (editingDomain != null) {
			return ((org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain) editingDomain).getAdapterFactory();
		}
		return null;
	}
«ELSEIF isCustomTab()»
«ELSE-»
«targetDef.proceed()»
«ENDIF-»
a55 15
«DEFINE createLayoutSources FOR gmfgen::GenCustomPropertyTab-»
if (object instanceof org.eclipse.gmf.gmfgraph.Layoutable) {
	org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource compositeSource = new org.eclipse.gmf.runtime.common.ui.services.properties.descriptors.CompositePropertySource(object);
		
	org.eclipse.emf.edit.provider.IItemPropertyDescriptor layoutPropertyDescriptor = new LayoutItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), "Layout Manager", "Layout Manager", org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getLayoutable_Layout(), true, new org.eclipse.emf.ecore.EObject[] {org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createBorderLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createCustomLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createFlowLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createGridLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createStackLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createXYLayout()});
	compositeSource.addPropertySource(new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(object, new SingleDescriptorPropertySource(layoutPropertyDescriptor), "EMF")); //$NON-NLS-1$

	org.eclipse.emf.edit.provider.IItemPropertyDescriptor layoutDataPropertyDescriptor = new LayoutItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), "Layout Data", "Layout Data", org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getLayoutable_LayoutData(), true, new org.eclipse.emf.ecore.EObject[] {org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createBorderLayoutData(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createCustomLayoutData(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createGridLayoutData(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createXYLayoutData()});
	compositeSource.addPropertySource(new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(object, new SingleDescriptorPropertySource(layoutDataPropertyDescriptor), "EMF")); //$NON-NLS-1$
	
	return compositeSource;
}
return null;
«ENDDEFINE»

d94 1
a94 1
	«IF isLayoutTab() || isPointTab()»
d96 1
a96 5
		«IF isLayoutTab()»
			«EXPAND LayoutItemPropertyDescriptorClass-»
		«ENDIF»
	«ELSEIF isCustomTab()»
	    «EXPAND getImageRegistry-»
d100 1
a102 1

a105 3
«IF isViewTab()-»
        return new org.eclipse.gmf.runtime.diagram.ui.properties.descriptors.NotationPropertySource(object, itemPropertySource, "View");
«ELSE-»
a106 1
«ENDIF-»    
d143 23
a165 3
«DEFINE LayoutItemPropertyDescriptorClass FOR gmfgen::GenCustomPropertyTab»
«EXPAND xpt::Common::generatedMemberComment»
public static class LayoutItemPropertyDescriptor extends org.eclipse.emf.edit.provider.ItemPropertyDescriptor {
d168 3
a170 1
	private org.eclipse.emf.ecore.EObject[] myValues;
d173 23
a195 3
	LayoutItemPropertyDescriptor(org.eclipse.emf.common.notify.AdapterFactory adapterFactory, String displayName, String description, org.eclipse.emf.ecore.EStructuralFeature feature, boolean isSettable, org.eclipse.emf.ecore.EObject[] valueInstances) {
		super(adapterFactory, displayName, description, feature, isSettable);
		myValues = valueInstances;
d199 4
a202 12
	protected java.util.Collection getComboBoxObjects(Object object) {
		if (object instanceof org.eclipse.emf.ecore.EObject) {
			org.eclipse.emf.ecore.EObject eObject = (org.eclipse.emf.ecore.EObject) object;
			Object currentValue = getValue(eObject, feature);
			java.util.Collection result = new java.util.ArrayList();
			result.add(currentValue);	
			org.eclipse.emf.ecore.EClass valueEClass = currentValue instanceof org.eclipse.emf.ecore.EObject ? ((org.eclipse.emf.ecore.EObject) currentValue).eClass() : null;
			for (int i = 0; i < myValues.length; i++) {
				if (myValues[i].eClass() == valueEClass) {
					continue;
				}
				result.add(myValues[i]);	
d204 12
a215 2
			if (currentValue != null) {
				result.add(null);
a216 1
			return result;
d218 2
a219 1
		return null;
d223 6
a228 12
	public void setPropertyValue(Object object, Object value) {
		if (value instanceof org.eclipse.emf.ecore.EObject) {
			org.eclipse.emf.ecore.EClass eClass =  ((org.eclipse.emf.ecore.EObject) value).eClass();
			value = eClass.getEPackage().getEFactoryInstance().create(eClass);
			if (value instanceof org.eclipse.gmf.gmfgraph.XYLayoutData) {
				org.eclipse.gmf.gmfgraph.XYLayoutData xyLayoutData = (org.eclipse.gmf.gmfgraph.XYLayoutData) value;
				xyLayoutData.setTopLeft(org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createPoint());
				xyLayoutData.getTopLeft().setX(0);
				xyLayoutData.getTopLeft().setY(0);
				xyLayoutData.setSize(org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createDimension());
				xyLayoutData.getSize().setDx(40);
				xyLayoutData.getSize().setDy(40);
d230 8
d239 1
a239 1
		super.setPropertyValue(object, value);
d241 306
d550 4
a553 18
«DEFINE getImageRegistry FOR gmfgen::GenCustomPropertyTab-»
  «EXPAND xpt::Common::generatedMemberComment»
  private static org.eclipse.jface.resource.ImageRegistry ourImageRegistry = new org.eclipse.jface.resource.ImageRegistry();
  
  «EXPAND xpt::Common::generatedMemberComment»
  static {
      ourImageRegistry.put(org.eclipse.gmf.gmfgraph.LineKind.LINE_SOLID_LITERAL.getLiteral(), «sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("icons/line_solid.png"));
      ourImageRegistry.put(org.eclipse.gmf.gmfgraph.LineKind.LINE_DASH_LITERAL.getLiteral(), «sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("icons/line_dash.png"));
      ourImageRegistry.put(org.eclipse.gmf.gmfgraph.LineKind.LINE_DOT_LITERAL.getLiteral(), «sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("icons/line_dot.png"));
      ourImageRegistry.put(org.eclipse.gmf.gmfgraph.LineKind.LINE_DASHDOT_LITERAL.getLiteral(), «sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("icons/line_dashdot.png"));
      ourImageRegistry.put(org.eclipse.gmf.gmfgraph.LineKind.LINE_DASHDOTDOT_LITERAL.getLiteral(), «sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("icons/line_dashdotdot.png"));
      ourImageRegistry.put(org.eclipse.gmf.gmfgraph.LineKind.LINE_CUSTOM_LITERAL.getLiteral(), «sheet.editorGen.plugin.getActivatorQualifiedClassName()».findImageDescriptor("icons/line_custom.png"));
  }

  «EXPAND xpt::Common::generatedMemberComment»
  public org.eclipse.jface.resource.ImageRegistry getImageRegistry() {
      return ourImageRegistry;
  }
d556 207
a762 10
«AROUND setInputMethod FOR gmfgen::GenCustomPropertyTab»
«IF isCustomTab()-»
	«EXPAND xpt::Common::generatedMemberComment»
	private java.util.Collection mySavedSelection = new java.util.ArrayList();
	
	«EXPAND xpt::Common::generatedMemberComment»
	public java.util.Collection getSavedSelection() {
	    //StructuredSelection structured = (StructuredSelection) super.getSelection();
	    //return structured.toList();
	    return mySavedSelection;
d764 16
a779 6
	
	«EXPAND xpt::Common::generatedMemberComment»
	public void setInput(org.eclipse.ui.IWorkbenchPart part, org.eclipse.jface.viewers.ISelection selection) {
		if (selection.isEmpty() || false == selection instanceof org.eclipse.jface.viewers.StructuredSelection) {
			super.setInput(part, selection);
			return;
d781 40
a820 11
		final org.eclipse.jface.viewers.StructuredSelection structuredSelection = ((org.eclipse.jface.viewers.StructuredSelection) selection);
		java.util.ArrayList transformedSelection = new java.util.ArrayList(structuredSelection.size());
		for (java.util.Iterator it = structuredSelection.iterator();  it.hasNext();) {
			Object r = transformSelection(it.next());
			if (r != null) {
				transformedSelection.add(r);
			}
		}
		mySavedSelection = transformedSelection;
		super.setInput(part, new org.eclipse.jface.viewers.StructuredSelection(transformedSelection));
	}
d822 7
a828 3
«targetDef.proceed()»
«ENDIF-»
«ENDAROUND»
@


1.1
log
@[173496] akarjakina - updated gmfgraph.editor bootstrap sample with recent GMF changes
@
text
@d15 45
d61 1
d64 5
a68 1
	    «EXPAND additionalPropertiesProvider-»
d76 1
a76 1
				return new org.eclipse.emf.edit.ui.provider.PropertySource(object, ips);
d83 1
d85 4
d91 6
a96 3
«DEFINE additionalPropertiesProvider FOR gmfgen::GenCustomPropertyTab-»
if (object instanceof org.eclipse.gmf.gmfgraph.Layoutable) {
	org.eclipse.gmf.runtime.common.ui.services.properties.descriptors.CompositePropertySource compositeSource = new org.eclipse.gmf.runtime.common.ui.services.properties.descriptors.CompositePropertySource(object);	
d98 18
a115 1
	compositeSource.addPropertySource(adaptToOldCompositePropertySource(object));
d117 5
a121 1
	org.eclipse.emf.edit.provider.IItemPropertyDescriptor layoutPropertyDescriptor = new ChildMetaclassItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), "Layout Manager", "Layout Manager", org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getLayoutable_Layout(), true, new org.eclipse.emf.ecore.EObject[] {org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createBorderLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createCustomLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createFlowLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createGridLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createStackLayout(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createXYLayout()});
d124 1
a124 1
	org.eclipse.emf.edit.provider.IItemPropertyDescriptor layoutDataPropertyDescriptor = new ChildMetaclassItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), "Layout Data", "Layout Data", org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getLayoutable_LayoutData(), true, new org.eclipse.emf.ecore.EObject[] {org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createBorderLayoutData(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createCustomLayoutData(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createGridLayoutData(), org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createXYLayoutData()});
d126 5
d132 18
a149 15
	if (object instanceof org.eclipse.gmf.gmfgraph.Polyline) {
		int counter = 1;
		for (java.util.Iterator it = ((org.eclipse.gmf.gmfgraph.Polyline) object).getTemplate().iterator(); it.hasNext(); counter++) {
			org.eclipse.gmf.gmfgraph.Point nextPoint = (org.eclipse.gmf.gmfgraph.Point) it.next();
			final String titleX = "Point " + counter + " X";
			org.eclipse.emf.edit.provider.IItemPropertyDescriptor nextPointPropertyDescriptorX = new org.eclipse.emf.edit.provider.ItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), titleX, titleX, org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getPoint_X(), true, "Template");
			compositeSource.addPropertySource(new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(nextPoint, new SingleDescriptorPropertySource(nextPointPropertyDescriptorX), "EMF") {
				protected org.eclipse.ui.views.properties.IPropertyDescriptor newPropertyDescriptor(org.eclipse.emf.edit.provider.IItemPropertyDescriptor itemPropertyDescriptor) {
					return new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor(object, itemPropertyDescriptor, getCategory()) {
						public Object getId() {
							return titleX;
						}
					};
				}
			});
d151 11
a161 12
			final String titleY = "Point " + counter + " Y";
			org.eclipse.emf.edit.provider.IItemPropertyDescriptor nextPointPropertyDescriptorY = new org.eclipse.emf.edit.provider.ItemPropertyDescriptor(«this.sheet.editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getItemProvidersAdapterFactory(), titleY, titleY, org.eclipse.gmf.gmfgraph.GMFGraphPackage.eINSTANCE.getPoint_Y(), true, "Template");
			compositeSource.addPropertySource(new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(nextPoint, new SingleDescriptorPropertySource(nextPointPropertyDescriptorY), "EMF") {
				protected org.eclipse.ui.views.properties.IPropertyDescriptor newPropertyDescriptor(org.eclipse.emf.edit.provider.IItemPropertyDescriptor itemPropertyDescriptor) {
					return new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor(object, itemPropertyDescriptor, getCategory()) {
						public Object getId() {
							return titleY;
						}
					};
				}
			});
		}
d163 1
a163 1

d166 1
d170 14
d185 8
a192 20
private org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource adaptToOldCompositePropertySource(Object object) {
	if (object instanceof org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource) {
		return (org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource) object;
	}
	org.eclipse.emf.common.notify.AdapterFactory af = getAdapterFactory(object);
	if (af != null) {
		org.eclipse.emf.edit.provider.IItemPropertySource ips = (org.eclipse.emf.edit.provider.IItemPropertySource) af.adapt(object, org.eclipse.emf.edit.provider.IItemPropertySource.class);
		if (ips != null) {
			return new org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositePropertySource(object, ips, "EMF");
		}
	}
	if (object instanceof org.eclipse.core.runtime.IAdaptable) {
		return (org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource) ((org.eclipse.core.runtime.IAdaptable) object).getAdapter(org.eclipse.gmf.runtime.common.ui.services.properties.ICompositePropertySource.class);
	}
	return null;
}

«EXPAND SingleDescriptorPropertySourceClass-»
«EXPAND ChildMetaclassItemPropertyDescriptorClass-»
«ENDAROUND»
d196 1
a196 1
public static class SingleDescriptorPropertySource implements org.eclipse.emf.edit.provider.IItemPropertySource {
d227 1
a227 1
«DEFINE ChildMetaclassItemPropertyDescriptorClass FOR gmfgen::GenCustomPropertyTab»
d229 1
a229 1
public static class ChildMetaclassItemPropertyDescriptor extends org.eclipse.emf.edit.provider.ItemPropertyDescriptor {
d235 1
a235 1
	ChildMetaclassItemPropertyDescriptor(org.eclipse.emf.common.notify.AdapterFactory adapterFactory, String displayName, String description, org.eclipse.emf.ecore.EStructuralFeature feature, boolean isSettable, org.eclipse.emf.ecore.EObject[] valueInstances) {
d281 54
@

