head	1.13;
access;
symbols
	v20080722-1827:1.13
	v20080718-1700:1.13
	v20080718-1731:1.13
	v20080716-1642:1.13
	R2_1_maintenance:1.13.0.2
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080610-1132:1.13
	v20080603-1553:1.13
	v20080528-1052:1.13
	v20080521:1.13
	v20080516-1143:1.13
	v20080512-1200:1.12
	v20080510-0100:1.12
	v20080507-1326:1.12
	v20080501-1739:1.12
	v20080425-1959:1.12
	v20080114-2222:1.7
	v20071214-1111:1.7
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.2
	R2_0:1.7
	R4_20:1.7
	v20070621-0000:1.7
	RC3_20:1.6
	v20070605-1400:1.6
	v20070601-1400:1.6
	v20070520-1200:1.5
	v20070420-1000:1.4
	v20070405-2000:1.4
	v20070405-1100:1.3
	v20070330-1300:1.1
	v20070307-0700:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.13
date	2008.05.14.11.16.58;	author ashatalin;	state Exp;
branches;
next	1.12;
commitid	377e482aca274567;

1.12
date	2008.04.21.14.42.09;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	6f82480ca7c04567;

1.11
date	2008.04.17.16.55.08;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	784e480780eb4567;

1.10
date	2008.04.15.13.38.49;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	1b9a4804afe84567;

1.9
date	2008.04.11.12.46.37;	author ashatalin;	state Exp;
branches;
next	1.8;
commitid	174247ff5dac4567;

1.8
date	2008.03.07.11.35.54;	author ashatalin;	state dead;
branches;
next	1.7;
commitid	5ab247d128944567;

1.7
date	2007.06.18.17.06.15;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	54d14676bb824567;

1.6
date	2007.05.31.15.52.32;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	49f1465eef2c4567;

1.5
date	2007.05.18.21.38.09;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	2f76464e1cbf4567;

1.4
date	2007.04.05.19.55.25;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	7f1461554204567;

1.3
date	2007.04.05.10.54.08;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	54d24614d54e4567;

1.2
date	2007.04.04.20.23.27;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	ade461409204567;

1.1
date	2007.03.02.15.39.20;	author atikhomirov;	state Exp;
branches;
next	;
commitid	717a45e845234567;


desc
@@


1.13
log
@- Migrating to new .gmfgen model
- Using (0,0) as a minimum size for DefaultNode to make resize feedback minimum size == (0,0)
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Anna Karjakina (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - cleaned and simplified outcome
 */
 
import "http://www.eclipse.org/gmf/2008/GenModel";
import "http://www.eclipse.org/emf/2002/Ecore";
import "http://www.eclipse.org/gmf/2008/GmfGraph/PropSheet";
import "http://www.eclipse.org/emf/2002/GenModel";

extension xpt::EMFUtils;

boolean isProxyTab(gmfgen::GenCustomPropertyTab tab) :
!getReferencingObjects(tab).typeSelect(propsheet::CustomPropertySection).isEmpty()
;

String getProxyTabSuperClassName(gmfgen::GenCustomPropertyTab tab) :
getCustomPropertySection(tab).section.className
;

propsheet::CustomPropertySection getCustomPropertySection(gmfgen::GenCustomPropertyTab tab) :
getReferencingObjects(tab).typeSelect(propsheet::CustomPropertySection).first()
;@


1.12
log
@Migrating to dynamic model usage.
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d14 1
a14 1
import "http://www.eclipse.org/gmf/2006/GenModel";
@


1.11
log
@Generating commit/unwrap methods + Filters for formTK-based properties sections.
@
text
@d16 1
a16 1
import "http://www.eclipse.org/gmf/2007/GmfGraph/PropSheet";
@


1.10
log
@Generating custom property tabs using the code generated by fotmTK  plugin.
@
text
@d17 1
d26 5
a30 1
getReferencingObjects(tab).typeSelect(propsheet::CustomPropertySection).section.className.first()
@


1.9
log
@Registering generated property tabs as GenCustomPropertyTabs
@
text
@d16 3
d21 1
a21 1
tab.className.endsWith("Proxy")
d25 1
a25 1
tab.className.replaceFirst("Proxy", "")
@


1.8
log
@Migrating to new templates from .codegen plugin.
@
text
@a13 2
import "http://www.eclipse.org/gmf/2007/GmfGraph/PropSheet";
import "http://www.eclipse.org/gmf/2006/GraphicalDefinition";
a14 1
import "http://www.eclipse.org/emf/2002/GenModel";
d17 2
a18 176
extension xpt::GenModelUtils;

boolean isPointTab(gmfgen::GenCustomPropertyTab tab) :
"points" == tab.iD
;

boolean isGeneratedTab(gmfgen::GenCustomPropertyTab tab) :
"genLayout" == tab.iD || "genStyles" == tab.iD || "genName" == tab.iD
;

cached propsheet::FeatureReference getModelElement(propsheet::Group modelElementOwner) :
modelElementOwner.modelMediator
;

cached propsheet::FeatureReference getModelElement(propsheet::Radio modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Checkbox modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::TextArea modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Date modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Time modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::StringCombo modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::IntCombo modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::BooleanCombo modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::CustomCombo modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Spin modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::TextField modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Sectionable modelElementOwner) :
null
;

cached String getQualifiedInterfaceName(genmodel::GenClassifier classifier) :
classifier.genPackage.basePackage+"."+classifier.genPackage.ecorePackage.name+(classifier.genPackage.interfacePackageSuffix != "" ? "."+classifier.genPackage.interfacePackageSuffix : "")+"."+getName(classifier)
;

cached String getQualifiedClassifierCreaterName(genmodel::GenClassifier classifier) :
classifier == null ? "null" : getQualifiedFactoryInterfaceName(classifier.genPackage) + ".eINSTANCE.create" + getName(classifier) + "()"
;

cached String getName(genmodel::GenClass genClass) :
getEClassifierName(genClass.ecoreClass)
;

cached String getName(genmodel::GenEnum enum) :
getEClassifierName(enum.ecoreEnum)
;

cached String getName(genmodel::GenDataType dataType) :
getEClassifierName(dataType.ecoreDataType)
;

cached String getName(genmodel::GenClassifier abstract) :
"AAA"+abstract.toString()+"AAA"
;

private cached String getName(genmodel::GenFeature genFeature) :
genFeature.ecoreFeature.name
;

private cached String getEClassifierName(ecore::EClassifier classifier) :
	switch (classifier.name) {
		case "Class" : "Class_"
		case "Name" : "Name_"
		default : classifier.name
	}
;

// TODO: completely rewrite this very bad-styled function!!!
cached String getSetterAccessor(genmodel::GenFeature feature) :
feature == null ? "" : (
let getAccessor = feature.getGetAccessor() :
getAccessor.startsWith("get|is") ? getAccessor.replaceFirst("get|is", "set") : "set" + feature.ecoreFeature.name.toFirstUpper()
)
;

// TODO: completely rewrite this very bad-styled function!!!
cached String getSetterAccessor(String getAccessor, String accessorName) :
getAccessor.replaceFirst("[.](get|is)" + accessorName + "[(][)]", ".set" + accessorName)
;

// TODO: add Java5 check: @@see GenEnumLiteralImpl.getEnumLiteralInstanceConstantName()
cached String getEnumLiteralInstanceConstantName(genmodel::GenEnumLiteral genLiteral) :
genLiteral.getEnumLiteral().replaceAll(" ", "_").toUpperCase() + "_LITERAL"
;

cached propsheet::CustomPropertySection getCustomPropertySection(propsheet::Sectionable section) :
section.parent == null ? ((propsheet::CustomPropertySection) section) : getCustomPropertySection(section.parent)
;

boolean createLabel(propsheet::Labeled labeled) :
labeled.text != null ? labeled.text.createLabel : null != labeled.getModelElement()
;

boolean isVisibleOnlyForTargets(propsheet::Group group) :
group.modelMediator != null ? group.modelMediator.visibleOnlyForTargets : false  
;

String name(propsheet::Sectionable section) :
section != null ? generateVarName(section) : ""  
;

// TODO: implement generation of variable names
private cached String generateVarName(propsheet::Sectionable section) :
((section.name == null || "" == section.name) && getModelElement(section) == null && getText(section) == null) ?
	"UnableToGenerateName" : composeVarName(section)
;

private cached propsheet::Text getText(propsheet::Sectionable section) :
null
;

private cached propsheet::Text getText(propsheet::Labeled section) :
section.text
;

private getTextValueForVar(propsheet::Text text) :
((String)text.overridedItemProviderText).replaceAll(" ", "")
;

private String composeVarName(propsheet::Sectionable section) :
	getVarPrefix()+buildMiddlePart(section)+getSectionableKindSuffix(section)
;

private String buildMiddlePart(propsheet::Sectionable section) :
	getMiddlePart(section).toFirstUpper().replaceAll("[ _]", "")
;

private String getMiddlePart(propsheet::Sectionable section) :
(section.name == null || "" == section.name || section.name.matches("^\\d+$")) ?
	(getModelElement(section) == null ? 
		(getText(section) == null ? 
			(section.name == null || "" == section.name ? "UnableToGenerateName" : section.name) : 
			getTextValueForVar(getText(section))) : 
		getModelElementNameForVar(getModelElement(section))) :
	section.name
;

private String getVarPrefix() : "my" ;

private cached String getSectionableKindSuffix(propsheet::Sectionable section) :
""
;

private cached String getSectionableKindSuffix(propsheet::Group section) :
createLabel(section) ? (isExpandable(section) ? "ExpandableComposite" : "Group") : "Composite"
d21 3
a23 166
private cached String getSectionableKindSuffix(propsheet::Radio section) :
"Radio"
;

private cached String getSectionableKindSuffix(propsheet::Checkbox section) :
"Checkbox"
;

private cached String getSectionableKindSuffix(propsheet::TextArea section) :
"TextArea"
;

private cached String getSectionableKindSuffix(propsheet::Date section) :
"Date"
;

private cached String getSectionableKindSuffix(propsheet::Time section) :
"Time"
;

private cached String getSectionableKindSuffix(propsheet::Combo section) :
"Combo"
;

private cached String getSectionableKindSuffix(propsheet::Spin section) :
"Spin"
;

private cached String getSectionableKindSuffix(propsheet::TextField section) :
"Text"
;

private cached String getSectionableKindSuffix(propsheet::Label section) :
"Label"
;

private cached String getModelElementNameForVar(propsheet::IsFeatureOfTypeReference featureRef) :
getName(featureRef.isOfType)
;

private cached String getModelElementNameForVar(propsheet::IsFeatureIsOfKindReference featureRef) :
	getVarName(featureRef.isOfValue.getEnumLiteral()).toFirstUpper()
;

private cached String getModelElementNameForVar(propsheet::ModelMediatorFeature featureRef) :
(featureRef.cast != null ? getName(featureRef.cast) : "") +
(featureRef.feature != null ? getVarName(getName(featureRef.feature)).toFirstUpper() : "")
;

private cached String getModelElementNameForVar(propsheet::FeatureReference featureRef) :
	getVarName(getName(featureRef.feature)).toFirstUpper()
;

private String getVarName(String originalName) :
	let x = getProcessedNames().select(n | originalName == n).size() :
		getProcessedNames().add(originalName) -> (x == 0 ? originalName : originalName + "$" + x)
;

private cached List[String] getProcessedNames() : {} ; 

cached String getFormattedName(genmodel::GenFeature genFeature) :
getName(genFeature) == null ? "" : format(getName(genFeature).toFirstUpper())
;

cached String getFormattedName(genmodel::GenClassifier genClassifier) :
getName(genClassifier) == null ? "" : format(getName(genClassifier))
;

//TODO: invoke CodeGenUtil.format(mixedCaseName, ' ', null, false, false), like GenFeatureImpl does 
private String format(String mixedCaseString) :
mixedCaseString
;

cached String getEnumLiteral(genmodel::GenEnumLiteral genLiteral) :
genLiteral.ecoreEnumLiteral.literal
;

cached String getEnumLiteralFriendlyName(genmodel::GenEnumLiteral genLiteral) :
getEnumLiteral(genLiteral).toLowerCase().toFirstUpper()
;

cached genmodel::GenClassifier getTarget(propsheet::Group group) :
group.getModelMediator().cast
;

cached List[propsheet::Group] collectAllParentGroups(propsheet::Sectionable section) :
section.parent == null ? {} : collectAllParentGroups(section.parent, {})
;

private cached List[propsheet::Group] collectAllParentGroups(propsheet::Group group, List[propsheet::Group] collected) :
group.parent == null ? collected : collectAllParentGroups(group.parent, collected).add(group)
;

cached propsheet::ModelMediatorFeature findModelMediator(propsheet::Group group) :
group.modelMediator == null ? (group.parent == null ? null : getModelMediator(group.parent)) : group.modelMediator
;

cached propsheet::ModelMediatorFeature getModelMediator(propsheet::Group group) :
group.modelMediator
;

cached genmodel::GenClassifier expectedType(propsheet::ModelMediatorFeature modelElement) :
modelElement.cast != null ? modelElement.cast : (modelElement.feature != null ? modelElement.feature.getTypeGenClassifier() : null)
;

cached genmodel::GenClassifier getTypeGenClassifier(genmodel::GenFeature genFeature) :
findGenClassifier(genFeature.genClass.genPackage.genModel, genFeature.ecoreFeature.eType)
;

cached String expectedTypeName(propsheet::ModelMediatorFeature modelElement) :
modelElement.expectedType() != null ? modelElement.expectedType().getQualifiedInterfaceName() : "/* XXX: Error: Useless ModelMediator with no feature or cast reference found*/ Object"
;

cached String expectedTypeVar(propsheet::ModelMediatorFeature modelElement) :
modelElement.expectedType() != null ? modelElement.expectedType().getName().toFirstLower() : "unknownTypeVar"
;

cached String castedVarCall(propsheet::ModelMediatorFeature modelElement, String elementName) :
modelElement.cast == null ? elementName : "(("+modelElement.cast.getQualifiedInterfaceName()+")"+elementName+")"
;

cached String castedVarFeatureCall(propsheet::ModelMediatorFeature modelElement, String varName) :
modelElement.castedVarCall(varName) + modelElement.addFeatureCall()
;

cached String addFeatureCall(propsheet::FeatureReference modelElement) :
modelElement.feature != null ? "."+modelElement.feature.getGetAccessor()+"()" : ""
;

boolean isExpandable(propsheet::Group group) :
group.expandable
;

boolean isNullCheck(propsheet::IsFeatureOfTypeReference ofType) :
ofType.feature == null && ofType.isOfType == null
;

boolean isNullCheck(propsheet::Reference ofType) :
false
;

cached List[propsheet::Date] collectAllDates(propsheet::Group group, List[propsheet::Date] collected) :
collected.addAll(group.contents.typeSelect(propsheet::Date)) ->
group.contents.typeSelect(propsheet::Group).collectAllDates(collected) ->
collected
;

cached List[propsheet::Time] collectAllTimes(propsheet::Group group, List[propsheet::Time] collected) :
collected.addAll(group.contents.typeSelect(propsheet::Time)) ->
group.contents.typeSelect(propsheet::Group).collectAllTimes(collected) ->
collected
;

cached List[propsheet::CustomCombo] collectAllCustomCombos(propsheet::Group group, List[propsheet::CustomCombo] collected) :
collected.addAll(group.contents.typeSelect(propsheet::CustomCombo)) ->
group.contents.typeSelect(propsheet::Group).collectAllCustomCombos(collected) ->
collected
;

cached Set[String] getUniqueQualifiedTargetTypeNamesUsed(List[propsheet::Sectionable] widgets) :
widgets.select(next | null != next.getModelElement()).getModelElement().feature.getFeatureTargetType().toSet()
;

cached String getUnqualifiedTypeName(String qualifiedTypeName) :
qualifiedTypeName.split("\\.").last()
;
@


1.7
log
@[191661] akarjakina - Improve GMFGraph Editor's propsheet model/codegen with TextArea, Combo and Date/Time support
@
text
@@


1.6
log
@[190196] akarjakina - Adjust GMFGraph Editor according recent gmfgraph metamodel with support for FigureDescriptor introduced
@
text
@d27 1
a27 1
"genLayout" == tab.iD || "genStyles" == tab.iD
d42 28
d141 1
a141 1
labeled.text != null ? labeled.text.createLabel : true
d206 16
d338 26
@


1.5
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d15 1
a15 1
import "http://www.eclipse.org/gmf/2005/GraphicalDefinition";
@


1.4
log
@kiss; cleaner and bit more simple
@
text
@d16 1
a16 1
import "http://www.eclipse.org/gmf/2005/GenModel/2.0";
@


1.3
log
@cleanup
@
text
@d11 1
d108 2
a109 2
cached propsheet::CustomPropertySection getCustomPropertySection(propsheet::Sectionable sectionable) :
sectionable.parent == null ? ((propsheet::CustomPropertySection) sectionable) : getCustomPropertySection(sectionable.parent)
d120 2
a121 2
String name(propsheet::Sectionable sectionable) :
sectionable != null ? generateVarName(sectionable) : ""  
d125 3
a127 3
private cached String generateVarName(propsheet::Sectionable sectionable) :
((sectionable.name == null || "" == sectionable.name) && getModelElement(sectionable) == null && getText(sectionable) == null) ?
	"UnableToGenerateName" : composeVarName(sectionable)
d130 1
a130 1
private cached propsheet::Text getText(propsheet::Sectionable sectionable) :
d134 2
a135 2
private cached propsheet::Text getText(propsheet::Labeled sectionable) :
sectionable.text
d142 2
a143 2
private cached String composeVarName(propsheet::Sectionable sectionable) :
getVarPrefix()+buildMiddlePart(sectionable).toFirstUpper()+getSectionableKindSuffix(sectionable)
d146 2
a147 2
private cached String buildMiddlePart(propsheet::Sectionable sectionable) :
getMiddlePart(sectionable).toFirstUpper().replaceAll("[ _]", "") + (sectionable.parent != null && sectionable.parent.parent != null ? buildMiddlePart(sectionable.parent) : "")
d150 8
a157 8
private cached String getMiddlePart(propsheet::Sectionable sectionable) :
(sectionable.name == null || "" == sectionable.name || sectionable.name.matches("^\\d+$")) ?
	(getModelElement(sectionable) == null ? 
		(getText(sectionable) == null ? 
			(sectionable.name == null || "" == sectionable.name ? "UnableToGenerateName" : sectionable.name) : 
			getTextValueForVar(getText(sectionable))) : 
		getModelElementNameForVar(getModelElement(sectionable))) :
	sectionable.name
d160 1
a160 3
private cached String getVarPrefix() :
"my"
;
d162 1
a162 1
private cached String getSectionableKindSuffix(propsheet::Sectionable sectionable) :
d166 2
a167 2
private cached String getSectionableKindSuffix(propsheet::Group sectionable) :
createLabel(sectionable) ? (isExpandable(sectionable) ? "ExpandableComposite" : "Group") : "Composite"
d170 1
a170 1
private cached String getSectionableKindSuffix(propsheet::Radio sectionable) :
d174 1
a174 1
private cached String getSectionableKindSuffix(propsheet::Checkbox sectionable) :
d178 1
a178 1
private cached String getSectionableKindSuffix(propsheet::Spin sectionable) :
d182 1
a182 1
private cached String getSectionableKindSuffix(propsheet::TextField sectionable) :
d186 1
a186 1
private cached String getSectionableKindSuffix(propsheet::Label sectionable) :
d195 1
a195 1
featureRef.isOfValue.getEnumLiteral().toFirstUpper()
d200 1
a200 1
(featureRef.feature != null ? getName(featureRef.feature).toFirstUpper() : "")
d204 6
a209 1
getName(featureRef.feature).toFirstUpper()
d212 2
d239 2
a240 2
cached List[propsheet::Group] collectAllParentGroups(propsheet::Sectionable sectionable) :
sectionable.parent == null ? {} : collectAllParentGroups(sectionable.parent, {})
@


1.2
log
@[173499] akarjakina - Enhance graphdef.editor with properties - use custom model to describe property sheet and generate PropertyTab code from that model
@
text
@a28 13
cached List[propsheet::Sectionable] collectAllParents(propsheet::Sectionable sectionable) :
sectionable.parent == null ? {sectionable} : collectAllParents(sectionable.parent, {sectionable})
;

private List[propsheet::Sectionable] collectAllParents(propsheet::Group target, List[propsheet::Sectionable] parents) :
parents.add(target) -> (target.parent == null ? parents : collectAllParents(target.parent, parents))
;

private String concatReverse(Collection[Object] coll) :
let list = coll.toList() :
	list.isEmpty() ? "" : (((String) list.last()) + concatReverse(list.withoutLast()))
;

d77 1
a77 1
private cached String getFeatureName(genmodel::GenFeature genFeature) :
d111 2
a112 2
boolean createLabel(propsheet::Text text) :
text != null ? text.createLabel : true
d126 1
a126 1
	"UnableToGenerateName" : composeVarName(buildMiddlePart(sectionable), sectionable)
d141 2
a142 2
private cached String composeVarName(String middlePart, propsheet::Sectionable sectionable) :
getVarPrefix()+middlePart.toFirstUpper()+getSectionableKindSuffix(sectionable)
d168 1
a168 1
createLabel(sectionable.text) ? (isExpandable(sectionable) ? "ExpandableComposite" : "Group") : "Composite"
d201 1
a201 1
(featureRef.feature != null ? getFeatureName(featureRef.feature).toFirstUpper() : "")
d205 1
a205 1
getFeatureName(featureRef.feature).toFirstUpper()
d209 1
a209 1
getFeatureName(genFeature) == null ? "" : format(getFeatureName(genFeature).toFirstUpper())
a228 4
cached String composeModelCall(propsheet::Sectionable sectionable, String targetVar) :
targetVar
;

@


1.1
log
@[176026] akarjakina - Fix notation background and foreground colors update
[173499] akarjakina - Add custom form-based property sections fro figure attributes
@
text
@d13 1
d19 1
a19 3
boolean isLayoutTab(gmfgen::GenCustomPropertyTab tab) :
"layout" == tab.iD
;
d25 275
a299 2
boolean isViewTab(gmfgen::GenCustomPropertyTab tab) :
"view" == tab.iD
d302 2
a303 2
boolean isCustomTab(gmfgen::GenCustomPropertyTab tab) :
"custom" == tab.iD
@

