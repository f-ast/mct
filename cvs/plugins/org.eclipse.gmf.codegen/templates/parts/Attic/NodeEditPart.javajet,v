head	1.96;
access;
symbols
	v20081022-1925:1.96
	v20081015-1925:1.96
	v20081008-1925:1.96
	v20081001-1925:1.96
	v20080924-1925:1.96
	v20080917-1925:1.96
	v20080911-1728:1.96
	v20080910-1520:1.96
	v20080903-1520:1.96
	v20080827-1520:1.96
	v20080813-1520:1.96
	v20080806-1520:1.96
	v20070202-0200:1.86
	v20061120-1300:1.94
	M3_20:1.94
	v20061117-0800:1.94
	v20061027-1200:1.86
	v20061020-1000:1.86
	v20061013-1330:1.92
	v20060919-0800:1.86
	v20060907-1100:1.86
	M1_20:1.88
	v20060904-1500:1.88
	v20060824-1600:1.86
	v20060817-1500:1.86
	v20060728-0500:1.86
	v20060713-1700:1.86
	R1_0_maintenance:1.86.0.2
	R1_0:1.86
	v20060627-1200:1.86
	v20060626-1420:1.86
	v20060620-0400:1.80
	v20060616-1400:1.79
	v20060616-1200:1.79
	v20060609-1400:1.79
	v20060531-1730:1.78
	v20060530-1930:1.78
	v20060526-1200:1.77
	v20060519-1300:1.73
	v20060519-0800:1.73
	v20060512-1000:1.70
	I20060512-1000:1.70
	I20060505-1400:1.70
	I20060428-1300:1.68
	I20060424-0500:1.67
	I20060424-0300:1.67
	M6_10:1.65
	I20060407-1200:1.58
	I20060331-1000:1.58
	I20060324-0300:1.57
	I20060317-1300:1.57
	I20060317-1200:1.57
	I20060316-1300:1.55
	I20060309-1300:1.44
	M5_10:1.43
	S20060303-1600:1.43
	I20060227-1730:1.40
	I20060216-1945:1.39
	I20060210-1715:1.38
	I20060209-1815:1.38
	I20060203-0830:1.34
	I20060202-1415:1.34
	I20060129-1145:1.34
	I20060127-0900:1.34
	I20060120-1530:1.31
	I20060113-1700:1.26
	M4_10:1.26
	I20060107-1100:1.23
	I20060105-1630:1.21
	I20051230-1230:1.20
	I20051223-1100:1.20
	I20051217-0925:1.19
	I20051208-2000:1.18
	I20051201-1800:1.16
	I20051124-2000:1.16
	M3_10:1.13
	I20051118-1245:1.13
	I20051111-1800:1.12
	I20051106-0900:1.8
	v20051030:1.8
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.96
date	2006.12.13.18.57.26;	author dstadnik;	state dead;
branches;
next	1.95;
commitid	68a45804d154567;

1.95
date	2006.12.12.12.00.00;	author dstadnik;	state Exp;
branches;
next	1.94;
commitid	2d28457e99bb4567;

1.94
date	2006.10.24.16.12.55;	author ashatalin;	state Exp;
branches;
next	1.93;

1.93
date	2006.10.24.14.49.09;	author ashatalin;	state Exp;
branches;
next	1.92;

1.92
date	2006.10.06.15.26.31;	author atikhomirov;	state Exp;
branches;
next	1.91;

1.91
date	2006.10.06.12.15.31;	author atikhomirov;	state Exp;
branches;
next	1.90;

1.90
date	2006.09.29.21.26.45;	author atikhomirov;	state Exp;
branches;
next	1.89;

1.89
date	2006.09.26.15.41.04;	author atikhomirov;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.25.18.32.58;	author atikhomirov;	state Exp;
branches;
next	1.87;

1.87
date	2006.07.07.11.58.56;	author dstadnik;	state Exp;
branches;
next	1.86;

1.86
date	2006.06.23.16.22.20;	author dstadnik;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.23.15.32.41;	author dstadnik;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.23.14.54.31;	author dstadnik;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.23.12.26.15;	author dstadnik;	state Exp;
branches;
next	1.82;

1.82
date	2006.06.21.12.55.34;	author dstadnik;	state Exp;
branches;
next	1.81;

1.81
date	2006.06.20.13.42.42;	author dstadnik;	state Exp;
branches;
next	1.80;

1.80
date	2006.06.19.14.02.19;	author ashatalin;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.06.14.07.30;	author ashatalin;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.30.18.37.42;	author atikhomirov;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.25.14.06.32;	author atikhomirov;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.24.18.05.30;	author atikhomirov;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.24.11.47.59;	author atikhomirov;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.22.17.40.10;	author ashatalin;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.17.13.18.44;	author atikhomirov;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.17.12.39.16;	author atikhomirov;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.05.17.42.56;	author ashatalin;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.05.15.42.02;	author atikhomirov;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.25.11.46.05;	author atikhomirov;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.20.20.37.15;	author ashatalin;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.20.08.12.10;	author dstadnik;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.14.11.17.05;	author ashatalin;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.14.10.18.29;	author dstadnik;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.14.07.21.22;	author dstadnik;	state Exp;
branches;
next	1.62;

1.62
date	2006.04.13.15.03.36;	author atikhomirov;	state Exp;
branches;
next	1.61;

1.61
date	2006.04.13.12.39.59;	author ashatalin;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.12.16.28.45;	author dstadnik;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.12.01.16.49;	author ashatalin;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.30.20.42.04;	author atikhomirov;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.17.16.52.37;	author atikhomirov;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.17.15.21.22;	author dstadnik;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.14.16.50.41;	author dstadnik;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.14.16.36.21;	author dstadnik;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.14.16.22.18;	author dstadnik;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.14.14.07.11;	author dstadnik;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.14.13.14.55;	author dstadnik;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.14.10.27.03;	author dstadnik;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.13.21.35.09;	author atikhomirov;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.13.20.25.59;	author atikhomirov;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.13.18.39.47;	author dstadnik;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.13.11.51.22;	author dstadnik;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.13.11.02.30;	author dstadnik;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.07.15.45.28;	author dstadnik;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.01.14.55.16;	author ashatalin;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.27.18.29.31;	author ashatalin;	state Exp;
branches;
next	1.41;

1.41
date	2006.02.27.10.43.20;	author ashatalin;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.23.15.41.16;	author ashatalin;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.13.17.36.15;	author atikhomirov;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.08.17.15.50;	author atikhomirov;	state Exp;
branches;
next	1.37;

1.37
date	2006.02.08.13.09.29;	author ashatalin;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.26.13.36.44;	author atikhomirov;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.24.10.23.26;	author dstadnik;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.23.19.58.06;	author ashatalin;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.20.13.07.39;	author dstadnik;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.19.16.49.16;	author dstadnik;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.19.00.10.44;	author ashatalin;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.16.19.05.24;	author ashatalin;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.16.18.59.18;	author ashatalin;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.12.15.37.38;	author ashatalin;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.12.11.43.59;	author dstadnik;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.10.16.16.58;	author ashatalin;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.06.19.22.30;	author atikhomirov;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.06.17.03.34;	author atikhomirov;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.05.17.30.30;	author atikhomirov;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.20.18.00.01;	author ashatalin;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.10.14.59.33;	author ashatalin;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.08.14.15.28;	author ashatalin;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.07.17.07.00;	author ashatalin;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.24.08.51.26;	author dstadnik;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.23.10.11.52;	author dstadnik;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.21.09.35.38;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.17.12.38.37;	author ashatalin;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.11.13.47.43;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.10.17.44.55;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.10.17.21.40;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.08.15.36.54;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.21.13.31.57;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.12.12.12.20;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.11.12.50.57;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.04.15.40.37;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.03.19.09.15;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.30.19.16.09;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.29.09.49.41;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.20.29;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.96
log
@use xpand template to generate node edit part
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.parts" class="NodeEditPartGenerator"
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"
	skeleton="../common.skeleton"%>
<%
final GenNode genNode = (GenNode) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
GenDiagram genDiagram = genNode.getDiagram();
boolean isXYLayout = ViewmapLayoutType.XY_LAYOUT_LITERAL.equals(genNode.getLayoutType());

class NodeEditPartHelper {
	private final List<GenNodeLabel> myInnerLabels = new LinkedList<GenNodeLabel>();
	private final List<GenNodeLabel> myExternalLabels = new LinkedList<GenNodeLabel>();
	private final List<GenCompartment> myPinnedCompartments = new LinkedList<GenCompartment>();
	private final List<GenCompartment> myFloatingCompartments = new LinkedList<GenCompartment>();
	private final List<GenChildNode> mySideAffixedChildren = new LinkedList<GenChildNode>();
	private GenNodeLabel myPrimaryLabel;
	private boolean myHasChildrenInListCompartments = false;
	private final boolean myIsSideAffixed;
	private final boolean myHasSideAffixedChildren;
	
	public NodeEditPartHelper(GenNode genNode){
		myPrimaryLabel = null;

		for (Iterator labels = genNode.getLabels().iterator(); labels.hasNext();) {
			GenNodeLabel next = (GenNodeLabel) labels.next();
			if (myPrimaryLabel == null){
				myPrimaryLabel = next;
			}
			if (next instanceof GenExternalNodeLabel) {
				myExternalLabels.add(next);
			} else if (next.getViewmap() instanceof ParentAssignedViewmap) {
				myInnerLabels.add(next);
			}
		}
		
		for (Iterator compartments = genNode.getCompartments().iterator(); compartments.hasNext();){
			GenCompartment next = (GenCompartment) compartments.next();
			if (next.getViewmap() instanceof ParentAssignedViewmap){
				myPinnedCompartments.add(next);
			} else {
				myFloatingCompartments.add(next);
			}	
			
			myHasChildrenInListCompartments |= next.isListLayout() && !next.getChildNodes().isEmpty();
		}
		
		for (Iterator childNodes = genNode.getChildNodes().iterator(); childNodes.hasNext();){
			GenChildNode next = (GenChildNode)childNodes.next();
			if (next instanceof GenChildSideAffixedNode){
				mySideAffixedChildren.add(next);
			}
		}
		
		myIsSideAffixed = genNode instanceof GenChildSideAffixedNode;
		myHasSideAffixedChildren = !mySideAffixedChildren.isEmpty();
	}
	
	public boolean isSideAffixed(){
		return myIsSideAffixed;
	}
	
	public boolean hasSideAffixedChildren(){
		return myHasSideAffixedChildren;
	}
	
	public String getEditPartSuperClassFQN(){
		if (isSideAffixed()){
			return hasSideAffixedChildren() ? 
				"org.eclipse.gmf.runtime.diagram.ui.editparts.BorderedBorderItemEditPart" :
				"org.eclipse.gmf.runtime.diagram.ui.editparts.AbstractBorderItemEditPart";
		} else {
			return hasSideAffixedChildren() ? 
				"org.eclipse.gmf.runtime.diagram.ui.editparts.AbstractBorderedShapeEditPart" : 
				"org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart";
		}
	}
	
	public boolean hasChildrenInListCompartments(){
		return myHasChildrenInListCompartments;
	}
	
	public boolean hasInnerFixedLabels(){
		return !myInnerLabels.isEmpty();
	}
	
	public boolean hasPinnedCompartments(){
		return !myPinnedCompartments.isEmpty();
	}
	
	public boolean hasFixedChildren(){
		return hasInnerFixedLabels() || hasPinnedCompartments();
	}
	
	public boolean hasExternalLabels(){
		return !myExternalLabels.isEmpty();
	}
	
	public GenNodeLabel getPrimaryLabel(){
		return myPrimaryLabel;
	}
	
	public Iterator getInnerFixedLabels(){
		return myInnerLabels.iterator();
	}
	
	public Iterator getExternalLabels(){
		return myExternalLabels.iterator();
	}
	
	public Iterator getPinnedCompartments(){
		return myPinnedCompartments.iterator();
	}	
	
	public Iterator getSideAffixedChildren(){
		return mySideAffixedChildren.iterator();
	}
}
final NodeEditPartHelper myHelper = new NodeEditPartHelper(genNode);
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%
if (genNode.getViewmap() instanceof InnerClassViewmap) {
importManager.registerInnerClass(((InnerClassViewmap) genNode.getViewmap()).getClassName());
}
importManager.addImport("org.eclipse.draw2d.IFigure");
importManager.addImport("org.eclipse.draw2d.StackLayout");
importManager.addImport("org.eclipse.gef.EditPolicy");
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles");
importManager.addImport("org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure");
importManager.addImport("org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
importManager.markImportLocation(stringBuffer);
%>

/**
 * @@generated
 */
public class <%=genNode.getEditPartClassName()%> extends <%=importManager.getImportedName(myHelper.getEditPartSuperClassFQN())%> {
<%{	GenCommonBase genCommonBase = genNode;%>
<%@@ include file="visualID.jetinc"%>
<%}%>

	/**
	 * @@generated
	 */
	protected IFigure contentPane;

	/**
	 * @@generated
	 */
	protected IFigure primaryShape;

	/**
	 * @@generated
	 */
	public <%=genNode.getEditPartClassName()%>(View view) {
		super(view);
	}

	/**
	 * @@generated
	 */
	protected void createDefaultEditPolicies() {
<%
if (!genNode.getChildNodes().isEmpty() || myHelper.hasChildrenInListCompartments()) {
%>
		installEditPolicy(EditPolicyRoles.CREATION_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy")%>()
<%	if (myHelper.hasChildrenInListCompartments()) {%>
		{

			public <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> getCommand(<%=importManager.getImportedName("org.eclipse.gef.Request")%> request) {
				if (understandsRequest(request)) {
					if (request instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewAndElementRequest")%>) {
						<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.core.edithelpers.CreateElementRequestAdapter")%> adapter =
							((<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewAndElementRequest")%>) request).getViewAndElementDescriptor().getCreateElementRequestAdapter();
						<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%> type =
							(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>) adapter.getAdapter(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>.class);
<%
		for (Iterator compartments = genNode.getCompartments().iterator(); compartments.hasNext();) {
			GenCompartment compartment = (GenCompartment) compartments.next();
			if (compartment.isListLayout() && !compartment.getChildNodes().isEmpty()) {
				for (Iterator children = compartment.getChildNodes().iterator(); children.hasNext(); ) {
					GenNode child = (GenNode) children.next();
%>
						if (type == <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=child.getUniqueIdentifier()%>) {
							<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> compartmentEditPart =
								getChildBySemanticHint(<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getType(<%=importManager.getImportedName(compartment.getEditPartQualifiedClassName())%>.VISUAL_ID));
							return compartmentEditPart == null ? null : compartmentEditPart.getCommand(request);
						}
<%
				}
			}
		}
%>
					}
					return super.getCommand(request);
				}
				return null;
			}
		}
<%	}%>
		);
<%}%>
		super.createDefaultEditPolicies();
<%if (myHelper.isSideAffixed()){%>
		installEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE, getPrimaryDragEditPolicy());
<%}%>		
		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE, new <%=importManager.getImportedName(genNode.getItemSemanticEditPolicyQualifiedClassName())%>());
<%if (genNode.getModelFacet() != null && !genNode.getReorientedIncomingLinks().isEmpty()) {%>
		installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new <%=importManager.getImportedName(genNode.getGraphicalNodeEditPolicyQualifiedClassName())%>());
<%}
if (!genNode.getChildNodes().isEmpty()) {%>
		installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.DragDropEditPolicy")%>());
<%}
if (genNode.getBehaviour(OpenDiagramBehaviour.class).size() == 1) /*doesn't make sense to install more than one policy for the same role*/ {%>
		installEditPolicy(EditPolicyRoles.OPEN_ROLE, new <%=importManager.getImportedName(genNode.getBehaviour(OpenDiagramBehaviour.class).get(0).getEditPolicyQualifiedClassName())%>());
<%}
if (genNode.needsCanonicalEditPolicy()) {%>
		installEditPolicy(EditPolicyRoles.CANONICAL_ROLE, new <%=importManager.getImportedName(genNode.getCanonicalEditPolicyQualifiedClassName())%>());
<%}%>
		installEditPolicy(EditPolicy.LAYOUT_ROLE, createLayoutEditPolicy());
<%{	GenCommonBase genCommonBase = genNode;%>
<%@@ include file="customBehaviour.jetinc"%>
<%}%>
	}

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.gef.editpolicies.LayoutEditPolicy")%> createLayoutEditPolicy() {
<%
final String fqnEditPart = importManager.getImportedName("org.eclipse.gef.EditPart");
switch(genNode.getLayoutType().getValue()){
	case ViewmapLayoutType.XY_LAYOUT:
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy")%> lep = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy")%>() {
<%		if (myHelper.hasExternalLabels()) {%>

			protected void decorateChild(EditPart child) {
				if (isExternalLabel(child)) {
					return;
				}
				super.decorateChild(child);
			}
<%		}%>

			protected EditPolicy createChildEditPolicy(<%=fqnEditPart%> child) {
				EditPolicy result = super.createChildEditPolicy(child);
				if (result == null) {
					return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy")%>();
				}
				return result;
			}
		};
<%		if (myHelper.hasExternalLabels()) {%>
		<%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%> xlep = new <%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%>() {

			protected boolean isExternalLabel(EditPart editPart) {
				return <%=genNode.getEditPartClassName()%>.this.isExternalLabel(editPart);
			}
		};
		xlep.setRealLayoutEditPolicy(lep);
		return xlep;
<%		} else {%>
		return lep;
<%
		}
		break;
	case ViewmapLayoutType.TOOLBAR_LAYOUT:
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy")%> lep = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy")%>() {
<%		if (myHelper.hasExternalLabels()) {%>

			protected void decorateChild(EditPart child) {
				if (isExternalLabel(child)) {
					return;
				}
				super.decorateChild(child);
			}
<%		}%>

			protected EditPolicy createChildEditPolicy(<%=fqnEditPart%> child) {
				if (child.getEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE) == null) {
					if (child instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart")%>) {
						return new <%=importManager.getImportedName(genDiagram.getTextSelectionEditPolicyQualifiedClassName())%>();
					}
				}
				return super.createChildEditPolicy(child);
			}
		};
<%		if (myHelper.hasExternalLabels()) {%>
		<%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%> xlep = new <%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%>() {

			protected boolean isExternalLabel(EditPart editPart) {
				return <%=genNode.getEditPartClassName()%>.this.isExternalLabel(editPart);
			}
		};
		xlep.setRealLayoutEditPolicy(lep);
		return xlep;
<%		} else {%>
		return lep;
<%
		}
		break;
	case ViewmapLayoutType.FLOW_LAYOUT:
%>
		<%=importManager.getImportedName("org.eclipse.gef.editpolicies.FlowLayoutEditPolicy")%> lep = new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.FlowLayoutEditPolicy")%>() {
<%		if (myHelper.hasExternalLabels()) {%>

			protected void decorateChild(EditPart child) {
				if (isExternalLabel(child)) {
					return;
				}
				super.decorateChild(child);
			}
<%		}%>

<%if (myHelper.hasSideAffixedChildren()) {%>
			protected EditPolicy createChildEditPolicy(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> child) {
				if (child instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart")%>) {
					return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.BorderItemSelectionEditPolicy")%>();
				}
				return super.createChildEditPolicy(child);
			}
<%}%>

			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> createAddCommand(<%=fqnEditPart%> child, <%=fqnEditPart%> after) {
				return null;
			}

			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> createMoveChildCommand(<%=fqnEditPart%> child, <%=fqnEditPart%> after) {
				return null;
			}

			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> getCreateCommand(<%=importManager.getImportedName("org.eclipse.gef.requests.CreateRequest")%> request) {
				return null;
			}
		};
<%		if (myHelper.hasExternalLabels()) {%>
		<%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%> xlep = new <%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%>() {

			protected boolean isExternalLabel(EditPart editPart) {
				return <%=genNode.getEditPartClassName()%>.this.isExternalLabel(editPart);
			}
		};
		xlep.setRealLayoutEditPolicy(lep);
		return xlep;
<%		} else {%>
		return lep;
<%
		}
		break;
	default:
%>
		<%=importManager.getImportedName("org.eclipse.gef.editpolicies.LayoutEditPolicy")%> lep = new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.LayoutEditPolicy")%>() {
<%		if (myHelper.hasExternalLabels()) {%>

			protected void decorateChild(EditPart child) {
				if (isExternalLabel(child)) {
					return;
				}
				super.decorateChild(child);
			}
<%		}%>

			protected EditPolicy createChildEditPolicy(<%=fqnEditPart%> child) {
				EditPolicy result = child.getEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE);
				if( result == null ){
					result = new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.NonResizableEditPolicy")%>();
				}
				return result;
			}

			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> getMoveChildrenCommand(<%=importManager.getImportedName("org.eclipse.gef.Request")%> request) {
				return null;
			}

			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> getCreateCommand(<%=importManager.getImportedName("org.eclipse.gef.requests.CreateRequest")%> request) {
				return null;
			}
		};
<%		if (myHelper.hasExternalLabels()) {%>
		<%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%> xlep = new <%=importManager.getImportedName(genDiagram.getExternalNodeLabelHostLayoutEditPolicyQualifiedClassName())%>() {

			protected boolean isExternalLabel(EditPart editPart) {
				return <%=genNode.getEditPartClassName()%>.this.isExternalLabel(editPart);
			}
		};
		xlep.setRealLayoutEditPolicy(lep);
		return xlep;
<%		} else {%>
		return lep;
<%
		}
} //switch
%>
	}

	/**
	 * @@generated
	 */
	protected IFigure createNodeShape() {
<%
String figureQualifiedClassName = null;
Viewmap viewmap = genNode.getViewmap();
if (viewmap instanceof FigureViewmap) {
	figureQualifiedClassName = ((FigureViewmap) viewmap).getFigureQualifiedClassName();
	if (figureQualifiedClassName == null || figureQualifiedClassName.trim().length() == 0) {
		figureQualifiedClassName = "org.eclipse.draw2d.RectangleFigure";
	}
	figureQualifiedClassName = importManager.getImportedName(figureQualifiedClassName);
%>
		return primaryShape = new <%=figureQualifiedClassName%>()<%if (isXYLayout) {%> {
			protected boolean useLocalCoordinates() {
				return true;
			}
		}<%} // if isXYLayout%>;
<%} // instanceof FigureViewmap
 else if (viewmap instanceof SnippetViewmap) {%>
		return <%=((SnippetViewmap) viewmap).getBody()%>;
<%} // instanceof SnippetViewmap; FIXME : obtain figure class name to generate getter
 else if (viewmap instanceof InnerClassViewmap) {
 	figureQualifiedClassName = ((InnerClassViewmap) viewmap).getClassName();
%>
		<%=figureQualifiedClassName%> figure = new <%=figureQualifiedClassName%>();
<%if (!genNode.getChildNodes().isEmpty() && isXYLayout) { /*otherwise, leave to figure's default value*/%>
 		figure.setUseLocalCoordinates(true);
<%}%>
 		return primaryShape = figure;
<%}%>
	}
<%if (figureQualifiedClassName != null) {%>

	/**
	 * @@generated
	 */
	public <%=figureQualifiedClassName%> getPrimaryShape() {
		return (<%=figureQualifiedClassName%>) primaryShape;
	}
<%}%>

<%
if (myHelper.hasFixedChildren()) {
%>
	/**
	 * @@generated
	 */
	protected boolean addFixedChild(EditPart childEditPart) {
<%
for (Iterator it = myHelper.getInnerFixedLabels(); it.hasNext(); ) {
	GenNodeLabel genLabel = (GenNodeLabel) it.next();
	final String labelEditPart = importManager.getImportedName(genLabel.getEditPartQualifiedClassName());
	final ParentAssignedViewmap childViewmap = (ParentAssignedViewmap) genLabel.getViewmap();
	final String childSetterName = childViewmap.getSetterName() == null ? "setLabel" : childViewmap.getSetterName();
%>
		if (childEditPart instanceof <%=labelEditPart%>) {
			((<%=labelEditPart%>) childEditPart).<%=childSetterName%>(getPrimaryShape().<%=childViewmap.getGetterName()%>());
			return true;
		}
<%
}

for (Iterator it = myHelper.getPinnedCompartments(); it.hasNext(); ) {
	GenCompartment next = (GenCompartment) it.next();
	final ParentAssignedViewmap childViewmap = (ParentAssignedViewmap) next.getViewmap();
	String compartmentEditPartFQN = importManager.getImportedName(next.getEditPartQualifiedClassName());
%>
		if (childEditPart instanceof <%=compartmentEditPartFQN%>) {
			<%=importManager.getImportedName("org.eclipse.draw2d.IFigure")%> pane = getPrimaryShape().<%=childViewmap.getGetterName()%>();
			setupContentPane(pane); // FIXME each comparment should handle his content pane in his own way 
			pane.add(((<%=compartmentEditPartFQN%>)childEditPart).getFigure());
			return true;
		}	
<%	
} // for pinned compartments

for (Iterator it = myHelper.getSideAffixedChildren(); it.hasNext(); ) {
	GenChildSideAffixedNode next = (GenChildSideAffixedNode) it.next();
	String sideAffixedEidtPartFQN = importManager.getImportedName(next.getEditPartQualifiedClassName());
%>
		if (childEditPart instanceof <%=sideAffixedEidtPartFQN%>) {
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemLocator")%> locator = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemLocator")%>(getMainFigure(), <%=importManager.getImportedName("org.eclipse.draw2d.PositionConstants")%>.<%=next.getPreferredSideName()%>);
			getBorderedFigure().getBorderItemContainer().add(((<%=sideAffixedEidtPartFQN%>)childEditPart).getFigure(), locator);
			return true;
		}
<%	
} // for side affixed
%>
		return false;
	}

	/**
	 * @@generated
	 */
	protected boolean removeFixedChild(EditPart childEditPart) {
<%
//XXX: ignore labels assuming that they never may be removed
for (Iterator it = myHelper.getPinnedCompartments(); it.hasNext(); ) {
	GenCompartment next = (GenCompartment) it.next();
	final ParentAssignedViewmap childViewmap = (ParentAssignedViewmap) next.getViewmap();
	String compartmentEditPartFQN = importManager.getImportedName(next.getEditPartQualifiedClassName());
%>		
		if (childEditPart instanceof <%=compartmentEditPartFQN%>) {
			<%=importManager.getImportedName("org.eclipse.draw2d.IFigure")%> pane = getPrimaryShape().<%=childViewmap.getGetterName()%>();
			pane.remove(((<%=compartmentEditPartFQN%>)childEditPart).getFigure());
			return true;
		}	
<%
} // for pinned compartments

for (Iterator it = myHelper.getSideAffixedChildren(); it.hasNext(); ) {
	GenChildNode next = (GenChildNode) it.next();
	String sideAffixedEidtPartFQN = importManager.getImportedName(next.getEditPartQualifiedClassName());
%>
		if (childEditPart instanceof <%=sideAffixedEidtPartFQN%>) {
			getBorderedFigure().getBorderItemContainer().remove(((<%=sideAffixedEidtPartFQN%>)childEditPart).getFigure());
			return true;
		}
<%	
} // for side affixed
%>
		return false;
	}
<%
} // if myHelper.hasFixedChildren()
%>

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure")%> createNodePlate() {
<%
int width = 40;
int height = 40;
DefaultSizeAttributes defSizeAttrs = (DefaultSizeAttributes) genNode.getViewmap().find(DefaultSizeAttributes.class);
if (defSizeAttrs != null) {
	width = defSizeAttrs.getWidth();
	height = defSizeAttrs.getHeight();
}
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure")%> result = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure")%>(getMapMode().DPtoLP(<%=width%>), getMapMode().DPtoLP(<%=height%>));
<%
if (myHelper.isSideAffixed()){		
%>
		//FIXME: workaround for #154536
		result.getBounds().setSize(result.getPreferredSize());
<%
}
%>		
		return result;
	}
<%if (genNode.getViewmap().find(ResizeConstraints.class) != null) {
	final ResizeConstraints rc = (ResizeConstraints) genNode.getViewmap().find(ResizeConstraints.class);
	final String draw2dPC = importManager.getImportedName("org.eclipse.draw2d.PositionConstants");%>

	/**
	 * @@generated
	 */
	public EditPolicy getPrimaryDragEditPolicy() {
		<%=importManager.getImportedName("org.eclipse.gef.editpolicies.ResizableEditPolicy")%> ep = (<%=importManager.getImportedName("org.eclipse.gef.editpolicies.ResizableEditPolicy")%>) super.getPrimaryDragEditPolicy();
		<%if (rc.getResizeHandleNames().isEmpty()) {%>
		ep.setResizeDirections(<%=draw2dPC%>.NONE);
		<% } else {%>
		ep.setResizeDirections(<%for (Iterator rcNamesIter = rc.getResizeHandleNames().iterator(); rcNamesIter.hasNext();) {
			String nextConstantName = (String) rcNamesIter.next();%><%=draw2dPC%>.<%=nextConstantName%><%if (rcNamesIter.hasNext()) {%> | <%}}%>);
		<%}%>
		return ep;
	}
<%}%>

<%if (myHelper.hasSideAffixedChildren()) {%>	 
	/**
	 * Creates figure for this edit part.
	 * 
	 * Body of this method does not depend on settings in generation model
	 * so you may safely remove <i>generated</i> tag and modify it.
	 * 
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure")%> createMainFigure() {
<%} else {%>
	/**
	 * Creates figure for this edit part.
	 * 
	 * Body of this method does not depend on settings in generation model
	 * so you may safely remove <i>generated</i> tag and modify it.
	 * 
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure")%> createNodeFigure() {
<%}%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure")%> figure = createNodePlate();
		figure.setLayoutManager(new StackLayout());
		IFigure shape = createNodeShape();
		figure.add(shape);
		contentPane = setupContentPane(shape);
		return figure;
	}

	/**
	 * Default implementation treats passed figure as content pane.
	 * Respects layout one may have set for generated figure.
	 * @@param nodeShape instance of generated figure class
	 * @@generated
	 */
	protected IFigure setupContentPane(IFigure nodeShape) {
		if (nodeShape.getLayoutManager() == null) {
<%
if (isXYLayout) {
%>
		nodeShape.setLayoutManager(new <%=importManager.getImportedName("org.eclipse.draw2d.FreeformLayout")%>() {

			public Object getConstraint(IFigure figure) {
				Object result = constraints.get(figure);
				if (result == null) {
					result = new <%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%>(0, 0, -1, -1);
				}
				return result;
			}
		});
<%} else {
	String layoutClassName = importManager.getImportedName("org.eclipse.gmf.runtime.draw2d.ui.figures.ConstrainedToolbarLayout");
%>
			<%=layoutClassName%> layout = new <%=layoutClassName%>();
			layout.setSpacing(getMapMode().DPtoLP(5));
			nodeShape.setLayoutManager(layout);
<%}%>
		}
		return nodeShape; // use nodeShape itself as contentPane
	}

	/**
	 * @@generated
	 */
	public IFigure getContentPane() {
		if (contentPane != null) {
			return contentPane;
		}
		return super.getContentPane();
	}
<%
if (myHelper.getPrimaryLabel() != null) {
	GenNodeLabel primaryLabel = myHelper.getPrimaryLabel();
%>

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gef.EditPart")%> getPrimaryChildEditPart() {
		return getChildBySemanticHint(<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getType(<%=importManager.getImportedName(primaryLabel.getEditPartQualifiedClassName())%>.VISUAL_ID));
	}
<%
}
if (myHelper.hasExternalLabels()) {
%>

	/**
	 * @@generated
	 */
	protected boolean isExternalLabel(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> childEditPart) {
<%
	for (Iterator externalLabels = myHelper.getExternalLabels(); externalLabels.hasNext();) {
		GenNodeLabel next = (GenNodeLabel) externalLabels.next();
%>
		if (childEditPart instanceof <%=importManager.getImportedName(next.getEditPartQualifiedClassName())%>) {
			return true;
		}
<%	}%>
		return false;
	}

	/**
	 * @@generated
	 */
	protected IFigure getExternalLabelsContainer() {
		<%=importManager.getImportedName("org.eclipse.gef.editparts.LayerManager")%> root = (<%=importManager.getImportedName("org.eclipse.gef.editparts.LayerManager")%>) getRoot();
		return root.getLayer(<%=importManager.getImportedName(genDiagram.getEditPartFactoryQualifiedClassName())%>.EXTERNAL_NODE_LABELS_LAYER);
	}

<%
}
if (myHelper.hasFixedChildren() || myHelper.hasExternalLabels()) {
%>

	/**
	 * @@generated
	 */
	protected void addChildVisual(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> childEditPart, int index) {
<%	if (myHelper.hasExternalLabels()) {%>
		if (isExternalLabel(childEditPart)) {
			IFigure labelFigure = ((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) childEditPart).getFigure();
			getExternalLabelsContainer().add(labelFigure);
			return;
		} 
<%
	}
	if (myHelper.hasFixedChildren()) {
%>		
		if (addFixedChild(childEditPart)) {
			return;
		}
<%	}%>
		super.addChildVisual(childEditPart, -1);
	}

	/**
	 * @@generated
	 */
	protected void removeChildVisual(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> childEditPart) {
<%	if (myHelper.hasExternalLabels()) {%>
		if (isExternalLabel(childEditPart)) {
			IFigure labelFigure = ((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) childEditPart).getFigure();
			getExternalLabelsContainer().remove(labelFigure);
			return;
		} 
<%
	}
	if (myHelper.hasFixedChildren()){
%>
		if (removeFixedChild(childEditPart)){
			return;
		}
<%	}%>
		super.removeChildVisual(childEditPart);
	}
<%	if (myHelper.hasExternalLabels()) {%>		

	/**
	 * @@generated
	 */
	public void removeNotify() {
		for (<%=importManager.getImportedName("java.util.Iterator")%> it = getChildren().iterator(); it.hasNext();) {
			<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> childEditPart = (<%=importManager.getImportedName("org.eclipse.gef.EditPart")%>) it.next();
			if (isExternalLabel(childEditPart)) {
				IFigure labelFigure = ((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) childEditPart).getFigure();
				getExternalLabelsContainer().remove(labelFigure);
			}
		}
		super.removeNotify();
	}
<%
	}
} // if hasFixedChildren || hasExternalLabels

/*
 * This code is important fore ferreshing shortcut decoration on 
 * adding corresponding annotation to the View instance.
 */
if (genNode instanceof GenTopLevelNode && genDiagram.generateShortcutIcon()) {%>

	/**
	 * @@generated
	 */
	protected void handleNotificationEvent(<%=importManager.getImportedName("org.eclipse.emf.common.notify.Notification")%> event) {
		if (event.getNotifier() == getModel() && <%=importManager.getImportedName("org.eclipse.emf.ecore.EcorePackage")%>.eINSTANCE.getEModelElement_EAnnotations().equals(event.getFeature())) {
			handleMajorSemanticChange();
		} else {
			super.handleNotificationEvent(event);
		}
	}
<%}%>

<%if (genNode.getViewmap() instanceof InnerClassViewmap) {%>
<%=((InnerClassViewmap) genNode.getViewmap()).getClassBody()%>
<%}%>
}
<%importManager.emitSortedImports();%>
@


1.95
log
@change getRevertedIncomingLinks() method to property for xpand templates
@
text
@@


1.94
log
@Processing notification more precisely.
@
text
@d211 1
a211 1
<%if (genNode.needsGraphicalNodeEditPolicy()) {%>
@


1.93
log
@D&D from diagram content navigator to Diagram surface.
@
text
@d757 1
a757 2
		Object feature = event.getFeature();
		if (<%=importManager.getImportedName("org.eclipse.emf.ecore.EcorePackage")%>.eINSTANCE.getEModelElement_EAnnotations().equals(feature)) {
@


1.92
log
@do not generate canonical edit policies unless needed
@
text
@d746 19
a764 1
%>	
@


1.91
log
@refactor common attribute (canonical ep name) into shared superclass, get ready to avoid generation of useless canonicalep classes
@
text
@d220 1
a220 1
if (genDiagram.needsCanonicalEditPolicy()) {%>
@


1.90
log
@[119465] support for diagram partitioning - started to reorganize the way we store behaviours in the genmodel - let them be reused. OpenDiagram as an example of new way to add behaviours.
@
text
@d220 1
a220 1
if (genDiagram.isSynchronized()) {%>
@


1.89
log
@do not generate GraphicalNodeEditPolicy unless there's smth for it to do
@
text
@d11 5
a15 5
	private final List myInnerLabels = new LinkedList();
	private final List myExternalLabels = new LinkedList();
	private final List myPinnedCompartments = new LinkedList();
	private final List myFloatingCompartments = new LinkedList();
	private final List mySideAffixedChildren = new LinkedList();
d217 3
a219 1

@


1.88
log
@[124826] mgolubev - Support nodes with border items
@
text
@d211 1
d213 2
a214 1
<%if (!genNode.getChildNodes().isEmpty()) {%>
@


1.87
log
@add custom behaviour
@
text
@d15 1
d18 2
d46 30
d113 4
d140 1
a140 1
public class <%=genNode.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart")%> {
d207 3
d316 9
d474 12
d508 11
d539 10
a548 1
		return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure")%>(getMapMode().DPtoLP(<%=width%>), getMapMode().DPtoLP(<%=height%>));
d568 12
d589 1
@


1.86
log
@#144885 CCE while moving external node label on diagram
@
text
@d104 1
a104 2
<%{
GenCommonBase genCommonBase = genNode;%>
d180 3
@


1.85
log
@[Fedor Isakov] #127491 When node is removed external label remains, should not
@
text
@d227 10
a236 1
		return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy")%>() {
d247 14
a260 1
<%	break;
d263 10
a272 1
		return new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.FlowLayoutEditPolicy")%>() {
d286 11
d298 1
@


1.84
log
@#144885 CCE while moving external node label on diagram
@
text
@d513 1
a513 2

if (myHelper.hasExternalLabels()){
d527 1
a527 3
<%
	}
%>
a540 1

d548 1
a548 3
<%
if (myHelper.hasExternalLabels()){
%>
d555 2
a556 2
}
if (myHelper.hasFixedChildren()){
d561 1
a561 3
<%
}
%>
d569 1
a569 3
<%
if (myHelper.hasExternalLabels()){
%>
d576 2
a577 2
}
if (myHelper.hasFixedChildren()){
d582 1
a582 3
<%
}
%>
d585 15
d601 2
a602 1
} // if hasFixedChildren || hasExternalLabels 
d605 1
a605 3
<%
if (genNode.getViewmap() instanceof InnerClassViewmap) {
%>
@


1.83
log
@#144885 CCE while moving external node label on diagram
@
text
@d255 2
a256 1
<%	break;
d259 10
a268 1
		return new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.LayoutEditPolicy")%>() {
d286 15
a300 1
<%} //switch %>
@


1.82
log
@use import manager to produce short class name
@
text
@d191 2
a192 3
%>	
		return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy")%>() {

a193 6
			protected <%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%> getCurrentConstraintFor(<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%> child) {
				if (isExternalLabel(child)) {
					return child.getFigure().getBounds().getTranslated(getLayoutOrigin());
				}
				return super.getCurrentConstraintFor(child);
			}
d201 1
a202 1
<%		}%>
d211 14
a224 1
<%	break;
@


1.81
log
@#144885 CCE while moving external node label on diagram
@
text
@d237 1
a237 1
			protected org.eclipse.gef.commands.Command createAddCommand(<%=fqnEditPart%> child, <%=fqnEditPart%> after) {
@


1.80
log
@#145734 Generate "delete from view" popup menu action for not-synchronized diagrams
@
text
@d194 16
@


1.79
log
@Using interface instead of sub-class.
@
text
@d175 4
a179 1
		installEditPolicy(EditPolicyRoles.CANONICAL_ROLE, new <%=importManager.getImportedName(genNode.getCanonicalEditPolicyQualifiedClassName())%>());
@


1.78
log
@use imported name in case of FigureViewmap
@
text
@d489 1
a489 1
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart")%> root = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart")%>) getRoot();
@


1.77
log
@[mgolubev] #139148 Respect gmfgraph.compartment figure
[mgolubev] #143619 Temp fix for misassumption of ParentAssignedViewmap regarding generated getter name
@
text
@d266 1
d268 1
a268 1
		return primaryShape = new <%=importManager.getImportedName(figureQualifiedClassName)%>()<%if (isXYLayout) {%> {
@


1.76
log
@Do not generate unnecessary code, e.g. label figure, when parent gonna assign one.
Explicitly handle (and distinguish) figures assigned by parent (thus placed in predefined location inside parent) and those added as ordinary child figures
InnerClassViewmapProducer updated to guess uses of parent's sub-figure inside children. It's not really a InnerClassViewmapProducer and should be renamed to smth like GeneratingViewmapProducer
Tests updated to cover logic added to the producer
@
text
@d9 73
d131 1
a131 6
boolean hasChildrenInListCompartments = false;
for (Iterator compartments = genNode.getCompartments().iterator(); compartments.hasNext();) {
	GenCompartment compartment = (GenCompartment) compartments.next();
	hasChildrenInListCompartments |= compartment.isListLayout() && !compartment.getChildNodes().isEmpty();
}
if (!genNode.getChildNodes().isEmpty() || hasChildrenInListCompartments) {
d134 1
a134 1
<%	if (hasChildrenInListCompartments) {%>
a258 1
boolean hasFixedChildren = false;
d294 2
d297 1
a297 9
	List innerFixedLabels = new ArrayList(genNode.getLabels().size());
	for (Iterator it = genNode.getLabels().iterator(); it.hasNext(); ) {
		GenNodeLabel genLabel = (GenNodeLabel) it.next();
		if (!(genLabel instanceof GenExternalNodeLabel) && genLabel.getViewmap() instanceof ParentAssignedViewmap) {
			innerFixedLabels.add(genLabel);
		}
	}
	if (!innerFixedLabels.isEmpty()) {
		hasFixedChildren = true;
a298 1

d304 5
a308 5
		for (Iterator it = innerFixedLabels.iterator(); it.hasNext(); ) {
			final GenNodeLabel genLabel = (GenNodeLabel) it.next();
			final String labelEditPart = importManager.getImportedName(genLabel.getEditPartQualifiedClassName());
			final ParentAssignedViewmap childViewmap = (ParentAssignedViewmap) genLabel.getViewmap();
			final String childSetterName = childViewmap.getSetterName() == null ? "setLabel" : childViewmap.getSetterName();
d314 17
a330 1
<%		}%>
d333 17
d351 3
d355 2
a356 1
}
d451 2
a452 2
if (!genNode.getLabels().isEmpty()) {
	GenNodeLabel primaryLabel = (GenNodeLabel) genNode.getLabels().get(0);
d463 2
a464 9
boolean hasExternalLabels = false;
for (Iterator labels = genNode.getLabels().iterator(); labels.hasNext();) {
	GenNodeLabel label = (GenNodeLabel) labels.next();
	if (label instanceof GenExternalNodeLabel) {
		hasExternalLabels = true;
		break;
	}
}
if (hasExternalLabels) {
a469 30
	protected void addChildVisual(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> childEditPart, int index) {
		if (isExternalLabel(childEditPart)) {
			IFigure labelFigure = ((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) childEditPart).getFigure();
			getExternalLabelsContainer().add(labelFigure);
		} else {
<%	if (hasFixedChildren) {%>
			if (!addFixedChild(childEditPart)) {
				super.addChildVisual(childEditPart, -1);
			}
<%	} else {%>
			super.addChildVisual(childEditPart, -1);
<%	}%>
		}
	}

	/**
	 * @@generated
	 */
	protected void removeChildVisual(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> childEditPart) {
		if (isExternalLabel(childEditPart)) {
			IFigure labelFigure = ((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) childEditPart).getFigure();
			getExternalLabelsContainer().remove(labelFigure);
		} else {
			super.removeChildVisual(childEditPart);
		}
	}

	/**
	 * @@generated
	 */
d472 2
a473 3
	for (Iterator labels = genNode.getLabels().iterator(); labels.hasNext();) {
		GenNodeLabel label = (GenNodeLabel) labels.next();
		if (label instanceof GenExternalNodeLabel) {
d475 1
a475 1
		if (childEditPart instanceof <%=importManager.getImportedName(label.getEditPartQualifiedClassName())%>) {
a478 1
		}
d493 29
a521 1
} else if (hasFixedChildren) {%>
d526 15
a540 3
	protected void addChildVisual(EditPart childEditPart, int index) {
		if (!addFixedChild(childEditPart)) {
			super.addChildVisual(childEditPart, -1);
d542 4
d548 4
a551 1
} /*else if hasFixedChildren && !hasExternalLabels*/
@


1.75
log
@#142211 Handle metamodel names that may have clashes with existing class names
@
text
@d228 1
a228 1
	List innerLabels = new ArrayList(genNode.getLabels().size());
d231 2
a232 2
		if (!(genLabel instanceof GenExternalNodeLabel)) {
			innerLabels.add(genLabel);
d235 1
a235 1
	if (!innerLabels.isEmpty()) {
d244 5
a248 16
		for (Iterator it = innerLabels.iterator(); it.hasNext(); ) {
			GenNodeLabel genLabel = (GenNodeLabel) it.next();
			String labelEditPart = importManager.getImportedName(genLabel.getEditPartQualifiedClassName());
			String labelFigureClassName = null;
			boolean isAccessor;
			if (genLabel.getViewmap() instanceof InnerClassViewmap) {
				labelFigureClassName = ((InnerClassViewmap) genLabel.getViewmap()).getClassName();
				isAccessor = true;
			} else if (genLabel.getViewmap() instanceof FigureViewmap) {
				labelFigureClassName = ((FigureViewmap) genLabel.getViewmap()).getFigureQualifiedClassName();
				isAccessor = false;
			} else {
				// temp hack to make tests pass
				labelFigureClassName = "org.eclipse.draw2d.Label";
				isAccessor = false;
			}
d251 1
a251 5
<%			if (isAccessor) {%>
			((<%=labelEditPart%>) childEditPart).setLabel(getPrimaryShape().getFigure<%=labelFigureClassName%>());
<%			} else {%>
			((<%=labelEditPart%>) childEditPart).setLabel(new <%=labelFigureClassName%>());
<%			}%>
d435 1
a435 2
} else {
	if (hasFixedChildren) {%>
d446 1
a446 2
	}
}
@


1.74
log
@Removing unnecessary imports.
@
text
@a19 1
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart");
d30 1
a30 1
public class <%=genNode.getEditPartClassName()%> extends ShapeNodeEditPart {
@


1.73
log
@use importAssistant to emit package statement instead of handcoding
@
text
@a117 1
final String fqnCommand = importManager.getImportedName("org.eclipse.gef.commands.Command");
d155 1
a155 1
			protected <%=fqnCommand%> createMoveChildCommand(<%=fqnEditPart%> child, <%=fqnEditPart%> after) {
d159 1
a159 1
			protected <%=fqnCommand%> getCreateCommand(<%=importManager.getImportedName("org.eclipse.gef.requests.CreateRequest")%> request) {
d176 1
a176 1
			protected <%=fqnCommand%> getMoveChildrenCommand(<%=importManager.getImportedName("org.eclipse.gef.Request")%> request) {
d180 1
a180 1
			protected <%=fqnCommand%> getCreateCommand(<%=importManager.getImportedName("org.eclipse.gef.requests.CreateRequest")%> request) {
@


1.72
log
@separate layout policy creation into separate method to ease overriding
@
text
@d5 2
a6 1
GenNode genNode = (GenNode) ((Object[]) argument)[0];
d11 1
a11 1
package <%=genDiagram.getEditPartsPackageName()%>;
a13 1
ImportUtil importManager = new ImportUtil(genDiagram.getEditPartsPackageName());
@


1.71
log
@[mgolubev] #140186 XYLayoutEditPolicy should not be installed for editparts that have figure with non-XYLayout in the gmfgraph model
@
text
@d110 7
d123 1
a123 1
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy")%>() {
d132 1
a132 1
		});
d136 1
a136 1
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy")%>() {
d146 1
a146 1
		});
d150 1
a150 1
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.FlowLayoutEditPolicy")%>() {
d163 1
a163 1
		});
d167 1
a167 1
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.LayoutEditPolicy")%>() {
d184 1
a184 2
		});

@


1.70
log
@Updating with latest state of the code.
@
text
@d7 1
a7 1
boolean useFlowLayout = !genNode.isListLayout();
d110 6
a115 1
<%if (useFlowLayout) {%>
d118 1
a118 1
			protected EditPolicy createChildEditPolicy(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> child) {
d126 3
a128 1
<%} else {%>
d131 1
a131 1
			protected EditPolicy createChildEditPolicy(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> child) {
d140 40
a179 1
<%}%>
d196 1
a196 1
		return primaryShape = new <%=importManager.getImportedName(figureQualifiedClassName)%>()<%if (useFlowLayout) {%> {
d200 1
a200 1
		}<%} // use flow layout%>;
d209 1
a209 1
<%if (!genNode.getChildNodes().isEmpty() && useFlowLayout) { /*otherwise, leave to figure's default value*/%>
d332 1
a332 2
if (!useFlowLayout) {
	String layoutClassName = importManager.getImportedName("org.eclipse.gmf.runtime.draw2d.ui.figures.ConstrainedToolbarLayout");
a333 4
			<%=layoutClassName%> layout = new <%=layoutClassName%>();
			layout.setSpacing(getMapMode().DPtoLP(5));
			nodeShape.setLayoutManager(layout);
<%} else {%>
d344 6
@


1.69
log
@reflect changes made possible with #134462 - just set constant value instead of overriding method
@
text
@d255 2
a256 1
			String nextConstantName = (String) rcNamesIter.next();%><%=draw2dPC%>.<%=nextConstantName%><%if (rcNamesIter.hasNext()) {%> | <%}}}%>);
@


1.68
log
@support "NodeFigure", "DefaultSizeNodeFigure" and "Connection" as gmfgraph figure names
@
text
@d244 1
a244 1
	final String javaUtilList = importManager.getImportedName("java.util.List");%>
d250 7
a256 19
		return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy")%>() {
			protected <%=javaUtilList%> createSelectionHandles() {
				final <%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%> part = (<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) getHost();
				final <%=javaUtilList%> list = new <%=importManager.getImportedName("java.util.ArrayList")%>();
				addMoveHandle(part, list);
				<%for (Iterator it = rc.getResizeHandleNames().iterator(); it.hasNext();) {
					String next = (String) it.next();%>
				<%=importManager.getImportedName("org.eclipse.gef.handles.ResizableHandleKit")%>.addHandle(part, list, <%=importManager.getImportedName("org.eclipse.draw2d.PositionConstants")%>.<%=next%>);
				<%} for (Iterator it = rc.getNonResizeHandleNames().iterator(); it.hasNext();) {
					String next = (String) it.next();%>
				<%=importManager.getImportedName("org.eclipse.gef.handles.NonResizableHandleKit")%>.addHandle(part, list, <%=importManager.getImportedName("org.eclipse.draw2d.PositionConstants")%>.<%=next%>);
				<%}%>
				return list;
			}
			private void addMoveHandle(final <%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%> part, final <%=javaUtilList%> list) {
				<%=importManager.getImportedName("org.eclipse.gef.handles.MoveHandle")%> moveHandle = new <%=importManager.getImportedName("org.eclipse.gef.handles.MoveHandle")%>(part);
				list.add(moveHandle);
			}
		};
@


1.67
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d14 3
a24 3
if (genNode.getViewmap() instanceof InnerClassViewmap) {
importManager.registerInnerClass(((InnerClassViewmap) genNode.getViewmap()).getClassName());
}
d230 1
a230 1
	protected NodeFigure createNodePlate() {
d240 1
a240 1
		return new DefaultSizeNodeFigure(getMapMode().DPtoLP(<%=width%>), getMapMode().DPtoLP(<%=height%>));
d279 2
a280 2
	protected NodeFigure createNodeFigure() {
		NodeFigure figure = createNodePlate();
@


1.66
log
@#136816 No selection feedback is provided for nodes with resize constraint NONE
@
text
@d86 1
a86 1
								getChildBySemanticHint(<%=importManager.getImportedName(compartment.getEditPartQualifiedClassName())%>.VISUAL_ID);
d337 1
a337 1
		return getChildBySemanticHint(<%=importManager.getImportedName(primaryLabel.getEditPartQualifiedClassName())%>.VISUAL_ID);
@


1.65
log
@Correcting attribute value.
@
text
@a265 2
				// just make it look nice <%// FIXME file bug against GEF to provide overridable method in ResizableEditPolicy itself%>
				moveHandle.setBorder(null);
@


1.64
log
@do not generate unused imports for the not resizable edit parts
@
text
@d164 1
a164 1
 		figure.setUseLocalCoordinates("true");
@


1.63
log
@#135693 Use decoration service to provide shortcut image
@
text
@a14 1
importManager.addImport("org.eclipse.draw2d.PositionConstants");
a243 1
	final String draw2dPositionConstraints = importManager.getImportedName("org.eclipse.draw2d.PositionConstants");
d257 1
a257 1
				<%=importManager.getImportedName("org.eclipse.gef.handles.ResizableHandleKit")%>.addHandle(part, list, <%=draw2dPositionConstraints%>.<%=next%>);
d260 1
a260 1
				<%=importManager.getImportedName("org.eclipse.gef.handles.NonResizableHandleKit")%>.addHandle(part, list, <%=draw2dPositionConstraints%>.<%=next%>);
@


1.62
log
@#135015 some heuristic to provide valid default useLocalCoordinates.
@
text
@a13 2
importManager.addImport("org.eclipse.draw2d.BorderLayout");
importManager.addImport("org.eclipse.draw2d.Figure");
a22 2
importManager.addImport("org.eclipse.emf.ecore.EAnnotation");
importManager.addImport("org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ImageFigureEx");
a288 6
		
		IFigure decorationShape = createDecorationPane();
		if (decorationShape != null) {
			figure.add(decorationShape);
		}

a290 18
	
	/**
	 * @@generated
	 */
	private IFigure createDecorationPane() {
		View view = (View) getModel();
		EAnnotation annotation = view.getEAnnotation("Shortcut"); //$NON-NLS-1$
		if (annotation == null) {
			return null;
		}
		
		Figure decorationPane = new Figure();
		decorationPane.setLayoutManager(new BorderLayout());

		ImageFigureEx imageFigure = new ImageFigureEx(<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getBundledImage("icons/shortcut.gif"), PositionConstants.EAST);
		decorationPane.add(imageFigure, BorderLayout.BOTTOM);
		return decorationPane;
	}
@


1.61
log
@#125900 Redundant annotations added to View in generated view factory

semantic hint class name plroperty removed from the model.
@
text
@d168 3
a170 1
 		figure.setUseLocalCoordinates(<%=useFlowLayout ? "true" : "false"%>);
@


1.60
log
@#135694 remove temporary code
@
text
@a11 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart;
d131 1
a131 1
					if (child instanceof ITextAwareEditPart) {
@


1.59
log
@#125900 Redundant annotations added to View in generated view factory

Visual ID used as a semantic hint for creation of all the diagram elements.
@
text
@d12 1
@


1.58
log
@#114061 Support shape with fixed horizontal/vertical size. First, 'resize' part of the request was covered.
Obsolete ShapeAttributes class was deleted, same attributes should be set in gmfgraph now.
@
text
@d37 4
d91 1
a91 1
								getChildBySemanticHint(<%=importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName())%>.<%=genNode.getUniqueIdentifier()%>Compartments.<%=compartment.getSemanticHintFieldName()%>);
a360 2
	String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
	String labelName = primaryLabel.getSemanticHintFieldName();
d367 1
a367 1
		return getChildBySemanticHint(<%=semanticHintsClassName%>.<%=genNode.getUniqueIdentifier()%>Labels.<%=labelName%>);
@


1.57
log
@Class names of Figures generated as inner classes may clash with well-known classes, thus we have to make sure we avoid that
@
text
@d241 4
d247 27
@


1.56
log
@expand compartments
@
text
@d27 3
@


1.55
log
@do not generate accessors for the ext node labels
@
text
@d290 1
a290 1
	String layoutClassName = importManager.getImportedName("org.eclipse.draw2d.ToolbarLayout");
@


1.54
log
@remove label cast
@
text
@d174 8
a181 1
	if (!genNode.getLabels().isEmpty()) {
d190 1
a190 1
		for (Iterator it = genNode.getLabels().iterator(); it.hasNext(); ) {
a349 1
<%	if (hasFixedChildren) {%>
a350 1
			addFixedChild(childEditPart);
d354 1
a357 1
		}
a358 4
		if (isExternalLabel(childEditPart)) {
			IFigure labelFigure = ((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) childEditPart).getFigure();
			getExternalLabelsContainer().add(labelFigure);
		} else {
d360 1
a361 1
<%	}%>
@


1.53
log
@fix external node labels
@
text
@d202 1
a202 2
			((<%=labelEditPart%>) childEditPart).setLabel(
				(<%=importManager.getImportedName("org.eclipse.draw2d.Label")%>) getPrimaryShape().getFigure<%=labelFigureClassName%>());
@


1.52
log
@do not readd labels
@
text
@d139 1
d173 4
a176 1
<%	if (!genNode.getLabels().isEmpty()) {%>
d181 1
a181 1
	protected void addChildVisual(EditPart childEditPart, int index) {
d201 1
a201 1
<%if (isAccessor) {%>
d204 1
a204 1
<%} else {%>
d206 2
a207 2
<%}%>
			return;
d210 1
a210 1
		super.addChildVisual(childEditPart, index);
d344 11
d361 1
d404 13
@


1.51
log
@provide custom text selection edit policy
@
text
@d203 1
@


1.50
log
@show selection; update default text
@
text
@d27 2
a28 1
importManager.markImportLocation(stringBuffer);%>
d110 1
d119 12
@


1.49
log
@simplified hierarchy of figures
@
text
@d70 4
a73 2
						<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.core.edithelpers.CreateElementRequestAdapter")%> adapter = ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewAndElementRequest")%>) request).getViewAndElementDescriptor().getCreateElementRequestAdapter();
						<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%> type = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>) adapter.getAdapter(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>.class);
d82 2
a83 1
							<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> compartmentEditPart = getChildBySemanticHint(<%=importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName())%>.<%=genNode.getUniqueIdentifier()%>Compartments.<%=compartment.getSemanticHintFieldName()%>);
d184 2
a185 1
			((<%=labelEditPart%>) childEditPart).setLabel(getPrimaryShape().getFigure<%=labelFigureClassName%>());
d265 1
a265 1
	String layoutClassName = importManager.getImportedName("org.eclipse.gmf.runtime.draw2d.ui.figures.ConstrainedToolbarLayout");
d270 1
a270 4
<%
} else {
// Flow layout
%>
d272 1
d281 1
a281 3
<%
}
%>
@


1.48
log
@fix tests errors (viewmaps in tests use FigureViewmap)
@
text
@d15 1
d17 1
d223 5
a227 2
		if (shape.getLayoutManager() == null){
			shape.setLayoutManager(new StackLayout());
a228 6
		
		IFigure shapeContents = new Figure();
		shape.add(shapeContents);
		shapeContents.setLayoutManager(new BorderLayout());
		addContentPane(shapeContents);
		decorateShape(shapeContents);
d236 1
a236 1
	private void decorateShape(IFigure shapeContents) {
d240 1
a240 1
			return;
d245 4
a248 4
		shapeContents.add(decorationPane, BorderLayout.BOTTOM);
		
		ImageFigureEx imageFigure = new ImageFigureEx(<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getBundledImage("icons/shortcut.gif"));
		decorationPane.add(imageFigure, BorderLayout.RIGHT);
d252 3
d257 2
a258 3
	protected void addContentPane(IFigure shape) {
		contentPane = new <%=importManager.getImportedName("org.eclipse.draw2d.Figure")%>();
		shape.add(contentPane, BorderLayout.CENTER);
d263 3
a265 3
		<%=layoutClassName%> layout = new <%=layoutClassName%>();
		layout.setSpacing(getMapMode().DPtoLP(5));
		contentPane.setLayoutManager(layout);
d270 1
a270 1
		contentPane.setLayoutManager(new <%=importManager.getImportedName("org.eclipse.draw2d.FreeformLayout")%>() {
d282 2
@


1.47
log
@use Labels instead of WrapLabels
@
text
@d164 1
d167 8
d178 1
d180 3
@


1.46
log
@do not generate unused code when there are no compartments
@
text
@d40 5
d120 1
a122 1
	String figureQualifiedClassName = null;
d128 1
a128 1
		return new <%=importManager.getImportedName(figureQualifiedClassName)%>()<%if (useFlowLayout) {%> {
d136 5
a140 3
<%} // instanceof SnippetViewmap 
 else if (viewmap instanceof InnerClassViewmap) {%>
		<%=((InnerClassViewmap) viewmap).getClassName()%> figure = new <%=((InnerClassViewmap) viewmap).getClassName()%>();
d142 1
a142 1
 		return figure;
d145 33
@


1.45
log
@#129145 do not use intermediate TextCompartmentEditParts
@
text
@d49 1
a49 1
boolean hasActualChildren = !genNode.getChildNodes().isEmpty();
d52 1
a52 1
	hasActualChildren |= compartment.isListLayout() && !compartment.getChildNodes().isEmpty();
d54 1
a54 1
if (hasActualChildren) {
d56 3
a58 1
		installEditPolicy(EditPolicyRoles.CREATION_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy")%>() {
d66 5
a70 5
	for (Iterator compartments = genNode.getCompartments().iterator(); compartments.hasNext();) {
		GenCompartment compartment = (GenCompartment) compartments.next();
		if (compartment.isListLayout() && !compartment.getChildNodes().isEmpty()) {
			for (Iterator children = compartment.getChildNodes().iterator(); children.hasNext(); ) {
				GenNode child = (GenNode) children.next();
d77 1
a79 1
	}
d86 4
a89 4
		});
<%
}
%>
d93 1
a93 3
<%
if (!genNode.getChildNodes().isEmpty()) {
%>
d95 1
a95 3
<%
}
%>
d97 1
a97 3
<%
if (useFlowLayout) {
%>
@


1.44
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@a247 3
	if (primaryLabel instanceof GenExternalNodeLabel) {
		labelName = ((GenExternalNodeLabel) primaryLabel).getSemanticHintLabelFieldName();
	}
d261 1
a261 1
	if (label instanceof ExternalLabel) {
d300 1
a300 1
		if (label instanceof ExternalLabel) {
@


1.43
log
@#127696 Templates should use new transaction API
@
text
@d9 1
@


1.42
log
@Adding "setUseLocalCoordinates" method.
Useful for inner shape-figures located outside of compartment.
@
text
@d189 1
a189 1
		EAnnotation annotation = view.getEAnnotation("Shortcutted"); //$NON-NLS-1$
@


1.41
log
@using importManager to add imports.
@
text
@d136 3
a138 1
 		return new <%=((InnerClassViewmap) viewmap).getClassName()%>();
@


1.40
log
@Registering createion edit policy before all the rest.
@
text
@d11 14
a24 13
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditPartsPackageName());%>
import org.eclipse.draw2d.BorderLayout;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.StackLayout;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure;
import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ImageFigureEx;
<%importManager.markImportLocation(stringBuffer);%>
@


1.39
log
@[mgolubev] #127252 layout support
@
text
@a45 3
		super.createDefaultEditPolicies();
		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE, new <%=importManager.getImportedName(genNode.getItemSemanticEditPolicyQualifiedClassName())%>());
		installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new <%=importManager.getImportedName(genNode.getGraphicalNodeEditPolicyQualifiedClassName())%>());
d85 5
@


1.38
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d166 3
a168 1
		shape.setLayoutManager(new StackLayout());
@


1.37
log
@#126896
generating CanonicalEditPolicy for visualizing containment reference as diagram link.
@
text
@d5 1
a5 1
GenNode genNode = (GenNode) argument;
@


1.36
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d91 3
a95 1
}
@


1.35
log
@ImportManager moved to oeg.common
@
text
@d189 1
a189 1
		ImageFigureEx imageFigure = new ImageFigureEx(<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.getInstance().getBundledImage("icons/shortcut.gif"));
@


1.34
log
@GenDiagram "slicing" goes on and this time attributes related to plugin activator class were moved into separate entity
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"
@


1.33
log
@#124830 Add all children of the list compartment to the popup bar of the parent node
@
text
@d189 1
a189 1
		ImageFigureEx imageFigure = new ImageFigureEx(<%=importManager.getImportedName(genDiagram.getPluginQualifiedClassName())%>.getInstance().getBundledImage("icons/shortcut.gif"));
@


1.32
log
@- Border should be defined in gmfgraph model
- Setter for features with "isList() == true" corrected
@
text
@a45 3
<%if (!genNode.getChildNodes().isEmpty()) {%>
		installEditPolicy(EditPolicyRoles.CREATION_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy")%>());
<%}%>
d49 41
a89 2
<%if (!genNode.getChildNodes().isEmpty()) {%>
		installEditPolicy(EditPolicyRoles.CREATION_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy")%>());
d92 4
a95 2
<%}%>
<%if (useFlowLayout) {%>
d111 2
a112 1
	protected IFigure createNodeShape() {<%
@


1.31
log
@#112054 direct edit and correct placement
@
text
@a17 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.RectangularDropShadowLineBorder;
a121 1
		figure.setBorder(new RectangularDropShadowLineBorder(1));
@


1.30
log
@prevent ArrayIndexOutOfBoundsException with external node labels
@
text
@d200 4
d210 1
a210 1
		return getChildBySemanticHint(<%=semanticHintsClassName%>.<%=genNode.getUniqueIdentifier()%>Labels.<%=primaryLabel.getSemanticHintFieldName()%>);
@


1.29
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@a15 2
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
d208 12
a219 1
<%}%>
d226 1
a226 1
			IFigure labelFigure = ((GraphicalEditPart) childEditPart).getFigure();
d229 1
a229 1
			super.addChildVisual(childEditPart, index);
d238 1
a238 1
			IFigure labelFigure = ((GraphicalEditPart) childEditPart).getFigure();
d250 3
a252 3
for (Iterator labels = genNode.getLabels().iterator(); labels.hasNext();) {
	GenNodeLabel label = (GenNodeLabel) labels.next();
	if (label instanceof ExternalLabel) {
d258 1
a259 1
}
d268 1
a268 1
		DiagramRootEditPart root = (DiagramRootEditPart) getRoot();
d272 4
a275 1
<%if (genNode.getViewmap() instanceof InnerClassViewmap) {%>
@


1.28
log
@Correcting border width. It is important for an inner elements layed out in XY.
@
text
@d7 1
a7 1
boolean useFlowLayout = genNode.getChildContainersPlacement() == CompartmentPlacementKind.FLOW_LITERAL;
@


1.27
log
@correcting creation of EP in case of XY layout
@
text
@d125 1
a125 1
		figure.setBorder(new RectangularDropShadowLineBorder(0));
@


1.26
log
@Imports added
@
text
@d65 1
a65 5
					if (result == null && child instanceof SubDetail_subDetailNameEditPart) {
						return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy")%>();
					} else if (result == null && child instanceof SubDetail_CompartmentEditPart) {
						return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy")%>();
					}
@


1.25
log
@#122054 support external node labels
@
text
@d62 1
a62 1
			protected EditPolicy createChildEditPolicy(EditPart child) {
d219 1
a219 1
	protected void addChildVisual(EditPart childEditPart, int index) {
d231 1
a231 1
	protected void removeChildVisual(EditPart childEditPart) {
d243 1
a243 1
	protected boolean isExternalLabel(EditPart childEditPart) {
@


1.24
log
@As a part of implementstion
#114178,114179
"Shortcutting" diagram elements.
@
text
@d2 1
a2 1
	imports="org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"
d16 2
d216 51
@


1.23
log
@New plugin with IFigure codegeneration to support #114177 (graphical definition model) was added
@
text
@d12 1
d22 2
d85 1
a85 1
}
d131 8
a138 1
		addContentPane(shape);
d141 18
a163 1
<%if (genNode.isExplicitContentPane()) {%>
d165 1
a165 4
		shape.setLayoutManager(new StackLayout());
		shape.add(contentPane);
<%} else {%>
		contentPane = shape;
a166 2
}

@


1.22
log
@one more flavor of snippet viewmap - inner class
@
text
@a12 1
import org.eclipse.draw2d.Shape;
@


1.21
log
@With #114177 in mind, viewmaps in genmodel should be simplistic as much as possible, no need to duplicate figure descriptions available in gmfgraph (and/or code generated from it)
@
text
@d93 3
d192 4
@


1.20
log
@#121581
Fields for the compartments are named unique.
@
text
@d76 1
a76 2
	protected IFigure createNodeShape() {
<%
a77 1
String figureQualifiedClassName = null;
d79 1
d81 2
a82 3
}
if (figureQualifiedClassName == null || figureQualifiedClassName.trim().length() == 0) {
	figureQualifiedClassName = "org.eclipse.draw2d.RectangleFigure";
d89 5
a93 8
}<%}%>;
	}

	/**
	 * @@generated
	 */
	protected void decorateNodeShape(Shape shape) {
<%@@ include file="shapeattrs.jetinc"%>
a124 3
		if (shape instanceof Shape) {
			decorateNodeShape((Shape) shape);
		}
@


1.19
log
@#118059
- ChildNodes could be places directly inside the node, without compartment
- XY layout is possible for Gen*Nodes
@
text
@d194 1
a194 1
		return getChildBySemanticHint(<%=semanticHintsClassName%>.<%=genNode.getUniqueIdentifier()%>Labels.<%=AccessUtil.getLabelTextId(primaryLabel)%>);
@


1.18
log
@Temporary commenting out the code
@
text
@d7 1
d45 3
d56 15
d87 5
a91 1
		return new <%=importManager.getImportedName(figureQualifiedClassName)%>();
d151 1
a151 1
//if (genNode.getChildContainersPlacement() == CompartmentPlacementKind.TOOLBAR_LITERAL) {
d158 1
a158 1
//} else {
d161 9
a169 1
//		contentPane.setLayoutManager(new <%=importManager.getImportedName("org.eclipse.draw2d.FreeformLayout")%>());
d171 1
a171 1
//}
@


1.17
log
@Not finished: childnodes could be contained in node, not only in compartment.
@
text
@d138 1
a138 1
		contentPane.setLayoutManager(new <%=importManager.getImportedName("org.eclipse.draw2d.FreeformLayout")%>());
@


1.16
log
@#112318 Do not overwrite paintFigure() method in node edit part when specific figure class is specified
@
text
@a16 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.ConstrainedToolbarLayout;
d125 7
a131 2
<%}%>
		ConstrainedToolbarLayout layout = new ConstrainedToolbarLayout();
d134 8
@


1.15
log
@#117660 move canonical edit policy into separate class to shorten it's file name
@
text
@d2 1
a2 1
	imports="org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.* java.util.*"
a10 2
import org.eclipse.draw2d.Figure;
import org.eclipse.draw2d.Graphics;
d12 1
a13 1
import org.eclipse.gef.EditPart;
d18 2
d32 1
a32 1
	private IFigure contentPane;
d58 1
a58 1
	protected NodeFigure createNodeFigure() {
d60 7
a66 5
String figureClassName;
if (genNode.getViewmap() instanceof FigureViewmap) {
	figureClassName = importManager.getImportedName(((FigureViewmap) genNode.getViewmap()).getFigureQualifiedClassName());
} else {
	figureClassName = importManager.getImportedName("org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure");
d68 10
a77 2
%> 
		<%=figureClassName%> node = new <%=figureClassName%>() {
d79 4
a82 6
			protected void paintFigure(Graphics graphics) {
				super.paintFigure(graphics);
				graphics.fillRectangle(getClientArea());
				graphics.drawRectangle(getClientArea());
			}
		};
d84 7
a90 10
for (Iterator it = genNode.getViewmap().getAttributes().iterator(); it.hasNext();) {
	Attributes next = (Attributes) it.next();
	if (next instanceof ShapeAttributes) {
		String figureVarName = "node";
		ShapeAttributes attrs = (ShapeAttributes) next;
%>
<%@@ include file="shapeattrs.jetinc" %>
<%	}
	if (next instanceof DefaultSizeAttributes) {
		DefaultSizeAttributes attrs = (DefaultSizeAttributes) next;
d92 1
a92 2
		node.setDefaultSize(getMapMode().DPtoLP(<%=attrs.getWidth()%>), getMapMode().DPtoLP(<%=attrs.getHeight()%>));
<%
d94 20
a113 5
}
%>
		node.setLayoutManager(new StackLayout());
		node.add(contentPane = createContentPane());
		return node;
d119 8
a126 2
	protected IFigure createContentPane() {
		IFigure plate = new Figure();
d129 1
a129 2
		plate.setLayoutManager(layout);
		return plate;
d150 1
a150 1
	public EditPart getPrimaryChildEditPart() {
@


1.14
log
@#116797 provide option in gmfgen model for the links to align direction in view with direction in model
@
text
@d48 1
a48 1
<%if (genNode.getChildNodes().size() > 0) {%>		
d51 1
a51 1
		installEditPolicy(EditPolicyRoles.CANONICAL_ROLE, new <%=genNode.getEditPartClassName()%>CanonicalEditPolicy());
d129 1
a129 12
	
<%
}

if (genNode.getChildNodes().size() > 0) {
	GenChildContainer childContainer = genNode;
	GenNode containerNode = genNode;
%>
<%@@ include file="childContainerCanonicalEditPolicy.jetinc" %>	
<%
}
%>
@


1.13
log
@#116655

Generating correct access for all the features.
@
text
@d16 1
d47 2
a48 3
<%
if (genNode.getChildNodes().size() > 0) {
%>		
d52 1
a52 3
<%
}
%>
@


1.12
log
@#115972 generate single class with semantic hints
@
text
@d2 2
a3 1
	imports="org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.* java.util.*"%>
@


1.11
log
@Using MapMode from editpart
@
text
@d121 1
a121 2
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
	String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d128 1
a128 1
		return getChildBySemanticHint(<%=semanticHintsClassName%>.Labels.<%=AccessUtil.getLabelTextId(primaryLabel)%>);
@


1.10
log
@#115861
ChildNode could be created not only in the compartment, but directly in it's parent.
@
text
@a17 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
d88 1
a88 1
		node.setDefaultSize(MapModeUtil.getMapMode().DPtoLP(<%=attrs.getWidth()%>), MapModeUtil.getMapMode().DPtoLP(<%=attrs.getHeight()%>));
d104 1
a104 1
		layout.setSpacing(MapModeUtil.getMapMode().DPtoLP(5));
@


1.9
log
@[dstadnik] #115466 custom semantic edit policies to control link creation
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.* java.util.*"%>
d18 1
a18 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d46 9
d89 1
a89 1
		node.setDefaultSize(MapMode.DPtoLP(<%=attrs.getWidth()%>), MapMode.DPtoLP(<%=attrs.getHeight()%>));
d105 1
a105 1
		layout.setSpacing(MapMode.DPtoLP(5));
d132 12
a143 1
<%}%>
@


1.8
log
@[dstadnik] #112195 multiple labels for the node, facets introduced, genmodel cleaned and refactored
@
text
@d16 1
d43 8
@


1.7
log
@[dstadnik] #112313 compilation errors when using DefaultSizeAttrs
@
text
@a19 3
<%if (genNode.hasNameToEdit()) {%>
import <%=genDiagram.getProvidersPackageName()%>.<%=AccessUtil.getSemanticHintsClassName(genNode)%>;
<%}%>
d59 2
a60 1
<%for (Iterator it = genNode.getViewmap().getAttributes().iterator(); it.hasNext();) {
d72 2
a73 1
<%	}
d101 6
a106 1
<%if (genNode.hasNameToEdit()) {%>
d112 1
a112 1
		return getChildBySemanticHint(<%=AccessUtil.getSemanticHintsClassName(genNode)%>.<%=AccessUtil.getNameSemanticHint(genNode)%>);
d115 2
a116 1
}<%importManager.emitSortedImports();%>
@


1.6
log
@[dstadnik] #112189 remove editProviders package attribute from genmodel
@
text
@d54 1
a54 1
		NodeFigure node = new <%=figureClassName%>() {
@


1.5
log
@[dstadnik]
#111455 Generate consistent names for notation view factories
#111461 Do not use 'final' keyword in method parameters
#111460 Generate dedicated edit part for the node label
#111457 Use model labels in palette factory
@
text
@d21 1
a21 1
import <%=genDiagram.getEditProvidersPackageName()%>.<%=AccessUtil.getSemanticHintsClassName(genNode)%>;
@


1.4
log
@figure class could be specified in .gmfgen along with dependent attributes. Notion of "Viewmap" captures that (visualization) information
@
text
@d23 1
@


1.3
log
@[dstadnik] support for (a) connections (with associated domain class) and (b) compartments
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
d9 1
a17 1
import org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure;
d45 9
a53 1
		NodeFigure node = new DefaultSizeNodeFigure(MapMode.DPtoLP(40), MapMode.DPtoLP(30)) {
d61 15
d110 1
a110 1
}
@


1.2
log
@[dstadnik] Use Notation Model as runtime model
@
text
@d2 1
a2 1
  imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
d45 1
a45 1
		NodeFigure node = new DefaultSizeNodeFigure(MapMode.DPtoLP(50), MapMode.DPtoLP(50)) {
d49 1
@


1.1
log
@*** empty log message ***
@
text
@d1 2
a2 1
<%@@ jet package="org.eclipse.gmf.codegen.templates.diacanvas" class="NodeEditPartGen" imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* java.util.* org.eclipse.gmf.codegen.util.ImportUtil"%>
a7 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditPartsPackageName());%>
d9 14
a22 22
import java.util.*;
import org.eclipse.draw2d.*;
import org.eclipse.emf.edit.domain.*;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.gef.*;
import org.eclipse.gef.commands.*;
import org.eclipse.gef.editparts.*;
import org.eclipse.gef.editpolicies.*;
import org.eclipse.gef.requests.*;
import org.eclipse.gef.tools.*;
<%importManager.addImport("org.eclipse.gmf.diagramrt.*");%>
import org.eclipse.gmf.runtime.gef.DefaultDirectEditManager;
import org.eclipse.gmf.runtime.gef.CompartmentsContentPane;
import org.eclipse.gmf.runtime.gef.commands.ChangeDiagramElementNameCommand;
import org.eclipse.gmf.runtime.gef.commands.CreateChildNodeCommand;
import org.eclipse.gmf.runtime.gef.commands.CreateDiagramLinkCommand;
import org.eclipse.gmf.runtime.gef.commands.DeleteDiagramNodeCommand;
import org.eclipse.gmf.runtime.update.UpdatablePart;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.Font;
<%importManager.markImportLocation(stringBuffer);%>
d27 1
a27 6
public class <%=genNode.getEditPartClassName()%> extends AbstractGraphicalEditPart implements org.eclipse.gef.NodeEditPart, UpdatablePart {
	/**
	 * @@generated
	 */
	public static final int VISUAL_ID = <%=genNode.getVisualID()%>;
<%if (genNode.hasNameToEdit()) {%>
d32 1
a32 17
	protected DirectEditManager myManager;

	/**
	 * @@generated
	 */
	private IFigure myDirectEditFigure;
<%}%>
<%if (!genNode.getChildContainers().isEmpty()) {%>
	/**
	 * @@generated
	 */
	private CompartmentsContentPane myContentPane;
<%}%>
	/**
	 * @@generated
	 */
	private ConnectionAnchor myAnchor;
d37 2
a38 2
	public <%=genNode.getEditPartClassName()%>(DiagramNode model) {
		setModel(model);
d44 2
a45 10
	protected void createEditPolicies() {
		// super.createEditPolicies();
		installEditPolicy(EditPolicy.LAYOUT_ROLE, createLayoutPolicy());
		installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, createGraphicalNodePolicy());
		installEditPolicy(EditPolicy.COMPONENT_ROLE, createComponentPolicy());
<%if (genNode.hasNameToEdit()) {%>
		installEditPolicy(EditPolicy.DIRECT_EDIT_ROLE, createDirectEditPolicy());
<%}%>
		installEditPolicy(EditPolicy.SELECTION_FEEDBACK_ROLE, createSelectionFeedbackPolicy());
	}
d47 3
a49 9
	/**
	 * @@generated
	 */
	protected EditPolicy createSelectionFeedbackPolicy() {
		return new ResizableEditPolicy() {
			protected IFigure createDragSourceFeedbackFigure() {
				IFigure feedback = super.createDragSourceFeedbackFigure();
				feedback.setForegroundColor(ColorConstants.darkGray);
				return feedback;
d52 3
d60 6
a65 11
	protected EditPolicy createComponentPolicy() {
		return new ComponentEditPolicy() {
			protected Command createDeleteCommand(GroupRequest deleteRequest) {
				// FIXME deleteRequest is GroupRequest. Should I respect editPart(s!) from request
				// rather then taking model of this editPart?
				if (deleteRequest.getEditParts().size() != 1 && deleteRequest.getEditParts().get(0) != getDiagramNode()) {
					System.err.println("WARNING: needs fix!");
				}
				return new DeleteDiagramNodeCommand(getDiagramNode());
			}
		};
d71 5
a75 40
	protected EditPolicy createLayoutPolicy() {
		return new LayoutEditPolicy() {
			protected EditPolicy createChildEditPolicy(EditPart child) {
				return null;
			}
			protected Command getCreateCommand(CreateRequest request) {
				if (request.getNewObjectType() != ChildNode.class) {
					return null;
				}
				ChildNode childNode = (ChildNode) request.getNewObject();
				// FIXME get feature from compartment definition, GenChildContainer.childFeatures
				// foreach (cn : genNode.childNode)
				// if cn.getDomainMetaClass == childNode.getDomainElement().eClass()) feature = cn.childFeature
				return new CreateChildNodeCommand(childNode, getDiagramNode());
			}
			protected Command getDeleteDependantCommand(Request request) {
				return null;
			}
			protected Command getMoveChildrenCommand(Request request) {
				return UnexecutableCommand.INSTANCE;
			}
			protected void showLayoutTargetFeedback(Request request) {
				if (myLayoutFeedback != null) {
					return;
				}
				myLayoutFeedback = createLayoutFeedback();
				addFeedback(myLayoutFeedback);
			}
			protected void eraseLayoutTargetFeedback(Request request) {
				removeFeedback(myLayoutFeedback);
				myLayoutFeedback = null;
			}
			private IFigure createLayoutFeedback() {
				RectangleFigure result = new RectangleFigure();
				result.setFill(false);
				result.setBounds(getHostFigure().getBounds().getExpanded(5, 5));
				return result;
			}
			private IFigure myLayoutFeedback;
		};
a76 101

	/**
	 * @@generated
	 */
	protected EditPolicy createGraphicalNodePolicy() {
		return new GraphicalNodeEditPolicy() {
			protected Command getConnectionCompleteCommand(CreateConnectionRequest request) {
				CreateDiagramLinkCommand cmd = (CreateDiagramLinkCommand) request.getStartCommand();
				cmd.setTargetNode(getDiagramNode());
				return cmd;
			}
			protected Command getConnectionCreateCommand(CreateConnectionRequest request) {
				if (request.getNewObjectType() != DiagramLink.class) {
					return null;
				}
				DiagramLink diagramLink = (DiagramLink) request.getNewObject();
				Command cmd = new CreateDiagramLinkCommand(diagramLink, getDiagramNode());
				request.setStartCommand(cmd);
				return cmd;
				// The disallow cursor will be shown IFF you return null
			}
			protected Command getReconnectSourceCommand(ReconnectRequest request) {
				return null; // TODO
			}
			protected Command getReconnectTargetCommand(ReconnectRequest request) {
				return null; // TODO
			}
		};
	}

	/**
	 * @@generated
	 */
	protected IFigure createFigure() {
<%if (genNode.getViewmapURI() != null) {%>
		IFigure r = <%=importManager.getImportedName("org.eclipse.gmf.diagramrt.gefsvg.SVGShapeFactory")%>.create("<%=genDiagram.getPluginID()%>", "<%=genNode.getViewmapURI()%>");
<%} else {%>
<%if (genNode.getNodeVisualizationKind() == 1) {%>
		RoundedRectangle r = new RoundedRectangle() {
<%}%>
<%if (genNode.getNodeVisualizationKind() == 2) {%>
		RectangleFigure r = new RectangleFigure() {
<%}%>
<%if (genNode.getNodeVisualizationKind() == 3) {%>
		Ellipse r = new Ellipse() {
<%}%>
<%if (genNode.getNodeVisualizationKind() == 4) {%>
		Triangle r = new Triangle() {
<%}%>
<%if (genNode.getNodeVisualizationKind() > 0 && genNode.getNodeVisualizationKind() < 5) {%>
			protected void fillShape(Graphics graphics) {
				graphics.pushState();
				graphics.setForegroundColor(getColorSupport().get("130,245,255")); //88, 210, 245
				graphics.fillGradient(getBounds(), true);
				graphics.popState();
			}
		};
		r.setLineWidth(2);
<%}%>
<%if (genNode.getNodeVisualizationKind() == 5) {%>
		Label r = new Label();
<%}%>
<%}%>
		r.setLocation(getDiagramNode().getLocation());
		if (getDiagramNode().getSize().isEmpty()) {
			r.setSize(100, 50);
		} else {
			r.setSize(getDiagramNode().getSize());
		}
		r.setBorder(new MarginBorder(0, 5, 0, 5));
<%if (genNode.getForegroundColor() != null) {%>
		if (getDiagramNode().getForegroundColor() == null) {
			// set default color, defined in genmodel
			r.setForegroundColor(getColorSupport().get("<%=genNode.getForegroundColor()%>"));
		}
<%}%>
<%if (genNode.getBackgroundColor() != null) {%>
		if (getDiagramNode().getBackgroundColor() == null) {
			r.setBackgroundColor(getColorSupport().get("<%=genNode.getBackgroundColor()%>"));
		}
<%}%>
		refreshColors(r);
<%if (genNode.hasNameToEdit() || !genNode.getAffixedStereotypes().isEmpty()) {%>
		r.setLayoutManager(new ToolbarLayout());
<%}%>
<%if (!genNode.getAffixedStereotypes().isEmpty()) {%>
		Label stereotypes = new Label();
<%
StringBuffer sb = new StringBuffer();
sb.append('<');
for (Iterator it = genNode.getAffixedStereotypes().iterator(); it.hasNext();) { 
	sb.append(it.next());
	sb.append(',');
}
sb.deleteCharAt(sb.length() - 1);
sb.append('>');
%>
		stereotypes.setText("<%=sb.toString()%>");
		stereotypes.setFont(<%=importManager.getImportedName("org.eclipse.jface.resource.JFaceResources")%>.getFontRegistry().getItalic(JFaceResources.TEXT_FONT));
		r.add(stereotypes);
<%}%>
a77 99
		r.add(getDirectEditFigure());
<%}%>
<%if (!genNode.getChildContainers().isEmpty()) {%>
		// XXX actually, content pane should be added with some constraint, 
		// not necessarily as the last figure. 
		myContentPane = createContentPane();
		r.add(myContentPane);
<%}%>
		return r;
	}

	/**
	 * @@generated
	 */
	public DiagramNode getDiagramNode() {
		return (DiagramNode) getModel();
	}

	/**
	 * @@generated
	 */
	protected void refreshVisuals() {
		visualPropertiesChanged();
		boundsChanged();
		super.refreshVisuals();
	}

	// XXX TODO? introduce ChangeColorRequest() with appropriate command to handle? With EditPolicy/handleRequest?
	// (+) undo, unified, (-) nothing, really.
	// ??? Request/policy? Enough to have command?

	/**
	 * @@generated
	 */
	protected void refreshColors(IFigure fig) {
		if (getDiagramNode().getForegroundColor() != null) {
			fig.setForegroundColor(getColorSupport().get(getDiagramNode().getForegroundColor()));
		}
		if (getDiagramNode().getBackgroundColor() != null) {
			fig.setBackgroundColor(getColorSupport().get(getDiagramNode().getBackgroundColor()));
		}
	}
<%if (!genNode.getChildNodes().isEmpty()) {%>
	/**
	 * @@generated
	 */
	protected List getModelChildren() {
		return getDiagramNode().getChildNodes();
	}
<%}%>
<%if (!genNode.getChildContainers().isEmpty() /* production: && !genNode.getChildNodes().isEmpty()*/) {%>

	/**
	 * @@generated
	 */
	protected CompartmentsContentPane createContentPane() {
		CompartmentsContentPane contentPane = new CompartmentsContentPane();
		// if (genNode.childContainersPlacement == TOOLBAR) {
		contentPane.setLayoutManager(new ToolbarLayout());
		// } else {
		//contentPane.setLayoutManager(new FlowLayout());
		//}
		IFigure compartment;
<%for (Iterator it = genNode.getChildContainers().iterator(); it.hasNext();) {
		GenChildContainer childContainer = (GenChildContainer) it.next();
%>
		compartment = createCompartment("<%=childContainer.getTitleKey()%>");
		
		// if childContainer.needsLabel() {
		// compartment.setLabel(childContainer.titleKey);
		//}
		// compartment.setCollapse(childContainer.canCollapse);
		// compartment.setHideEmpty(childContainer.hideIfEmpty);
		// switch (compartment.layoutKind)
		compartment.setLayoutManager(new ToolbarLayout());
		contentPane.register("<%=childContainer.getGroupID()%>", compartment);
<%}%>
		return contentPane;
	}


	/**
	 * @@generated
	 */
	protected IFigure createCompartment(String title) {
		LabeledContainer r = new LabeledContainer();
		r.setLabel(title);
		r.setOpaque(false);
		return r;
	}

	/**
	 * @@generated
	 */
	protected void addChildVisual(EditPart childEditPart, int index) {
		ChildNode model = (ChildNode) childEditPart.getModel();
		IFigure child = ((GraphicalEditPart)childEditPart).getFigure();
		myContentPane.addChildVisual(model.getGroupID(), child, index);
	}
d82 2
a83 11
	protected void removeChildVisual(EditPart childEditPart) {
		ChildNode model = (ChildNode) childEditPart.getModel();
		IFigure child = ((GraphicalEditPart)childEditPart).getFigure();
		myContentPane.removeChildVisual(model.getGroupID(), child);
	}

	/**
	 * @@generated
	 */
	public IFigure getContentPane() {
		return myContentPane;
a85 98
	/**
	 * @@generated
	 */
	protected List getModelSourceConnections() {
		return getDiagramNode().getOutgoingLinks();
	}

	/**
	 * @@generated
	 */
	protected List getModelTargetConnections() {
		return getDiagramNode().getIncomingLinks();
	}

	/**
	 * @@generated
	 */
	public void boundsChanged() {
		getFigure().setLocation(getDiagramNode().getLocation());
		getFigure().setSize(getDiagramNode().getSize());
		getFigure().revalidate();
	}

	/**
	 * @@generated
	 */
	public void visualPropertiesChanged() {
		refreshColors(getFigure());
	}

	/**
	 * @@generated
	 */
	public void structuralPropertiesChanged() {
		refreshChildren();
	}

	/**
	 * @@generated
	 */
	public void incomingLinksChanged() {
		refreshTargetConnections();
	}

	/**
	 * @@generated
	 */
	public void outgoingLinksChanged() {
		refreshSourceConnections();
	}

<%if (genNode.hasNameToEdit()) {%>
<%@@ include file="directedit.jetinc"%>
<%}%>
	/**
	 * @@generated
	 */
	public ConnectionAnchor getSourceConnectionAnchor(ConnectionEditPart arg0) {
		return getAnchor();
	}

	/**
	 * @@generated
	 */
	public ConnectionAnchor getTargetConnectionAnchor(ConnectionEditPart arg0) {
		return getAnchor();
	}

	/**
	 * @@generated
	 */
	public ConnectionAnchor getSourceConnectionAnchor(Request arg0) {
		return getAnchor();
	}

	/**
	 * @@generated
	 */
	public ConnectionAnchor getTargetConnectionAnchor(Request arg0) {
		return getAnchor();
	}

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.gef.ColorSupport")%> getColorSupport() {
		return ((<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>) getRoot().getContents()).getColorSupport();
	}

	/**
	 * @@generated
	 */
	private ConnectionAnchor getAnchor() {
		if (myAnchor == null) {
			myAnchor = new ChopboxAnchor(getFigure());
		}
		return myAnchor;
	}
a86 1
<%importManager.emitSortedImports();%>@

