head	1.50;
access;
symbols
	v20081022-1925:1.50
	v20081015-1925:1.50
	v20081008-1925:1.50
	v20081001-1925:1.50
	v20080924-1925:1.50
	v20080917-1925:1.50
	v20080911-1728:1.50
	v20080910-1520:1.50
	v20080903-1520:1.50
	v20080827-1520:1.50
	v20080813-1520:1.50
	v20080806-1520:1.50
	v20070202-0200:1.48
	v20061214-0000:1.48
	v20061120-1300:1.48
	M3_20:1.48
	v20061117-0800:1.48
	v20061027-1200:1.48
	v20061020-1000:1.48
	v20061013-1330:1.48
	v20060919-0800:1.48
	v20060907-1100:1.48
	M1_20:1.48
	v20060904-1500:1.48
	v20060824-1600:1.48
	v20060817-1500:1.48
	v20060728-0500:1.48
	v20060713-1700:1.48
	R1_0_maintenance:1.48.0.2
	R1_0:1.48
	v20060627-1200:1.48
	v20060626-1420:1.48
	v20060620-0400:1.48
	v20060616-1400:1.48
	v20060616-1200:1.48
	v20060609-1400:1.48
	v20060531-1730:1.47
	v20060530-1930:1.47
	v20060526-1200:1.47
	v20060519-1300:1.47
	v20060519-0800:1.47
	v20060512-1000:1.45
	I20060512-1000:1.45
	I20060505-1400:1.44
	I20060428-1300:1.42
	I20060424-0500:1.42
	I20060424-0300:1.42
	M6_10:1.40
	I20060407-1200:1.38
	I20060331-1000:1.38
	I20060324-0300:1.38
	I20060317-1300:1.38
	I20060317-1200:1.38
	I20060316-1300:1.38
	I20060309-1300:1.37
	M5_10:1.36
	S20060303-1600:1.36
	I20060227-1730:1.36
	I20060216-1945:1.36
	I20060210-1715:1.36
	I20060209-1815:1.36
	I20060203-0830:1.32
	I20060202-1415:1.32
	I20060129-1145:1.32
	I20060127-0900:1.32
	I20060120-1530:1.31
	I20060113-1700:1.29
	M4_10:1.29
	I20060107-1100:1.26
	I20060105-1630:1.26
	I20051230-1230:1.26
	I20051223-1100:1.26
	I20051217-0925:1.25
	I20051208-2000:1.25
	I20051201-1800:1.25
	I20051124-2000:1.25
	M3_10:1.24
	I20051118-1245:1.24
	I20051111-1800:1.22
	I20051106-0900:1.21
	v20051030:1.19
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.50
date	2006.12.15.19.25.23;	author dstadnik;	state dead;
branches;
next	1.49;
commitid	54dd4582f6a24567;

1.49
date	2006.12.14.19.02.23;	author dstadnik;	state Exp;
branches;
next	1.48;
commitid	408e45819fb94567;

1.48
date	2006.06.01.09.04.14;	author dstadnik;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.15.17.18.16;	author ashatalin;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.10.11.13.14;	author dstadnik;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.02.17.43.25;	author ashatalin;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.02.17.15.38;	author dstadnik;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.20.20.37.15;	author ashatalin;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.20.17.08.07;	author ashatalin;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.14.15.19.57;	author dstadnik;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.13.22.22.23;	author ashatalin;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.13.11.02.30;	author dstadnik;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.07.15.45.28;	author dstadnik;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.08.17.15.50;	author atikhomirov;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.08.12.28.12;	author atikhomirov;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.33;

1.33
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.24.12.01.20;	author dstadnik;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.19.17.33.05;	author ashatalin;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.19.00.10.44;	author ashatalin;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.12.17.19.23;	author ashatalin;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.12.11.43.59;	author dstadnik;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.12.10.41.33;	author dstadnik;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.20.18.00.01;	author ashatalin;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.22.11.50.03;	author dstadnik;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.18.13.55.34;	author ashatalin;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.16.07.42.24;	author dstadnik;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.11.13.47.43;	author dstadnik;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.04.18.26.17;	author atikhomirov;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.02.17.53.03;	author atikhomirov;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.27.16.12.20;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.26.17.33.09;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.24.16.47.40;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.24.14.58.46;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.21.13.31.57;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.18.11.09.13;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.14.12.17.18;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.13.14.21.40;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.13.12.45.56;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.13.11.42.21;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.11.12.50.57;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.10.12.57.39;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.07.12.19.10;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.06.16.03.15;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.04.15.40.37;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.04.13.18.07;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.30.19.16.05;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.29.09.49.41;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.20.29;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.50
log
@rewrite edit part factory template in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.parts" class="EditPartFactoryGenerator" 
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import org.eclipse.draw2d.FigureUtilities;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.Label;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartFactory;
import org.eclipse.gef.tools.CellEditorLocator;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart;
import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.viewers.CellEditor;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
<%
importManager.markImportLocation(stringBuffer);
final String visualIDRegistryClassName = importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName());
%>

/**
 * @@generated
 */
public class <%=genDiagram.getEditPartFactoryClassName()%> implements EditPartFactory {

	/**
	 * @@generated
	 */
	public EditPart createEditPart(EditPart context, Object model) {
		if (model instanceof View) {
			View view = (View) model;
			int viewVisualID = <%=visualIDRegistryClassName%>.getVisualID(view);
			switch (viewVisualID) {
<%
for (Iterator containers = genDiagram.getAllContainers().iterator(); containers.hasNext();) {
	GenContainerBase container = (GenContainerBase) containers.next();
%>
			case <%=importManager.getImportedName(container.getEditPartQualifiedClassName())%>.VISUAL_ID:
				 return new <%=container.getEditPartClassName()%>(view);
<%
	if (container instanceof GenNode) {
		GenNode node = (GenNode) container;
		for (Iterator labels = node.getLabels().iterator(); labels.hasNext();) {
			GenNodeLabel label = (GenNodeLabel) labels.next();
%>
			case <%=importManager.getImportedName(label.getEditPartQualifiedClassName())%>.VISUAL_ID:
				return new <%=label.getEditPartClassName()%>(view);
<%
		}
	}
}
for (Iterator links = genDiagram.getLinks().iterator(); links.hasNext();) {
	GenLink link = (GenLink) links.next();
%>		
			case <%=importManager.getImportedName(link.getEditPartQualifiedClassName())%>.VISUAL_ID:
				return new <%=link.getEditPartClassName()%>(view);
<%
	for (Iterator linkLabels = link.getLabels().iterator(); linkLabels.hasNext();) {
		GenLinkLabel linkLabel = (GenLinkLabel) linkLabels.next();
%>
			case <%=importManager.getImportedName(linkLabel.getEditPartQualifiedClassName())%>.VISUAL_ID:
				return new <%=linkLabel.getEditPartClassName()%>(view);
<%
	}
}
%>
			}
		}
		return createUnrecognizedEditPart(context, model);
	}

	/**
	 * @@generated
	 */
	 private EditPart createUnrecognizedEditPart(EditPart context, Object model) {
	 	// Handle creation of unrecognized child node EditParts here
	 	return null;
	 }

	/**
	 * @@generated
	 */
	public static CellEditorLocator getTextCellEditorLocator(ITextAwareEditPart source){
        if (source.getFigure() instanceof WrapLabel)
            return new TextCellEditorLocator((WrapLabel) source.getFigure());
        else {
            IFigure figure = source.getFigure();
            return new LabelCellEditorLocator((Label) figure);
        }
    }

	/**
	 * @@generated
	 */
	static private class TextCellEditorLocator implements CellEditorLocator {

		/**
		 * @@generated
		 */
		private WrapLabel wrapLabel;
		
		/**
		 * @@generated
		 */
		public TextCellEditorLocator(WrapLabel wrapLabel) {
			super();
			this.wrapLabel = wrapLabel;
		}

		/**
		 * @@generated
		 */
		public WrapLabel getWrapLabel() {
			return wrapLabel;
		}

		/**
		 * @@generated
		 */
		public void relocate(CellEditor celleditor) {
			Text text = (Text) celleditor.getControl();
			Rectangle rect = getWrapLabel().getTextBounds().getCopy();
			getWrapLabel().translateToAbsolute(rect);
			
			if (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)
				rect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));
			else {
				int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
				rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));
			}

			if (!rect.equals(new Rectangle(text.getBounds())))
				text.setBounds(rect.x, rect.y, rect.width, rect.height);
		}

	}

	/**
	 * @@generated
	 */
	private static class LabelCellEditorLocator implements CellEditorLocator {

		/**
		 * @@generated
		 */
		private Label label;

		/**
		 * @@generated
		 */
		public LabelCellEditorLocator(Label label) {
			this.label = label;
		}

		/**
		 * @@generated
		 */
		public Label getLabel() {
			return label;
		}

		/**
		 * @@generated
		 */
		public void relocate(CellEditor celleditor) {
			Text text = (Text) celleditor.getControl();
			Rectangle rect = getLabel().getTextBounds().getCopy();
			getLabel().translateToAbsolute(rect);

			int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
			rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));

			if (!rect.equals(new Rectangle(text.getBounds())))
				text.setBounds(rect.x, rect.y, rect.width, rect.height);
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.49
log
@[164935] Use border items infrastructure to support external labels
@
text
@@


1.48
log
@fix some nls markers
@
text
@a36 5
	public static final String EXTERNAL_NODE_LABELS_LAYER = "External Node Labels"; //$NON-NLS-1$

	/**
	 * @@generated
	 */
@


1.47
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d37 1
a37 1
	public static final String EXTERNAL_NODE_LABELS_LAYER = "External Node Labels";
@


1.46
log
@#131543 Obsolete code should be eliminated
@
text
@d5 1
d8 1
a8 1
package <%=genDiagram.getEditPartsPackageName()%>;
a9 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditPartsPackageName());%>
@


1.45
log
@#133836 Creating a child node without a label causes error
@
text
@a44 3
			if (!<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(<%=visualIDRegistryClassName%>.getModelID(view))) {
				return null;
			}
@


1.44
log
@@@generated comments added.
@
text
@a47 1
			
d57 1
a57 1
	if (container instanceof GenNode && !((GenNode) container).isListContainerEntry()) {
d87 1
a87 1
	
@


1.43
log
@add missing @@generated tags
@
text
@d114 3
d119 3
d127 3
a129 1
		
d134 3
d160 3
d165 3
d172 3
d179 3
@


1.42
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d97 3
d109 3
d144 3
@


1.41
log
@Removing obsolete code to get rid of compilation warnings.
@
text
@d55 1
a55 1
			case <%=container.getVisualID()%>:
d63 1
a63 1
			case <%=label.getVisualID()%>:
d72 1
a72 1
			case <%=link.getVisualID()%>:
d78 1
a78 1
			case <%=linkLabel.getVisualID()%>:
@


1.40
log
@use correct cell editor locator for WrapLabels
@
text
@a4 1
final String modelID = genDiagram.getEditorGen().getModelID();
@


1.39
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d11 5
d18 3
d22 3
d98 65
@


1.38
log
@#129145 do not use intermediate TextCompartmentEditParts
@
text
@d14 4
a17 1
<%importManager.markImportLocation(stringBuffer);%>
a28 4
<%@@ include file="../editor/getModelID.jetinc" %>

<%@@ include file="../editor/getVisualID.jetinc" %>

d35 1
a35 1
			if (!"<%=modelID%>".equals(getModelID(view))) {
d39 1
a39 1
			int viewVisualID = getVisualID(view);
@


1.37
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@a52 14
			if (label instanceof ExternalLabel) {
// [++] Just to remove unnecessary imports we are doing this import insode a loop
				String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
// [--]
				String labelViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + ((ExternalLabel) label).getSemanticHintLabelFieldName();
%>
			case <%=label.getVisualID()%>:
				if (<%=labelViewId%>.equals(view.getType())) {
					return new <%=label.getEditPartClassName()%>(view);
				} else {
					return new <%=((ExternalLabel) label).getTextEditPartClassName()%>(view);
				}
<%
			} else {
a56 1
			}
a66 3
// [++] Just to remove unnecessary imports we are doing this import insode a loop
		String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
// [--]
a67 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + linkLabel.getSemanticHintLabelFieldName();
d70 1
a70 5
				if (<%=labelViewId%>.equals(view.getType())) {
					return new <%=linkLabel.getEditPartClassName()%>(view);
				} else {
					return new <%=linkLabel.getTextEditPartClassName()%>(view);
				}
@


1.36
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d7 1
@


1.35
log
@constant used throughout templates to identify diagram (genModel.getModelName) was extracted as explicit attribute
packagePrefix added
@
text
@d4 1
a4 1
final GenDiagram genDiagram = (GenDiagram) argument;
@


1.34
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d5 1
a5 1
final String modelID = genDiagram.getEditorGen().getDomainGenModel().getModelName();
@


1.33
log
@ImportManager moved to oeg.common
@
text
@d3 4
a6 1
<%GenDiagram genDiagram = (GenDiagram) argument;%>
d35 1
a35 1
			if (!"<%=genDiagram.getEMFGenModel().getModelName()%>".equals(getModelID(view))) {
@


1.32
log
@rename GenContainerEditPart -> GenContainerBase
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.31
log
@#124413
Cleaning up the gmfgen model
@
text
@d39 2
a40 2
for (Iterator containers = genDiagram.getAllContainerEditParts().iterator(); containers.hasNext();) {
	GenContainerEditPart container = (GenContainerEditPart) containers.next();
@


1.30
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@a25 6
<%
List genLinks = genDiagram.getLinks();
Collection allContainers = new LinkedList(genDiagram.getAllContainers());
allContainers.add(genDiagram);
%>

d39 1
a39 1
for (Iterator containers = allContainers.iterator(); containers.hasNext();) {
d42 2
a43 2
		case <%=container.getVisualID()%>:
			 return new <%=container.getEditPartClassName()%>(view);
d55 6
a60 6
		case <%=label.getVisualID()%>:
			if (<%=labelViewId%>.equals(view.getType())) {
				return new <%=label.getEditPartClassName()%>(view);
			} else {
				return new <%=((ExternalLabel) label).getTextEditPartClassName()%>(view);
			}
d64 2
a65 2
		case <%=label.getVisualID()%>:
			return new <%=label.getEditPartClassName()%>(view);
d71 1
a71 1
for (Iterator links = genLinks.iterator(); links.hasNext();) {
@


1.29
log
@#114178
Create shortcut functionality added
@
text
@d28 2
a29 1
Collection allContainers = AccessUtil.getAllContainers(genDiagram);
a43 2
			case <%=genDiagram.getVisualID()%>:
				return new <%=genDiagram.getEditPartClassName()%>(view);
d46 1
a46 1
	GenChildContainer container = (GenChildContainer) containers.next();
d51 1
a51 1
	if (container instanceof GenChildNode ? !((GenChildNode) container).isListContainerEntry() : container instanceof GenNode) {
@


1.28
log
@#122054 support external node labels
@
text
@d22 2
d25 1
d37 1
a37 1
			if (!"<%=genDiagram.getEMFGenModel().getModelName()%>".equals(view.getDiagram().getType())) {
@


1.27
log
@#122054 support external node labels (partial fix)
@
text
@d17 5
@


1.26
log
@#121581
Fields for the compartments are named unique.
@
text
@d48 14
d66 1
@


1.25
log
@#112187 generate separate class for the link label text view
@
text
@d66 1
a66 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + AccessUtil.getLabelId(linkLabel);
@


1.24
log
@#117026
Generating Shape edit parts for inner elements if necessary.
@
text
@d64 1
a64 2
		String semanticPackageInterfaceName = importManager.getImportedName(genDiagram.getDomainMetaModel().getQualifiedPackageInterfaceName());
// [--]		
a66 8
		String semanticLinkInterfaceName;
		if (link.getModelFacet() instanceof TypeLinkModelFacet) {
			TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) link.getModelFacet();
			semanticLinkInterfaceName = modelFacet.getMetaClass().getClassifierAccessorName();
		} else {
			FeatureModelFacet modelFacet = (FeatureModelFacet) link.getModelFacet();
			semanticLinkInterfaceName = modelFacet.getMetaFeature().getGenClass().getClassifierAccessorName();
		}
d70 1
a70 6
					return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.LabelEditPart")%>(view) {
					
						public int getKeyPoint() {
							return <%=importManager.getImportedName("org.eclipse.draw2d.ConnectionLocator")%>.<%=linkLabel.getAlignment()%>;
						}
					};
d72 1
a72 9
					return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editparts.TextCompartmentEditPart")%>(view) {

						public <%=importManager.getImportedName("org.eclipse.gmf.runtime.common.ui.services.parser.IParser")%> getParser() {
							if (parser == null) {
								parser = new <%=importManager.getImportedName(genDiagram.getStructuralFeatureParserQualifiedClassName())%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().getEStructuralFeature("<%=linkLabel.getMetaFeature().getName()%>"));
							}
							return parser;
						}
					};
d77 1
a77 1
%>		
@


1.23
log
@#116031 avoid hardcoded class names in templates
@
text
@d44 1
a44 1
	if (container instanceof GenNode) {
@


1.22
log
@#115972 generate single class with semantic hints
@
text
@d90 1
a90 1
								parser = new <%=importManager.getImportedName(genDiagram.getProvidersPackageName() + ".StructuralFeatureParser")%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().getEStructuralFeature("<%=linkLabel.getMetaFeature().getName()%>"));
@


1.21
log
@[ashatalin] #115107 remove uses of deprecated runtime code in templates
@
text
@a54 1

a60 1
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(link);
d63 1
a63 1
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d67 1
a67 1
		String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelId(linkLabel);
a75 1

@


1.20
log
@[ashatalin] #114750 annotate diagram runtime model elements with visual id to tell one from another during EP decision making
@
text
@a6 9
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.draw2d.ConnectionLocator;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
a8 11
import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;
import org.eclipse.gmf.runtime.diagram.ui.editparts.LabelEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.TextCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.DragDropEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.Node;
a9 1
import <%=genDiagram.getProvidersPackageName()%>.StructuralFeatureParser;
a20 1
String semanticPackageInterfaceName = importManager.getImportedName(genDiagram.getDomainMetaModel().getQualifiedPackageInterfaceName());
a62 1
	String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d64 4
d82 1
a82 1
					return new LabelEditPart(view) {
d85 1
a85 1
							return ConnectionLocator.<%=linkLabel.getAlignment()%>;
d89 1
a89 1
					return new TextCompartmentEditPart(view) {
d91 1
a91 1
						public IParser getParser() {
d93 1
a93 1
								parser = new StructuralFeatureParser(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().getEStructuralFeature("<%=linkLabel.getMetaFeature().getName()%>"));
@


1.19
log
@[ashatalin] #113892 flexible compartment hierarchy
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.util.*"%>
d38 7
d51 2
a52 10
			if (model instanceof Diagram) {
				return createDiagramEditPart((Diagram) model);
			} else if (view instanceof Node) {
				if (view.eContainer() instanceof Diagram || (view.getType() != null && view.getType().length() > 0)) {
					return createNodeEditPart((Node) model);
				} else {
					return createChildNodeEditPart((Node) model);
				}
			} else if (view instanceof Edge) {
				return createEdgeEditPart((Edge) model);
d54 19
a72 4
		}
		return null;
	}

a73 13
GenPackage genPackage = genDiagram.getDomainMetaModel();
List genNodes = genDiagram.getNodes();
List genLinks = genDiagram.getLinks();
String semanticPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
%>

	/**
	 * @@generated
	 */
	private EditPart createDiagramEditPart(Diagram diagram) {
		EObject element = diagram.getElement();
		if (<%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getDiagramVisualID(element) != -1) {
			return new <%=genDiagram.getEditPartClassName()%>(diagram);
a74 1
		return null;
d76 1
d78 5
a82 18
	/**
	 * @@generated
	 */
	private EditPart createNodeEditPart(Node node) {
		EditPart linkLabelEditPart = createLinkLabelEditPart(node);
		if (linkLabelEditPart != null) {
			return linkLabelEditPart;
		}
		final EObject element = node.getElement();
		int nodeVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getNodeVisualID(element);
		
		switch (nodeVID) {
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String modelElementInterfaceName = importManager.getImportedName(genNode.getDomainMetaClass().getQualifiedInterfaceName());
%>
		case <%=genNode.getVisualID()%>:
d84 1
a84 1
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
d86 10
a95 92
	List labels = genNode.getLabels();
	for (int j = 0; j < labels.size(); j++) {
		GenNodeLabel label = (GenNodeLabel) labels.get(j);
		String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(label);
%>
			if (<%=labelTextViewId%>.equals(node.getType())) {
				return new <%=label.getEditPartClassName()%>(node);
			}
<%
	}
	List genCompartments = genNode.getCompartments();
	for (int j = 0; j < genCompartments.size(); j++) {
		GenCompartment genCompartment = (GenCompartment) genCompartments.get(j);
		String compartmentId = semanticHintsClassName + ".Compartments." + AccessUtil.getCompartmentId(genCompartment);
%>
			if (<%=compartmentId%>.equals(node.getType())) {
				return new ListCompartmentEditPart(node) {

					protected boolean hasModelChildrenChanged(Notification evt) {
						return false;
					}

					protected void createDefaultEditPolicies() {
						super.createDefaultEditPolicies();
						installEditPolicy(EditPolicyRoles.CREATION_ROLE, new CreationEditPolicy());
						installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE, new DragDropEditPolicy());
						installEditPolicy(EditPolicyRoles.CANONICAL_ROLE, new CanonicalEditPolicy() {
							protected List getSemanticChildrenList() {
								List result = new LinkedList();
<%
		Map childFeature2NodesMap = new HashMap();
		for (Iterator it = genCompartment.getChildNodes().iterator(); it.hasNext();) {
			GenChildNode nextChildNode = (GenChildNode) it.next();
			GenFeature genFeature = nextChildNode.getModelFacet().getChildMetaFeature();
			List genChildNodes; 
			if (!childFeature2NodesMap.containsKey(genFeature)) {
				genChildNodes = new ArrayList();
				childFeature2NodesMap.put(genFeature, genChildNodes);
			} else {
				genChildNodes = (List) childFeature2NodesMap.get(genFeature);
			}

			if (nextChildNode.getDomainMetaClass() == null) {
				genChildNodes.clear();
				genChildNodes.add(nextChildNode);
				continue;
			}
			if (genChildNodes.size() == 1 && ((GenChildNode) genChildNodes.get(0)).getDomainMetaClass() == null) {
				continue;
			}
			genChildNodes.add(nextChildNode);
		}
		
		for (Iterator it = childFeature2NodesMap.entrySet().iterator(); it.hasNext();) {
			Map.Entry nextEntry = (Map.Entry) it.next();
			GenFeature nextFeature = (GenFeature) nextEntry.getKey();
			List childNodes = (List) nextEntry.getValue();
			if (childNodes.size() == 1 && ((GenChildNode) childNodes.get(0)).getDomainMetaClass() == null) {
%>
								result.<%=nextFeature.isListType() ? "addAll" : "add"%>(((<%=modelElementInterfaceName%>) element).<%=nextFeature.getGetAccessor()%>());
<%
				continue;
			}
			
			if (nextFeature.isListType()) {
%>
								Collection featureValues = ((<%=modelElementInterfaceName%>) element).<%=nextFeature.getGetAccessor()%>();
								for (Iterator it = featureValues.iterator(); it.hasNext();) {
									EObject nextValue = (EObject) it.next();
<%
			} else {
%>
								EObject nextValue = (EObject) ((<%=modelElementInterfaceName%>) element).<%=nextFeature.getGetAccessor()%>();
<%
			}
%>
								EClass nextEClass = nextValue.eClass();
<%			
			for (Iterator childNodesIterator = childNodes.iterator(); childNodesIterator.hasNext();) {
				GenChildNode nextChildNode = (GenChildNode) childNodesIterator.next();
				GenClass domainMetaclass = nextChildNode.getDomainMetaClass();
%>
								if (<%=importManager.getImportedName(domainMetaclass.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=domainMetaclass.getClassifierAccessorName()%>().equals(nextEClass)) {
									result.add(nextValue);
								} <%=childNodesIterator.hasNext() ? "else" : ""%>
<%
			}
			if (nextFeature.isListType()) {
%>
								}
<%
			}
a96 6
%>
								return result;
							}
						});
						//installEditPolicy(EditPolicy.NODE_ROLE, null);
					}
a97 9
					protected String getTitleName() {
						return "<%=genCompartment.getTitle()%>";
					}
				};
			}
<%	}%>
			return new <%=genNode.getEditPartClassName()%>(node);
<%
}
d99 10
a108 32
		}
		return createUnrecognizedNodeEditPart(node);
	}
	
	/**
	 * @@generated
	 */
	private EditPart createLinkLabelEditPart(Node node) {
<%if (!genLinks.isEmpty()) {%>
		EObject element = node.getElement();
		int linkVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getLinkWithClassVisualID(element);
		
		switch (linkVID) {
<%
	for (int i = 0; i < genLinks.size(); i++) {
		GenLink genLink = (GenLink) genLinks.get(i);
		String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genLink);
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
		if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
			TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
			String semanticLinkInterfaceName = modelFacet.getMetaClass().getClassifierAccessorName();
%>
		case <%=genLink.getVisualID()%>:
<%
			List labels = genLink.getLabels();
			for (int j = 0; j < labels.size(); j++) {
				GenLinkLabel label = (GenLinkLabel) labels.get(j);
				String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelId(label);
				String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(label);
%>
			if (<%=labelViewId%>.equals(node.getType())) {
				return new LabelEditPart(node) {
d110 5
a114 11
					public int getKeyPoint() {
						return ConnectionLocator.<%=label.getAlignment()%>;
					}
				};
			}
			if (<%=labelTextViewId%>.equals(node.getType())) {
				return new TextCompartmentEditPart(node) {

					public IParser getParser() {
						if (parser == null) {
							parser = new StructuralFeatureParser(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().getEStructuralFeature("<%=label.getMetaFeature().getName()%>"));
d116 2
a117 6
						return parser;
					}
				};
			}
<%			}%>
			return null;
a118 1
		}
d120 3
a122 1
%>
d124 1
a124 35
<%}%>				
		return null;
	}
	
	/**
	 * @@generated
	 */
	private EditPart createUnrecognizedNodeEditPart(Node node) {
		// Handle creation of unrecognized node EditParts here
	 	return null;
	}

	/**
	 * @@generated
	 */
	private EditPart createChildNodeEditPart(Node node) {
		EObject element = node.getElement();
		int nodeVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getChildNodeVisualID(element);
		
		switch (nodeVID) {
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	List genChildNodes = AccessUtil.getAllChildNodes(genNode);
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
%>
		case <%=genChildNode.getVisualID()%>:
			return new <%=genChildNode.getEditPartClassName()%>(node);
<%
	}
}
%>
		} 
		return createUnrecognizedChildNodeEditPart(node);
d130 1
a130 1
	 private EditPart createUnrecognizedChildNodeEditPart(Node node) {
a134 49
	/**
	 * @@generated
	 */
	private EditPart createEdgeEditPart(Edge edge) {
<%if (!genLinks.isEmpty()) {%>
		EObject element = edge.getElement();
		if (element == null) {
<%
	for (int i = 0; i < genLinks.size(); i++) {
		GenLink genLink = (GenLink) genLinks.get(i);
		if (genLink.getModelFacet() instanceof FeatureModelFacet) {
			String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genLink);
			String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
%>
			if (<%=semanticHintsClassName%>.VIEW_TYPE.equals(edge.getType())) {
				return new <%=genLink.getEditPartClassName()%>(edge);
			}
<%
		}
	}
%>
			return null;
		}
		int linkVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getLinkWithClassVisualID(element);
		
		switch (linkVID) {
<%
	for (int i = 0; i < genLinks.size(); i++) {
		GenLink genLink = (GenLink) genLinks.get(i);
		if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
%>
		case <%=genLink.getVisualID()%>:
			return new <%=genLink.getEditPartClassName()%>(edge);
<%
		}
	}
%>
		}
<%}%>
		return createUnrecognizedEdgeEditPart(edge);				
	}

	/**
	 * @@generated
	 */
	 private EditPart createUnrecognizedEdgeEditPart(Edge edge) {
	 	// Handle creation of unrecognized edge EditParts here
	 	return null;
	 }
@


1.18
log
@#113823 childMetaFeature moved to TypeModelFacet
@
text
@d108 4
a111 4
	List genChildContainers = genNode.getChildContainers();
	for (int j = 0; j < genChildContainers.size(); j++) {
		GenChildContainer genChildContainer = (GenChildContainer) genChildContainers.get(j);
		String compartmentId = semanticHintsClassName + ".Compartments." + AccessUtil.getCompartmentId(genChildContainer);
d129 1
a129 1
		for (Iterator it = genNode.getChildNodes().iterator(); it.hasNext();) {
a130 4
//TODO: add link from ChildNode to it's compartment into genmodel
			if (!genChildContainer.getGroupID().equals(nextChildNode.getGroupID())) {
				continue;
			}
d199 1
a199 1
						return "<%=genChildContainer.getTitleKey()%>";
d287 1
a287 1
	List genChildNodes = genNode.getChildNodes();
@


1.17
log
@[ashatalin] #113258 sync diagram and domain models using canonicalEditPolicy
@
text
@d135 1
a135 1
			GenFeature genFeature = nextChildNode.getChildMetaFeature() != null ? nextChildNode.getChildMetaFeature() : nextChildNode.getModelFacet().getContainmentMetaFeature();
@


1.16
log
@[dstadnik] #113525 Get rid of LinkWithClass/LinkWithReference, use parallel hierarchy of modelFacet instead
@
text
@d7 5
d14 1
d22 1
d85 1
a85 1
		EObject element = node.getElement();
d92 1
d124 75
@


1.15
log
@[dstadnik] #112195 multiple labels for the node, facets introduced, genmodel cleaned and refactored
@
text
@d147 3
a149 3
		if (genLink instanceof GenLinkWithClass) {
			GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
			String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
d240 1
a240 1
		if (genLink instanceof GenLinkReferenceOnly) {
d259 1
a259 1
		if (genLink instanceof GenLinkWithClass) {
@


1.14
log
@[dstadnik] #112174 and #112185 - constants for compartments and labels
@
text
@d90 4
a93 2
	if (genNode.hasNameToEdit()) {
		String semanticHint = semanticHintsClassName + '.' + AccessUtil.getNameSemanticHint(genNode);
d95 2
a96 2
			if (<%=semanticHint%>.equals(node.getType())) {
				return new <%=AccessUtil.getNodeLabelEditPartClassName(genNode)%>(node);
d137 1
a137 3
<%
if (genLinks.size() != 0) {
%>
d155 3
a157 3
				LinkLabel label = (LinkLabel) labels.get(j);
				String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLinkLabelId(label);
				String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLinkLabelTextId(label);
d172 1
a172 1
							parser = new StructuralFeatureParser(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().getEStructuralFeature("<%=label.getDomainMetaFeature().getName()%>"));
d185 1
a185 3
<%
}
%>				
d214 2
a215 1
<%	}
d234 1
a234 3
<%
if (!genLinks.isEmpty()) {
%>
d268 1
a268 3
<%
}
%>
@


1.13
log
@[dstadnik] #112176 support references w/o domain class
@
text
@d40 1
a40 2
				boolean isTopLevel = view.eContainer() instanceof Diagram || (view.getType() != null && view.getType().length() > 0);
				if (isTopLevel) {
d88 2
a90 2
		String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d101 1
d103 1
a103 1
			if ("<%=genChildContainer.getGroupID()%>".equals(node.getType())) {
d145 2
d156 2
d159 1
a159 1
			if ("<%=AccessUtil.getLinkLabelViewName(label)%>".equals(node.getType())) {
d167 1
a167 1
			if ("<%=AccessUtil.getLinkLabelTextViewName(label)%>".equals(node.getType())) {
a262 1
			GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
d276 1
a276 1
	
a283 1

@


1.12
log
@[ashatalin] #112122 Action to initialize diagram for domain model.
 unique id introduced, refactoring to use it throughout the code
@
text
@d232 1
a232 1
if (genLinks.size() != 0) {
d235 17
@


1.11
log
@[rdvorak] #112097 genmodel support to use expression evaluation to choose editpart (visual representation)
@
text
@a8 1
import org.eclipse.emf.ecore.EClass;
d55 2
d65 1
a65 2
		EClass elementMetaclass = element.eClass();
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>().equals(elementMetaclass) && isDiagram<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>_<%=genDiagram.getVisualID()%>((<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%>) element)) {
d75 4
d80 3
a82 42
		EClass elementMetaclass = element.eClass();
<%
List genLinks = genDiagram.getLinks();
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink instanceof GenLinkWithClass) {
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
%>
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(elementMetaclass) && isEdge<%=semanticLinkInterfaceName%>_<%=genLinkWithClass.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) element)) {
<%
		List labels = genLink.getLabels();
		for (int j = 0; j < labels.size(); j++) {
			LinkLabel label = (LinkLabel) labels.get(j);
%>
			if ("<%=AccessUtil.getLinkLabelViewName(label)%>".equals(node.getType())) {
				return new LabelEditPart(node) {

					public int getKeyPoint() {
						return ConnectionLocator.<%=label.getAlignment()%>;
					}
				};
			}
			if ("<%=AccessUtil.getLinkLabelTextViewName(label)%>".equals(node.getType())) {
				return new TextCompartmentEditPart(node) {

					public IParser getParser() {
						if (parser == null) {
							parser = new StructuralFeatureParser(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().getEStructuralFeature("<%=label.getDomainMetaFeature().getName()%>"));
						}
						return parser;
					}
				};
			}
<%		}%>
			return null;
		}
<%
	}
}
%>				
a83 1
List genNodes = genDiagram.getNodes();
a85 2
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getClassifierAccessorName();
	String qualifiedInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
d87 1
a87 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticNodeInterfaceName%>().equals(elementMetaclass) && isNode<%=semanticNodeInterfaceName%>_<%=genNode.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) element)) {
a123 1
		} else
a126 2
		{ 
			return createUnrecognizedNodeEditPart(node);
d128 1
d134 58
a191 2
	 private EditPart createUnrecognizedNodeEditPart(Node node) {
	 	// Handle creation of unrecognized node EditParts here
d193 1
a193 1
	 }
d200 3
a202 1
		EClass elementMetaclass = element.eClass();
a208 2
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
d210 1
a210 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticChildNodeInterfaceName%>().equals(elementMetaclass) && isChildNode<%=semanticChildNodeInterfaceName%>_<%=genChildNode.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) element)) {
a211 1
		} else 
d215 2
a216 3
		{ 
			return createUnrecognizedChildNodeEditPart(node);
		}
a230 2
		EObject element = edge.getElement();
		EClass elementMetaclass = element.eClass();
d232 1
a232 1
if (genLinks.size() == 0) {
d234 4
a237 1
		return createUnrecognizedEdgeEditPart(edge);
a238 1
} else {
a242 2
			String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
			String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
d244 1
a244 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(elementMetaclass) && isEdge<%=semanticLinkInterfaceName%>_<%=genLinkWithClass.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) element)) {
a245 1
		} else 
a249 2
		{
			return createUnrecognizedEdgeEditPart(edge);
d253 2
a254 1
%>				
a264 57
	/**
	 * @@generated
	 */
	private boolean isDiagram<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>_<%=genDiagram.getVisualID()%>(<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%> element) {
		return true;
	}
	
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getClassifierAccessorName();
	String qualifiedNodeInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
%>
	/**
	 * @@generated
	 */
	private boolean isNode<%=semanticNodeInterfaceName%>_<%=genNode.getVisualID()%>(<%=importManager.getImportedName(qualifiedNodeInterfaceName)%> element) {
		return <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genNode)%>(element);
	}

<%
	List genChildNodes = genNode.getChildNodes();
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedChildNodeInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
%>
	/**
	 * @@generated
	 */
	private boolean isChildNode<%=semanticChildNodeInterfaceName%>_<%=genChildNode.getVisualID()%>(<%=importManager.getImportedName(qualifiedChildNodeInterfaceName)%> element) {
		return <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genChildNode)%>(element);
	}

<%	}
}
%>
	
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink instanceof GenLinkWithClass) {
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
%>
	/**
	 * @@generated
	 */
	private boolean isEdge<%=semanticLinkInterfaceName%>_<%=genLinkWithClass.getVisualID()%>(<%=importManager.getImportedName(qualifiedInterfaceName)%> element) {
		return <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genLink)%>(element);
	}
<%
	}
}
%>

@


1.10
log
@[dstadnik] #112194 Link label should be positioned on the link accordingly to it's weight defined
in gmfgen model
@
text
@d272 1
a272 1
		return true;
d286 1
a286 1
		return true;
d305 1
a305 1
		return true;
@


1.9
log
@[dstadnik] #112189 remove editProviders package attribute from genmodel
@
text
@d7 1
d93 6
a98 1
				return new LabelEditPart(node);
@


1.8
log
@[dstadnik]
#111780 Link labels with read-only flag and relative positioning
@
text
@d23 1
a23 1
import <%=genDiagram.getEditProvidersPackageName()%>.StructuralFeatureParser;
d122 1
a122 1
		String semanticHintsQualifiedClassName = genDiagram.getEditProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
@


1.7
log
@missing import
@
text
@d12 2
d15 1
d23 1
d77 36
a213 1
List genLinks = genDiagram.getLinks();
@


1.6
log
@[ashatalin]
#111773 Multiple views for single domain metaelement based on it's state
#111782 Support same metaelement both as top-level and inner diagram element
@
text
@d8 1
@


1.5
log
@[dstadnik]
#111455 Generate consistent names for notation view factories
#111461 Do not use 'final' keyword in method parameters
#111460 Generate dedicated edit part for the node label
#111457 Use model labels in palette factory
@
text
@d15 3
d32 16
a47 1
			EObject element = view.getElement();
d52 60
a111 2
			if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genDiagram.getDomainDiagramElement().getName()%>().isInstance(element)) {
				return new <%=genDiagram.getEditPartClassName()%>(view);
d113 25
a138 1
List genNodes = genDiagram.getNodes();
d140 12
a151 2
		GenNode genNode = (GenNode) genNodes.get(i);
		String semanticNodeInterfaceName = genNode.getDomainMetaClass().getName();
d153 19
a171 1
			else if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticNodeInterfaceName%>().isInstance(element)) {
d173 2
a174 4
		if (genNode.hasNameToEdit()) {
			String semanticHintsQualifiedClassName = genDiagram.getEditProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
			String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
			String semanticHint = semanticHintsClassName + '.' + AccessUtil.getNameSemanticHint(genNode);
d176 13
a188 3
				if (<%=semanticHint%>.equals(view.getType())) {
					return new <%=AccessUtil.getNodeLabelEditPartClassName(genNode)%>(view);
				}
d191 38
a228 26
		List genChildContainers = genNode.getChildContainers();
		for (int j = 0; j < genChildContainers.size(); j++) {
			GenChildContainer genChildContainer = (GenChildContainer) genChildContainers.get(j);
%>
				if ("<%=genChildContainer.getGroupID()%>".equals(view.getType())) {
					return new ListCompartmentEditPart(view) {

						protected boolean hasModelChildrenChanged(Notification evt) {
							return false;
						}

						protected void createDefaultEditPolicies() {
							super.createDefaultEditPolicies();
							installEditPolicy(EditPolicyRoles.CREATION_ROLE, new CreationEditPolicy());
							installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE, new DragDropEditPolicy());
							//installEditPolicy(EditPolicy.NODE_ROLE, null);
						}

						protected String getTitleName() {
							return "<%=genChildContainer.getTitleKey()%>";
						}
					};
				}
<%		}%>
				return new <%=genNode.getEditPartClassName()%>(view);
			}
d230 5
a234 4
		List genChildNodes = genNode.getChildNodes();
		for (int j = 0; j < genChildNodes.size(); j++) {
			GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
			String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getName();
d236 8
a243 4
			else if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticChildNodeInterfaceName%>().isInstance(element)) {
				return new <%=genChildNode.getEditPartClassName()%>(view);
			}
<%		}
d245 3
a247 1
List genLinks = genDiagram.getLinks();
d252 2
a253 1
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getName();
d255 6
a260 3
			else if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().isInstance(element)) {
				return new <%=genLink.getEditPartClassName()%>(view);
			}
d265 1
a265 3
		}
		return null;
	}
@


1.4
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d2 1
a2 1
	imports="java.util.List org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.util.*"%>
a10 1
import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;
a11 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.TextCompartmentEditPart;
a15 1
import <%=genDiagram.getEditProvidersPackageName()%>.StructuralFeatureParser;
d51 1
a51 11
					return new TextCompartmentEditPart(view) {

						public IParser getParser() {
							if (parser == null) {
								if (<%=semanticHint%>.equals(((View) getModel()).getType())) {
									parser = new StructuralFeatureParser(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticNodeInterfaceName%>().getEStructuralFeature("<%=genNode.getDomainNameFeature().getName()%>"));
								}
							}
							return parser;
						}
					};
@


1.3
log
@[dstadnik] support for (a) connections (with associated domain class) and (b) compartments
@
text
@d34 1
a34 1
GenPackage genPackage = genDiagram.getEmfGenModel().findGenPackage(genDiagram.getDomainMetaModel());
@


1.2
log
@[dstadnik] Use Notation Model as runtime model
@
text
@d2 1
a2 1
  imports="java.util.List org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.util.*"%>
d7 1
d12 1
a12 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
d14 3
d38 1
a38 1
				return new DiagramEditPart(view);
d66 25
d94 25
a118 1
<%}%>
@


1.1
log
@*** empty log message ***
@
text
@d1 2
a2 2
<%@@ jet package="org.eclipse.gmf.codegen.templates.diacanvas" class="EditPartFactoryGen" 
  imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.ecore.* org.eclipse.emf.codegen.ecore.genmodel.* java.util.* org.eclipse.gmf.codegen.util.ImportUtil"%>
d5 1
d7 8
a14 4

import org.eclipse.emf.ecore.*;
import org.eclipse.gef.*;
import org.eclipse.gmf.diagramrt.*;
d26 3
a28 20
		if (model instanceof ChildNode) {
			return createChildEditPart(context, (ChildNode) model);
		}
		if (model instanceof DiagramNode) {
			return createNodeEditPart(context, (DiagramNode) model);
		}
		if (model instanceof DiagramLink) {
			return createLinkEditPart(context, (DiagramLink) model);
		}
		if (model instanceof DiagramCanvas) {
			return createCanvasEditPart(context, (DiagramCanvas) model);
		}
		return null;
	}

	/**
	 * @@generated
	 */
	public EditPart createNodeEditPart(EditPart context, DiagramNode diagramElement) {
		final int visualID = diagramElement.getVisualID();
d30 2
a31 3
	//HashMap domainToGenNode = new HashMap();
	for (Iterator it = genDiagram.getNodes().iterator(); it.hasNext();) {
		GenNode genNode = (GenNode) it.next();
d33 3
a35 1
		<%@@ include file="nodeepfactory.jetinc"%>
d37 4
a40 1
	}
d42 1
a42 9
		System.err.println("No NodeEditPart for " + diagramElement + " with visualID=" + visualID);
		return null;
	}

	/**
	 * @@generated
	 */
	public EditPart createLinkEditPart(EditPart context, DiagramLink diagramElement) {
		final int visualID = diagramElement.getVisualID();
d44 23
a66 8
	for (Iterator it = genDiagram.getLinks().iterator(); it.hasNext();) {
		GenLink genLink = (GenLink) it.next();
%>
		<%@@ include file="linkepfactory.jetinc"%>
<%
	}
%>
		System.err.println("No LinkEditPart for " + diagramElement + " with visualID=" + visualID);
a68 26

	/**
	 * @@generated
	 */
	public EditPart createChildEditPart(EditPart context, ChildNode diagramElement) {
		DiagramNode parentNode = (DiagramNode) context.getModel();
		final EClass parentMetaClass = parentNode.getDomainModelElement().eClass();
		final EClass childMetaClass = diagramElement.getDomainModelElement().eClass();
<%
	for (Iterator it = genDiagram.getNodes().iterator(); it.hasNext();) {
		GenNode genNode = (GenNode) it.next();
		if (!genNode.getChildNodes().isEmpty()) {
%>
		<%@@ include file="childnodeepfactory.jetinc"%>
<%		}
	}
%>
		return null;
	}

	/**
	 * @@generated
	 */
	public EditPart createCanvasEditPart(EditPart context, DiagramCanvas model) {
		return new <%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>(model);
	}
d70 1
a70 1
<%importManager.emitSortedImports();%>@

