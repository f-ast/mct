head	1.24;
access;
symbols
	v20081022-1925:1.24
	v20081015-1925:1.24
	v20081008-1925:1.24
	v20081001-1925:1.24
	v20080930-1130:1.24
	v20080926-1245:1.24
	v20080924-1925:1.24
	v20080917-1925:1.24
	v20080911-1728:1.24
	v20080910-1520:1.24
	v20080903-1520:1.24
	v20080827-1520:1.24
	v20080813-1520:1.24
	v20080806-1520:1.24
	v20080722-1827:1.24
	v20080718-1731:1.24
	v20080716-1600:1.21.2.1
	v20080716-1642:1.24
	R2_1_maintenance:1.21.0.2
	Root_R2_1_maintenance:1.21
	R2_1_0:1.21
	v20080610-1132:1.21
	v20080603-1553:1.21
	v20080528-1052:1.21
	v20080521:1.20
	v20080516-1543:1.18
	v20080516-1143:1.18
	v20080512-1200:1.18
	v20080508-2000:1.17
	v20080507-1326:1.17
	v20080503-1740:1.13
	v20080501-1739:1.13
	v20080425-1959:1.11
	v20080417-1610:1.11
	v20080411-0411:1.10
	v20080404-1111:1.10
	v20080322-0000:1.10
	v20080222-1200:1.3
	v20080215-1500:1.3
	v20080207-0207:1.1.2.3
	v20071222-1111:1.2
	v20071214-1111:1.2
	v20071130-1111:1.2
	v20071124-0000:1.1.2.2
	v20071112-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070928-0000:1.1.2.2
	v20070921-0000:1.1.2.2
	v20070915-0000:1.1.2.2
	R2_0_maintenance:1.1.0.2;
locks; strict;
comment	@# @;


1.24
date	2008.07.01.20.17.58;	author atikhomirov;	state Exp;
branches;
next	1.23;
commitid	275f486a90f64567;

1.23
date	2008.07.01.18.48.54;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	4f11486a7c164567;

1.22
date	2008.06.27.14.32.04;	author ashatalin;	state Exp;
branches;
next	1.21;
commitid	1f994864f9e34567;

1.21
date	2008.05.28.12.37.11;	author ashatalin;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	5958483d51f64567;

1.20
date	2008.05.20.17.10.11;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	30ed483305f34567;

1.19
date	2008.05.20.15.45.10;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	29294832f2054567;

1.18
date	2008.05.12.16.14.29;	author atikhomirov;	state Exp;
branches;
next	1.17;
commitid	5cf648286ce44567;

1.17
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	39124821b4de4567;

1.16
date	2008.05.05.21.06.41;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	4186481f76b14567;

1.15
date	2008.05.05.18.20.18;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	446f481f4fe14567;

1.14
date	2008.05.05.11.25.38;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	3020481eeeb24567;

1.13
date	2008.04.30.21.02.48;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	8334818de784567;

1.12
date	2008.04.30.13.16.12;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	7a874818711c4567;

1.11
date	2008.04.14.08.31.34;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	bb3480316654567;

1.10
date	2008.03.05.17.13.14;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	2bbd47ced4aa4567;

1.9
date	2008.03.05.16.41.09;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	4c0b47cecd244567;

1.8
date	2008.03.04.20.27.07;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	2ac447cdb09b4567;

1.7
date	2008.02.29.21.19.51;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	45a447c876f24567;

1.6
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	19d047c419ed4567;

1.5
date	2008.02.22.11.56.45;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	6cf447beb87c4567;

1.4
date	2008.02.22.11.24.53;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	5c9347beb1044567;

1.3
date	2008.02.06.11.31.32;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	49c147a99a944567;

1.2
date	2007.09.10.21.17.30;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	153446e5b4694567;

1.1
date	2007.09.10.20.58.22;	author dstadnik;	state dead;
branches
	1.1.2.1;
next	;
commitid	f4446e5afed4567;

1.1.2.1
date	2007.09.10.20.58.22;	author dstadnik;	state Exp;
branches;
next	1.1.2.2;
commitid	f4446e5afed4567;

1.1.2.2
date	2007.09.10.21.02.18;	author dstadnik;	state Exp;
branches;
next	1.1.2.3;
commitid	1cb446e5b0da4567;

1.1.2.3
date	2008.02.06.11.29.01;	author ashatalin;	state Exp;
branches;
next	;
commitid	468247a999fd4567;

1.21.2.1
date	2008.06.27.14.35.04;	author ashatalin;	state Exp;
branches;
next	;
commitid	22d84864fa974567;


desc
@@


1.24
log
@[227127] support literal values for feature initializers. step 2: generate initialization code according to model setting
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - refactored javaInitilizers not to use methods from GMFGen model
 *                               [221347] Got rid of generated interfaces 
 *                               (IObjectInitializer, IFeatureInitializer) and implementation thereof
 */

«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::providers::ElementInitializers»

«DEFINE ElementInitializers FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class ElementInitializers {
	«EXPAND Initializers»
	«EXPAND JavaSupport»
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE Initializers FOR GenDiagram-»
	«EXPAND initMethod FOREACH getAllNodes()-»
	«EXPAND initMethod FOREACH links-»
«ENDDEFINE»

«DEFINE JavaSupport FOR GenDiagram-»
«IF editorGen.expressionProviders != null && !editorGen.expressionProviders.providers.typeSelect(GenJavaExpressionProvider).isEmpty()-»
	«EXPAND javaMethod FOREACH getAllNodes()-»
	«EXPAND javaMethod FOREACH links-»
«ENDIF-»
«ENDDEFINE»


«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»


«REM»
	Definitions of initializer objects.
«ENDREM»

«DEFINE initMethod FOR GenNode»«EXPAND initMethod(this) FOR modelFacet»«ENDDEFINE»
«DEFINE initMethod FOR GenLink»«EXPAND initMethod(this) FOR modelFacet»«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR TypeModelFacet-»
«EXPAND initMethod(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR GenElementInitializer»«ERROR "No idea how to init using " + this»«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static void init_«diagramElement.getUniqueIdentifier()»(«EXPAND MetaModel::QualifiedClassName FOR elementClass» instance) {
		try {
			«FOREACH initializers AS i»«EXPAND performInit(diagramElement, "instance", elementClass, getSuffixes(initializers.indexOf(i))) FOR i»«ENDFOREACH-»
		} catch(RuntimeException e) {
			«diagramElement.getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Element initialization failed", e); //$NON-NLS-1$						
		}
	}
«ENDDEFINE»

«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, List[int] counters) FOR GenFeatureInitializer»«ENDDEFINE»

«REM»
		FIXME: need cleaner appoach to provider's language switch (not to mix if == literal and polymorphism)
«ENDREM»
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, List[int] counters) FOR GenFeatureValueSpec-»
«IF value.provider.getLanguage() == GenLanguage::literal-»
	«EXPAND MetaModel::modifyFeature(instanceVar, instanceClass, value.body) FOR feature»
«ELSE-»
«LET getVariableName("value", counters) AS expressionVarName-»
	Object «expressionVarName» = «EXPAND evaluateExpr(diagramElement, this, instanceVar) FOR value.provider»;
«IF isListType(feature)-»
	if («expressionVarName» instanceof java.util.Collection) {
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».clear();
«IF expressionResultNeedsCast(getTypeGenClassifier(feature))-»
		for (java.util.Iterator it = ((java.util.Collection) «expressionVarName»).iterator(); it.hasNext(); ) {
			Object next = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(it.next(), «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
			«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add(next);
		}
«ELSE-»
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».addAll(((java.util.Collection) «expressionVarName»));
«ENDIF-»
	} else {
«IF expressionResultNeedsCast(getTypeGenClassifier(feature))-»
		«expressionVarName» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(«expressionVarName», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
«ENDIF-»
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add((«EXPAND MetaModel::QualifiedClassName /*XXX sorta hack, better would be MM::setFeatureValue that supports lists*/FOR getTypeGenClassifier(feature)») «expressionVarName»);
	}
«ELSE-»
«IF expressionResultNeedsCast(getTypeGenClassifier(feature))»
	«expressionVarName» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(«expressionVarName», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
«ENDIF-»
	«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, expressionVarName, true) FOR feature»;
«ENDIF /*isListType*/-»
«ENDLET-»
«ENDIF /*is literal expression*/-»
«ENDDEFINE»

«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, List[int] counters) FOR GenReferenceNewElementSpec-»
«FOREACH newElementInitializers AS newElemInit-»
«LET getSuffixes(counters, newElementInitializers.indexOf(newElemInit)) AS initializerCounters-»
«LET getVariableName("newInstance", initializerCounters) AS newInstanceVar-»
«EXPAND MetaModel::NewInstance(newInstanceVar) FOR newElemInit.elementClass»
«EXPAND MetaModel::modifyFeature(instanceVar, instanceClass, newInstanceVar) FOR feature»;
«FOREACH newElemInit.initializers AS i»«EXPAND performInit(diagramElement, newInstanceVar, newElemInit.elementClass, getSuffixes(initializerCounters, newElemInit.initializers.indexOf(i))) FOR i»«ENDFOREACH»
«ENDLET-»
«ENDLET-»
«ENDFOREACH-»
«ENDDEFINE»

/////////////////////////////////

«DEFINE evaluateExpr(GenCommonBase diagramElement, GenFeatureValueSpec valueExpr, String instanceVar) FOR GenExpressionProviderBase»«ENDDEFINE»

// XXX perhaps, using instance.eClass() is better option than MetaModel::MetaClass (though, need to rely on instance variable name/type) 
«DEFINE evaluateExpr(GenCommonBase diagramElement, GenFeatureValueSpec valueExpr, String instanceVar) FOR GenExpressionInterpreter-»
«EXPAND xpt::expressions::getExpression::getExpression(valueExpr.value, valueExpr.featureSeqInitializer.elementClass)».evaluate(«instanceVar»)«-»
«ENDDEFINE»

«REM»
	XXX revisit: if emf java merge doesn't support genereated NOT methods with modified
	return type, there's no much sense to keep Object value = invokeJavaMethodWithSpecificReturnType,
	as client won't benefit from such code (he can't modify return type and thus would get duplicated methods on regeneration)
	However, if merge does ignore method return type when merging, allowing Object as return type may help. 
«ENDREM»
«DEFINE evaluateExpr(GenCommonBase diagramElement, GenFeatureValueSpec valueExpr, String instanceVar) FOR GenJavaExpressionProvider-»
«javaMethodName(diagramElement, valueExpr)»(«instanceVar»)«-»
«ENDDEFINE»

/////////////////////////////////

«DEFINE javaMethod FOR GenNode»«EXPAND javaMethod(this) FOR modelFacet»«ENDDEFINE»
«DEFINE javaMethod FOR GenLink»«EXPAND javaMethod(this) FOR modelFacet»«ENDDEFINE»
«DEFINE javaMethod(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»
«DEFINE javaMethod(GenCommonBase diagramElement) FOR TypeModelFacet-»
«EXPAND javaMethod(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»

«DEFINE javaMethod(GenCommonBase diagramElement) FOR GenElementInitializer»«ERROR "No idea how to handle " + this»«ENDDEFINE»
«DEFINE javaMethod(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
«FOREACH recurseCollectValueSpec(this) AS vs»«EXPAND javaMethod(diagramElement, vs) FOR vs.value.provider»«ENDFOREACH-»
«ENDDEFINE»

«DEFINE javaMethod(GenCommonBase diagramElement, GenFeatureValueSpec vs) FOR GenExpressionProviderBase-»«ENDDEFINE»
«DEFINE javaMethod(GenCommonBase diagramElement, GenFeatureValueSpec vs) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static «EXPAND MetaModel::featureTargetType FOR vs.feature» «javaMethodName(diagramElement, vs)»(«EXPAND MetaModel::QualifiedClassName FOR vs.featureSeqInitializer.elementClass» self) {
«IF injectExpressionBody && vs.value.body != null && vs.value.body.length() != 0-»
		«vs.value.body»
«ELSEIF throwException || (injectExpressionBody && (vs.value.body == null || vs.value.body.length() == 0))-»
		// TODO: implement this method to return value  
		// for «EXPAND MetaModel::MetaFeature FOR vs.feature»
		// Ensure that you remove @@generated or mark it @@generated NOT
		throw new java.lang.UnsupportedOperationException("No user java implementation provided in '«javaMethodName(diagramElement, vs)»' operation");«EXPAND xpt::Common::nonNLS»
«ELSE-»
		return null;
«ENDIF-»	
	}
«ENDDEFINE»@


1.23
log
@refactored templates moving towards [188329] - Support Java 5.0 (would need to respect generic types when adding into collections) while trying to accomplish [227127]
@
text
@d78 3
d82 3
d111 1
@


1.22
log
@[238295] - Can't organize imports due to syntax errors in the compilation unit ElementInitializers.java, Counter overflow? 2.1 RC3
@
text
@d112 1
a112 5
«IF isListType(feature)-»
«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass) FOR feature».add(«newInstanceVar»);
«ELSE-»
«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, newInstanceVar) FOR feature»;
«ENDIF-»
@


1.21
log
@[233205] - Support Polyline figure in .gmfgraph editor
@
text
@d69 1
a69 1
			«FOREACH initializers AS i»«EXPAND performInit(diagramElement, "instance", elementClass, initializers.indexOf(i)) FOR i»«ENDFOREACH-»
d76 1
a76 1
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, int count) FOR GenFeatureInitializer»«ENDDEFINE»
d78 3
a80 2
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, int count) FOR GenFeatureValueSpec-»
	Object value«count» = «EXPAND evaluateExpr(diagramElement, this, instanceVar) FOR value.provider»;
d82 1
a82 1
	if (value«count» instanceof java.util.Collection) {
d85 1
a85 1
		for (java.util.Iterator it = ((java.util.Collection) value«count»).iterator(); it.hasNext(); ) {
d90 1
a90 1
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».addAll(((java.util.Collection) value«count»));
d94 1
a94 1
		value«count» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(value«count», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
d96 1
a96 1
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add((«EXPAND MetaModel::QualifiedClassName /*XXX sorta hack, better would be MM::setFeatureValue that supports lists*/FOR getTypeGenClassifier(feature)») value«count»);
d100 1
a100 1
	value«count» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(value«count», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
d102 1
a102 1
	«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, "value" + count, true) FOR feature»;
d104 1
d107 4
a110 4
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, int count) FOR GenReferenceNewElementSpec-»
«FOREACH newElementInitializers AS newElemInit»
«LET (count+1)*100+newElementInitializers.indexOf(newElemInit) AS initializerCount-»
«LET "newInstance" + initializerCount AS newInstanceVar-»
d117 1
a117 1
«FOREACH newElemInit.initializers AS i»«EXPAND performInit(diagramElement, newInstanceVar, newElemInit.elementClass, (initializerCount+1)*100 + newElemInit.initializers.indexOf(i)) FOR i»«ENDFOREACH-»
a122 1

@


1.21.2.1
log
@[238295] - Can't organize imports due to syntax errors in the compilation unit ElementInitializers.java, Counter overflow? 2.1 RC3
@
text
@d69 1
a69 1
			«FOREACH initializers AS i»«EXPAND performInit(diagramElement, "instance", elementClass, getSuffixes(initializers.indexOf(i))) FOR i»«ENDFOREACH-»
d76 1
a76 1
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, List[int] counters) FOR GenFeatureInitializer»«ENDDEFINE»
d78 2
a79 3
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, List[int] counters) FOR GenFeatureValueSpec-»
«LET getVariableName("value", counters) AS expressionVarName-»
	Object «expressionVarName» = «EXPAND evaluateExpr(diagramElement, this, instanceVar) FOR value.provider»;
d81 1
a81 1
	if («expressionVarName» instanceof java.util.Collection) {
d84 1
a84 1
		for (java.util.Iterator it = ((java.util.Collection) «expressionVarName»).iterator(); it.hasNext(); ) {
d89 1
a89 1
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».addAll(((java.util.Collection) «expressionVarName»));
d93 1
a93 1
		«expressionVarName» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(«expressionVarName», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
d95 1
a95 1
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add((«EXPAND MetaModel::QualifiedClassName /*XXX sorta hack, better would be MM::setFeatureValue that supports lists*/FOR getTypeGenClassifier(feature)») «expressionVarName»);
d99 1
a99 1
	«expressionVarName» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(«expressionVarName», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
d101 1
a101 1
	«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, expressionVarName, true) FOR feature»;
a102 1
«ENDLET-»
d105 4
a108 4
«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, List[int] counters) FOR GenReferenceNewElementSpec-»
«FOREACH newElementInitializers AS newElemInit-»
«LET getSuffixes(counters, newElementInitializers.indexOf(newElemInit)) AS initializerCounters-»
«LET getVariableName("newInstance", initializerCounters) AS newInstanceVar-»
d115 1
a115 1
«FOREACH newElemInit.initializers AS i»«EXPAND performInit(diagramElement, newInstanceVar, newElemInit.elementClass, getSuffixes(initializerCounters, newElemInit.initializers.indexOf(i))) FOR i»«ENDFOREACH»
d121 1
@


1.20
log
@[221347] comment 4: duplicated methods when there are more than one initializer for specific feature - tell them apart by diagram element.
@
text
@d107 3
a109 1
«EXPAND MetaModel::NewInstance("newInstance" + count) FOR newElemInit.elementClass»
d111 1
a111 1
«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass) FOR feature».add(newInstance«count»);
d113 1
a113 1
«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, "newInstance" + count) FOR feature»;
d115 3
a117 1
«FOREACH newElemInit.initializers AS i»«EXPAND performInit(diagramElement, "newInstance" + count, newElemInit.elementClass, (count+1)*100 + newElemInit.initializers.indexOf(i)) FOR i»«ENDFOREACH-»
@


1.19
log
@[228913], JavaProvider attributes: even if no body is set but throwsException is false, do not generate exception, rather respect throwException==false
@
text
@d40 3
a42 22
«IF editorGen.expressionProviders != null-»
«LET getJavaValueSpecs(this) AS javaValueSpecs-»
«FOREACH javaValueSpecs.value.purgeDups() AS valueExpr-»
«FOREACH javaValueSpecs.select(vs | vs.value == valueExpr).feature.purgeDups() AS genFeature-»
«LET (GenFeatureValueSpec) javaValueSpecs.select(vs | vs.value == valueExpr && vs.feature == genFeature).first() AS vs»
	«EXPAND xpt::Common::generatedMemberComment»
	private static «EXPAND MetaModel::featureTargetType FOR vs.feature» «javaMethodName(vs)»(«EXPAND MetaModel::QualifiedClassName FOR vs.featureSeqInitializer.elementClass» self) {
«IF ((GenJavaExpressionProvider) vs.value.provider).injectExpressionBody && vs.value.body != null && vs.value.body.length() != 0-»
		«vs.value.body»
«ELSEIF ((GenJavaExpressionProvider) vs.value.provider).throwException || (((GenJavaExpressionProvider) vs.value.provider).injectExpressionBody && (vs.value.body == null || vs.value.body.length() == 0))-»
		// TODO: implement this method to return value  
		// for «EXPAND MetaModel::MetaFeature FOR vs.feature»
		// Ensure that you remove @@generated or mark it @@generated NOT
		throw new java.lang.UnsupportedOperationException("No user java implementation provided in '«javaMethodName(vs)»' operation");«EXPAND xpt::Common::nonNLS»
«ELSE-»
		return null;
«ENDIF-»	
	}
«ENDLET-»
«ENDFOREACH-»
«ENDFOREACH-»
«ENDLET-»
d134 1
a134 1
«javaMethodName(valueExpr)»(«instanceVar»)«-»
d136 31
@


1.18
log
@possible compilation error for Java5-enabled domain models - lists are typed, hence need explicit cast
@
text
@d49 1
a49 1
«ELSEIF ((GenJavaExpressionProvider) vs.value.provider).throwException || vs.value.body == null || vs.value.body.length() == 0-»
@


1.17
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d114 1
a114 1
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add(value«count»);
d146 6
@


1.16
log
@[228913] cleaned isCopy and java provider's getOperationName that are not in use any more; introduced fine-tuning options: use expressions body for java methods and whether to throw exception or fail silently (using reasonable/appropriate for the context default value), latter change obsoleted NoImplException and respective debug options
@
text
@d17 1
a17 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
d40 22
a61 3
«IF editorGen.expressionProviders != null && !editorGen.expressionProviders.providers.typeSelect(GenJavaExpressionProvider).isEmpty()-»
	«EXPAND javaInitializer FOREACH getAllNodes()-»
	«EXPAND javaInitializer FOREACH links-»
d65 1
d98 1
a98 1
	Object value«count» = «EXPAND evaluateExpr(diagramElement, this, instanceVar) FOR diagramElement.getDiagram().editorGen.expressionProviders.getProvider(this)»;
d143 1
a143 1
«EXPAND xpt::expressions::getExpression::getExpression(valueExpr, valueExpr.featureSeqInitializer.elementClass)».evaluate(«instanceVar»)«-»
d147 1
a147 1
«javaMethodName(diagramElement, valueExpr)»(«instanceVar»)«-»
a148 36


«REM»
	Definitions of Java initialization methods.
«ENDREM»

«DEFINE javaInitializer FOR GenNode»«EXPAND javaInitializer(this) FOR modelFacet»«ENDDEFINE»
«DEFINE javaInitializer FOR GenLink»«EXPAND javaInitializer(this) FOR modelFacet»«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR TypeModelFacet-»
«EXPAND javaInitializer(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenElementInitializer»«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
«FOREACH diagramElement.getDiagram().editorGen.expressionProviders.providers.typeSelect(GenJavaExpressionProvider) AS jp-»
«FOREACH getFeatureInitializers(this, jp) AS valueExpression-»
«EXPAND xpt::Common::generatedMemberComment»
private static «EXPAND MetaModel::featureTargetType FOR valueExpression.feature» «javaMethodName(diagramElement, valueExpression)»(«EXPAND MetaModel::QualifiedClassName FOR valueExpression.featureSeqInitializer.elementClass» self) {
«IF jp.injectExpressionBody && valueExpression.body != null && valueExpression.body.length() != 0-»
	«valueExpression.body»
«ELSEIF jp.throwException || valueExpression.body == null || valueExpression.body.length() == 0-»
	// TODO: implement this method to return value  
	// for «EXPAND MetaModel::MetaFeature FOR valueExpression.feature»
	// Ensure that you remove @@generated or mark it @@generated NOT
	throw new java.lang.UnsupportedOperationException("No user java implementation provided in '«javaMethodName(diagramElement, valueExpression)»' operation");«EXPAND xpt::Common::nonNLS»
«ELSE-»
	return null;
«ENDIF-»	
}
«ENDFOREACH-»
«ENDFOREACH-»
«ENDDEFINE»@


1.15
log
@[228913] item 4 - do not use expression body to create method name
@
text
@d151 3
d157 4
a160 5
	/* Expression body:
	   «valueExpression.body»
	 */
	
	throw new «jp.container.getAbstractExpressionQualifiedClassName()».NoImplException("No user java implementation provided in '«javaMethodName(diagramElement, valueExpression)»' operation");«EXPAND xpt::Common::nonNLS»
@


1.14
log
@[226725] Refactor domain element initialization not to be duplicated in Lite RT
@
text
@d41 2
a42 5
	«EXPAND xpt::Common::generatedMemberComment»
	static class Java {
		«EXPAND javaInitializer FOREACH getAllNodes()-»
		«EXPAND javaInitializer FOREACH links-»
	}
d78 1
a78 1
	Object value«count» = «EXPAND evaluateExpr(this, instanceVar) FOR diagramElement.getDiagram().editorGen.expressionProviders.getProvider(this)»;
d119 1
a119 1
«DEFINE evaluateExpr(GenFeatureValueSpec valueExpr, String instanceVar) FOR GenExpressionProviderBase»«ENDDEFINE»
d122 1
a122 1
«DEFINE evaluateExpr(GenFeatureValueSpec valueExpr, String instanceVar) FOR GenExpressionInterpreter-»
d126 2
a127 2
«DEFINE evaluateExpr(GenFeatureValueSpec valueExpr, String instanceVar) FOR GenJavaExpressionProvider-»
Java.«getOperationName(valueExpr)»(«instanceVar»)«-»
d150 1
a150 1
private static «EXPAND MetaModel::featureTargetType FOR valueExpression.feature» «jp.getOperationName(valueExpression)»(«EXPAND MetaModel::QualifiedClassName FOR valueExpression.featureSeqInitializer.elementClass» self) {
d158 1
a158 1
	throw new «jp.container.getAbstractExpressionQualifiedClassName()».NoImplException("No user java implementation provided in '«jp.getOperationName(valueExpression)»' operation"); «EXPAND xpt::Common::nonNLS»
@


1.13
log
@[228913] item #5: clean getExpression, refactor its use
@
text
@d35 2
a36 2
	«EXPAND initializer FOREACH getAllNodes()-»
	«EXPAND initializer FOREACH links-»
d56 2
a57 2
«DEFINE initializer FOR GenNode»«EXPAND initializer(this) FOR modelFacet»«ENDDEFINE»
«DEFINE initializer FOR GenLink»«EXPAND initializer(this) FOR modelFacet»«ENDDEFINE»
d59 1
a59 1
«DEFINE initializer(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»
d61 2
a62 2
«DEFINE initializer(GenCommonBase diagramElement) FOR TypeModelFacet-»
«EXPAND initializer(diagramElement) FOR modelElementInitializer-»
d65 1
a65 1
«DEFINE initializer(GenCommonBase diagramElement) FOR GenElementInitializer»«ENDDEFINE»
d67 1
a67 1
«DEFINE initializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
d81 1
a81 1
	Object value«count» = «EXPAND initializerExpr(this) FOR diagramElement.getDiagram().editorGen.expressionProviders.getProvider(this)».evaluate(«instanceVar»);
d122 1
a122 1
«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionProviderBase»«ENDDEFINE»
d125 2
a126 2
«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionInterpreter-»
«EXPAND xpt::expressions::getExpression::getExpression(valueExpr, valueExpr.featureSeqInitializer.elementClass)-»
d129 2
a130 9
«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenJavaExpressionProvider-»
«LET valueExpr.featureSeqInitializer.elementClass AS exprContext-»
	new «container.getAbstractExpressionQualifiedClassName()»(«EXPAND MetaModel::MetaClass FOR exprContext») {

		protected Object doEvaluate(Object context, java.util.Map env) {
			«EXPAND MetaModel::DeclareAndAssign("self", "context", true) FOR exprContext»
			return Java.«getOperationName(valueExpr)»(self);
		}
	}«ENDLET-»
d152 11
a162 1
«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpression, valueExpression.featureSeqInitializer.elementClass, null) FOR jp-»
@


1.12
log
@Correcting compilation errors.
@
text
@d126 2
a127 1
«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», «EXPAND MetaModel::MetaClass FOR valueExpr.featureSeqInitializer.elementClass»)«ENDDEFINE»
@


1.11
log
@[221347] refactor ElementInitializers, 2/2: avoid reflective code if generation of specific code is possible.
@
text
@d87 1
a87 1
			Object next = «diagramElement.getDiagram().editorGen.expressionProviders.abstractExpressionClassName».performCast(it.next(), «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
d95 1
a95 1
		value«count» = «diagramElement.getDiagram().editorGen.expressionProviders.abstractExpressionClassName».performCast(value«count», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
d101 1
a101 1
	value«count» = «diagramElement.getDiagram().editorGen.expressionProviders.abstractExpressionClassName».performCast(value«count», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
@


1.10
log
@[221347] refactor/simplify ElementInitializers - I suspect duplicated ValueExpression were collected with the old approach, and there was recursion anyway, so I simplified the code to be explicit about its intentions
@
text
@a20 1
«EXTENSION xpt::GenModelUtils»
d81 24
a104 7
«EXPAND initializerExpr(this) FOR diagramElement.getDiagram().editorGen.expressionProviders.getProvider(this)».assignTo(«EXPAND MetaModel::MetaFeature FOR feature», «instanceVar»);
«REM»
 	XXX rewriting initializerExpr (unwrapping right here) would help to get rid of extra DeclareAndAssign
 	though need to consider performCast from assignTo
«EXPAND MetaModel::DeclareAndAssign("valueX", "expr.evaluate("+instanceVar+")", true) FOR findGenClassifier(feature.genClass.genPackage.genModel, feature.ecoreFeature.eType)»
«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, "valueX") FOR feature»;
«ENDREM»
d115 1
a115 1
«FOREACH newElemInit.initializers AS i»«EXPAND performInit(diagramElement, "newInstance" + count, newElemInit.elementClass, count+100 + newElemInit.initializers.indexOf(i)) FOR i»«ENDFOREACH-»
d124 1
d126 1
a126 2
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», «EXPAND MetaModel::MetaClass FOR valueExpr.featureSeqInitializer.elementClass»)
«ENDDEFINE»
@


1.9
log
@[221347] refactor/simplify ElementInitializers - shorten path to initializers
@
text
@a128 1

@


1.8
log
@[221347] refactor/simplify ElementInitializers. Step 1/2: make it simple and straightforward but do not touch existing facilities
@
text
@d11 3
a13 1
 *    Artem Tikhomirov (Borland) - refactored javaInitilizers not to use methods from GMFGen model 
d29 2
a30 1
	«EXPAND Initializers(this) FOR editorGen.expressionProviders-»
d35 4
a38 11
«DEFINE Initializers(GenDiagram diagram) FOR GenExpressionProviderContainer-»

// TODO move init methods out from nested Initializers class
«EXPAND xpt::Common::generatedClassComment»
public static class Initializers {
	«EXPAND initializer FOREACH diagram.getAllNodes()-»
	«EXPAND initializer FOREACH diagram.links-»

	«EXPAND xpt::Common::generatedMemberComment»
	private Initializers() {}

d40 2
d44 2
a45 2
		«EXPAND javaInitializer FOREACH diagram.getAllNodes()-»
		«EXPAND javaInitializer FOREACH diagram.links-»
d47 1
a47 1
}
a57 1

@


1.7
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d14 1
d19 1
d34 1
a42 84
	«EXPAND xpt::Common::generatedMemberComment»
	public static interface IObjectInitializer {

		«EXPAND xpt::Common::generatedMemberComment»
		public void init(org.eclipse.emf.ecore.EObject instance);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static abstract class ObjectInitializer implements IObjectInitializer {

		«EXPAND xpt::Common::generatedMemberComment»
		final org.eclipse.emf.ecore.EClass element;

		«EXPAND xpt::Common::generatedMemberComment»
		private java.util.List featureInitializers = new java.util.ArrayList();

		«EXPAND xpt::Common::generatedMemberComment»
		ObjectInitializer(org.eclipse.emf.ecore.EClass element) {
			this.element = element;
			init();
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected abstract void init();

		«EXPAND xpt::Common::generatedMemberComment»
		protected final IFeatureInitializer add(IFeatureInitializer initializer) {
			featureInitializers.add(initializer);
			return initializer;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void init(org.eclipse.emf.ecore.EObject instance) {
			for (java.util.Iterator it = featureInitializers.iterator(); it.hasNext();) {
				IFeatureInitializer nextExpr = (IFeatureInitializer)it.next();
				try {
					nextExpr.init(instance);
				} catch(RuntimeException e) {
					«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
							"Feature initialization failed", e); //$NON-NLS-1$						
				}
			}
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	interface IFeatureInitializer {

		«EXPAND xpt::Common::generatedMemberComment»
		void init(org.eclipse.emf.ecore.EObject contextInstance);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	static IFeatureInitializer createNewElementFeatureInitializer(org.eclipse.emf.ecore.EStructuralFeature initFeature, ObjectInitializer[] newObjectInitializers) {
		final org.eclipse.emf.ecore.EStructuralFeature feature = initFeature;
		final ObjectInitializer[] initializers = newObjectInitializers;
		return new IFeatureInitializer() {

			public void init(org.eclipse.emf.ecore.EObject contextInstance) {
				for (int i = 0; i < initializers.length; i++) {
					org.eclipse.emf.ecore.EObject newInstance = initializers[i].element.getEPackage().getEFactoryInstance().create(initializers[i].element);
					if (feature.isMany()) {
						((java.util.Collection) contextInstance.eGet(feature)).add(newInstance);
					} else {
						contextInstance.eSet(feature, newInstance);
					}
					initializers[i].init(newInstance);
				}
			}
		};
	}

	«EXPAND xpt::Common::generatedMemberComment»
	static IFeatureInitializer createExpressionFeatureInitializer(org.eclipse.emf.ecore.EStructuralFeature initFeature,
			 «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» valueExpression) {
		final org.eclipse.emf.ecore.EStructuralFeature feature = initFeature;
		final «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression = valueExpression;
		return new IFeatureInitializer() {

			public void init(org.eclipse.emf.ecore.EObject contextInstance) {
				expression.assignTo(feature, contextInstance);
			}
		};
	}
d59 1
a59 3
«DEFINE initializer FOR GenNode-»
	«EXPAND initializer(this) FOR modelFacet-»
«ENDDEFINE»
d61 1
a61 3
«DEFINE initializer FOR GenLink-»
	«EXPAND initializer(this) FOR modelFacet-»
«ENDDEFINE»
d63 1
a63 2
«DEFINE initializer(GenCommonBase diagramElement) FOR ModelFacet-»
«ENDDEFINE»
d66 1
a66 1
	«EXPAND initializer(diagramElement) FOR modelElementInitializer-»
d69 1
a69 2
«DEFINE initializer(GenCommonBase diagramElement) FOR GenElementInitializer-»
«ENDDEFINE»
d72 8
a79 10

		«EXPAND xpt::Common::generatedMemberComment»
		public static final IObjectInitializer «getInitializerFieldName(diagramElement.getUniqueIdentifier())» =
				new ObjectInitializer(«EXPAND MetaModel::MetaClass FOR elementClass») {

		 	protected void init() {
		 	«EXPAND addInitializer(diagramElement) FOREACH initializers-»
			}
			«EXPAND nestedInitializer(diagramElement) FOREACH initializers-»
		};
d82 1
a82 2
«DEFINE nestedInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-»
«ENDDEFINE»
d84 8
a91 13
«DEFINE nestedInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-»
	«FOREACH newElementInitializers AS seqInitializer-»

		ObjectInitializer «seqInitializer.getInitializerFieldName(diagramElement.getUniqueIdentifier())»() {
			return new ObjectInitializer(«EXPAND MetaModel::MetaClass FOR seqInitializer.elementClass») {

		 		protected void init() {
		 			«EXPAND addInitializer(diagramElement) FOREACH seqInitializer.initializers-»
				}
			};
		}
		«EXPAND nestedInitializer(diagramElement) FOREACH seqInitializer.initializers-»
	«ENDFOREACH-»
d94 10
a103 1
«DEFINE addInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-»
a105 7
«DEFINE addInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-»
	add(createNewElementFeatureInitializer(«EXPAND MetaModel::MetaFeature FOR feature», new ObjectInitializer[] {
	«FOREACH newElementInitializers AS newElemInit-»
		«newElemInit.getInitializerFieldName(diagramElement.getUniqueIdentifier())»(),
	«ENDFOREACH-»
	}));
«ENDDEFINE»
d107 1
a107 7
«DEFINE addInitializer(GenCommonBase diagramElement) FOR GenFeatureValueSpec-»
	add(createExpressionFeatureInitializer(«EXPAND MetaModel::MetaFeature FOR feature»,
	«LET diagramElement.getDiagram().editorGen.expressionProviders AS providers-»
		«EXPAND initializerExpr(this) FOR providers.getProvider(this)-»
	«ENDLET-»
	 ));
«ENDDEFINE»
d109 1
a109 2
«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionProviderBase-»
«ENDDEFINE»
d112 1
a112 2
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», //$NON-NLS-1$
		«EXPAND MetaModel::MetaClass FOR valueExpr.featureSeqInitializer.elementClass»)
d116 1
a116 1
	«LET valueExpr.featureSeqInitializer.elementClass AS exprContext-»
d123 1
a123 2
	}
	«ENDLET-»
d131 1
a131 3
«DEFINE javaInitializer FOR GenNode-»
	«EXPAND javaInitializer(this) FOR modelFacet-»
«ENDDEFINE»
d133 1
a133 3
«DEFINE javaInitializer FOR GenLink-»
	«EXPAND javaInitializer(this) FOR modelFacet-»
«ENDDEFINE»
d135 1
a135 2
«DEFINE javaInitializer(GenCommonBase diagramElement) FOR ModelFacet-»
«ENDDEFINE»
d138 1
a138 1
	«EXPAND javaInitializer(diagramElement) FOR modelElementInitializer-»
d141 1
a141 2
«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenElementInitializer-»
«ENDDEFINE»
@


1.6
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d11 1
d17 1
d162 1
a162 1
				new ObjectInitializer(«getElementClassAccessor()») {
d178 1
a178 1
			return new ObjectInitializer(«seqInitializer.getElementClassAccessor()») {
d193 1
a193 1
	add(createNewElementFeatureInitializer(«featureSeqInitializer.getFeatureAccessor(this)», new ObjectInitializer[] {
d201 1
a201 1
	add(createExpressionFeatureInitializer(«featureSeqInitializer.getFeatureAccessor(this)»,
d221 1
a221 1
			«getQualifiedInstanceClassName(exprContext)» self = («getQualifiedInstanceClassName(exprContext)») context;
d252 6
a257 13
	«LET diagramElement.getDiagram().editorGen.expressionProviders AS providers-»
		«FOREACH getJavaExpressionFeatureInitializersList(providers) AS valueExpression-»
			«EXPAND javaInitializer(valueExpression, valueExpression.featureSeqInitializer.elementClass, null) FOR providers.getProvider(valueExpression)-»
		«ENDFOREACH-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»
@


1.5
log
@copyright year updated; minor fix to use common code
@
text
@d211 1
a211 1
		«EXPAND xpt::Common::metaClassAccessor FOR valueExpr.featureSeqInitializer.elementClass»)
d216 1
a216 1
	new «container.getAbstractExpressionQualifiedClassName()»(«EXPAND xpt::Common::metaClassAccessor FOR exprContext») {
@


1.4
log
@[150177] phase I, refactor existing code: use same template for metainfo access
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d15 1
a15 1
«EXTENSION xpt::GenModelUtils»
@


1.3
log
@[216935] - Generating Diagram with Nested Initializers in .gmfmap file
@
text
@d211 1
a211 1
		«getQualifiedClassifierAccessor(valueExpr.featureSeqInitializer.elementClass)»())
d216 1
a216 1
	new «container.getAbstractExpressionQualifiedClassName()»(«getQualifiedClassifierAccessor(exprContext)»()) {
@


1.2
log
@rewrite element initializer in xpand
@
text
@a254 8
	«EXPAND nestedJavaInitializer(diagramElement) FOREACH initializers-»
«ENDDEFINE»

«DEFINE nestedJavaInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-»
«ENDDEFINE»

«DEFINE nestedJavaInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-»
	«EXPAND javaInitializer(diagramElement) FOREACH newElementInitializers-»
@


1.1
log
@file ElementInitializers.xpt was initially added on branch R2_0_maintenance.
@
text
@d1 270
@


1.1.2.1
log
@rewrite element initializers in xpand
@
text
@a0 270
/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

´IMPORT "http://www.eclipse.org/gmf/2006/GenModel"ª
´IMPORT "http://www.eclipse.org/emf/2002/GenModel"ª
´EXTENSION xpt::GenModelUtilsª

´DEFINE ElementInitializers FOR gmfgen::GenDiagram-ª
´EXPAND xpt::Common::copyright FOR editorGen-ª
package ´providersPackageNameª;

´EXPAND xpt::Common::generatedClassCommentª
public class ElementInitializers {
	´EXPAND Initializers(this) FOR editorGen.expressionProviders-ª
	´EXPAND additions-ª
}
´ENDDEFINEª

´DEFINE Initializers(GenDiagram diagram) FOR GenExpressionProviderContainer-ª

´EXPAND xpt::Common::generatedClassCommentª
public static class Initializers {
	´EXPAND initializer FOREACH diagram.getAllNodes()-ª
	´EXPAND initializer FOREACH diagram.links-ª

	´EXPAND xpt::Common::generatedMemberCommentª
	private Initializers() {}

	´EXPAND xpt::Common::generatedMemberCommentª
	public static interface IObjectInitializer {

		´EXPAND xpt::Common::generatedMemberCommentª
		public void init(org.eclipse.emf.ecore.EObject instance);
	}

	´EXPAND xpt::Common::generatedMemberCommentª
	public static abstract class ObjectInitializer implements IObjectInitializer {

		´EXPAND xpt::Common::generatedMemberCommentª
		final org.eclipse.emf.ecore.EClass element;

		´EXPAND xpt::Common::generatedMemberCommentª
		private java.util.List featureInitializers = new java.util.ArrayList();

		´EXPAND xpt::Common::generatedMemberCommentª
		ObjectInitializer(org.eclipse.emf.ecore.EClass element) {
			this.element = element;
			init();
		}

		´EXPAND xpt::Common::generatedMemberCommentª
		protected abstract void init();

		´EXPAND xpt::Common::generatedMemberCommentª
		protected final IFeatureInitializer add(IFeatureInitializer initializer) {
			featureInitializers.add(initializer);
			return initializer;
		}

		´EXPAND xpt::Common::generatedMemberCommentª
		public void init(org.eclipse.emf.ecore.EObject instance) {
			for (java.util.Iterator it = featureInitializers.iterator(); it.hasNext();) {
				IFeatureInitializer nextExpr = (IFeatureInitializer)it.next();
				try {
					nextExpr.init(instance);
				} catch(RuntimeException e) {
					´editorGen.plugin.getActivatorQualifiedClassName()ª.getInstance().logError(
							"Feature initialization failed", e); //$NON-NLS-1$						
				}
			}
		}
	}

	´EXPAND xpt::Common::generatedMemberCommentª
	interface IFeatureInitializer {

		´EXPAND xpt::Common::generatedMemberCommentª
		void init(org.eclipse.emf.ecore.EObject contextInstance);
	}

	´EXPAND xpt::Common::generatedMemberCommentª
	static IFeatureInitializer createNewElementFeatureInitializer(org.eclipse.emf.ecore.EStructuralFeature initFeature, ObjectInitializer[] newObjectInitializers) {
		final org.eclipse.emf.ecore.EStructuralFeature feature = initFeature;
		final ObjectInitializer[] initializers = newObjectInitializers;
		return new IFeatureInitializer() {

			public void init(org.eclipse.emf.ecore.EObject contextInstance) {
				for (int i = 0; i < initializers.length; i++) {
					org.eclipse.emf.ecore.EObject newInstance = initializers[i].element.getEPackage().getEFactoryInstance().create(initializers[i].element);
					if (feature.isMany()) {
						((java.util.Collection) contextInstance.eGet(feature)).add(newInstance);
					} else {
						contextInstance.eSet(feature, newInstance);
					}
					initializers[i].init(newInstance);
				}
			}
		};
	}

	´EXPAND xpt::Common::generatedMemberCommentª
	static IFeatureInitializer createExpressionFeatureInitializer(org.eclipse.emf.ecore.EStructuralFeature initFeature,
			 ´editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()ª valueExpression) {
		final org.eclipse.emf.ecore.EStructuralFeature feature = initFeature;
		final ´editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()ª expression = valueExpression;
		return new IFeatureInitializer() {

			public void init(org.eclipse.emf.ecore.EObject contextInstance) {
				expression.assignTo(feature, contextInstance);
			}
		};
	}

	´EXPAND xpt::Common::generatedMemberCommentª
	static class Java {
		´EXPAND javaInitializer FOREACH diagram.getAllNodes()-ª
		´EXPAND javaInitializer FOREACH diagram.links-ª
	}
}
´ENDDEFINEª

´DEFINE additions FOR gmfgen::GenDiagramª´ENDDEFINEª


´REMª
	Definitions of initializer objects.
´ENDREMª

´DEFINE initializer FOR GenNode-ª
	´EXPAND initializer(this) FOR modelFacet-ª
´ENDDEFINEª

´DEFINE initializer FOR GenLink-ª
	´EXPAND initializer(this) FOR modelFacet-ª
´ENDDEFINEª

´DEFINE initializer(GenCommonBase diagramElement) FOR ModelFacet-ª
´ENDDEFINEª

´DEFINE initializer(GenCommonBase diagramElement) FOR TypeModelFacet-ª
	´EXPAND initializer(diagramElement) FOR modelElementInitializer-ª
´ENDDEFINEª

´DEFINE initializer(GenCommonBase diagramElement) FOR GenElementInitializer-ª
´ENDDEFINEª

´DEFINE initializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-ª

		´EXPAND xpt::Common::generatedMemberCommentª
		public static final IObjectInitializer ´getInitializerFieldName(diagramElement.getUniqueIdentifier())ª =
				new ObjectInitializer(´getElementClassAccessor()ª) {

		 	protected void init() {
		 	´EXPAND addInitializer(diagramElement) FOREACH initializers-ª
			}
			´EXPAND nestedInitializer(diagramElement) FOREACH initializers-ª
		};
´ENDDEFINEª

´DEFINE nestedInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-ª
´ENDDEFINEª

´DEFINE nestedInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-ª
	´FOREACH newElementInitializers AS seqInitializer-ª

		ObjectInitializer ´seqInitializer.getInitializerFieldName(diagramElement.getUniqueIdentifier())ª() {
			return new ObjectInitializer(´seqInitializer.getElementClassAccessor()ª) {

		 		protected void init() {
		 			´EXPAND addInitializer(diagramElement) FOREACH seqInitializer.initializers-ª
				}
			};
		}
		´EXPAND nestedInitializer(diagramElement) FOREACH seqInitializer.initializers-ª
	´ENDFOREACH-ª
´ENDDEFINEª

´DEFINE addInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-ª
´ENDDEFINEª

´DEFINE addInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-ª
	add(createNewElementFeatureInitializer(´featureSeqInitializer.getFeatureAccessor(this)ª, new ObjectInitializer[] {
	´FOREACH newElementInitializers AS newElemInit-ª
		´newElemInit.getInitializerFieldName(diagramElement.getUniqueIdentifier())ª(),
	´ENDFOREACH-ª
	}));
´ENDDEFINEª

´DEFINE addInitializer(GenCommonBase diagramElement) FOR GenFeatureValueSpec-ª
	add(createExpressionFeatureInitializer(´featureSeqInitializer.getFeatureAccessor(this)ª,
	´LET diagramElement.getDiagram().editorGen.expressionProviders AS providers-ª
		´EXPAND initializerExpr(this) FOR providers.getProvider(this)-ª
	´ENDLET-ª
	 ));
´ENDDEFINEª

´DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionProviderBase-ª
´ENDDEFINEª

´DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionInterpreter-ª
	´getQualifiedClassName()ª.´getExpressionAccessor(valueExpr)ª(´valueExpr.getBodyString()ª, //$NON-NLS-1$
		´getQualifiedClassifierAccessor(valueExpr.featureSeqInitializer.elementClass)ª())
´ENDDEFINEª

´DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenJavaExpressionProvider-ª
	´LET valueExpr.featureSeqInitializer.elementClass AS exprContext-ª
	new ´container.getAbstractExpressionQualifiedClassName()ª(´getQualifiedClassifierAccessor(exprContext)ª()) {

		protected Object doEvaluate(Object context, java.util.Map env) {
			´getQualifiedInstanceClassName(exprContext)ª self = (´getQualifiedInstanceClassName(exprContext)ª) context;
			return Java.´getOperationName(valueExpr)ª(self);
		}
	}
	´ENDLET-ª
´ENDDEFINEª


´REMª
	Definitions of Java initialization methods.
´ENDREMª

´DEFINE javaInitializer FOR GenNode-ª
	´EXPAND javaInitializer(this) FOR modelFacet-ª
´ENDDEFINEª

´DEFINE javaInitializer FOR GenLink-ª
	´EXPAND javaInitializer(this) FOR modelFacet-ª
´ENDDEFINEª

´DEFINE javaInitializer(GenCommonBase diagramElement) FOR ModelFacet-ª
´ENDDEFINEª

´DEFINE javaInitializer(GenCommonBase diagramElement) FOR TypeModelFacet-ª
	´EXPAND javaInitializer(diagramElement) FOR modelElementInitializer-ª
´ENDDEFINEª

´DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenElementInitializer-ª
´ENDDEFINEª

´DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-ª
	´LET diagramElement.getDiagram().editorGen.expressionProviders AS providers-ª
		´FOREACH getJavaExpressionFeatureInitializersList(providers) AS valueExpression-ª
			´EXPAND javaInitializer(valueExpression, valueExpression.featureSeqInitializer.elementClass, null) FOR providers.getProvider(valueExpression)-ª
		´ENDFOREACH-ª
	´ENDLET-ª
	´EXPAND nestedJavaInitializer(diagramElement) FOREACH initializers-ª
´ENDDEFINEª

´DEFINE nestedJavaInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-ª
´ENDDEFINEª

´DEFINE nestedJavaInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-ª
	´EXPAND javaInitializer(diagramElement) FOREACH newElementInitializers-ª
´ENDDEFINEª

´DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-ª
´ENDDEFINEª

´DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-ª
	´EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-ª
´ENDDEFINEª
@


1.1.2.2
log
@fix patch
@
text
@d13 7
a19 7
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«EXTENSION xpt::GenModelUtils»

«DEFINE ElementInitializers FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;
d21 1
a21 1
«EXPAND xpt::Common::generatedClassComment»
d23 2
a24 2
	«EXPAND Initializers(this) FOR editorGen.expressionProviders-»
	«EXPAND additions-»
d26 1
a26 1
«ENDDEFINE»
d28 1
a28 1
«DEFINE Initializers(GenDiagram diagram) FOR GenExpressionProviderContainer-»
d30 1
a30 1
«EXPAND xpt::Common::generatedClassComment»
d32 2
a33 2
	«EXPAND initializer FOREACH diagram.getAllNodes()-»
	«EXPAND initializer FOREACH diagram.links-»
d35 1
a35 1
	«EXPAND xpt::Common::generatedMemberComment»
d38 1
a38 1
	«EXPAND xpt::Common::generatedMemberComment»
d41 1
a41 1
		«EXPAND xpt::Common::generatedMemberComment»
d45 1
a45 1
	«EXPAND xpt::Common::generatedMemberComment»
d48 1
a48 1
		«EXPAND xpt::Common::generatedMemberComment»
d51 1
a51 1
		«EXPAND xpt::Common::generatedMemberComment»
d54 1
a54 1
		«EXPAND xpt::Common::generatedMemberComment»
d60 1
a60 1
		«EXPAND xpt::Common::generatedMemberComment»
d63 1
a63 1
		«EXPAND xpt::Common::generatedMemberComment»
d69 1
a69 1
		«EXPAND xpt::Common::generatedMemberComment»
d76 1
a76 1
					«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
d83 1
a83 1
	«EXPAND xpt::Common::generatedMemberComment»
d86 1
a86 1
		«EXPAND xpt::Common::generatedMemberComment»
d90 1
a90 1
	«EXPAND xpt::Common::generatedMemberComment»
d110 1
a110 1
	«EXPAND xpt::Common::generatedMemberComment»
d112 1
a112 1
			 «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» valueExpression) {
d114 1
a114 1
		final «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression = valueExpression;
d123 1
a123 1
	«EXPAND xpt::Common::generatedMemberComment»
d125 2
a126 2
		«EXPAND javaInitializer FOREACH diagram.getAllNodes()-»
		«EXPAND javaInitializer FOREACH diagram.links-»
d129 1
a129 1
«ENDDEFINE»
d131 1
a131 1
«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»
d134 1
a134 1
«REM»
d136 1
a136 1
«ENDREM»
d138 3
a140 3
«DEFINE initializer FOR GenNode-»
	«EXPAND initializer(this) FOR modelFacet-»
«ENDDEFINE»
d142 3
a144 3
«DEFINE initializer FOR GenLink-»
	«EXPAND initializer(this) FOR modelFacet-»
«ENDDEFINE»
d146 2
a147 2
«DEFINE initializer(GenCommonBase diagramElement) FOR ModelFacet-»
«ENDDEFINE»
d149 3
a151 3
«DEFINE initializer(GenCommonBase diagramElement) FOR TypeModelFacet-»
	«EXPAND initializer(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»
d153 2
a154 2
«DEFINE initializer(GenCommonBase diagramElement) FOR GenElementInitializer-»
«ENDDEFINE»
d156 1
a156 1
«DEFINE initializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
d158 3
a160 3
		«EXPAND xpt::Common::generatedMemberComment»
		public static final IObjectInitializer «getInitializerFieldName(diagramElement.getUniqueIdentifier())» =
				new ObjectInitializer(«getElementClassAccessor()») {
d163 1
a163 1
		 	«EXPAND addInitializer(diagramElement) FOREACH initializers-»
d165 1
a165 1
			«EXPAND nestedInitializer(diagramElement) FOREACH initializers-»
d167 1
a167 1
«ENDDEFINE»
d169 2
a170 2
«DEFINE nestedInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-»
«ENDDEFINE»
d172 2
a173 2
«DEFINE nestedInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-»
	«FOREACH newElementInitializers AS seqInitializer-»
d175 2
a176 2
		ObjectInitializer «seqInitializer.getInitializerFieldName(diagramElement.getUniqueIdentifier())»() {
			return new ObjectInitializer(«seqInitializer.getElementClassAccessor()») {
d179 1
a179 1
		 			«EXPAND addInitializer(diagramElement) FOREACH seqInitializer.initializers-»
d183 12
a194 12
		«EXPAND nestedInitializer(diagramElement) FOREACH seqInitializer.initializers-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE addInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-»
«ENDDEFINE»

«DEFINE addInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-»
	add(createNewElementFeatureInitializer(«featureSeqInitializer.getFeatureAccessor(this)», new ObjectInitializer[] {
	«FOREACH newElementInitializers AS newElemInit-»
		«newElemInit.getInitializerFieldName(diagramElement.getUniqueIdentifier())»(),
	«ENDFOREACH-»
d196 1
a196 1
«ENDDEFINE»
d198 5
a202 5
«DEFINE addInitializer(GenCommonBase diagramElement) FOR GenFeatureValueSpec-»
	add(createExpressionFeatureInitializer(«featureSeqInitializer.getFeatureAccessor(this)»,
	«LET diagramElement.getDiagram().editorGen.expressionProviders AS providers-»
		«EXPAND initializerExpr(this) FOR providers.getProvider(this)-»
	«ENDLET-»
d204 1
a204 1
«ENDDEFINE»
d206 2
a207 2
«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionProviderBase-»
«ENDDEFINE»
d209 8
a216 8
«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenExpressionInterpreter-»
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», //$NON-NLS-1$
		«getQualifiedClassifierAccessor(valueExpr.featureSeqInitializer.elementClass)»())
«ENDDEFINE»

«DEFINE initializerExpr(GenFeatureValueSpec valueExpr) FOR GenJavaExpressionProvider-»
	«LET valueExpr.featureSeqInitializer.elementClass AS exprContext-»
	new «container.getAbstractExpressionQualifiedClassName()»(«getQualifiedClassifierAccessor(exprContext)»()) {
d219 2
a220 2
			«getQualifiedInstanceClassName(exprContext)» self = («getQualifiedInstanceClassName(exprContext)») context;
			return Java.«getOperationName(valueExpr)»(self);
d223 2
a224 2
	«ENDLET-»
«ENDDEFINE»
d227 1
a227 1
«REM»
d229 1
a229 1
«ENDREM»
d231 40
a270 40
«DEFINE javaInitializer FOR GenNode-»
	«EXPAND javaInitializer(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE javaInitializer FOR GenLink-»
	«EXPAND javaInitializer(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR ModelFacet-»
«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR TypeModelFacet-»
	«EXPAND javaInitializer(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenElementInitializer-»
«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
	«LET diagramElement.getDiagram().editorGen.expressionProviders AS providers-»
		«FOREACH getJavaExpressionFeatureInitializersList(providers) AS valueExpression-»
			«EXPAND javaInitializer(valueExpression, valueExpression.featureSeqInitializer.elementClass, null) FOR providers.getProvider(valueExpression)-»
		«ENDFOREACH-»
	«ENDLET-»
	«EXPAND nestedJavaInitializer(diagramElement) FOREACH initializers-»
«ENDDEFINE»

«DEFINE nestedJavaInitializer(GenCommonBase diagramElement) FOR GenFeatureInitializer-»
«ENDDEFINE»

«DEFINE nestedJavaInitializer(GenCommonBase diagramElement) FOR GenReferenceNewElementSpec-»
	«EXPAND javaInitializer(diagramElement) FOREACH newElementInitializers-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»
@


1.1.2.3
log
@[216935] - Generating Diagram with Nested Initializers in .gmfmap file
@
text
@d255 8
@


