head	1.5;
access;
symbols
	v20081022-1925:1.5
	v20081015-1925:1.5
	v20081008-1925:1.5
	v20081001-1925:1.5
	v20080930-1130:1.5
	v20080926-1245:1.5
	v20080924-1925:1.5
	v20080917-1925:1.5
	v20080911-1728:1.5
	v20080910-1520:1.5
	v20080903-1520:1.5
	v20080827-1520:1.5
	v20080813-1520:1.5
	v20080806-1520:1.5
	v20080722-1827:1.5
	v20080718-1731:1.5
	v20080716-1600:1.5
	v20080716-1642:1.5
	R2_1_maintenance:1.5.0.2
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080610-1132:1.5
	v20080603-1553:1.5
	v20080528-1052:1.5
	v20080521:1.5
	v20080516-1543:1.5
	v20080516-1143:1.5
	v20080512-1200:1.5
	v20080508-2000:1.5
	v20080507-1326:1.5
	v20080503-1740:1.4
	v20080501-1739:1.4
	v20080425-1959:1.4
	v20080417-1610:1.4
	v20080411-0411:1.4
	v20080404-1111:1.4
	v20080322-0000:1.4
	v20080222-1200:1.4
	v20080215-1500:1.4
	v20080207-0207:1.4
	v20071222-1111:1.4
	v20071214-1111:1.4
	v20071130-1111:1.4
	v20071124-0000:1.4
	v20071112-0000:1.4
	v20071108-0000:1.4
	v20071003-0000:1.4
	v20070928-0000:1.4
	v20070921-0000:1.4
	v20070915-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.2
	v20070614-1400:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.5
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	39124821b4de4567;

1.4
date	2007.06.21.12.27.46;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	5deb467a6ec24567;

1.3
date	2007.06.15.18.16.06;	author dstadnik;	state Exp;
branches;
next	1.2;
commitid	3b804672d7664567;

1.2
date	2007.06.14.11.43.30;	author ashatalin;	state Exp;
branches;
next	1.1;
commitid	dd4467129e24567;

1.1
date	2007.06.12.12.20.13;	author dstadnik;	state Exp;
branches;
next	;
commitid	5d34466e8f7c4567;


desc
@@


1.5
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::diagram::Utils»

«DEFINE ViewProvider FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR getDiagram().editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «notationViewProviderClassName» extends org.eclipse.gmf.runtime.diagram.core.providers.AbstractViewProvider {
	«EXPAND getDiagramViewClass-»
	«EXPAND getNodeViewClass-»
	«EXPAND getEdgeViewClass-»
	«EXPAND getSemanticElementType-»
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE getDiagramViewClass FOR gmfgen::GenDiagram-»

«EXPAND xpt::Common::generatedMemberComment»
protected Class getDiagramViewClass(org.eclipse.core.runtime.IAdaptable semanticAdapter, String diagramKind) {
	«REM»When diagram domain element is null only diagram kind is checked«ENDREM-»
	«EXPAND defineSemanticElement FOR domainDiagramElement-»
	if («EXPAND xpt::editor::VisualIDRegistry::modelID».equals(diagramKind)«EXPAND checkSemanticElement(this) FOR domainDiagramElement») {
			return «getNotationViewFactoryQualifiedClassName()».class;
	}
	return null;
}
«ENDDEFINE»

«DEFINE defineSemanticElement FOR genmodel::GenClass-»
org.eclipse.emf.ecore.EObject semanticElement = getSemanticElement(semanticAdapter);
«ENDDEFINE»

«DEFINE checkSemanticElement(gmfgen::GenDiagram diagram) FOR genmodel::GenClass» && «EXPAND xpt::editor::VisualIDRegistry::getDiagramVisualIDMethodCall FOR diagram»(semanticElement) != -1«ENDDEFINE»

«DEFINE getNodeViewClass FOR gmfgen::GenDiagram-»

«EXPAND xpt::Common::generatedMemberComment»
protected Class getNodeViewClass(org.eclipse.core.runtime.IAdaptable semanticAdapter,
		org.eclipse.gmf.runtime.notation.View containerView, String semanticHint) {
	if (containerView == null) {
		return null;
	}
	org.eclipse.gmf.runtime.emf.type.core.IElementType elementType = getSemanticElementType(semanticAdapter);
	org.eclipse.emf.ecore.EObject domainElement = getSemanticElement(semanticAdapter);
	int visualID;
	if (semanticHint == null) {
		// Semantic hint is not specified. Can be a result of call from CanonicalEditPolicy.
		// In this situation there should be NO elementType, visualID will be determined
		// by VisualIDRegistry.getNodeVisualID() for domainElement.
		if (elementType != null || domainElement == null) {
			return null;
		}
		visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall»(containerView, domainElement);
	} else {
		visualID = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall»(semanticHint);
		if (elementType != null) {
			// Semantic hint is specified together with element type.
			// Both parameters should describe exactly the same diagram element.
			// In addition we check that visualID returned by VisualIDRegistry.getNodeVisualID() for
			// domainElement (if specified) is the same as in element type.
			if (!«getElementTypesQualifiedClassName()».isKnownElementType(elementType)
					|| (!(elementType instanceof org.eclipse.gmf.runtime.emf.type.core.IHintedType))) {
				return null; // foreign element type
			}
			String elementTypeHint = ((org.eclipse.gmf.runtime.emf.type.core.IHintedType) elementType).getSemanticHint();
			if (!semanticHint.equals(elementTypeHint)) {
				return null; // if semantic hint is specified it should be the same as in element type
			}
			if (domainElement != null && visualID != «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall»(containerView, domainElement)) {
				return null; // visual id for node EClass should match visual id from element type
			}
		} else {
			// Element type is not specified. Domain element should be present (except pure design elements).
			// This method is called with EObjectAdapter as parameter from:
			//   - ViewService.createNode(View container, EObject eObject, String type, PreferencesHint preferencesHint) 
			//   - generated ViewFactory.decorateView() for parent element
	«IF getElements(this).select(e | e.elementType != null).size() > 0-»
			if (!«getEditPartQualifiedClassName()».MODEL_ID.equals(«getVisualIDRegistryQualifiedClassName()».getModelID(containerView))) {
				return null; // foreign diagram
			}
			switch (visualID) {
		«IF getElements(this).typeSelect(gmfgen::GenNode).elementType.typeSelect(gmfgen::NotationType).size() > 0-»
			«EXPAND caseVisualID FOREACH getElements(this).typeSelect(gmfgen::GenNode).elementType.typeSelect(gmfgen::NotationType)-»
				break; // pure design element
		«ENDIF-»
		«IF getElements(this).typeSelect(gmfgen::GenNode).elementType.typeSelect(gmfgen::MetamodelType).size() > 0 ||
				getElements(this).typeSelect(gmfgen::GenNode).elementType.typeSelect(gmfgen::SpecializationType).size() > 0-»
			«EXPAND caseVisualID FOREACH getElements(this).typeSelect(gmfgen::GenNode).elementType.typeSelect(gmfgen::MetamodelType)-»
			«EXPAND caseVisualID FOREACH getElements(this).typeSelect(gmfgen::GenNode).elementType.typeSelect(gmfgen::SpecializationType)-»
				if (domainElement == null || visualID != «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall»(containerView, domainElement)) {
					return null; // visual id in semantic hint should match visual id for domain element
				}
				break;
		«ENDIF-»
			«EXPAND checkChildrenVisualIDs FOREACH getElements(this).select(e | e.elementType != null)-»
			default:
				return null;
			}
	«ELSE-»
			return null;
	«ENDIF-»
		}
	}
	return getNodeViewClass(containerView, visualID);
}

«EXPAND xpt::Common::generatedMemberComment»
protected Class getNodeViewClass(org.eclipse.gmf.runtime.notation.View containerView, int visualID) {
	if (containerView == null || !«EXPAND xpt::editor::VisualIDRegistry::canCreateNodeMethodCall»(containerView, visualID)) {
		return null;
	}
	switch (visualID) {
	«EXPAND caseContainerVisualID FOREACH getAllChildContainers()-»
	«EXPAND caseEntry FOREACH links.labels-»
	}
	return null;
}
«ENDDEFINE»

«DEFINE caseVisualID FOR gmfgen::ElementType-»
	«EXPAND xpt::Common::caseVisualID FOR diagramElement»
«ENDDEFINE»

«DEFINE checkChildrenVisualIDs FOR gmfgen::GenCommonBase-»
«ENDDEFINE»

«DEFINE checkChildrenVisualIDs FOR gmfgen::GenNode-»
	«EXPAND xpt::Common::caseVisualID FOREACH labels-»
	«EXPAND xpt::Common::caseVisualID FOREACH compartments-»
	«IF !labels.isEmpty() || !compartments.isEmpty()-»
if («EXPAND xpt::editor::VisualIDRegistry::visualID» != «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR getDiagram()»(containerView)
		|| containerView.getElement() != domainElement) {
	return null; // wrong container
}
break;
	«ENDIF-»
«ENDDEFINE»

«DEFINE checkChildrenVisualIDs FOR gmfgen::GenLink-»
	«EXPAND xpt::Common::caseVisualID FOREACH labels-»
	«IF !labels.isEmpty()-»
if («EXPAND xpt::editor::VisualIDRegistry::visualID» != «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR getDiagram()»(containerView)
		|| containerView.getElement() != domainElement) {
	return null; // wrong container
}
break;
	«ENDIF-»
«ENDDEFINE»

«DEFINE caseContainerVisualID FOR gmfgen::GenChildContainer-»
	«EXPAND caseEntry-»
«ENDDEFINE»

«DEFINE caseContainerVisualID FOR gmfgen::GenNode-»
	«EXPAND caseEntry-»
	«EXPAND caseEntry FOREACH labels-»
«ENDDEFINE»

«DEFINE caseEntry FOR gmfgen::GenCommonBase-»
	«EXPAND xpt::Common::caseVisualID» return «getNotationViewFactoryQualifiedClassName()».class;
«ENDDEFINE»

«DEFINE getEdgeViewClass FOR gmfgen::GenDiagram-»

«EXPAND xpt::Common::generatedMemberComment»
protected Class getEdgeViewClass(org.eclipse.core.runtime.IAdaptable semanticAdapter,
		org.eclipse.gmf.runtime.notation.View containerView, String semanticHint) {
	org.eclipse.gmf.runtime.emf.type.core.IElementType elementType = getSemanticElementType(semanticAdapter);
	if (!«getElementTypesQualifiedClassName()».isKnownElementType(elementType)
			|| (!(elementType instanceof org.eclipse.gmf.runtime.emf.type.core.IHintedType))) {
		return null; // foreign element type
	}
	String elementTypeHint = ((org.eclipse.gmf.runtime.emf.type.core.IHintedType) elementType).getSemanticHint();
	if (elementTypeHint == null) {
		return null; // our hint is visual id and must be specified
	}
	if (semanticHint != null && !semanticHint.equals(elementTypeHint)) {
		return null; // if semantic hint is specified it should be the same as in element type
	}
	int visualID = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall»(elementTypeHint);
	org.eclipse.emf.ecore.EObject domainElement = getSemanticElement(semanticAdapter);
	if (domainElement != null && visualID != «EXPAND xpt::editor::VisualIDRegistry::getLinkWithClassVisualIDMethodCall»(domainElement)) {
		return null; // visual id for link EClass should match visual id from element type
	}
	return getEdgeViewClass(visualID);
}

«EXPAND xpt::Common::generatedMemberComment»
protected Class getEdgeViewClass(int visualID) {
	switch (visualID) {
	«EXPAND caseEntry FOREACH links-»
	}
	return null;
}
«ENDDEFINE»

«DEFINE getSemanticElementType FOR gmfgen::GenDiagram-»

«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.emf.type.core.IElementType getSemanticElementType(
		org.eclipse.core.runtime.IAdaptable semanticAdapter) {
	if (semanticAdapter == null) {
		return null;
	}
	return (org.eclipse.gmf.runtime.emf.type.core.IElementType) semanticAdapter.getAdapter(
			org.eclipse.gmf.runtime.emf.type.core.IElementType.class);
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»
@


1.4
log
@[193580] Error opening pure design diagram
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.3
log
@[192844] Link labels are missing in generated diagram editors
@
text
@d37 4
a40 4
	org.eclipse.emf.ecore.EObject semanticElement = getSemanticElement(semanticAdapter);
	if («EXPAND xpt::editor::VisualIDRegistry::modelID».equals(diagramKind)
			&& «EXPAND xpt::editor::VisualIDRegistry::getDiagramVisualIDMethodCall»(semanticElement) != -1) {
		return «getNotationViewFactoryQualifiedClassName()».class;
d46 6
d90 1
a90 1
			// Element type is not specified. Domain element should be present.
d99 8
a106 1
			«EXPAND xpt::Common::caseVisualID FOREACH getElements(this).select(e | e.elementType != null).typeSelect(gmfgen::GenNode)-»
d111 1
d137 4
@


1.2
log
@[192613] - Generated ???ViewProvider.getNodeViewClass block creation of diagragram node by semanticHint and domainElement
@
text
@d20 1
a20 1
	«EXPAND xpt::Common::copyright FOR getDiagram().editorGen-»
d23 1
a23 1
	«EXPAND xpt::Common::generatedClassComment»
a24 1

a25 1
	
a26 1
	
a27 1
	
a28 1
	
d34 2
a35 1
	«EXPAND xpt::Common::generatedMemberComment»
d37 4
a40 3
	«EXPAND defineSemanticElement FOR domainDiagramElement-»
	if («EXPAND xpt::editor::VisualIDRegistry::modelID».equals(diagramKind)«EXPAND checkSemanticElement(this) FOR domainDiagramElement») {
			return «getNotationViewFactoryQualifiedClassName()».class;
d46 1
a46 3
«DEFINE defineSemanticElement FOR genmodel::GenClass-»
org.eclipse.emf.ecore.EObject semanticElement = getSemanticElement(semanticAdapter);
«ENDDEFINE»
d48 3
a50 5
«DEFINE checkSemanticElement(gmfgen::GenDiagram diagram) FOR genmodel::GenClass» && «EXPAND xpt::editor::VisualIDRegistry::getDiagramVisualIDMethodCall FOR diagram»(semanticElement) != -1«ENDDEFINE»
	
«DEFINE getNodeViewClass FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
protected Class getNodeViewClass(org.eclipse.core.runtime.IAdaptable semanticAdapter, org.eclipse.gmf.runtime.notation.View containerView, String semanticHint) {
a55 1
	
d58 3
a60 5
«REM»
	No semanticHint specified. Can be a result of call from CanonicalEditPolicy.
	In this situation there should be NO elementType, visualID will be determined
	by VisualIDRegistry.getNodeVisualID() for domainElement.
«ENDREM»«-»
d68 9
a76 6
«REM»
	semanticHint specified together with elementType. Both parameters should describe exactly the same 
	diagram element. In addition cecking visualID returned by VisualIDRegistry.getNodeVisualID() for
	domainElement (if specified) - there should be same value.
«ENDREM»«-»
			«EXPAND defineElementTypeHint-»
d78 1
a78 1
				return null;
d81 1
a81 1
				return null;
d84 7
a90 14
«REM»
	elementType was not specified. DomainElement shoud present. Result of calling this method with EObjectAdapter
	as a parameter:
	- ViewService.createNode(View container, EObject eObject, String type, PreferencesHint preferencesHint) 
	- generated ViewFactory.decorateView() for parent element). 

	In first case (passed semanticHint corresponds to the domain element-based diagram node) comparing visualID
	returned from the registry with the semanticHint one.
	In the last case (passed semanticHint corresponds to the compartment or label) checking passed domain model 
	element is the same as specified for the parent view (contract for compartment and labels). 
«ENDREM»«-»
	«IF !getElements(this).select(commonBase | null != commonBase.elementType).isEmpty()-»
			if (domainElement == null) {
				return null;
d93 7
a99 7
				«EXPAND xpt::Common::caseVisualID FOREACH getElements(this).select(commonBase | null != commonBase.elementType)»
					if (visualID != «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(containerView, domainElement)) {
						return null;
					}
					break;
				«EXPAND caseEssentialChildrenVisualID FOREACH getElements(this).select(commonBase | null != commonBase.elementType).typeSelect(gmfgen::GenNode)-»
			default: 
d107 6
a112 1
	if (!«EXPAND xpt::editor::VisualIDRegistry::canCreateNodeMethodCall»(containerView, visualID)) {
d116 2
a117 2
		«EXPAND caseContainerVisualID FOREACH getAllChildContainers()-»
		«EXPAND caseEntry FOREACH links.labels-»
d123 10
a132 6
«DEFINE caseEssentialChildrenVisualID FOR gmfgen::GenNode-»
«EXPAND xpt::Common::caseVisualID FOREACH labels»
«EXPAND xpt::Common::caseVisualID FOREACH compartments»
«IF !labels.isEmpty() || !compartments.isEmpty()-»
if («EXPAND xpt::editor::VisualIDRegistry::visualID» != «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR getDiagram()»(containerView) || containerView.getElement() != domainElement) {
	return null;
d135 1
a135 1
«ENDIF-»
d138 6
a143 3
«DEFINE defineElementTypeHint FOR gmfgen::GenDiagram-»
if (!«getElementTypesQualifiedClassName()».isKnownElementType(elementType) || false == elementType instanceof org.eclipse.gmf.runtime.emf.type.core.IHintedType) {
	return null;
d145 2
a146 1
String elementTypeHint = ((org.eclipse.gmf.runtime.emf.type.core.IHintedType) elementType).getSemanticHint();
d159 1
a159 2
«EXPAND xpt::Common::caseVisualID»
	return «getNotationViewFactoryQualifiedClassName()».class;
a161 1
	
d163 4
a166 2
	«EXPAND xpt::Common::generatedMemberComment»
protected Class getEdgeViewClass(org.eclipse.core.runtime.IAdaptable semanticAdapter, org.eclipse.gmf.runtime.notation.View containerView, String semanticHint) {
d168 3
a170 2
	if (elementType == null) {
		return null;
d172 1
a172 1
	«EXPAND defineElementTypeHint-»
d174 1
a174 1
		return null;
d177 1
a177 1
		return null;
d182 1
a182 1
		return null;
d184 5
d190 1
a190 1
		«EXPAND caseEntry FOREACH links-»
d197 4
a200 2
	«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.emf.type.core.IElementType getSemanticElementType(org.eclipse.core.runtime.IAdaptable semanticAdapter) {
d204 2
a205 1
	return (org.eclipse.gmf.runtime.emf.type.core.IElementType) semanticAdapter.getAdapter(org.eclipse.gmf.runtime.emf.type.core.IElementType.class);
d208 2
a209 2
	
«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»@


1.1
log
@move providers out of diagram folder
@
text
@d90 1
a90 1
		} «IF !getElements(this).select(commonBase | null != commonBase.elementType).isEmpty()»	else {
d92 9
a100 3
	elementType was not specified. This should happen only for compartments and labels. Checking that 
	semanticHint reference to one of these elements + do not checking domainElement visualID since passed
	domainElement belongs to the parent view.
d102 4
d108 6
d116 4
a119 1
		}«ENDIF»
d132 11
@

