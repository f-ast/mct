head	1.11;
access;
symbols
	v20081022-1925:1.11
	v20081015-1925:1.11
	v20081008-1925:1.11
	v20081001-1925:1.11
	v20080930-1130:1.11
	v20080926-1245:1.11
	v20080924-1925:1.11
	v20080917-1925:1.11
	v20080911-1728:1.11
	v20080910-1520:1.11
	v20080903-1520:1.11
	v20080827-1520:1.11
	v20080813-1520:1.11
	v20080806-1520:1.11
	v20080722-1827:1.11
	v20080718-1731:1.11
	v20080716-1600:1.11
	v20080716-1642:1.11
	R2_1_maintenance:1.11.0.2
	Root_R2_1_maintenance:1.11
	R2_1_0:1.11
	v20080610-1132:1.11
	v20080603-1553:1.11
	v20080528-1052:1.11
	v20080521:1.11
	v20080516-1543:1.10
	v20080516-1143:1.10
	v20080512-1200:1.10
	v20080508-2000:1.10
	v20080507-1326:1.10
	v20080503-1740:1.8
	v20080501-1739:1.7
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080411-0411:1.5
	v20080404-1111:1.5
	v20080322-0000:1.5
	v20080222-1200:1.2
	v20080215-1500:1.2
	v20080207-0207:1.1.2.1
	v20071222-1111:1.2
	v20071214-1111:1.2
	v20071130-1111:1.2
	v20071124-0000:1.1.2.1
	v20071112-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070928-0000:1.1.2.1
	v20070921-0000:1.1.2.1
	v20070915-0000:1.1.2.1
	R2_0_maintenance:1.1.0.2;
locks; strict;
comment	@# @;


1.11
date	2008.05.20.15.45.10;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	29294832f2054567;

1.10
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	39124821b4de4567;

1.9
date	2008.05.05.21.06.41;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	4186481f76b14567;

1.8
date	2008.05.02.18.38.51;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	bd7481b5fbb4567;

1.7
date	2008.04.30.21.06.39;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	ac54818df5f4567;

1.6
date	2008.04.14.08.38.03;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	1b0e480317df4567;

1.5
date	2008.02.29.21.19.51;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	45a447c876f24567;

1.4
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	19d047c419ed4567;

1.3
date	2008.02.22.11.24.52;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	5c9347beb1044567;

1.2
date	2007.09.13.18.19.01;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	51ec46e97f104567;

1.1
date	2007.09.13.18.16.19;	author dstadnik;	state dead;
branches
	1.1.2.1;
next	;
commitid	485346e97e6f4567;

1.1.2.1
date	2007.09.13.18.16.19;	author dstadnik;	state Exp;
branches;
next	;
commitid	485346e97e6f4567;


desc
@@


1.11
log
@[228913], JavaProvider attributes: even if no body is set but throwsException is false, do not generate exception, rather respect throwException==false
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - introduced GenAuditContext entity
 *                                 straightforward and simple #validate() implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::EMFUtils»
«EXTENSION xpt::GenAuditRoot»


«DEFINE ValidationProvider FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «validationProviderClassName»
		extends org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.AbstractContributionItemProvider {

	«EXPAND constraintsActive-»

	«EXPAND shouldConstraintsBePrivate-»

	«EXPAND runWithActiveConstraints-»

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.jface.action.IAction createAction(String actionId,
			org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor partDescriptor) {
		if («editorGen.editor.packageName».ValidateAction.VALIDATE_ACTION_KEY.equals(actionId)) {
			return new «editorGen.editor.packageName».ValidateAction(partDescriptor);
		}
		return super.createAction(actionId, partDescriptor);
	}


	«EXPAND isInDefaultEditorContext-»

«EXPAND selectors FOR editorGen.audits-»

«EXPAND strategy_support»

«EXPAND constraintAdapters(this) FOR editorGen.audits-»

«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE constraintsActive FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
private static boolean constraintsActive = false;	
«ENDDEFINE»

«DEFINE shouldConstraintsBePrivate FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
public static boolean shouldConstraintsBePrivate() {
	return false;
}
«ENDDEFINE»

«DEFINE runWithActiveConstraints FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
public static void runWithConstraints(org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain, Runnable operation) {
	final Runnable op = operation;
	Runnable task = new Runnable() {
		public void run() {
			try {
				constraintsActive = true;
				op.run();
			} finally {
				constraintsActive = false;
			}
		}
	};
	if(editingDomain != null) {
		try {
			editingDomain.runExclusive(task);
		} catch (Exception e) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Validation failed", e); «EXPAND xpt::Common::nonNLS»
		}
	} else {
		task.run();
	}
}
«ENDDEFINE»


«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE selectors FOR GenAuditRoot-»
«FOREACH clientContexts AS ctx»
	«EXPAND xpt::Common::generatedMemberComment»
	public static class «ctx.className» implements org.eclipse.emf.validation.model.IClientSelector {

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean selects(Object object) {
«IF ctx.ruleTargets.typeSelect(GenDiagramElementTarget).size() > 0 -»
			if (isInDefaultEditorContext(object) && object instanceof org.eclipse.gmf.runtime.notation.View) {
				final int id = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»((org.eclipse.gmf.runtime.notation.View) object);
				boolean result = false;
«FOREACH getTargetDiagramElements(ctx) AS e-»
				result = result || id == «EXPAND xpt::editor::VisualIDRegistry::visualID FOR e»;
«ENDFOREACH-»
				return result;
			}
			return false;
«ELSE-»
			return isInDefaultEditorContext(object);
«ENDIF-»
		}
	}
«ENDFOREACH-»
«ENDDEFINE»

«DEFINE isInDefaultEditorContext FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
static boolean isInDefaultEditorContext(Object object) {
	if(shouldConstraintsBePrivate() && !constraintsActive) {
		return false;
	}
	if (object instanceof org.eclipse.gmf.runtime.notation.View) {
		return constraintsActive && «EXPAND xpt::editor::VisualIDRegistry::modelID».equals(«EXPAND xpt::editor::VisualIDRegistry::getModelIDMethodCall»((org.eclipse.gmf.runtime.notation.View) object));
	}
	return true;
}
«ENDDEFINE»


«DEFINE strategy_support FOR GenDiagram-»
«IF hasDiagramElementTargetRule(editorGen.audits)-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static org.eclipse.emf.validation.service.ITraversalStrategy getNotationTraversalStrategy(
			org.eclipse.emf.validation.service.IBatchValidator validator) {
		return new CtxSwitchStrategy(validator);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class CtxSwitchStrategy implements org.eclipse.emf.validation.service.ITraversalStrategy {

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.validation.service.ITraversalStrategy defaultStrategy;

		«EXPAND xpt::Common::generatedMemberComment»
		private int currentSemanticCtxId = -1;

		«EXPAND xpt::Common::generatedMemberComment»
		private boolean ctxChanged = true;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.ecore.EObject currentTarget;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.ecore.EObject preFetchedNextTarget;

		«EXPAND xpt::Common::generatedMemberComment»
		private final int[] contextSwitchingIdentifiers;

		«EXPAND xpt::Common::generatedMemberComment»
		CtxSwitchStrategy(org.eclipse.emf.validation.service.IBatchValidator validator) {
			this.defaultStrategy = validator.getDefaultTraversalStrategy();
			this.contextSwitchingIdentifiers = new int[] {
				«EXPAND xpt::editor::VisualIDRegistry::visualID FOREACH getAllTargetDiagramElements(editorGen.audits) SEPARATOR ","»
			};
			java.util.Arrays.sort(this.contextSwitchingIdentifiers);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void elementValidated(org.eclipse.emf.ecore.EObject element,
				org.eclipse.core.runtime.IStatus status) {
			defaultStrategy.elementValidated(element, status);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean hasNext() {
			return defaultStrategy.hasNext();
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean isClientContextChanged() {
			if (preFetchedNextTarget == null) {
				preFetchedNextTarget = next();
				prepareNextClientContext(preFetchedNextTarget);
			}
			return ctxChanged;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public org.eclipse.emf.ecore.EObject next() {
			org.eclipse.emf.ecore.EObject nextTarget = preFetchedNextTarget;
			if (nextTarget == null) {
				nextTarget = defaultStrategy.next();
			}
			this.preFetchedNextTarget = null;
			return this.currentTarget = nextTarget;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void startTraversal(java.util.Collection traversalRoots,	org.eclipse.core.runtime.IProgressMonitor monitor) {
			defaultStrategy.startTraversal(traversalRoots, monitor);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private void prepareNextClientContext(org.eclipse.emf.ecore.EObject nextTarget) { 
			if (nextTarget != null && currentTarget != null) {
				if (nextTarget instanceof org.eclipse.gmf.runtime.notation.View) {
					final int id = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»((org.eclipse.gmf.runtime.notation.View) nextTarget);
					int nextSemanticId = (id != -1 && java.util.Arrays.binarySearch(contextSwitchingIdentifiers, id) >= 0) ? id : -1;
					if ((currentSemanticCtxId != -1 && currentSemanticCtxId != nextSemanticId)
							|| (nextSemanticId != -1 && nextSemanticId != currentSemanticCtxId)) {
						this.ctxChanged = true;
					}«/*[artem] not sure why not ctxChanged = <expr>, is it intentional not to reset ctxChanged if condition did not match? I doubt. FIXME?*/»
					currentSemanticCtxId = nextSemanticId;
				} else {
					// context of domain model
					this.ctxChanged = currentSemanticCtxId != -1;
					currentSemanticCtxId = -1;
				}
			} else {
				this.ctxChanged = false;
			}
		}
	}
«ENDIF-»
«ENDDEFINE»


«DEFINE constraintAdapters(GenDiagram diagram) FOR GenAuditRoot-»
«IF diagram.editorGen.expressionProviders != null-»
«EXPAND constraintAdapter(diagram.editorGen.expressionProviders) FOREACH rules.select(a | a.requiresConstraintAdapter)-»
«IF !rules.select(a | a.requiresConstraintAdapter).isEmpty()»
«EXPAND constraintAdapters_formatMethod»
«ENDIF»
«ENDIF-»
«ENDDEFINE»

«DEFINE constraintAdapter(GenExpressionProviderContainer container) FOR GenAuditRule-»
«IF target != null && target.getContext() != null-»

	«EXPAND xpt::Common::generatedMemberComment»
	public static class «getConstraintAdapterLocalClassName()» extends org.eclipse.emf.validation.AbstractModelConstraint {

«IF rule.provider.getLanguage().value != GenLanguage::java.value-»
		«EXPAND xpt::Common::generatedMemberComment»
		private «container.getAbstractExpressionQualifiedClassName()» expression;

«ENDIF-»
		«EXPAND xpt::Common::generatedMemberComment»
		public org.eclipse.core.runtime.IStatus validate(org.eclipse.emf.validation.IValidationContext ctx) {
			«EXPAND constraintAdapter_initContext(this) FOR target-»
			«EXPAND constraintAdapter_validateMethod(this) FOR rule.provider-»
		}
	}
«ENDIF-»
«ENDDEFINE»


«DEFINE constraintAdapters_formatMethod FOR GenAuditRoot-»
	«EXPAND xpt::Common::generatedMemberComment»
	static String formatElement(org.eclipse.emf.ecore.EObject object) {
		return org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(object, true);
	}
«ENDDEFINE»
 
/*
 * Expects 'context' variable to be initialized
 */
«DEFINE constraintAdapter_validateMethod(GenAuditRule audit) FOR GenExpressionProviderBase»«ERROR "No idea how to evaluate an audit rule for " + this»«ENDDEFINE»

«DEFINE constraintAdapter_validateMethod(GenAuditRule audit) FOR GenExpressionInterpreter-»
			if (expression == null) {
				expression = «EXPAND xpt::expressions::getExpression::getExpression(audit.rule, audit.target.getContext())»;
			}
			Object result = expression.evaluate(context);
			if (result instanceof Boolean && ((Boolean) result).booleanValue()) {
				return org.eclipse.core.runtime.Status.OK_STATUS;«REM»XXX why not ctx.createSuccessStatus()???«ENDREM»
			}
			return ctx.createFailureStatus(new Object[] { formatElement(ctx.getTarget()) });
«ENDDEFINE»

«DEFINE constraintAdapter_validateMethod(GenAuditRule audit) FOR GenJavaExpressionProvider-»
«IF injectExpressionBody && audit.rule.body != null && audit.rule.body.length() != 0-»
			«audit.rule.body»
«ELSEIF throwException || (injectExpressionBody && (audit.rule.body == null || audit.rule.body.length() == 0))-»
			// TODO: put validation code here
			// Ensure that you remove @@generated tag or use @@generated NOT
			//
			// To construct approprate return value, use ctx.createSuccessStatus()
			// or ctx.createFailureStatus(...)
			throw new java.lang.UnsupportedOperationException("No user java implementation provided for #validate(IValidationContext) operation");«EXPAND xpt::Common::nonNLS»
«ELSE-»
			return ctx.createFailureStatus(new Object[] { "No user java implementation provided for #validate(IValidationContext) operation" });«EXPAND xpt::Common::nonNLS»
«ENDIF-»
«ENDDEFINE»

/*
 *	Contract: declare variable with the name 'context' of appropriate type
 */
«DEFINE constraintAdapter_initContext(GenAuditRule audit) FOR GenAuditable-»
«EXPAND MetaModel::DeclareAndAssign("context", "ctx.getTarget()", false) FOR getContext()»
«ENDDEFINE»

«DEFINE constraintAdapter_initContext(GenAuditRule audit) FOR GenDomainAttributeTarget-»
	final Object«REM»Actual context type is genDomainAttributeTarget.getContext()«ENDREM» context = ctx.getTarget().eGet(«EXPAND MetaModel::MetaFeature FOR attribute»);
«REM»
	For now, leave reflective access that gives Object-compatible result.
	
	FIXME: introduce MetaModel::DeclareAndAssignAttributeValueAsObject, that would 
		check if attibute type is primitive and wrap accordingly, but access attribute directly!
«ENDREM-»
	if (context == null) {
«IF nullAsError-»
		return ctx.createFailureStatus(new Object[] { formatElement(ctx.getTarget()) });
«ELSE-»
		return org.eclipse.core.runtime.Status.OK_STATUS;
«ENDIF-»
	}
«ENDDEFINE»

«DEFINE constraintAdapter_initContext(GenAuditRule audit) FOR GenAuditedMetricTarget-»
final Number context = «IF metric == null /*though metamodel constraint should not allow this*/»null /*FIXME: metric target was not correctly specified in the model*/«ELSE»«EXPAND MetricProvider::invokeCalcMethod("ctx.getTarget()", false) FOR metric»«ENDIF»;
«ENDDEFINE»
@


1.10
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d293 1
a293 1
«ELSEIF throwException || audit.rule.body == null || audit.rule.body.length() == 0-»
@


1.9
log
@[228913] cleaned isCopy and java provider's getOperationName that are not in use any more; introduced fine-tuning options: use expressions body for java methods and whether to throw exception or fail silently (using reasonable/appropriate for the context default value), latter change obsoleted NoImplException and respective debug options
@
text
@d15 1
a15 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
d252 1
a252 1
«IF container.getProvider(rule).getLanguage().value != GenLanguage::java.value-»
d260 1
a260 1
			«EXPAND constraintAdapter_validateMethod(this) FOR container.getProvider(rule)»
@


1.8
log
@[230014] refactor MetricProvider.xpt
@
text
@d291 3
d299 4
a302 1
			return ctx.createFailureStatus(new Object[] { "No user java implementation provided for #validate(IValidationContext) operation" }); «EXPAND xpt::Common::nonNLS»
@


1.7
log
@[228913] item #4 and [226149] no need for explicit nested Java class with operations when validate() method itself is appropriate place.
Code different for full and lite version extracted into a separate template, lite version updated to override only those templates that needed, without extra effort duplication.
@
text
@d324 1
a324 1
final Number context = «audit.root.editorGen.diagram.getMetricProviderQualifiedClassName()».calculateMetric(«toStringLiteral(metric == null ? "" : metric.key)», ctx.getTarget());
@


1.6
log
@[226149] Refactor Validation/Constraints: explicit context groupings instead of ID matching, unused IClientSelectors implementations are no longer generated, less custom code in the model, odd approach with map (semanticCtxIdMap) replaced with in-place VisualID check.
@
text
@d12 1
d53 1
a53 4
«IF editorGen.expressionProviders != null-»
		«EXPAND constraintAdapters(this) FOR editorGen.audits-»
«ENDIF-»
«IF editorGen.audits != null && editorGen.expressionProviders != null-»
a54 9
	«EXPAND xpt::Common::generatedMemberComment»
static class JavaAudits {
	«FOREACH editorGen.audits.rules AS rule-»
		«IF rule.rule != null && rule.target != null && rule.target.getContext() != null-»
			«EXPAND javaInitializer(rule.rule, rule.target.getContext(), null) FOR editorGen.expressionProviders.getProvider(rule.rule)-»
		«ENDIF-»
	«ENDFOREACH-»
}
«ENDIF-»
a97 7
«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»

d238 6
a243 5
	«FOREACH rules AS rule-»
		«IF rule.requiresConstraintAdapter && null != rule.rule && null != rule.target && null != rule.target.getContext()-»
			«EXPAND constraintAdapter(diagram) FOR rule-»
		«ENDIF-»
	«ENDFOREACH-»
d246 2
a247 1
«DEFINE constraintAdapter(GenDiagram diagram) FOR GenAuditRule-»
d250 1
a250 2
	public static class «getConstraintAdapterLocalClassName()»
			extends org.eclipse.emf.validation.AbstractModelConstraint {
d252 1
d254 1
a254 6
		private «diagram.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression;

		«EXPAND xpt::Common::generatedMemberComment»
		public «getConstraintAdapterLocalClassName()»() {
			expression = «EXPAND initializerExpr(rule, target.getContext()) FOR diagram.editorGen.expressionProviders.getProvider(rule)»;
		}
d256 1
d259 2
a260 8
			Object evalCtx = ctx.getTarget();
			«EXPAND evalContext(diagram) FOR target-»
			Object result = expression.evaluate(evalCtx);
			if (result instanceof Boolean && ((Boolean) result).booleanValue()) {
				return org.eclipse.core.runtime.Status.OK_STATUS;
			}
			return ctx.createFailureStatus(new Object[] {
				 org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(ctx.getTarget(), true) });
d263 1
d266 6
a271 1
«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionProviderBase-»
d273 5
d279 9
a287 3
«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionInterpreter-»
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», //$NON-NLS-1$
		«EXPAND MetaModel::MetaClass FOR exprContext»)
d290 7
a296 8
«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenJavaExpressionProvider-»
	new «container.getAbstractExpressionQualifiedClassName()»(«EXPAND MetaModel::MetaClass FOR exprContext») {

		protected Object doEvaluate(Object context, java.util.Map env) {
			«EXPAND MetaModel::DeclareAndAssign("self", "context", true) FOR exprContext»
			return JavaAudits.«getOperationName(valueExpr)»(self);
		}
	}
d299 5
a303 1
«DEFINE evalContext(GenDiagram diagram) FOR GenAuditable-»
d306 14
a319 3
«DEFINE evalContext(GenDiagram diagram) FOR GenDomainAttributeTarget-»
	if (evalCtx instanceof org.eclipse.emf.ecore.EObject) {
		evalCtx = ((org.eclipse.emf.ecore.EObject) evalCtx).eGet(«EXPAND MetaModel::MetaFeature FOR attribute»);
a320 8
	if (evalCtx == null) {
	«IF nullAsError-»
		return ctx.createFailureStatus(new Object[] {
				org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(ctx.getTarget(), true) });
	«ELSE-»
		return org.eclipse.core.runtime.Status.OK_STATUS;
	«ENDIF-»
	}			
d323 2
a324 4
«DEFINE evalContext(GenDiagram diagram) FOR GenAuditedMetricTarget-»
	«LET metric == null ? "" : metric.key AS metricKey-»
	evalCtx = «diagram.getMetricProviderQualifiedClassName()».calculateMetric(«toStringLiteral(metricKey)», evalCtx);
	«ENDLET-»
@


1.5
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d11 1
d16 1
d19 2
d30 3
a32 2
	«EXPAND xpt::Common::generatedMemberComment»
	private static boolean constraintsActive = false;
d34 1
a34 4
	«EXPAND xpt::Common::generatedMemberComment»
	public static boolean shouldConstraintsBePrivate() {
		return false;
	}
d45 12
d58 30
a87 16
	public static void runWithConstraints(org.eclipse.gmf.runtime.notation.View view, Runnable op) {
		final Runnable fop = op;
		Runnable task = new Runnable() {

			public void run() {
				try {
					constraintsActive = true;
					fop.run();
				} finally {
					constraintsActive = false;
				}
			}
		};
		org.eclipse.emf.transaction.TransactionalEditingDomain txDomain =
				org.eclipse.emf.transaction.util.TransactionUtil.getEditingDomain(view);
		if (txDomain != null) {
d89 4
a92 4
				txDomain.runExclusive(task);
			} catch (Exception e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
						"Validation action failed", e); //$NON-NLS-1$
a93 2
		} else {
			task.run();
d95 9
d105 6
d112 8
d121 13
a133 2
	static boolean isInDefaultEditorContext(Object object) {
		if (shouldConstraintsBePrivate() && !constraintsActive) {
d135 3
a138 5
		if (object instanceof org.eclipse.gmf.runtime.notation.View) {
			return constraintsActive && «getEditPartQualifiedClassName()».MODEL_ID.equals(
					«getVisualIDRegistryQualifiedClassName()».getModelID((org.eclipse.gmf.runtime.notation.View) object));
		}
		return true;
d140 15
a155 3
	«EXPAND xpt::Common::generatedMemberComment»
	static final java.util.Map semanticCtxIdMap = new java.util.HashMap();
	«EXPAND selectors FOR editorGen.audits-»
d157 2
d172 1
a172 1
		private String currentSemanticCtxId;
d184 3
d189 4
d226 1
a226 2
		public void startTraversal(java.util.Collection traversalRoots,
				org.eclipse.core.runtime.IProgressMonitor monitor) {
d234 4
a237 4
					String id = ((org.eclipse.gmf.runtime.notation.View) nextTarget).getType();
					String nextSemanticId = id != null && semanticCtxIdMap.containsKey(id) ? id : null;
					if ((currentSemanticCtxId != null && !currentSemanticCtxId.equals(nextSemanticId))
							|| (nextSemanticId != null && !nextSemanticId.equals(currentSemanticCtxId))) {
d239 1
a239 1
					}
d243 2
a244 2
					this.ctxChanged = currentSemanticCtxId != null;
					currentSemanticCtxId = null;
d251 1
a251 19
	«IF editorGen.expressionProviders != null-»
		«EXPAND constraintAdapters(this) FOR editorGen.audits-»
	«ENDIF-»
	«IF editorGen.audits != null && editorGen.expressionProviders != null-»

	«EXPAND xpt::Common::generatedMemberComment»
static class JavaAudits {
	«FOREACH editorGen.audits.rules AS rule-»
		«IF rule.rule != null && rule.target != null && rule.target.getContext() != null-»
			«EXPAND javaInitializer(rule.rule, rule.target.getContext(), null) FOR editorGen.expressionProviders.getProvider(rule.rule)-»
		«ENDIF-»
	«ENDFOREACH-»
}
	«ENDIF-»
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
a253 48
«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE selectors FOR GenAuditRoot-»
	«FOREACH rules AS rule-»
		«IF null != rule.target && null != rule.target.getClientContextID()-»
			«EXPAND selector FOR rule-»
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE selector FOR GenAuditRule-»

	«EXPAND xpt::Common::generatedMemberComment»
	public static class «contextSelectorLocalClassName» implements org.eclipse.emf.validation.model.IClientSelector {

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean selects(Object object) {
		«IF { target }.typeSelect(GenDiagramElementTarget).size() > 0 -»
			if (isInDefaultEditorContext(object) && object instanceof org.eclipse.gmf.runtime.notation.View) {
				String id = ((org.eclipse.gmf.runtime.notation.View) object).getType();
				return id != null && semanticCtxIdMap.get(id) == «contextSelectorLocalClassName».class;
			}
			return false;
		«ELSE-»
			return isInDefaultEditorContext(object);
		«ENDIF-»
		}
	}
	«EXPAND contexts(this) FOR target-»
«ENDDEFINE»

«DEFINE contexts(GenAuditRule rule) FOR GenAuditable-»
«ENDDEFINE»

«DEFINE contexts(GenAuditRule rule) FOR GenDiagramElementTarget-»

	«EXPAND xpt::Common::generatedMemberComment»
	static {
	«FOREACH element AS element-»
		semanticCtxIdMap.put(String.valueOf(«element.getEditPartQualifiedClassName()».VISUAL_ID),
				«rule.contextSelectorLocalClassName».class); //$NON-NLS-1$
	«ENDFOREACH-»
	}
«ENDDEFINE»
@


1.4
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d291 1
a291 1
			«getQualifiedInstanceClassName(exprContext)» self = («getQualifiedInstanceClassName(exprContext)») context;
@


1.3
log
@[150177] phase I, refactor existing code: use same template for metainfo access
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d284 1
a284 1
		«EXPAND xpt::Common::metaClassAccessor FOR exprContext»)
d288 1
a288 1
	new «container.getAbstractExpressionQualifiedClassName()»(«EXPAND xpt::Common::metaClassAccessor FOR exprContext») {
d302 1
a302 1
		evalCtx = ((org.eclipse.emf.ecore.EObject) evalCtx).eGet(«EXPAND xpt::Common::metaFeatureAccessor FOR attribute»);
@


1.2
log
@rewrite validation prov in xpand
@
text
@d284 1
a284 1
		«getQualifiedClassifierAccessor(exprContext)»())
d288 1
a288 1
	new «container.getAbstractExpressionQualifiedClassName()»(«getQualifiedClassifierAccessor(exprContext)»()) {
d302 1
a302 1
		evalCtx = ((org.eclipse.emf.ecore.EObject) evalCtx).eGet(«getQualifiedFeatureAccessorName(attribute)»());
@


1.1
log
@file ValidationProvider.xpt was initially added on branch R2_0_maintenance.
@
text
@d1 318
@


1.1.2.1
log
@rewrite validation prov in xpand
@
text
@a0 318
/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::EMFUtils»

«DEFINE ValidationProvider FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «validationProviderClassName»
		extends org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.AbstractContributionItemProvider {

	«EXPAND xpt::Common::generatedMemberComment»
	private static boolean constraintsActive = false;

	«EXPAND xpt::Common::generatedMemberComment»
	public static boolean shouldConstraintsBePrivate() {
		return false;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.jface.action.IAction createAction(String actionId,
			org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor partDescriptor) {
		if («editorGen.editor.packageName».ValidateAction.VALIDATE_ACTION_KEY.equals(actionId)) {
			return new «editorGen.editor.packageName».ValidateAction(partDescriptor);
		}
		return super.createAction(actionId, partDescriptor);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static void runWithConstraints(org.eclipse.gmf.runtime.notation.View view, Runnable op) {
		final Runnable fop = op;
		Runnable task = new Runnable() {

			public void run() {
				try {
					constraintsActive = true;
					fop.run();
				} finally {
					constraintsActive = false;
				}
			}
		};
		org.eclipse.emf.transaction.TransactionalEditingDomain txDomain =
				org.eclipse.emf.transaction.util.TransactionUtil.getEditingDomain(view);
		if (txDomain != null) {
			try {
				txDomain.runExclusive(task);
			} catch (Exception e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
						"Validation action failed", e); //$NON-NLS-1$
			}
		} else {
			task.run();
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	static boolean isInDefaultEditorContext(Object object) {
		if (shouldConstraintsBePrivate() && !constraintsActive) {
			return false;
		}
		if (object instanceof org.eclipse.gmf.runtime.notation.View) {
			return constraintsActive && «getEditPartQualifiedClassName()».MODEL_ID.equals(
					«getVisualIDRegistryQualifiedClassName()».getModelID((org.eclipse.gmf.runtime.notation.View) object));
		}
		return true;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	static final java.util.Map semanticCtxIdMap = new java.util.HashMap();
	«EXPAND selectors FOR editorGen.audits-»

	«EXPAND xpt::Common::generatedMemberComment»
	public static org.eclipse.emf.validation.service.ITraversalStrategy getNotationTraversalStrategy(
			org.eclipse.emf.validation.service.IBatchValidator validator) {
		return new CtxSwitchStrategy(validator);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class CtxSwitchStrategy implements org.eclipse.emf.validation.service.ITraversalStrategy {

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.validation.service.ITraversalStrategy defaultStrategy;

		«EXPAND xpt::Common::generatedMemberComment»
		private String currentSemanticCtxId;

		«EXPAND xpt::Common::generatedMemberComment»
		private boolean ctxChanged = true;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.ecore.EObject currentTarget;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.ecore.EObject preFetchedNextTarget;

		«EXPAND xpt::Common::generatedMemberComment»
		CtxSwitchStrategy(org.eclipse.emf.validation.service.IBatchValidator validator) {
			this.defaultStrategy = validator.getDefaultTraversalStrategy();
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void elementValidated(org.eclipse.emf.ecore.EObject element,
				org.eclipse.core.runtime.IStatus status) {
			defaultStrategy.elementValidated(element, status);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean hasNext() {
			return defaultStrategy.hasNext();
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean isClientContextChanged() {
			if (preFetchedNextTarget == null) {
				preFetchedNextTarget = next();
				prepareNextClientContext(preFetchedNextTarget);
			}
			return ctxChanged;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public org.eclipse.emf.ecore.EObject next() {
			org.eclipse.emf.ecore.EObject nextTarget = preFetchedNextTarget;
			if (nextTarget == null) {
				nextTarget = defaultStrategy.next();
			}
			this.preFetchedNextTarget = null;
			return this.currentTarget = nextTarget;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void startTraversal(java.util.Collection traversalRoots,
				org.eclipse.core.runtime.IProgressMonitor monitor) {
			defaultStrategy.startTraversal(traversalRoots, monitor);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private void prepareNextClientContext(org.eclipse.emf.ecore.EObject nextTarget) { 
			if (nextTarget != null && currentTarget != null) {
				if (nextTarget instanceof org.eclipse.gmf.runtime.notation.View) {
					String id = ((org.eclipse.gmf.runtime.notation.View) nextTarget).getType();
					String nextSemanticId = id != null && semanticCtxIdMap.containsKey(id) ? id : null;
					if ((currentSemanticCtxId != null && !currentSemanticCtxId.equals(nextSemanticId))
							|| (nextSemanticId != null && !nextSemanticId.equals(currentSemanticCtxId))) {
						this.ctxChanged = true;
					}
					currentSemanticCtxId = nextSemanticId;
				} else {
					// context of domain model
					this.ctxChanged = currentSemanticCtxId != null;
					currentSemanticCtxId = null;
				}
			} else {
				this.ctxChanged = false;
			}
		}
	}
	«IF editorGen.expressionProviders != null-»
		«EXPAND constraintAdapters(this) FOR editorGen.audits-»
	«ENDIF-»
	«IF editorGen.audits != null && editorGen.expressionProviders != null-»

	«EXPAND xpt::Common::generatedMemberComment»
static class JavaAudits {
	«FOREACH editorGen.audits.rules AS rule-»
		«IF rule.rule != null && rule.target != null && rule.target.getContext() != null-»
			«EXPAND javaInitializer(rule.rule, rule.target.getContext(), null) FOR editorGen.expressionProviders.getProvider(rule.rule)-»
		«ENDIF-»
	«ENDFOREACH-»
}
	«ENDIF-»
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE selectors FOR GenAuditRoot-»
	«FOREACH rules AS rule-»
		«IF null != rule.target && null != rule.target.getClientContextID()-»
			«EXPAND selector FOR rule-»
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE selector FOR GenAuditRule-»

	«EXPAND xpt::Common::generatedMemberComment»
	public static class «contextSelectorLocalClassName» implements org.eclipse.emf.validation.model.IClientSelector {

		«EXPAND xpt::Common::generatedMemberComment»
		public boolean selects(Object object) {
		«IF { target }.typeSelect(GenDiagramElementTarget).size() > 0 -»
			if (isInDefaultEditorContext(object) && object instanceof org.eclipse.gmf.runtime.notation.View) {
				String id = ((org.eclipse.gmf.runtime.notation.View) object).getType();
				return id != null && semanticCtxIdMap.get(id) == «contextSelectorLocalClassName».class;
			}
			return false;
		«ELSE-»
			return isInDefaultEditorContext(object);
		«ENDIF-»
		}
	}
	«EXPAND contexts(this) FOR target-»
«ENDDEFINE»

«DEFINE contexts(GenAuditRule rule) FOR GenAuditable-»
«ENDDEFINE»

«DEFINE contexts(GenAuditRule rule) FOR GenDiagramElementTarget-»

	«EXPAND xpt::Common::generatedMemberComment»
	static {
	«FOREACH element AS element-»
		semanticCtxIdMap.put(String.valueOf(«element.getEditPartQualifiedClassName()».VISUAL_ID),
				«rule.contextSelectorLocalClassName».class); //$NON-NLS-1$
	«ENDFOREACH-»
	}
«ENDDEFINE»

«DEFINE constraintAdapters(GenDiagram diagram) FOR GenAuditRoot-»
	«FOREACH rules AS rule-»
		«IF rule.requiresConstraintAdapter && null != rule.rule && null != rule.target && null != rule.target.getContext()-»
			«EXPAND constraintAdapter(diagram) FOR rule-»
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE constraintAdapter(GenDiagram diagram) FOR GenAuditRule-»

	«EXPAND xpt::Common::generatedMemberComment»
	public static class «getConstraintAdapterLocalClassName()»
			extends org.eclipse.emf.validation.AbstractModelConstraint {

		«EXPAND xpt::Common::generatedMemberComment»
		private «diagram.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression;

		«EXPAND xpt::Common::generatedMemberComment»
		public «getConstraintAdapterLocalClassName()»() {
			expression = «EXPAND initializerExpr(rule, target.getContext()) FOR diagram.editorGen.expressionProviders.getProvider(rule)»;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public org.eclipse.core.runtime.IStatus validate(org.eclipse.emf.validation.IValidationContext ctx) {
			Object evalCtx = ctx.getTarget();
			«EXPAND evalContext(diagram) FOR target-»
			Object result = expression.evaluate(evalCtx);
			if (result instanceof Boolean && ((Boolean) result).booleanValue()) {
				return org.eclipse.core.runtime.Status.OK_STATUS;
			}
			return ctx.createFailureStatus(new Object[] {
				 org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(ctx.getTarget(), true) });
		}
	}
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionInterpreter-»
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», //$NON-NLS-1$
		«getQualifiedClassifierAccessor(exprContext)»())
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenJavaExpressionProvider-»
	new «container.getAbstractExpressionQualifiedClassName()»(«getQualifiedClassifierAccessor(exprContext)»()) {

		protected Object doEvaluate(Object context, java.util.Map env) {
			«getQualifiedInstanceClassName(exprContext)» self = («getQualifiedInstanceClassName(exprContext)») context;
			return JavaAudits.«getOperationName(valueExpr)»(self);
		}
	}
«ENDDEFINE»

«DEFINE evalContext(GenDiagram diagram) FOR GenAuditable-»
«ENDDEFINE»

«DEFINE evalContext(GenDiagram diagram) FOR GenDomainAttributeTarget-»
	if (evalCtx instanceof org.eclipse.emf.ecore.EObject) {
		evalCtx = ((org.eclipse.emf.ecore.EObject) evalCtx).eGet(«getQualifiedFeatureAccessorName(attribute)»());
	}
	if (evalCtx == null) {
	«IF nullAsError-»
		return ctx.createFailureStatus(new Object[] {
				org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(ctx.getTarget(), true) });
	«ELSE-»
		return org.eclipse.core.runtime.Status.OK_STATUS;
	«ENDIF-»
	}			
«ENDDEFINE»

«DEFINE evalContext(GenDiagram diagram) FOR GenAuditedMetricTarget-»
	«LET metric == null ? "" : metric.key AS metricKey-»
	evalCtx = «diagram.getMetricProviderQualifiedClassName()».calculateMetric(«toStringLiteral(metricKey)», evalCtx);
	«ENDLET-»
«ENDDEFINE»
@

