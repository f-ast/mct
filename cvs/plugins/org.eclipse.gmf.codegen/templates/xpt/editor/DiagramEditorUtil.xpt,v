head	1.26;
access;
symbols
	v20081022-1925:1.26
	v20081015-1925:1.26
	v20081008-1925:1.24
	v20081001-1925:1.24
	v20080930-1130:1.24
	v20080926-1245:1.24
	v20080924-1925:1.24
	v20080917-1925:1.24
	v20080911-1728:1.24
	v20080910-1520:1.24
	v20080903-1520:1.24
	v20080827-1520:1.24
	v20080813-1520:1.24
	v20080806-1520:1.24
	v20080722-1827:1.24
	v20080718-1731:1.24
	v20080716-1600:1.23
	v20080716-1642:1.24
	R2_1_maintenance:1.23.0.2
	Root_R2_1_maintenance:1.23
	R2_1_0:1.23
	v20080610-1132:1.23
	v20080603-1553:1.23
	v20080528-1052:1.23
	v20080521:1.23
	v20080516-1543:1.23
	v20080516-1143:1.23
	v20080512-1200:1.23
	v20080508-2000:1.23
	v20080507-1326:1.23
	v20080503-1740:1.22
	v20080501-1739:1.22
	v20080425-1959:1.22
	v20080417-1610:1.22
	v20080411-0411:1.22
	v20080404-1111:1.22
	v20080322-0000:1.22
	v20080222-1200:1.19
	v20080215-1500:1.19
	v20080207-0207:1.19
	v20071222-1111:1.19
	v20071214-1111:1.19
	v20071130-1111:1.19
	v20071124-0000:1.19
	v20071112-0000:1.19
	v20071108-0000:1.19
	v20071003-0000:1.19
	v20070928-0000:1.19
	v20070921-0000:1.19
	v20070915-0000:1.19
	v20070903-0000:1.19
	v20070809-0000:1.19
	R2_0_maintenance:1.19.0.2
	R2_0:1.19
	R4_20:1.19
	v20070621-0000:1.19
	RC3_20:1.19
	v20070614-1400:1.19
	v20070608-1300:1.19
	v20070605-1400:1.19
	v20070601-1400:1.19
	v20070525-1500:1.19
	v20070520-1200:1.19
	v20070518-1300:1.18
	v20070504-1000:1.17
	v20070427-0600:1.17
	v20070420-1000:1.15
	v20070413-1300:1.12
	v20070405-1100:1.7
	v20070403-1500:1.6
	v20070330-1300:1.6
	v20060330-1300:1.6
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070307-0700:1.3
	v20070301-1200:1.3
	v20070228-2000:1.3
	v20070221-1500:1.3
	v20070208-1800:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.26
date	2008.10.15.18.15.59;	author atikhomirov;	state Exp;
branches;
next	1.25;
commitid	bb8448f6335e4567;

1.25
date	2008.10.15.17.35.45;	author atikhomirov;	state Exp;
branches;
next	1.24;
commitid	966a48f629f04567;

1.24
date	2008.07.01.18.48.54;	author atikhomirov;	state Exp;
branches;
next	1.23;
commitid	4f11486a7c164567;

1.23
date	2008.05.07.13.56.00;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	39124821b4de4567;

1.22
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	19d047c419ed4567;

1.21
date	2008.02.22.20.45.07;	author atikhomirov;	state Exp;
branches;
next	1.20;
commitid	45fc47bf34534567;

1.20
date	2008.02.22.20.24.43;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	377d47bf2f8a4567;

1.19
date	2007.05.18.21.17.18;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	2591464e17d14567;

1.18
date	2007.05.15.19.19.22;	author ashatalin;	state Exp;
branches;
next	1.17;
commitid	43d3464a07b84567;

1.17
date	2007.04.24.17.31.30;	author ashatalin;	state Exp;
branches;
next	1.16;
commitid	5743462e3ef14567;

1.16
date	2007.04.24.16.46.00;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	7ecd462e34474567;

1.15
date	2007.04.19.14.48.46;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	2c994627814d4567;

1.14
date	2007.04.19.14.39.34;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	48ac46277f254567;

1.13
date	2007.04.19.14.31.32;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	c0046277d444567;

1.12
date	2007.04.06.17.13.51;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	2bdf46167fce4567;

1.11
date	2007.04.06.15.34.21;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	33134616687b4567;

1.10
date	2007.04.06.14.14.50;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	5af4461655d94567;

1.9
date	2007.04.06.10.21.04;	author dstadnik;	state Exp;
branches;
next	1.8;
commitid	70ce46161f0f4567;

1.8
date	2007.04.05.15.03.04;	author ashatalin;	state Exp;
branches;
next	1.7;
commitid	7e8946150fa54567;

1.7
date	2007.04.04.11.18.20;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	2664461389794567;

1.6
date	2007.03.28.08.49.38;	author dstadnik;	state Exp;
branches;
next	1.5;
commitid	2240460a2c174567;

1.5
date	2007.03.15.12.19.49;	author dstadnik;	state Exp;
branches;
next	1.4;
commitid	1fd45f939e44567;

1.4
date	2007.03.15.11.57.13;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	21b545f934984567;

1.3
date	2007.02.05.17.27.22;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	13b045c768f94567;

1.2
date	2007.02.02.20.00.05;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	364f45c398454567;

1.1
date	2007.02.02.19.45.10;	author atikhomirov;	state Exp;
branches;
next	;
commitid	1a2145c394c34567;


desc
@@


1.26
log
@refactoring: redirected cast through MetaModel.xpt
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«EXTENSION xpt::editor::GenDiagram»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::editor::Utils»

«DEFINE DiagramEditorUtil FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::copyright FOR editorGen-»
package «editorGen.editor.packageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «diagramEditorUtilClassName» {

«EXPAND saveOptions-»

«EXPAND openDiagramMethod-»
«IF editorGen.application == null-»

	«EXPAND setCharsetMethods-»
«ENDIF-»

«EXPAND getUniqueFileNameMethod-»

«IF editorGen.application != null»
	/**
	 * Allows user to select file and loads it as a model.
	 * 
	 * @@generated
	 */
	public static org.eclipse.emf.ecore.resource.Resource openModel(
			org.eclipse.swt.widgets.Shell shell, String description, org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain) {
		org.eclipse.swt.widgets.FileDialog fileDialog = new org.eclipse.swt.widgets.FileDialog(shell, org.eclipse.swt.SWT.OPEN);
		if (description != null) {
			fileDialog.setText(description);
		}
		fileDialog.open();
		String fileName = fileDialog.getFileName();
		if (fileName == null || fileName.length() == 0) {
			return null;
		}
		if (fileDialog.getFilterPath() != null) {
			fileName = fileDialog.getFilterPath() + java.io.File.separator + fileName;
		}
		org.eclipse.emf.common.util.URI uri = org.eclipse.emf.common.util.URI.createFileURI(fileName);
		org.eclipse.emf.ecore.resource.Resource resource = null;
		try {
			resource = editingDomain.getResourceSet().getResource(uri, true);
		} catch (org.eclipse.emf.common.util.WrappedException we) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to load resource: " + uri, we); «EXPAND xpt::Common::nonNLS»
			org.eclipse.jface.dialogs.MessageDialog.openError(shell, 
                «EXPAND xpt::Externalizer::accessorCall(i18nKeyForOpenModelResourceErrorDialog().titleKey()) FOR editorGen»,
				org.eclipse.osgi.util.NLS.bind(
				    «EXPAND xpt::Externalizer::accessorCall(i18nKeyForOpenModelResourceErrorDialog().messageKey()) FOR editorGen»,
				    fileName));
		}
		return resource;
	}
«ENDIF»

	/**
	 * Runs the wizard in a dialog.
	 * 
	 * @@generated
	 */
	public static void runWizard(org.eclipse.swt.widgets.Shell shell, org.eclipse.jface.wizard.Wizard wizard, String settingsKey) {
		org.eclipse.jface.dialogs.IDialogSettings pluginDialogSettings = «editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getDialogSettings();
		org.eclipse.jface.dialogs.IDialogSettings wizardDialogSettings = pluginDialogSettings.getSection(settingsKey);
		if (wizardDialogSettings == null) {
			wizardDialogSettings = pluginDialogSettings.addNewSection(settingsKey);
		}
		wizard.setDialogSettings(wizardDialogSettings);
		org.eclipse.jface.wizard.WizardDialog dialog = new org.eclipse.jface.wizard.WizardDialog(shell, wizard);
		dialog.create();
		dialog.getShell().setSize(Math.max(500, dialog.getShell().getSize().x), 500);
		dialog.open();
	}

«EXPAND createDiagramMethod-»
«IF domainDiagramElement != null»
	«EXPAND createInitialModelMethod»
	«EXPAND attachModelMethod»
	«IF hasDocumentRoot()»«EXPAND createDocumentRootMethod»«ENDIF»
«ENDIF»

«EXPAND selectElementsMethod»
«EXPAND findElementsMethod»
«EXPAND findViewMethod»

«EXPAND additions»
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE saveOptions FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static java.util.Map getSaveOptions() {
		java.util.Map saveOptions = new java.util.HashMap();
		saveOptions.put(org.eclipse.emf.ecore.xmi.XMLResource.OPTION_ENCODING, "UTF-8"); «EXPAND xpt::Common::nonNLS»
		saveOptions.put(org.eclipse.emf.ecore.resource.Resource.OPTION_SAVE_ONLY_IF_CHANGED, org.eclipse.emf.ecore.resource.Resource.OPTION_SAVE_ONLY_IF_CHANGED_MEMORY_BUFFER);
		return saveOptions;
	}
«ENDDEFINE»

«DEFINE openDiagramMethod FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static boolean openDiagram(org.eclipse.emf.ecore.resource.Resource diagram) throws org.eclipse.ui.PartInitException {
«IF editorGen.application == null-»
		String path = diagram.getURI().toPlatformString(true);
		org.eclipse.core.resources.IResource workspaceResource = org.eclipse.core.resources.ResourcesPlugin.getWorkspace().getRoot().findMember(new org.eclipse.core.runtime.Path(path));
		if (workspaceResource instanceof org.eclipse.core.resources.IFile) {
			org.eclipse.ui.IWorkbenchPage page = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
			return null != page.openEditor(new org.eclipse.ui.part.FileEditorInput((org.eclipse.core.resources.IFile) workspaceResource), «editorGen.editor.getQualifiedClassName()».ID);
		}
		return false;
«ELSE-»
		org.eclipse.ui.IWorkbenchPage page = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
		page.openEditor(new org.eclipse.emf.common.ui.URIEditorInput(diagram.getURI()), «editorGen.editor.getQualifiedClassName()».ID);
		return true;
«ENDIF-»
	}
«ENDDEFINE»

«DEFINE setCharsetMethods FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static void setCharset(org.eclipse.core.resources.IFile file) {
		if (file == null) {
			return;
		}
		try {
			file.setCharset("UTF-8", new org.eclipse.core.runtime.NullProgressMonitor()); «EXPAND xpt::Common::nonNLS»
		} catch (org.eclipse.core.runtime.CoreException e) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to set charset for file " + file.getFullPath(), e); «EXPAND xpt::Common::nonNLS»
		}
	}	
«ENDDEFINE»

«DEFINE getUniqueFileNameMethod FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static String getUniqueFileName(org.eclipse.core.runtime.IPath containerFullPath, String fileName, String extension) {
		if (containerFullPath == null) {
			containerFullPath = new org.eclipse.core.runtime.Path(""); «EXPAND xpt::Common::nonNLS»
		}
		if (fileName == null || fileName.trim().length() == 0) {
			fileName = "default"; «EXPAND xpt::Common::nonNLS»
		}
		org.eclipse.core.runtime.IPath filePath = containerFullPath.append(fileName);
		if (extension != null && !extension.equals(filePath.getFileExtension())) {
			filePath = filePath.addFileExtension(extension);
		}
		extension = filePath.getFileExtension();
		fileName = filePath.removeFileExtension().lastSegment();
		int i = 1;
		while (
		«IF editorGen.application == null-»
			org.eclipse.core.resources.ResourcesPlugin.getWorkspace().getRoot().exists(filePath)
		«ELSE-»
			filePath.toFile().exists()
		«ENDIF-»
		) {
			i++;
			filePath = containerFullPath.append(fileName + i);
			if (extension != null) {
				filePath = filePath.addFileExtension(extension);
			}
		}
		return filePath.lastSegment();
	}
«ENDDEFINE»

«DEFINE createDiagramMethod FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment(editorGen.application == null ? "This method should be called within a workspace modify operation since it creates resources." : "")»
	public static org.eclipse.emf.ecore.resource.Resource createDiagram(org.eclipse.emf.common.util.URI diagramURI,«IF standaloneDomainModel()» org.eclipse.emf.common.util.URI modelURI,«ENDIF» org.eclipse.core.runtime.IProgressMonitor progressMonitor) {
		org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain = org.eclipse.gmf.runtime.emf.core.GMFEditingDomainFactory.INSTANCE.createEditingDomain();
		progressMonitor.beginTask(«EXPAND xpt::Externalizer::accessorCall(i18nKeyForCreateDiagramProgressTask()) FOR editorGen», 3);
		final org.eclipse.emf.ecore.resource.Resource diagramResource = editingDomain.getResourceSet().createResource(diagramURI);
«IF standaloneDomainModel()-»
		final org.eclipse.emf.ecore.resource.Resource modelResource = editingDomain.getResourceSet().createResource(modelURI);
«ELSEIF domainDiagramElement != null && hasDocumentRoot() /*for standalone models, we assume its resourcefactory would be able to set extendedMetaData option*/-»
		((org.eclipse.emf.ecore.xmi.XMLResource) diagramResource).getDefaultSaveOptions().put(org.eclipse.emf.ecore.xmi.XMLResource.OPTION_EXTENDED_META_DATA, Boolean.TRUE);
		((org.eclipse.emf.ecore.xmi.XMLResource) diagramResource).getDefaultLoadOptions().put(org.eclipse.emf.ecore.xmi.XMLResource.OPTION_EXTENDED_META_DATA, Boolean.TRUE);
«ENDIF-»
		final String diagramName = diagramURI.lastSegment();
		org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand command = new org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand(editingDomain, «EXPAND xpt::Externalizer::accessorCall(i18nKeyForCreateDiagramCommandLabel()) FOR editorGen», java.util.Collections.EMPTY_LIST) {
			protected org.eclipse.gmf.runtime.common.core.command.CommandResult doExecuteWithResult(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
«IF domainDiagramElement != null-»
				«EXPAND MetaModel::QualifiedClassName FOR domainDiagramElement» model = createInitialModel();
				attachModelToResource(model, «IF standaloneDomainModel()»model«ELSE»diagram«ENDIF»Resource);
«ENDIF»
				org.eclipse.gmf.runtime.notation.Diagram diagram = org.eclipse.gmf.runtime.diagram.core.services.ViewService.createDiagram(
«IF domainDiagramElement != null-»
				«EXPAND MetaModel::DowncastToEObject("model") FOR domainDiagramElement», 
«ENDIF-»
					«EXPAND xpt::editor::VisualIDRegistry::modelID», «EXPAND xpt::plugin::Activator::preferenceHintAccess FOR editorGen»);
				if (diagram != null) {
					diagramResource.getContents().add(diagram);
					diagram.setName(diagramName);
«IF domainDiagramElement != null-»
					diagram.setElement(«EXPAND MetaModel::DowncastToEObject("model") FOR domainDiagramElement»);
«ENDIF-»
				}
				
				try {
					«IF standaloneDomainModel()»modelResource.save(«EXPAND xpt::Common::getSaveOptions»);«ENDIF»
					diagramResource.save(«EXPAND xpt::Common::getSaveOptions»);
				} catch (java.io.IOException e) {
					«/* TODO CommandResult.newErrorCommandResult(e) would be better? Or even throw ExecutionEx?*/»
					«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to store model and diagram resources", e); «EXPAND xpt::Common::nonNLS»
				}
				return org.eclipse.gmf.runtime.common.core.command.CommandResult.newOKCommandResult();
			}
		};
		try {
			org.eclipse.core.commands.operations.OperationHistoryFactory.getOperationHistory().execute(command, new org.eclipse.core.runtime.SubProgressMonitor(progressMonitor, 1), null);
		} catch (org.eclipse.core.commands.ExecutionException e) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to create model and diagram", e); «EXPAND xpt::Common::nonNLS»
		}
«IF editorGen.application == null-»
		«IF standaloneDomainModel()»setCharset(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(modelResource));«ENDIF»
		setCharset(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(diagramResource));
«ENDIF-»
		return diagramResource;
	}
«ENDDEFINE»

«DEFINE createInitialModelMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment("Create a new instance of domain element associated with canvas.\n<!-- begin-user-doc -->\n<!-- end-user-doc -->")»
	private static «EXPAND MetaModel::QualifiedClassName FOR domainDiagramElement» createInitialModel() {
		return «EXPAND MetaModel::NewInstance FOR domainDiagramElement»;
	}
«ENDDEFINE»

«DEFINE attachModelMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment("Store model element in the resource.\n<!-- begin-user-doc -->\n<!-- end-user-doc -->")»
	private static void attachModelToResource(«EXPAND MetaModel::QualifiedClassName FOR domainDiagramElement» model, org.eclipse.emf.ecore.resource.Resource resource) {
		resource.getContents().add(«IF hasDocumentRoot()»createDocumentRoot(model)«ELSE»«EXPAND MetaModel::DowncastToEObject("model") FOR domainDiagramElement»«ENDIF»);
	}
«ENDDEFINE»

// invoke only when there's DocumentRoot in the domain model
«DEFINE createDocumentRootMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment»
	private static «EXPAND MetaModel::QualifiedClassName FOR getDocumentRoot()» createDocumentRoot(«EXPAND MetaModel::QualifiedClassName FOR domainDiagramElement» model) {
		«EXPAND MetaModel::NewInstance("docRoot") FOR getDocumentRoot()»
«LET getDocumentRootSetFeature() AS f»«IF f == null-»
		docRoot.set«domainDiagramElement.ecoreClass.name»(model); // FIXME name of the set method is pure guess«ELSE-»
		«EXPAND MetaModel::modifyFeature("docRoot", getDocumentRoot(), "model") FOR f»;«ENDIF»
«ENDLET-»
		return docRoot;
	}
«ENDDEFINE»

«DEFINE selectElementsMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment»
	public static void selectElementsInDiagram(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart, java.util.List/*EditPart*/ editParts) {
		diagramPart.getDiagramGraphicalViewer().deselectAll();

		org.eclipse.gef.EditPart firstPrimary = null;
		for (java.util.Iterator it = editParts.iterator(); it.hasNext();) {
			org.eclipse.gef.EditPart nextPart = (org.eclipse.gef.EditPart) it.next();
			diagramPart.getDiagramGraphicalViewer().appendSelection(nextPart);
			if(firstPrimary == null && nextPart instanceof org.eclipse.gmf.runtime.diagram.ui.editparts.IPrimaryEditPart) {
				firstPrimary = nextPart;
			}
		}

		if(!editParts.isEmpty()) {
			diagramPart.getDiagramGraphicalViewer().reveal(firstPrimary != null ? firstPrimary : (org.eclipse.gef.EditPart)editParts.get(0));
		}
	}
«ENDDEFINE»

«DEFINE findElementsMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment»
	private static int findElementsInDiagramByID(org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramPart, org.eclipse.emf.ecore.EObject element, java.util.List editPartCollector) {
		org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramGraphicalViewer viewer = (org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramGraphicalViewer) diagramPart.getViewer();
		final int intialNumOfEditParts = editPartCollector.size();
		
		if (element instanceof org.eclipse.gmf.runtime.notation.View) { // support notation element lookup
			org.eclipse.gef.EditPart editPart = (org.eclipse.gef.EditPart) viewer.getEditPartRegistry().get(element);
			if (editPart != null) {
				editPartCollector.add(editPart);
				return 1;
			}
		}

		String elementID = org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getProxyID(element);
		java.util.List associatedParts = viewer.findEditPartsForElement(elementID, org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart.class);
		// perform the possible hierarchy disjoint -> take the top-most parts only
		for (java.util.Iterator editPartIt = associatedParts.iterator(); editPartIt.hasNext();) {
			org.eclipse.gef.EditPart nextPart = (org.eclipse.gef.EditPart) editPartIt.next();
			org.eclipse.gef.EditPart parentPart = nextPart.getParent();
			while (parentPart != null && !associatedParts.contains(parentPart)) {
				parentPart = parentPart.getParent();
			}
			if (parentPart == null) {
				editPartCollector.add(nextPart);
			}
		}

		if (intialNumOfEditParts == editPartCollector.size()) {
			if (!associatedParts.isEmpty()) {
				editPartCollector.add(associatedParts.iterator().next());
			} else {
				if (element.eContainer() != null) {
					return findElementsInDiagramByID(diagramPart, element.eContainer(), editPartCollector);
				}
			}
		}
		return editPartCollector.size() - intialNumOfEditParts;
	}
«ENDDEFINE»

«DEFINE findViewMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment»
	public static org.eclipse.gmf.runtime.notation.View findView(org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramEditPart, org.eclipse.emf.ecore.EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
		boolean hasStructuralURI = false;						
		if(targetElement.eResource() instanceof org.eclipse.emf.ecore.xmi.XMLResource) {
			hasStructuralURI = ((org.eclipse.emf.ecore.xmi.XMLResource)targetElement.eResource()).getID(targetElement) == null;
		}
		
		org.eclipse.gmf.runtime.notation.View view = null;
		if(hasStructuralURI && !lazyElement2ViewMap.getElement2ViewMap().isEmpty()) {
			view = (org.eclipse.gmf.runtime.notation.View)lazyElement2ViewMap.getElement2ViewMap().get(targetElement);
		} else if (findElementsInDiagramByID(diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
			org.eclipse.gef.EditPart editPart = (org.eclipse.gef.EditPart) lazyElement2ViewMap.editPartTmpHolder.get(0);
			lazyElement2ViewMap.editPartTmpHolder.clear();
			view = editPart.getModel() instanceof org.eclipse.gmf.runtime.notation.View ? (org.eclipse.gmf.runtime.notation.View) editPart.getModel() : null;
		}
	
		return (view == null) ? diagramEditPart.getDiagramView() : view;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static class LazyElement2ViewMap {
		«EXPAND xpt::Common::generatedMemberComment»
		private java.util.Map element2ViewMap;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.gmf.runtime.notation.View scope;

		«EXPAND xpt::Common::generatedMemberComment»
		private java.util.Set elementSet;

		«EXPAND xpt::Common::generatedMemberComment»
		public final java.util.List editPartTmpHolder = new java.util.ArrayList();

		«EXPAND xpt::Common::generatedMemberComment»
		public LazyElement2ViewMap(org.eclipse.gmf.runtime.notation.View scope, java.util.Set elements) {
			this.scope = scope;
			this.elementSet = elements;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public final java.util.Map getElement2ViewMap() {
			if(element2ViewMap == null) {
				element2ViewMap = new java.util.HashMap();
				// map possible notation elements to itself as these can't be found by view.getElement()
				for (java.util.Iterator it = elementSet.iterator(); it.hasNext();) {
					org.eclipse.emf.ecore.EObject element = (org.eclipse.emf.ecore.EObject) it.next();
					if(element instanceof org.eclipse.gmf.runtime.notation.View) {
						org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) element;
						if(view.getDiagram() == scope.getDiagram()) {
							element2ViewMap.put(element, element); // take only those that part of our diagram
						}
					}
				}
				
				buildElement2ViewMap(scope, element2ViewMap, elementSet);					
			}
			return element2ViewMap;
		}
		«EXPAND xpt::Common::generatedMemberComment»
		static java.util.Map buildElement2ViewMap(org.eclipse.gmf.runtime.notation.View parentView, java.util.Map element2ViewMap, java.util.Set elements) {
			if(elements.size() == element2ViewMap.size()) return element2ViewMap;

			if(parentView.isSetElement() && !element2ViewMap.containsKey(parentView.getElement()) && elements.contains(parentView.getElement())) {
				element2ViewMap.put(parentView.getElement(), parentView);
				if(elements.size() == element2ViewMap.size()) return element2ViewMap;
			}
			
			for (java.util.Iterator it = parentView.getChildren().iterator(); it.hasNext();) {
				buildElement2ViewMap((org.eclipse.gmf.runtime.notation.View) it.next(), element2ViewMap, elements);			
				if(elements.size() == element2ViewMap.size()) return element2ViewMap;
			}
			for (java.util.Iterator it = parentView.getSourceEdges().iterator(); it.hasNext();) {
				buildElement2ViewMap((org.eclipse.gmf.runtime.notation.View) it.next(), element2ViewMap, elements);			
				if(elements.size() == element2ViewMap.size()) return element2ViewMap;
			}
			for (java.util.Iterator it = parentView.getSourceEdges().iterator(); it.hasNext();) {
				buildElement2ViewMap((org.eclipse.gmf.runtime.notation.View) it.next(), element2ViewMap, elements);			
				if(elements.size() == element2ViewMap.size()) return element2ViewMap;
			}	
			return element2ViewMap;
		}
	} //LazyElement2ViewMap	
«ENDDEFINE»

«DEFINE i18nAccessors FOR gmfgen::GenDiagram-»
«EXPAND xpt::Externalizer::accessorField(i18nKeyForOpenModelResourceErrorDialog().titleKey())-»
«EXPAND xpt::Externalizer::accessorField(i18nKeyForOpenModelResourceErrorDialog().messageKey())-»
«EXPAND xpt::Externalizer::accessorField(i18nKeyForCreateDiagramProgressTask())-»
«EXPAND xpt::Externalizer::accessorField(i18nKeyForCreateDiagramCommandLabel())-»
«ENDDEFINE»

«DEFINE i18nValues FOR gmfgen::GenDiagram-»
«EXPAND xpt::Externalizer::messageEntry(i18nKeyForOpenModelResourceErrorDialog().titleKey(), "Error")-»
«EXPAND xpt::Externalizer::messageEntry(i18nKeyForOpenModelResourceErrorDialog().messageKey(), "Failed to load model file {0}")-»
«EXPAND xpt::Externalizer::messageEntry(i18nKeyForCreateDiagramProgressTask(), "Creating diagram and model files")-»
«EXPAND xpt::Externalizer::messageEntry(i18nKeyForCreateDiagramCommandLabel(), "Creating diagram and model")-»
«ENDDEFINE»
@


1.25
log
@[250767] refactored to access DIAGRAM_PREFERENCES_HINT uniformly
@
text
@d211 1
a211 1
					diagram.setElement(«IF domainDiagramElement.isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»model);
d248 1
a248 1
		resource.getContents().add(«IF hasDocumentRoot()»createDocumentRoot(model)«ELSE»«IF domainDiagramElement.isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»model«ENDIF»);
@


1.24
log
@refactored templates moving towards [188329] - Support Java 5.0 (would need to respect generic types when adding into collections) while trying to accomplish [227127]
@
text
@d204 1
a204 1
				«IF domainDiagramElement.isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»model, 
d206 1
a206 1
					«EXPAND xpt::editor::VisualIDRegistry::modelID»,	«editorGen.plugin.getActivatorQualifiedClassName()».DIAGRAM_PREFERENCES_HINT);
@


1.23
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d259 1
a259 1
		«EXPAND MetaModel::setFeatureValue("docRoot", getDocumentRoot(), "model") FOR f»;«ENDIF»
@


1.22
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d12 1
a12 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.21
log
@[150177] phase I, refactor existing code: use same template for metainfo access
@
text
@d241 1
a241 1
		return «EXPAND xpt::Common::newInstance FOR domainDiagramElement»;
d256 1
a256 1
		«EXPAND xpt::Common::newInstance("docRoot") FOR getDocumentRoot()»
d259 1
a259 1
		«EXPAND xpt::Common::setFeatureValue("docRoot", getDocumentRoot(), "model") FOR f»;«ENDIF»
@


1.20
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d259 1
a259 1
		docRoot.set«f.getAccessorName()»(model);«ENDIF»
@


1.19
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d199 1
a199 1
				«domainDiagramElement.getQualifiedInterfaceName()» model = createInitialModel();
d240 1
a240 1
	private static «domainDiagramElement.getQualifiedInterfaceName()» createInitialModel() {
d247 1
a247 1
	private static void attachModelToResource(«domainDiagramElement.getQualifiedInterfaceName()» model, org.eclipse.emf.ecore.resource.Resource resource) {
d255 1
a255 1
	private static «getDocumentRoot().getQualifiedInterfaceName()» createDocumentRoot(«domainDiagramElement.getQualifiedInterfaceName()» model) {
@


1.18
log
@Replacing static method calls with templates.
@
text
@d12 1
a12 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.17
log
@F.Q. name used
@
text
@d206 1
a206 1
					«getEditPartQualifiedClassName()».MODEL_ID,	«editorGen.plugin.getActivatorQualifiedClassName()».DIAGRAM_PREFERENCES_HINT);
@


1.16
log
@copy of EdutUIUtil logic to open diagram to avoid lookup for default editor id - we do know which one we'd like to open from this editorUtil, and don't want to fail if there are few editors registered for the same extension
@
text
@d122 1
a122 1
		org.eclipse.core.resources.IResource workspaceResource = org.eclipse.core.resources.ResourcesPlugin.getWorkspace().getRoot().findMember(new Path(path));
@


1.15
log
@static fields considered harmful
ENCODING option is from XML, not XMIResource
No one recalls the need to record unknown features, nor is that information processed. Unless requested, let's avoid any extra save/load option not to confuse anybody.
@
text
@d121 7
a127 1
		return org.eclipse.emf.edit.ui.util.EditUIUtil.openEditor((org.eclipse.emf.ecore.EObject) diagram.getContents().get(0));
@


1.14
log
@account for pure-design models
@
text
@d109 5
a113 9
private static java.util.Map ourSaveOptions = null;

	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.Map getSaveOptions() {
	if (ourSaveOptions == null) {
		ourSaveOptions = new java.util.HashMap();
		ourSaveOptions.put(org.eclipse.emf.ecore.xmi.XMIResource.OPTION_ENCODING, "UTF-8"); «EXPAND xpt::Common::nonNLS»
		ourSaveOptions.put(org.eclipse.emf.ecore.xmi.XMLResource.OPTION_RECORD_UNKNOWN_FEATURE, Boolean.TRUE);
		ourSaveOptions.put(org.eclipse.emf.ecore.resource.Resource.OPTION_SAVE_ONLY_IF_CHANGED, org.eclipse.emf.ecore.resource.Resource.OPTION_SAVE_ONLY_IF_CHANGED_MEMORY_BUFFER);
a114 2
	return ourSaveOptions;
}
@


1.13
log
@With EMF's 171996 fix, we should set extendedMetaData to true when serializing xsd-based model into same file as diagram.
For standalone xsd-based models, this option should be set by generated ResourceFactoryImpl.
I assume this option set is correct fix for 171060
@
text
@d191 1
a191 1
«ELSEIF hasDocumentRoot() /*for standalone models, we assume its resourcefactory would be able to set extendedMetaData option*/-»
@


1.12
log
@Using standard utility methods.
@
text
@d191 3
@


1.11
log
@[139733] akarjakina - i18n support
@
text
@d228 2
a229 2
		«IF standaloneDomainModel()»setCharset(modelURI);«ENDIF»
		setCharset(diagramURI);
@


1.10
log
@Using standard utility methods.
@
text
@d17 1
d61 6
a66 2
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to load resource: " + uri, we);
			org.eclipse.jface.dialogs.MessageDialog.openError(shell, "Error", "Failed to load model file " + fileName);
d187 1
a187 1
		progressMonitor.beginTask("Creating diagram and model files", 3);
d193 1
a193 1
		org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand command = new org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand(editingDomain, "Creating diagram and model", java.util.Collections.EMPTY_LIST) { «EXPAND xpt::Common::nonNLS»
d228 2
a229 2
		«IF standaloneDomainModel()»setCharset(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(modelResource));«ENDIF»
		setCharset(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(diagramResource));
d406 15
a420 1
«ENDDEFINE»@


1.9
log
@[178992] Model root should be casted to EObject if it has ext interface
@
text
@a30 2
	
	«EXPAND getFileMethod-»
a132 5
	private static void setCharset(org.eclipse.emf.common.util.URI uri) {
		setCharset(getFile(uri));
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
a144 15
// XXX private visibility? seems only setCharset is using this method
«DEFINE getFileMethod FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static org.eclipse.core.resources.IFile getFile(org.eclipse.emf.common.util.URI uri) {
		if (uri.toString().startsWith("platform:/resource")) { «EXPAND xpt::Common::nonNLS»
			String path = uri.toString().substring("platform:/resource".length()); «EXPAND xpt::Common::nonNLS»
			org.eclipse.core.resources.IResource workspaceResource = org.eclipse.core.resources.ResourcesPlugin.getWorkspace().getRoot().findMember(new org.eclipse.core.runtime.Path(path));
			if (workspaceResource instanceof org.eclipse.core.resources.IFile) {
				return (org.eclipse.core.resources.IFile) workspaceResource;
			}
		}
		return null;
	}
«ENDDEFINE»

d223 2
a224 2
		«IF standaloneDomainModel()»setCharset(modelURI);«ENDIF»
		setCharset(diagramURI);
@


1.8
log
@[179970] - Adopt code generater to make use of EMF "conditional resource saving"
@
text
@d262 1
a262 1
		resource.getContents().add(«IF hasDocumentRoot()»createDocumentRoot(model)«ELSE»model«ENDIF»);
@


1.7
log
@User should be able to configure whether NON-NLS markers are shown or not
@
text
@a23 1
«EXPAND openDiagramMethod»
d25 9
a33 4
«IF editorGen.application == null»
	«EXPAND setCharsetMethod»
	«EXPAND getFileMethod»
«ENDIF»
d35 1
a35 1
«EXPAND getUniqueFileNameMethod»
d87 1
a87 1
«EXPAND createDiagramMethod»
d104 16
d133 1
a133 2
// XXX private visibility?
«DEFINE setCharsetMethod FOR gmfgen::GenDiagram»
d136 5
a140 1
		org.eclipse.core.resources.IFile file = getFile(uri);
d149 1
a149 1
	}
d153 1
a153 1
«DEFINE getFileMethod FOR gmfgen::GenDiagram»
d155 1
a155 1
	public static org.eclipse.core.resources.IFile getFile(org.eclipse.emf.common.util.URI uri) {
d167 1
a167 1
«DEFINE getUniqueFileNameMethod FOR gmfgen::GenDiagram»
d200 1
a200 1
«DEFINE createDiagramMethod FOR gmfgen::GenDiagram»
d230 2
a231 4
					java.util.Map options = new java.util.HashMap();
					options.put(org.eclipse.emf.ecore.xmi.XMIResource.OPTION_ENCODING, "UTF-8"); «EXPAND xpt::Common::nonNLS»
					«IF standaloneDomainModel()»modelResource.save(options);«ENDIF»
					diagramResource.save(options);
@


1.6
log
@[168660] Support shortcuts in RCP applications
@
text
@d122 1
a122 1
			file.setCharset("UTF-8", new org.eclipse.core.runtime.NullProgressMonitor()); //$NON-NLS-1$
d124 1
a124 1
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to set charset for file " + file.getFullPath(), e); //$NON-NLS-1$
d133 2
a134 2
		if (uri.toString().startsWith("platform:/resource")) { //$NON-NLS-1$
			String path = uri.toString().substring("platform:/resource".length()); //$NON-NLS-1$
d148 1
a148 1
			containerFullPath = new org.eclipse.core.runtime.Path(""); //$NON-NLS-1$
d151 1
a151 1
			fileName = "default"; //$NON-NLS-1$
d187 1
a187 1
		org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand command = new org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand(editingDomain, "Creating diagram and model", java.util.Collections.EMPTY_LIST) { //$NON-NLS-1$
d208 1
a208 1
					options.put(org.eclipse.emf.ecore.xmi.XMIResource.OPTION_ENCODING, "UTF-8"); //$NON-NLS-1$
d213 1
a213 1
					«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to store model and diagram resources", e); //$NON-NLS-1$
d221 1
a221 1
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to create model and diagram", e); //$NON-NLS-1$
@


1.5
log
@refactor 'exists' method
@
text
@d33 50
@


1.4
log
@[168661] Use URIs instead of IResources to make code reusable in RCP
@
text
@a30 2
«EXPAND existsMethod»

a93 7
«DEFINE existsMethod FOR gmfgen::GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment»
	public static boolean exists(org.eclipse.core.runtime.IPath path) {
		«IF editorGen.application == null»return org.eclipse.core.resources.ResourcesPlugin.getWorkspace().getRoot().exists(path);«ELSE»return path.toFile().exists();«ENDIF»
	}
«ENDDEFINE»

d110 7
a116 1
		while (exists(filePath)) {
@


1.3
log
@Copyrights added.
@
text
@d33 2
a95 1
// XXX Who's using this one?
d103 27
@


1.2
log
@share new instance (factory.eInstance.create) creation code
@
text
@d19 1
@


1.1
log
@DiagramEditorUtil with xpand
@
text
@d158 1
a158 1
		return «EXPAND newInstance FOR domainDiagramElement»;
d173 1
a173 1
		«EXPAND newInstance("docRoot") FOR getDocumentRoot()»
d326 1
a326 7
«ENDDEFINE»

«DEFINE newInstance FOR genmodel::GenClass-»
«genPackage.getQualifiedFactoryInterfaceName()».«genPackage.getFactoryInstanceName()».create«ecoreClass.name»()«ENDDEFINE»

«DEFINE newInstance(String varName) FOR genmodel::GenClass-»
«getQualifiedInterfaceName()» «varName» = «EXPAND newInstance»;«ENDDEFINE»@

