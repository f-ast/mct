head	1.2;
access;
symbols
	v20081022-1925:1.2
	v20081015-1925:1.2
	v20081008-1925:1.2
	v20081001-1925:1.2
	v20080924-1925:1.2
	v20080917-1925:1.2
	v20080911-1728:1.2
	v20080910-1520:1.2
	v20080903-1520:1.2
	v20080827-1520:1.2
	v20080813-1520:1.2
	v20080806-1520:1.2
	v20070427-0600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.2
date	2007.05.03.09.58.55;	author dstadnik;	state dead;
branches;
next	1.1;
commitid	518a4639b24f4567;

1.1
date	2007.04.27.08.33.37;	author dstadnik;	state Exp;
branches;
next	;
commitid	15c64631b5604567;


desc
@@


1.2
log
@refactor message format parser; introduce editor pattern
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«DEFINE AbstractParser FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public abstract class «abstractParserClassName» implements org.eclipse.gmf.runtime.common.ui.services.parser.IParser {

	«EXPAND xpt::Common::generatedMemberComment»
	private String viewPattern;

	«EXPAND xpt::Common::generatedMemberComment»
	private java.text.MessageFormat viewProcessor;

	«EXPAND xpt::Common::generatedMemberComment»
	private String editPattern;

	«EXPAND xpt::Common::generatedMemberComment»
	private java.text.MessageFormat editProcessor;

	«EXPAND xpt::Common::generatedMemberComment»
	public String getViewPattern() {
		return viewPattern;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected java.text.MessageFormat getViewProcessor() {
		return viewProcessor;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public void setViewPattern(String viewPattern) {
		this.viewPattern = viewPattern;
		viewProcessor = createViewProcessor(viewPattern);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected java.text.MessageFormat createViewProcessor(String viewPattern) {
		return new java.text.MessageFormat(viewPattern);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public String getEditPattern() {
		return editPattern;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected java.text.MessageFormat getEditProcessor() {
		return editProcessor;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public void setEditPattern(String editPattern) {
		this.editPattern = editPattern;
		editProcessor = createEditProcessor(editPattern);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected java.text.MessageFormat createEditProcessor(String editPattern) {
		return new java.text.MessageFormat(editPattern);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public String getPrintString(org.eclipse.core.runtime.IAdaptable adapter, int flags) {
		return getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public String getEditString(org.eclipse.core.runtime.IAdaptable adapter, int flags) {
		return getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected abstract String getStringByPattern(org.eclipse.core.runtime.IAdaptable adapter,
			int flags, String pattern, java.text.MessageFormat processor);

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus isValidEditString(
			org.eclipse.core.runtime.IAdaptable element, String editString) {
		java.text.ParsePosition pos = new java.text.ParsePosition(0);
		Object[] values = getEditProcessor().parse(editString, pos);
		if (values == null) {
			return new org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus(
					«editorGen.plugin.getActivatorQualifiedClassName()».ID,
					org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus.UNEDITABLE,
					"Invalid input at " + pos.getErrorIndex());
		}
		return validateNewValues(values);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus validateNewValues(Object[] values) {
		return org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus.EDITABLE_STATUS;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.gmf.runtime.common.core.command.ICommand getParseCommand(
			org.eclipse.core.runtime.IAdaptable adapter, String newString, int flags) {
		Object[] values = getEditProcessor().parse(newString, new java.text.ParsePosition(0));
		if (values == null || validateNewValues(values).getCode() !=
				org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus.EDITABLE) {
			return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
		}
		return getParseCommand(adapter, values);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected abstract org.eclipse.gmf.runtime.common.core.command.ICommand getParseCommand(
			org.eclipse.core.runtime.IAdaptable adapter, Object[] values);

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.jface.text.contentassist.IContentAssistProcessor getCompletionProcessor(
			org.eclipse.core.runtime.IAdaptable element) {
		return null;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.gmf.runtime.common.core.command.ICommand getModificationCommand(
			org.eclipse.emf.ecore.EObject element, org.eclipse.emf.ecore.EStructuralFeature feature, Object value) {
		value = getValidNewValue(feature, value);
		if (value instanceof InvalidValue) {
			return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
		}
		org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest request =
				new org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest(element, feature, value);
		return new org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand(request);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected Object getValidValue(org.eclipse.emf.ecore.EStructuralFeature feature, Object value) {
		org.eclipse.emf.ecore.EClassifier type = feature.getEType();
		if (type instanceof org.eclipse.emf.ecore.EDataType) {
			Class iClass = type.getInstanceClass();
			if (String.class.equals(iClass)) {
				if (value == null) {
					value = ""; //$NON-NLS-1$
				}
			}
		}
		return value;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected Object getValidNewValue(org.eclipse.emf.ecore.EStructuralFeature feature, Object value) {
		org.eclipse.emf.ecore.EClassifier type = feature.getEType();
		if (type instanceof org.eclipse.emf.ecore.EDataType) {
			Class iClass = type.getInstanceClass();
			if (Boolean.TYPE.equals(iClass)) {
				if (value instanceof Boolean) {
					// ok
				} else if (value instanceof String) {
					value = Boolean.valueOf((String) value);
				} else {
					value = new InvalidValue("Value of type Boolean is expected");
				}
			} else if (Character.TYPE.equals(iClass)) {
				if (value instanceof Character) {
					// ok
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						value = new Character(s.charAt(0));
					}
				} else {
					value = new InvalidValue("Value of type Character is expected");
				}
			} else if (Byte.TYPE.equals(iClass)) {
				if (value instanceof Byte) {
					// ok
				} else if (value instanceof Number) {
					value = new Byte(((Number) value).byteValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Byte.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Byte value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Byte is expected");
				}
			} else if (Short.TYPE.equals(iClass)) {
				if (value instanceof Short) {
					// ok
				} else if (value instanceof Number) {
					value = new Short(((Number) value).shortValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Short.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Short value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Short is expected");
				}
			} else if (Integer.TYPE.equals(iClass)) {
				if (value instanceof Integer) {
					// ok
				} else if (value instanceof Number) {
					value = new Integer(((Number) value).intValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Integer.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Integer value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Integer is expected");
				}
			} else if (Long.TYPE.equals(iClass)) {
				if (value instanceof Long) {
					// ok
				} else if (value instanceof Number) {
					value = new Long(((Number) value).longValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Long.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Long value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Long is expected");
				}
			} else if (Float.TYPE.equals(iClass)) {
				if (value instanceof Float) {
					// ok
				} else if (value instanceof Number) {
					value = new Float(((Number) value).floatValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Float.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Float value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Float is expected");
				}
			} else if (Double.TYPE.equals(iClass)) {
				if (value instanceof Double) {
					// ok
				} else if (value instanceof Number) {
					value = new Double(((Number) value).doubleValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Double.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Double value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Double is expected");
				}
			} else if (type instanceof org.eclipse.emf.ecore.EEnum) {
				if (value instanceof String) {
					org.eclipse.emf.ecore.EEnumLiteral literal =
							((org.eclipse.emf.ecore.EEnum) type).getEEnumLiteralByLiteral((String) value);
					if (literal == null) {
						value = new InvalidValue("Unknown literal: " + value);
					} else {
						value = literal.getInstance();
					}
				} else {
					value = new InvalidValue("Value of type String is expected");
				}
			}
		}
		return value;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected class InvalidValue {

		«EXPAND xpt::Common::generatedMemberComment»
		private String description;

		«EXPAND xpt::Common::generatedMemberComment»
		public InvalidValue(String description) {
			this.description = description;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public String toString() {
			return description;
		}
	}
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram-»«ENDDEFINE»
@


1.1
log
@rewrite AbstractParser in xpand
@
text
@@

