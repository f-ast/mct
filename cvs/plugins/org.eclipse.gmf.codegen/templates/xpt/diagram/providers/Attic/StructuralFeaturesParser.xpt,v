head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081015-1925:1.3
	v20081008-1925:1.3
	v20081001-1925:1.3
	v20080924-1925:1.3
	v20080917-1925:1.3
	v20080911-1728:1.3
	v20080910-1520:1.3
	v20080903-1520:1.3
	v20080827-1520:1.3
	v20080813-1520:1.3
	v20080806-1520:1.3
	v20070427-0600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.3
date	2007.05.03.09.58.54;	author dstadnik;	state dead;
branches;
next	1.2;
commitid	518a4639b24f4567;

1.2
date	2007.04.27.12.10.25;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	66d04631e8314567;

1.1
date	2007.04.27.09.26.27;	author dstadnik;	state Exp;
branches;
next	;
commitid	4a7d4631c1c24567;


desc
@@


1.3
log
@refactor message format parser; introduce editor pattern
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«DEFINE StructuralFeaturesParser FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «structuralFeaturesParserClassName» extends «getAbstractParserQualifiedClassName()» {

	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.emf.ecore.EStructuralFeature[] features;

	«EXPAND xpt::Common::generatedMemberComment»
	public «structuralFeaturesParserClassName»(org.eclipse.emf.ecore.EStructuralFeature[] features) {
		this.features = features;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected String getStringByPattern(
			org.eclipse.core.runtime.IAdaptable adapter, int flags, String pattern, java.text.MessageFormat processor) {
		org.eclipse.emf.ecore.EObject element =
				(org.eclipse.emf.ecore.EObject) adapter.getAdapter(org.eclipse.emf.ecore.EObject.class);
		Object[] values = new Object[features.length];
		for (int i = 0; i < features.length; i++) {
			org.eclipse.emf.ecore.EStructuralFeature feature = features[i];
			Object value = element.eGet(feature);
			value = getValidValue(feature, value);
			values[i] = value;
		}
		return processor.format(values, new StringBuffer(), new java.text.FieldPosition(0)).toString();
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus validateNewValues(Object[] values) {
		if (values.length != features.length) {
			return org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus.UNEDITABLE_STATUS;
		}
		for (int i = 0; i < values.length; i++) {
			Object value = getValidNewValue(features[i], values[i]);
			if (value instanceof InvalidValue) {
				return new org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus(
						«editorGen.plugin.getActivatorQualifiedClassName()».ID,
						org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus.UNEDITABLE,
						value.toString());
			}
		}
		return org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus.EDITABLE_STATUS;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.gmf.runtime.common.core.command.ICommand getParseCommand(
			org.eclipse.core.runtime.IAdaptable adapter, Object[] values) {
		org.eclipse.emf.ecore.EObject element =
				(org.eclipse.emf.ecore.EObject) adapter.getAdapter(org.eclipse.emf.ecore.EObject.class);
		if (element == null) {
			return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
		}
		org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain =
				org.eclipse.emf.transaction.util.TransactionUtil.getEditingDomain(element);
		if (editingDomain == null) {
			return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
		}
		org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand command =
				new org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand(
						editingDomain, "Set Values"); //$NON-NLS-1$
		for (int i = 0; i < values.length; i++) {
			command.compose(getModificationCommand(element, features[i], values[i]));
		}
		return command;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public boolean isAffectingEvent(Object event, int flags) {
		if (event instanceof org.eclipse.emf.common.notify.Notification) {
			Object feature = ((org.eclipse.emf.common.notify.Notification) event).getFeature();
			for (int i = 0; i < features.length; i++) {
				if (features[i] == feature) {
					return true;
				}
			}
		}
		return false;
	}
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram-»«ENDDEFINE»
@


1.2
log
@use arrays instead of collections
@
text
@@


1.1
log
@rewrite StructuralFeaturesParser in xpand
@
text
@d25 1
a25 1
	private java.util.List features;
d28 1
a28 1
	public «structuralFeaturesParserClassName»(java.util.List features) {
d37 3
a39 3
		java.util.List values = new java.util.ArrayList(features.size());
		for (java.util.Iterator it = features.iterator(); it.hasNext();) {
			org.eclipse.emf.ecore.EStructuralFeature feature = (org.eclipse.emf.ecore.EStructuralFeature) it.next();
d42 1
a42 1
			values.add(value);
d44 1
a44 2
		return processor.format(values.toArray(new Object[values.size()]),
				new StringBuffer(), new java.text.FieldPosition(0)).toString();
d49 1
a49 1
		if (values.length != features.size()) {
d53 1
a53 1
			Object value = getValidNewValue((org.eclipse.emf.ecore.EStructuralFeature) features.get(i), values[i]);
d81 1
a81 3
			org.eclipse.emf.ecore.EStructuralFeature feature =
					(org.eclipse.emf.ecore.EStructuralFeature) features.get(i);
			command.compose(getModificationCommand(element, feature, values[i]));
d90 4
a93 2
			if (features.contains(feature)) {
				return true;
@

