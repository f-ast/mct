head	1.34;
access;
symbols
	v20081022-1925:1.34
	v20081015-1925:1.34
	v20081008-1925:1.34
	v20081001-1925:1.34
	v20080930-1130:1.34
	v20080926-1245:1.34
	v20080924-1925:1.34
	v20080917-1925:1.34
	v20080911-1728:1.34
	v20080910-1520:1.34
	v20080903-1520:1.34
	v20080827-1520:1.34
	v20080813-1520:1.33
	v20080806-1520:1.33
	v20080722-1827:1.33
	v20080718-1731:1.33
	v20080716-1600:1.31
	v20080716-1642:1.33
	R2_1_maintenance:1.31.0.2
	Root_R2_1_maintenance:1.31
	R2_1_0:1.31
	v20080610-1132:1.31
	v20080603-1553:1.31
	v20080528-1052:1.31
	v20080521:1.31
	v20080516-1543:1.31
	v20080516-1143:1.31
	v20080512-1200:1.31
	v20080508-2000:1.31
	v20080507-1326:1.31
	v20080503-1740:1.30
	v20080501-1739:1.30
	v20080425-1959:1.30
	v20080417-1610:1.30
	v20080411-0411:1.30
	v20080404-1111:1.30
	v20080322-0000:1.30
	v20080222-1200:1.22
	v20080215-1500:1.22
	v20080207-0207:1.21.2.1
	v20071222-1111:1.22
	v20071214-1111:1.22
	v20071130-1111:1.22
	v20071124-0000:1.21.2.1
	v20071112-0000:1.22
	v20071108-0000:1.22
	v20071003-0000:1.21
	v20070928-0000:1.21
	v20070921-0000:1.21
	v20070915-0000:1.21
	v20070903-0000:1.21
	v20070809-0000:1.21
	R2_0_maintenance:1.21.0.2
	R2_0:1.21
	R4_20:1.21
	v20070621-0000:1.21
	RC3_20:1.21
	v20070614-1400:1.21
	v20070608-1300:1.21
	v20070605-1400:1.21
	v20070601-1400:1.21
	v20070525-1500:1.18
	v20070520-1200:1.17
	v20070518-1300:1.16
	v20070504-1000:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.34
date	2008.08.22.15.20.16;	author atikhomirov;	state Exp;
branches;
next	1.33;
commitid	1abb48aed9234567;

1.33
date	2008.07.16.14.15.30;	author ashatalin;	state Exp;
branches;
next	1.32;
commitid	26a9487e02814567;

1.32
date	2008.06.30.19.46.29;	author atikhomirov;	state Exp;
branches;
next	1.31;
commitid	763c486938144567;

1.31
date	2008.05.07.13.56.02;	author atikhomirov;	state Exp;
branches;
next	1.30;
commitid	39124821b4de4567;

1.30
date	2008.02.28.19.04.37;	author atikhomirov;	state Exp;
branches;
next	1.29;
commitid	cd347c705c44567;

1.29
date	2008.02.28.16.37.15;	author atikhomirov;	state Exp;
branches;
next	1.28;
commitid	2cc347c6e33a4567;

1.28
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.27;
commitid	19d047c419ed4567;

1.27
date	2008.02.22.20.24.44;	author atikhomirov;	state Exp;
branches;
next	1.26;
commitid	377d47bf2f8a4567;

1.26
date	2008.02.22.11.56.45;	author atikhomirov;	state Exp;
branches;
next	1.25;
commitid	6cf447beb87c4567;

1.25
date	2008.02.21.21.28.45;	author atikhomirov;	state Exp;
branches;
next	1.24;
commitid	68147bded0c4567;

1.24
date	2008.02.21.20.18.09;	author atikhomirov;	state Exp;
branches;
next	1.23;
commitid	468b47bddc804567;

1.23
date	2008.02.21.18.35.58;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	6b4047bdc48d4567;

1.22
date	2007.10.26.12.32.27;	author ashatalin;	state Exp;
branches;
next	1.21;
commitid	7ac44721de5b4567;

1.21
date	2007.05.30.15.58.40;	author ashatalin;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	7535465d9f304567;

1.20
date	2007.05.30.14.46.35;	author ashatalin;	state Exp;
branches;
next	1.19;
commitid	5353465d8e4b4567;

1.19
date	2007.05.28.16.52.23;	author ashatalin;	state Exp;
branches;
next	1.18;
commitid	51cb465b08c54567;

1.18
date	2007.05.24.10.53.39;	author ashatalin;	state Exp;
branches;
next	1.17;
commitid	81e46556eb34567;

1.17
date	2007.05.18.21.17.20;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	2591464e17d14567;

1.16
date	2007.05.17.17.36.25;	author ashatalin;	state Exp;
branches;
next	1.15;
commitid	48df464c92984567;

1.15
date	2007.05.16.18.37.51;	author ashatalin;	state Exp;
branches;
next	1.14;
commitid	23e9464b4f7f4567;

1.14
date	2007.05.15.19.19.22;	author ashatalin;	state Exp;
branches;
next	1.13;
commitid	43d3464a07b84567;

1.13
date	2007.05.15.18.17.00;	author ashatalin;	state Exp;
branches;
next	1.12;
commitid	149d4649f91b4567;

1.12
date	2007.05.11.16.01.30;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	44f84644934f4567;

1.11
date	2007.05.11.13.50.54;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	6340464474b24567;

1.10
date	2007.05.10.12.53.11;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	1cd8464315b74567;

1.9
date	2007.05.09.16.33.06;	author ashatalin;	state Exp;
branches;
next	1.8;
commitid	14eb4641f7c14567;

1.8
date	2007.05.09.16.19.09;	author ashatalin;	state Exp;
branches;
next	1.7;
commitid	714a4641f47d4567;

1.7
date	2007.05.08.13.54.38;	author ashatalin;	state Exp;
branches;
next	1.6;
commitid	49274640811e4567;

1.6
date	2007.05.08.12.29.05;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	152646406d114567;

1.5
date	2007.05.07.11.49.24;	author ashatalin;	state Exp;
branches;
next	1.4;
commitid	73ec463f12444567;

1.4
date	2007.05.04.15.27.49;	author ashatalin;	state Exp;
branches;
next	1.3;
commitid	6ef6463b50ec4567;

1.3
date	2007.05.03.20.42.14;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	7f0b463a49254567;

1.2
date	2007.05.01.17.56.31;	author ashatalin;	state Exp;
branches;
next	1.1;
commitid	58c746377f464567;

1.1
date	2007.05.01.13.28.04;	author ashatalin;	state Exp;
branches;
next	;
commitid	143a463740554567;

1.21.2.1
date	2007.10.26.12.30.01;	author ashatalin;	state Exp;
branches;
next	;
commitid	75fa4721ddc84567;


desc
@@


1.34
log
@[243151] mgolubev - explicit source/target for links
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 *    Michael Golubev (Borland) - [243151] explicit source/target for links
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«EXTENSION xpt::diagram::updater::Utils»
«EXTENSION xpt::diagram::editpolicies::LinkUtils»
«EXTENSION xpt::GenModelUtils»

«DEFINE DiagramUpdater FOR gmfgen::GenDiagramUpdater-»
	«EXPAND xpt::Common::copyright FOR editorGen-»
package «editorGen.editor.packageName»;

	«EXPAND xpt::Common::generatedClassComment»
public class «diagramUpdaterClassName» {
	«EXPAND isShortcutOrphaned-»
«LET editorGen.diagram.getAllContainers().select(container | hasSemanticChildren(container)) AS semanticContainers-»

	«EXPAND getGenericSemanticChildrenOfView(semanticContainers)-»
	«EXPAND getSemanticChildrenOfView FOREACH semanticContainers-»
	«EXPAND getPhantomNodesIterator-»
«ENDLET-»

	«EXPAND getGenericConnectedLinks(getAllSemanticElements(editorGen.diagram), getContainedLinksMethodNameSuffix())-»
	
	«EXPAND getGenericConnectedLinks(getAllSemanticDiagramElements(editorGen.diagram), getIncomingLinksMethodNameSuffix())-»
	
	«EXPAND getGenericConnectedLinks(getAllSemanticDiagramElements(editorGen.diagram), getOutgoingLinksMethodNameSuffix())-»
	«EXPAND getContainedLinks FOREACH getAllSemanticElements(editorGen.diagram)-»
	«EXPAND getIncomingLinks FOREACH getAllSemanticDiagramElements(editorGen.diagram)-»
	«EXPAND getOutgoingLinks FOREACH getAllSemanticDiagramElements(editorGen.diagram)-»
	«EXPAND getContainedLinksByTypeMethod FOREACH getAllContainedLinks(editorGen.diagram)-»
	«EXPAND getIncomingLinksByTypeMethod FOREACH getAllIncomingLinks(editorGen.diagram)-»
	«EXPAND getOutgoingLinksByTypeMethod FOREACH getAllOutgoingLinks(editorGen.diagram)-»

	«EXPAND additions-»
}
«ENDDEFINE»

«REM»
	Currently shortcuts are supported only for domain-based diagram element.
	This means, view.isSetElement() == true.
«ENDREM»
«DEFINE isShortcutOrphaned FOR gmfgen::GenDiagramUpdater-»
	«IF !editorGen.diagram.containsShortcutsTo.isEmpty()-»

	«EXPAND xpt::Common::generatedMemberComment»
public static boolean isShortcutOrphaned(org.eclipse.gmf.runtime.notation.View view) {
	return !view.isSetElement() || view.getElement() == null || view.getElement().eIsProxy();
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE getGenericSemanticChildrenOfView(List[gmfgen::GenContainerBase] semanticContainers) FOR gmfgen::GenDiagramUpdater-»
	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List getSemanticChildren(org.eclipse.gmf.runtime.notation.View view) {
	«IF !semanticContainers.isEmpty()-»
	switch («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»(view)) {
		«EXPAND getSemanticChildrenCase FOREACH semanticContainers-»
	}
	«ENDIF-»
	return java.util.Collections.EMPTY_LIST;
}
«ENDDEFINE»

«DEFINE getSemanticChildrenCase FOR gmfgen::GenContainerBase-»
«EXPAND xpt::Common::caseVisualID»
	return «EXPAND getSemanticChildrenMethodName»(view);
«ENDDEFINE»

«DEFINE getSemanticChildrenOfView FOR gmfgen::GenContainerBase-»

	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List «EXPAND getSemanticChildrenMethodName»(org.eclipse.gmf.runtime.notation.View view) {
	«IF getSemanticChildrenChildFeatures(this).size() > 0 || getPhantomNodes(this).size() > 0-»
	«EXPAND defineModelElement-»
	java.util.List result = new java.util.LinkedList();
«REM»childMetaFeature can be null here!«ENDREM»«-»
		«FOREACH getSemanticChildrenChildFeatures(this) AS childMetaFeature-»
			«IF null == childMetaFeature-»
	{ /*FIXME no containment/child feature found in the genmodel, toolsmith need to specify Class here manually*/ childElement = /*FIXME no containment/child feature found in the genmodel, toolsmith need to specify correct one here manually*/;
			«ELSEIF isListType(childMetaFeature)-»
	for (java.util.Iterator it = «EXPAND MetaModel::getFeatureValue("modelElement", getModelElementType()) FOR childMetaFeature».iterator(); it.hasNext();) {
		«EXPAND MetaModel::DeclareAndAssign("childElement", "it.next()", true) FOR getTypeGenClassX(childMetaFeature)»
			«ELSE-»
	{ «EXPAND MetaModel::DeclareAndAssign("childElement", "modelElement", getModelElementType(), childMetaFeature) FOR getTypeGenClassX(childMetaFeature)»
			«ENDIF-»
		int visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, «EXPAND MetaModel::DowncastToEObject("childElement") FOR getTypeGenClassX(childMetaFeature)»);
			«EXPAND checkChildElementVisualID(null != childMetaFeature && isListType(childMetaFeature)) FOREACH getSemanticChildren(this, childMetaFeature)-»
	}
		«ENDFOREACH-»
		«IF !getPhantomNodes(this).isEmpty()-»
	org.eclipse.emf.ecore.resource.Resource resource = modelElement.eResource();
	for (java.util.Iterator semanticIterator = getPhantomNodesIterator(resource); semanticIterator.hasNext();) {
		org.eclipse.emf.ecore.EObject childElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
		if (childElement == modelElement) {
			continue;
		}
			«EXPAND addNextIfPhantom FOREACH getPhantomNodes(this)-»
	}
		«ENDIF-»		
	return result;
	«ELSE-»
	return java.util.Collections.EMPTY_LIST;
	«ENDIF-»
}
«ENDDEFINE»

«DEFINE defineModelElement FOR gmfgen::GenContainerBase-»
if (!view.isSetElement()) {
	return java.util.Collections.EMPTY_LIST;
}
«EXPAND MetaModel::DeclareAndAssign("modelElement", "view.getElement()") FOR getModelElementType()»
«ENDDEFINE»

«DEFINE defineModelElement FOR gmfgen::GenCompartment-»
if (false == view.eContainer() instanceof org.eclipse.gmf.runtime.notation.View) {
	return java.util.Collections.EMPTY_LIST;
}
org.eclipse.gmf.runtime.notation.View containerView = (org.eclipse.gmf.runtime.notation.View) view.eContainer();
if (!containerView.isSetElement()) {
	return java.util.Collections.EMPTY_LIST;
}
«EXPAND MetaModel::DeclareAndAssign("modelElement", "containerView.getElement()") FOR getModelElementType()»
«ENDDEFINE»

«DEFINE getSemanticChildrenMethodName FOR gmfgen::GenContainerBase»get«getUniqueIdentifier()»SemanticChildren«ENDDEFINE»

«DEFINE getSemanticChildrenMethodCall FOR gmfgen::GenContainerBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND getSemanticChildrenMethodName»«ENDDEFINE»

«DEFINE checkChildElementVisualID(boolean inLoop) FOR gmfgen::GenNode-»
if (visualID == «EXPAND xpt::editor::VisualIDRegistry::visualID») {
	result.add(new «getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(«IF null != modelFacet.childMetaFeature»«EXPAND MetaModel::DowncastToEObject("childElement") FOR getTypeGenClassX(modelFacet.childMetaFeature)»«ENDIF», visualID));
«IF inLoop-»
	continue;
«ENDIF-»
}
«ENDDEFINE»

«DEFINE addNextIfPhantom FOR gmfgen::GenNode-»
if («EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, childElement) == «EXPAND xpt::editor::VisualIDRegistry::visualID») {
	result.add(new «getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(childElement, «EXPAND xpt::editor::VisualIDRegistry::visualID»));
	continue;
}
«ENDDEFINE»


«DEFINE getPhantomNodesIterator FOR gmfgen::GenDiagramUpdater-»
	«IF !getPhantomNodes(editorGen.diagram).isEmpty()-»
	
	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Iterator getPhantomNodesIterator(org.eclipse.emf.ecore.resource.Resource resource) {
	return resource.getAllContents();
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE getGenericConnectedLinks(List[gmfgen::GenCommonBase] linkContainers, String methodNameSuffix) FOR gmfgen::GenDiagramUpdater-»
	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List get«methodNameSuffix»Links(org.eclipse.gmf.runtime.notation.View view) {
	«IF !linkContainers.isEmpty()-»
	switch («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»(view)) {
		«EXPAND getContainedLinksCase(methodNameSuffix) FOREACH linkContainers-»
	}
	«ENDIF-»
	return java.util.Collections.EMPTY_LIST;
}
«ENDDEFINE»

«DEFINE getContainedLinksCase(String methodNameSuffix) FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::caseVisualID»
	return «EXPAND linkGetterName(methodNameSuffix)»(view);
«ENDDEFINE»

«REM»This DEFING can be used from other templates to inject call to the corresponding method«ENDREM»
«DEFINE getContainedLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getContainedLinksMethodNameSuffix())»«ENDDEFINE»

«REM»This DEFING can be used from other templates to inject call to the corresponding method«ENDREM»
«DEFINE getIncomingLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getIncomingLinksMethodNameSuffix())»«ENDDEFINE»

«REM»This DEFING can be used from other templates to inject call to the corresponding method«ENDREM»
«DEFINE getOutgoingLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getOutgoingLinksMethodNameSuffix())»«ENDDEFINE»

«DEFINE linkGetterName(String suffix) FOR gmfgen::GenCommonBase»get«getUniqueIdentifier()»«suffix»Links«ENDDEFINE»

«DEFINE getContainedLinks FOR gmfgen::GenCommonBase-»
	«EXPAND getConnectedLinks(getContainedLinks(getMetaClass(this), getDiagram()), getContainedLinksMethodNameSuffix(), false)-»
«ENDDEFINE»

«DEFINE getIncomingLinks FOR gmfgen::GenLinkEnd-»
	«EXPAND getConnectedLinks(getIncomingLinks(this), getIncomingLinksMethodNameSuffix(), true)-»
«ENDDEFINE»

«DEFINE getOutgoingLinks FOR gmfgen::GenLinkEnd-»
	«EXPAND getConnectedLinks(getOutgoingLinks(this), getOutgoingLinksMethodNameSuffix(), false)-»
«ENDDEFINE»

«DEFINE getConnectedLinks(List[gmfgen::GenLink] genLinks, String methodNameSuffix, boolean needCrossReferencer) FOR gmfgen::GenCommonBase-»

	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List «EXPAND linkGetterName(methodNameSuffix)»(org.eclipse.gmf.runtime.notation.View view) {
	«IF !genLinks.isEmpty()-»
		«LET getMetaClass(this) AS metaclass-»
	«EXPAND MetaModel::DeclareAndAssign("modelElement", "view.getElement()") FOR metaclass»
			«IF needCrossReferencer-»
	java.util.Map crossReferences = org.eclipse.emf.ecore.util.EcoreUtil.CrossReferencer.find(view.eResource().getResourceSet().getResources());
			«ENDIF-»
	java.util.List result = new java.util.LinkedList();
			«EXPAND colectConnectedLinks(methodNameSuffix, needCrossReferencer, metaclass.isExternalInterface()) FOREACH genLinks-»
	return result;
		«ENDLET-»
	«ELSE-»
	return java.util.Collections.EMPTY_LIST;
	«ENDIF-»
}
«ENDDEFINE»

«DEFINE colectConnectedLinks(String methodNameSuffix, boolean needCrossReferencer, boolean isExternalInterface) FOR gmfgen::GenLink-»
«IF isExternalInterface-»
	if («EXPAND MetaModel::IsInstance("modelElement") FOR modelFacet.getLinkEndType(methodNameSuffix)») {
«ENDIF-»
	result.addAll(«EXPAND chooseConnectedLinksByTypeMethodName(methodNameSuffix, this) FOR modelFacet»(«IF isExternalInterface-»
«EXPAND MetaModel::CastEObject("modelElement") FOR getLinkEndType(modelFacet, methodNameSuffix)»«ELSE»modelElement«ENDIF»«IF needCrossReferencer», crossReferences«ENDIF»));	
«IF isExternalInterface-»
	}
«ENDIF-»
«ENDDEFINE»

«DEFINE chooseConnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«REM»
	For FeatureModelFacet-based links we are calling 
	getOutgoing???Links instead of getContained???Links
«ENDREM»
«DEFINE chooseConnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
«IF getContainedLinksMethodNameSuffix() == methodNameSuffix»«EXPAND getConnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix()) FOR genLink-»
«ELSE»«EXPAND getConnectedLinksByTypeMethodName(methodNameSuffix) FOR genLink-»
«ENDIF-»
«ENDDEFINE»

«REM»
	For TypeModelFacet-based links we are calling 
	getContained???Links instead of getOutgoinf???Links 
	if sourceMetaFeature was not specified
«ENDREM»
«DEFINE chooseConnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
«IF getOutgoingLinksMethodNameSuffix() == methodNameSuffix && null == sourceMetaFeature»«EXPAND getConnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink-»
«ELSE»«EXPAND getConnectedLinksByTypeMethodName(methodNameSuffix) FOR genLink-»
«ENDIF-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod FOR gmfgen::GenLink»«EXPAND getContainedLinksByTypeMethod(this) FOR modelFacet»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodName(String suffix) FOR gmfgen::GenLink»get«suffix»«EXPAND getConnectedLinksByTypeMethodFragment FOR modelFacet»_«visualID»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::TypeLinkModelFacet»TypeModelFacetLinks_«metaClass.ecoreClass.name»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::FeatureLinkModelFacet»FeatureModelFacetLinks_«metaFeature.genClass.ecoreClass.name»_«metaFeature.ecoreFeature.name.toFirstUpper()»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet»«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»

	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Collection «EXPAND getConnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(«EXPAND MetaModel::QualifiedClassName FOR childMetaFeature.genClass» container) {
	«EXPAND getContainedLinksByTypeMethodBody(genLink, false)-»
}
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethodBody(gmfgen::GenLink genLink, boolean sourceVarDefined) FOR gmfgen::TypeLinkModelFacet-»
java.util.Collection result = new java.util.LinkedList();
	«LET childMetaFeature.isListType() AS inLoop-»
«IF inLoop-»
for (java.util.Iterator links = «EXPAND MetaModel::getFeatureValue("container", childMetaFeature.genClass) FOR childMetaFeature».iterator(); links.hasNext();) {
	org.eclipse.emf.ecore.EObject linkObject = (org.eclipse.emf.ecore.EObject ) links.next();
	if («EXPAND MetaModel::NotInstance("linkObject") FOR metaClass») {
		continue;
	}
	«EXPAND MetaModel::DeclareAndAssign("link", "linkObject") FOR metaClass»
«ELSE-»
	«IF getTypeGenClassX(childMetaFeature) == metaClass-»
		«EXPAND MetaModel::DeclareAndAssign("link", "container", getSourceType(), childMetaFeature) FOR metaClass»
	«ELSE-»
		«EXPAND MetaModel::DeclareAndAssign("linkObject", "container", getSourceType(), childMetaFeature) FOR getTypeGenClassX(childMetaFeature)»
		if («EXPAND MetaModel::NotInstance("linkObject") FOR metaClass») {
			return result;
		}
		«EXPAND MetaModel::DeclareAndAssign("link", "linkObject") FOR metaClass»
	«ENDIF-»
«ENDIF-»
		«EXPAND checkLinkVisualID(genLink, inLoop)-»
		«EXPAND defineLinkDestination(inLoop)-»
		«IF null != sourceMetaFeature-»
			«EXPAND defineLinkSource(inLoop)-»
			«IF sourceVarDefined-»
				«EXPAND checkLinkSource(inLoop)-»
			«ENDIF-»
			«EXPAND addLinkDescriptor(genLink, "src", "dst")-»
		«ELSE-»
			«EXPAND addLinkDescriptor(genLink, "container", "dst")-»
		«ENDIF-»
«IF inLoop-»
}
«ENDIF-»
	«ENDLET-»
return result;	
«ENDDEFINE»

«DEFINE addLinkDescriptor(gmfgen::GenLink genLink, String srcVar, String dstVar) FOR gmfgen::TypeLinkModelFacet-»
result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND MetaModel::DowncastToEObject(srcVar) FOR getSourceType()», «EXPAND MetaModel::DowncastToEObject(dstVar) FOR getTargetType()», «EXPAND MetaModel::DowncastToEObject("link") FOR metaClass», «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
«ENDDEFINE»

«DEFINE checkLinkVisualID(gmfgen::GenLink genLink, boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if («EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink» != «EXPAND xpt::editor::VisualIDRegistry::getLinkWithClassVisualIDMethodCall FOR genLink.getDiagram()»(«EXPAND MetaModel::DowncastToEObject("link") FOR metaClass»)) {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«ENDDEFINE»

«DEFINE defineLinkSource(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
	«IF sourceMetaFeature.isListType()-»
java.util.List sources = «EXPAND MetaModel::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
Object theSource = sources.size() == 1 ? sources.get(0) : null;
if («EXPAND MetaModel::NotInstance("theSource") FOR getSourceType()») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«EXPAND MetaModel::DeclareAndAssign("src", "theSource", true) FOR getSourceType()»
	«ELSE-»
«EXPAND MetaModel::DeclareAndAssign("src", "link", metaClass, sourceMetaFeature) FOR getSourceType()»
	«ENDIF-»
«ENDDEFINE»

«DEFINE checkLinkSource(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if (src != source) {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«ENDDEFINE»

«DEFINE defineLinkDestination(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
	«IF targetMetaFeature.isListType()-»
java.util.List targets = «EXPAND MetaModel::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
Object theTarget = targets.size() == 1 ? targets.get(0) : null;
if («EXPAND MetaModel::NotInstance("theTarget") FOR getTargetType()») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«EXPAND MetaModel::DeclareAndAssign("dst", "theTarget", true) FOR getTargetType()»
	«ELSE-»
«EXPAND MetaModel::DeclareAndAssign("dst", "link", metaClass, targetMetaFeature) FOR getTargetType()»
	«ENDIF-»
«ENDDEFINE»

«DEFINE stopLinkProcessing(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
«IF inLoop-»
continue;
«ELSE-»
return result;
«ENDIF-»
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethod FOR gmfgen::GenLink-»

	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Collection «EXPAND getConnectedLinksByTypeMethodName(getIncomingLinksMethodNameSuffix())»(«EXPAND MetaModel::QualifiedClassName FOR modelFacet.getTargetType()» target, java.util.Map crossReferences) {
	java.util.Collection result = new java.util.LinkedList();
	java.util.Collection settings = (java.util.Collection) crossReferences.get(target);
	for (java.util.Iterator it = settings.iterator(); it.hasNext();) {
		org.eclipse.emf.ecore.EStructuralFeature.Setting setting = (org.eclipse.emf.ecore.EStructuralFeature.Setting) it.next();
		«EXPAND getIncomingLinksByTypeMethodBody(this) FOR modelFacet-»
	}
	return result;	
}
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
if (setting.getEStructuralFeature() != «EXPAND MetaModel::MetaFeature FOR targetMetaFeature» || «EXPAND MetaModel::NotInstance("setting.getEObject()") FOR metaClass») {
	continue;
}
«EXPAND MetaModel::DeclareAndAssign("link", "setting.getEObject()") FOR metaClass»
	«EXPAND checkLinkVisualID(genLink, true)-»
	«IF null != sourceMetaFeature-»
		«EXPAND defineLinkSource(true)-»
		«EXPAND addLinkDescriptor(genLink, "src", "target")-»
	«ELSE-»
		«EXPAND defineLinkContainer(true)-»
		«EXPAND addLinkDescriptor(genLink, "container", "target")-»
«REM»TODO: continue here.«ENDREM»
	«ENDIF-»
«ENDDEFINE»

«DEFINE defineLinkContainer(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if (false == «EXPAND MetaModel::IsContainerInstance("link", metaClass) FOR containmentMetaFeature.genClass») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«EXPAND MetaModel::DeclareAndAssignContainer("container", "link", metaClass) FOR containmentMetaFeature.genClass»
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
if (setting.getEStructuralFeature() == «EXPAND MetaModel::MetaFeature FOR metaFeature») {
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(setting.getEObject(), «EXPAND MetaModel::DowncastToEObject("target") FOR getTargetType()», «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
}
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethod FOR gmfgen::GenLink-»
	«EXPAND getOutgoingLinksByTypeMethod(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethodSignature FOR gmfgen::GenLink»private static java.util.Collection «EXPAND getConnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix())»(«EXPAND MetaModel::QualifiedClassName FOR modelFacet.getSourceType()» source)«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»

	«EXPAND xpt::Common::generatedMemberComment»
«EXPAND getOutgoingLinksByTypeMethodSignature FOR genLink» {
	java.util.Collection result = new java.util.LinkedList();
	«IF metaFeature.isListType()-»
	for (java.util.Iterator destinations = «EXPAND MetaModel::getFeatureValue("source", getSourceType()) FOR metaFeature».iterator(); destinations.hasNext();) {
		«EXPAND MetaModel::DeclareAndAssign("destination", "destinations.next()", true) FOR getTargetType()»
	«ELSE-»
	«EXPAND MetaModel::DeclareAndAssign("destination", "source", getSourceType(), metaFeature) FOR getTargetType()»
	if (destination == null) {
		return result;
	}
	«ENDIF-»
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND MetaModel::DowncastToEObject("source") FOR getSourceType()», «EXPAND MetaModel::DowncastToEObject("destination") FOR getTargetType()», «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
	«IF metaFeature.isListType()-»
	}
	«ENDIF-»
	return result;
}
«ENDDEFINE»

«REM»More careful way to find container should be used here then GMF will be modified in accordance«ENDREM»
«DEFINE getOutgoingLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
	«IF null != sourceMetaFeature-»
	
		«EXPAND xpt::Common::generatedMemberComment»
«EXPAND getOutgoingLinksByTypeMethodSignature FOR genLink» {
	«EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container = null;
	// Find container element for the link.
	// Climb up by containment hierarchy starting from the source
	// and return the first element that is instance of the container class.
	for (org.eclipse.emf.ecore.EObject element = «EXPAND MetaModel::DowncastToEObject("source") FOR getSourceType()»; element != null && container == null; element = element.eContainer()) {
		if («EXPAND MetaModel::IsInstance("element") FOR containmentMetaFeature.genClass») {
			container = «EXPAND MetaModel::CastEObject("element") FOR containmentMetaFeature.genClass»;
		}
	}
	if (container == null) {
		return java.util.Collections.EMPTY_LIST;
	}
		«EXPAND getContainedLinksByTypeMethodBody(genLink, true)-»
}		
	«ENDIF-»
«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE incorrectLinkModelFacet FOR gmfgen::LinkModelFacet-»
	«ERROR "Incorrect LinkModelFacet: " + this»
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagramUpdater»«ENDDEFINE»@


1.33
log
@Correcting compilation errors.
@
text
@d11 1
d202 2
a203 2
«DEFINE getIncomingLinks FOR gmfgen::GenCommonBase-»
	«EXPAND getConnectedLinks(getIncomingLinks(getMetaClass(this), getDiagram()), getIncomingLinksMethodNameSuffix(), true)-»
d206 2
a207 2
«DEFINE getOutgoingLinks FOR gmfgen::GenCommonBase-»
	«EXPAND getConnectedLinks(getOutgoingLinks(getMetaClass(this), getDiagram()), getOutgoingLinksMethodNameSuffix(), false)-»
@


1.32
log
@[226882] Support links with childMetaFeature not from container
@
text
@d286 1
a286 1
private static java.util.Collection «EXPAND getConnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(«EXPAND MetaModel::QualifiedClassName FOR getSourceType()» container) {
@


1.31
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d286 1
a286 1
private static java.util.Collection «EXPAND getConnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(«EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container) {
d295 1
a295 1
for (java.util.Iterator links = «EXPAND MetaModel::getFeatureValue("container", containmentMetaFeature.genClass) FOR childMetaFeature».iterator(); links.hasNext();) {
@


1.30
log
@[150177] phase II, access to metamodel through generated facility - deal with occasional plain Objects
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.29
log
@refactor false == isInstance to NotInstance
@
text
@d95 1
a95 1
		«EXPAND MetaModel::DeclareAndAssign("childElement", "it.next()") FOR getTypeGenClassX(childMetaFeature)»
d294 1
a294 1
		«IF inLoop-»
d296 16
a311 10
	Object linkObject = links.next();
			«EXPAND defineLink(inLoop)-»
		«ELSE-»
			«IF getTypeGenClassX(childMetaFeature) == metaClass-»
«EXPAND MetaModel::DeclareAndAssign("link", "container", getSourceType(), childMetaFeature) FOR metaClass»
			«ELSE-»
«EXPAND MetaModel::DeclareAndAssign("linkObject", "container", getSourceType(), childMetaFeature) FOR getTypeGenClassX(childMetaFeature)»
				«EXPAND defineLink(inLoop)-»
			«ENDIF-»
		«ENDIF-»
d323 1
a323 1
		«IF inLoop-»
d325 1
a325 1
		«ENDIF-»
a339 7
«DEFINE defineLink(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if («EXPAND MetaModel::NotInstance("linkObject") FOR metaClass») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«EXPAND MetaModel::DeclareAndAssign("link", "linkObject") FOR metaClass»
«ENDDEFINE»

d347 1
a347 1
«EXPAND MetaModel::DeclareAndAssign("src", "theSource") FOR getSourceType()»
d366 1
a366 1
«EXPAND MetaModel::DeclareAndAssign("dst", "theTarget") FOR getTargetType()»
d440 1
a440 1
		«EXPAND MetaModel::DeclareAndAssign("destination", "destinations.next()") FOR getTargetType()»
@


1.28
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d335 1
a335 1
if (false == «EXPAND MetaModel::IsInstance("linkObject") FOR metaClass») {
d345 1
a345 1
if (false == «EXPAND MetaModel::IsInstance("theSource") FOR getSourceType()») {
d364 1
a364 1
if (false == «EXPAND MetaModel::IsInstance("theTarget") FOR getTargetType()») {
d396 1
a396 1
if (setting.getEStructuralFeature() != «EXPAND MetaModel::MetaFeature FOR targetMetaFeature» || false == «EXPAND MetaModel::IsInstance("setting.getEObject()") FOR metaClass») {
@


1.27
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d94 1
a94 1
	for (java.util.Iterator it = «EXPAND xpt::Common::getFeatureValue("modelElement", getModelElementType()) FOR childMetaFeature».iterator(); it.hasNext();) {
d99 1
a99 1
		int visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, «EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»childElement);
d144 1
a144 1
	result.add(new «getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(«IF null != modelFacet.childMetaFeature»«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(modelFacet.childMetaFeature)»«ENDIF»childElement, visualID));
d295 1
a295 1
for (java.util.Iterator links = «EXPAND xpt::Common::getFeatureValue("container", containmentMetaFeature.genClass) FOR childMetaFeature».iterator(); links.hasNext();) {
d325 1
a325 1
result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»«srcVar», «EXPAND xpt::Common::castToEObject FOR getTargetType()»«dstVar», «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
d329 1
a329 1
if («EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink» != «EXPAND xpt::editor::VisualIDRegistry::getLinkWithClassVisualIDMethodCall FOR genLink.getDiagram()»(«EXPAND xpt::Common::castToEObject FOR metaClass»link)) {
d343 1
a343 1
java.util.List sources = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
d362 1
a362 1
java.util.List targets = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
d396 1
a396 1
if (setting.getEStructuralFeature() != «EXPAND xpt::Common::metaFeatureAccessor FOR targetMetaFeature» || false == «EXPAND MetaModel::IsInstance("setting.getEObject()") FOR metaClass») {
d419 2
a420 2
if (setting.getEStructuralFeature() == «EXPAND xpt::Common::metaFeatureAccessor FOR metaFeature») {
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(setting.getEObject(), «EXPAND xpt::Common::castToEObject FOR getTargetType()»target, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
d440 1
a440 1
	for (java.util.Iterator destinations = «EXPAND xpt::Common::getFeatureValue("source", getSourceType()) FOR metaFeature».iterator(); destinations.hasNext();) {
d448 1
a448 1
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»source, «EXPAND xpt::Common::castToEObject FOR getTargetType()»destination, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
d466 1
a466 1
	for (org.eclipse.emf.ecore.EObject element = «EXPAND xpt::Common::castToEObject FOR getSourceType()» source; element != null && container == null; element = element.eContainer()) {
@


1.26
log
@copyright year updated; minor fix to use common code
@
text
@d220 1
a220 1
			«EXPAND colectConnnectedLinks(methodNameSuffix, needCrossReferencer, metaclass.isExternalInterface()) FOREACH genLinks-»
d229 9
a237 36
«DEFINE colectConnnectedLinks(String methodNameSuffix, boolean needCrossReferencer, boolean isExternalInterface) FOR gmfgen::GenLink-»
	«IF isExternalInterface-»
if (modelElement instanceof «EXPAND getLinkEndType(methodNameSuffix) FOR modelFacet») {
	«ENDIF-»
	result.addAll(«EXPAND chooseConnnectedLinksByTypeMethodName(methodNameSuffix, this) FOR modelFacet»(«EXPAND castLinkObject(methodNameSuffix, isExternalInterface) FOR modelFacet»modelElement«IF needCrossReferencer», crossReferences«ENDIF»));	
	«IF isExternalInterface-»
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE castLinkObject(String methodNameSuffix, boolean isExternalInterface) FOR gmfgen::LinkModelFacet»«IF isExternalInterface»(«EXPAND getLinkEndType(methodNameSuffix)») «ENDIF»«ENDDEFINE»

«DEFINE getLinkEndType(String methodNameSuffix) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«REM»
	For FeatureModelFacet-based links we are calling 
	getOutgoing???Links instead of getContained???Links
«ENDREM»
«DEFINE getLinkEndType(String methodNameSuffix) FOR gmfgen::FeatureLinkModelFacet-»
«IF getIncomingLinksMethodNameSuffix() == methodNameSuffix-»
«getQualifiedInterfaceName(getTargetType())»«ELSE-»
«getQualifiedInterfaceName(getSourceType())»«ENDIF-»
«ENDDEFINE»

«REM»
	For TypeModelFacet-based links we are calling 
	getContained???Links instead of getOutgoinf???Links 
	if sourceMetaFeature was not specified
«ENDREM»
«DEFINE getLinkEndType(String methodNameSuffix) FOR gmfgen::TypeLinkModelFacet-»
«IF getIncomingLinksMethodNameSuffix() == methodNameSuffix-»
«getQualifiedInterfaceName(getTargetType())»«ELSEIF getOutgoingLinksMethodNameSuffix() == methodNameSuffix && null != sourceMetaFeature-»
«getQualifiedInterfaceName(getSourceType())»«ELSE-»
«getQualifiedInterfaceName(containmentMetaFeature.genClass)»«ENDIF-»
d240 1
a240 1
«DEFINE chooseConnnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
d248 3
a250 3
«DEFINE chooseConnnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
«IF getContainedLinksMethodNameSuffix() == methodNameSuffix»«EXPAND getConnnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix()) FOR genLink-»
«ELSE»«EXPAND getConnnectedLinksByTypeMethodName(methodNameSuffix) FOR genLink-»
d259 3
a261 3
«DEFINE chooseConnnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
«IF getOutgoingLinksMethodNameSuffix() == methodNameSuffix && null == sourceMetaFeature»«EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink-»
«ELSE»«EXPAND getConnnectedLinksByTypeMethodName(methodNameSuffix) FOR genLink-»
d267 1
a267 1
«DEFINE getConnnectedLinksByTypeMethodName(String suffix) FOR gmfgen::GenLink»get«suffix»«EXPAND getConnectedLinksByTypeMethodFragment FOR modelFacet»_«visualID»«ENDDEFINE»
d286 1
a286 1
private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container) {
d384 1
a384 1
private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getIncomingLinksMethodNameSuffix())»(«getQualifiedInterfaceName(modelFacet.getTargetType())» target, java.util.Map crossReferences) {
d432 1
a432 1
«DEFINE getOutgoingLinksByTypeMethodSignature FOR gmfgen::GenLink»private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix())»(«getQualifiedInterfaceName(modelFacet.getSourceType())» source)«ENDDEFINE»
@


1.25
log
@[150177] phase I, refactor existing code: special alternatives for EObject.eContainer access; started extracting casts/qualified names when there's solid reason
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d298 1
a298 1
«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::FeatureLinkModelFacet»FeatureModelFacetLinks_«getFeatureAccessorName(metaFeature)»«ENDDEFINE»
@


1.24
log
@[150177] phase I, refactor existing code: better name (DeclareAndAssign instead of CastAndAssign), alternative method that uses feature accessor to get initial value
@
text
@d423 1
a423 1
if (setting.getEStructuralFeature() != «EXPAND xpt::Common::metaFeatureAccessor FOR targetMetaFeature» || false == setting.getEObject() instanceof «getQualifiedInterfaceName(metaClass)») {
d439 1
a439 1
if (false == «IF metaClass.isExternalInterface()»((org.eclipse.emf.ecore.EObject) «ENDIF»link«IF metaClass.isExternalInterface()»)«ENDIF».eContainer() instanceof «getQualifiedInterfaceName(containmentMetaFeature.genClass)») {
d442 1
a442 1
«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») «IF metaClass.isExternalInterface()»((org.eclipse.emf.ecore.EObject) «ENDIF»link«IF metaClass.isExternalInterface()»)«ENDIF».eContainer();
d489 1
a489 1
	«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container = null;
d495 1
a495 1
			container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») element;
@


1.23
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d95 1
a95 1
		«EXPAND MetaModel::CastAndAssign("childElement", "it.next()") FOR getTypeGenClassX(childMetaFeature)»
d97 1
a97 1
	{ «getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» childElement = «EXPAND xpt::Common::getFeatureValue("modelElement", getModelElementType()) FOR childMetaFeature»;
d124 1
a124 1
«EXPAND getModelelementType» modelElement = («EXPAND getModelelementType») view.getElement();
d135 1
a135 1
«EXPAND getModelelementType» modelElement = («EXPAND getModelelementType») containerView.getElement();
a157 1
«DEFINE getModelelementType FOR gmfgen::GenContainerBase»«getQualifiedInterfaceName(getModelElementType())»«ENDDEFINE»
d215 1
a215 1
	«EXPAND MetaModel::CastAndAssign("modelElement", "view.getElement()") FOR metaclass»
d327 1
a327 1
«getQualifiedInterfaceName(metaClass)» link = «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR childMetaFeature»;
d329 1
a329 1
«getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» linkObject = «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR childMetaFeature»;
d365 1
a365 1
«EXPAND MetaModel::CastAndAssign("link", "linkObject") FOR metaClass»
d375 1
a375 1
«EXPAND MetaModel::CastAndAssign("src", "theSource") FOR getSourceType()»
d377 1
a377 1
«getQualifiedInterfaceName(getSourceType())» src = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
d394 1
a394 1
«EXPAND MetaModel::CastAndAssign("dst", "theTarget") FOR getTargetType()»
d396 1
a396 1
«getQualifiedInterfaceName(getTargetType())» dst = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
d426 1
a426 1
«EXPAND MetaModel::CastAndAssign("link", "setting.getEObject()") FOR metaClass»
d468 1
a468 1
		«EXPAND MetaModel::CastAndAssign("destination", "destinations.next()") FOR getTargetType()»
d470 1
a470 1
	«getQualifiedInterfaceName(getTargetType())» destination = «EXPAND xpt::Common::getFeatureValue("source", getSourceType()) FOR metaFeature»;
@


1.22
log
@[200668] - ???DiagramUpdater provides some insufficient code
@
text
@d95 1
a95 1
		«getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» childElement = («getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))») it.next();
d216 1
a216 1
	«getQualifiedInterfaceName(metaclass)» modelElement = («getQualifiedInterfaceName(metaclass)») view.getElement();
d363 1
a363 1
if (false == linkObject instanceof «getQualifiedInterfaceName(metaClass)») {
d366 1
a366 1
«getQualifiedInterfaceName(metaClass)» link = («getQualifiedInterfaceName(metaClass)») linkObject;
d373 1
a373 1
if (false == theSource instanceof «getQualifiedInterfaceName(getSourceType())») {
d376 1
a376 1
«getQualifiedInterfaceName(getSourceType())» src = («getQualifiedInterfaceName(getSourceType())») theSource;
d392 1
a392 1
if (false == theTarget instanceof «getQualifiedInterfaceName(getTargetType())») {
d395 1
a395 1
«getQualifiedInterfaceName(getTargetType())» dst = («getQualifiedInterfaceName(getTargetType())») theTarget;
d427 1
a427 1
«getQualifiedInterfaceName(metaClass)» link = («getQualifiedInterfaceName(metaClass)») setting.getEObject();
d469 1
a469 1
		«getQualifiedInterfaceName(getTargetType())» destination = («getQualifiedInterfaceName(getTargetType())») destinations.next();
d495 1
a495 1
		if (element instanceof «getQualifiedInterfaceName(containmentMetaFeature.genClass)») {
@


1.21
log
@Correcting shortcuts processing.
@
text
@d472 3
@


1.21.2.1
log
@[200668] - ???DiagramUpdater provides some insufficient code
@
text
@a471 3
	if (destination == null) {
		return result;
	}
@


1.20
log
@[189594] - Exception Semantic Refresh failed
@
text
@d60 1
a60 1
	return view.getEAnnotation("Shortcut") != null && (!view.isSetElement() || view.getElement() == null || view.getElement().eIsProxy()); «EXPAND xpt::Common::nonNLS»
@


1.19
log
@- ViewProvider is in xpand now.
- Separating semantic part of VisualIDRegistry from pure-notation.
@
text
@d51 4
d60 1
a60 1
	return view.getEAnnotation("Shortcut") != null && view.isSetElement() && (view.getElement() == null || view.getElement().eIsProxy()); «EXPAND xpt::Common::nonNLS»
d87 1
a87 1
	«EXPAND getModelelementType» modelElement = («EXPAND getModelelementType») view.getElement();
d120 18
@


1.18
log
@[188662] - Connection links are lost in new OpenDiagramEditPolicy editor
@
text
@d96 1
a96 1
			«EXPAND checkChildElementVisualID FOREACH getSemanticChildren(this, childMetaFeature)-»
d120 1
a120 1
«DEFINE checkChildElementVisualID FOR gmfgen::GenNode-»
d123 3
@


1.17
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@a33 1
«LET getAllSemanticElements(editorGen.diagram) AS semanticElements-»
d35 1
a35 1
	«EXPAND getGenericConnectedLinks(semanticElements, getContainedLinksMethodNameSuffix())-»
d37 1
a37 1
	«EXPAND getGenericConnectedLinks(semanticElements, getIncomingLinksMethodNameSuffix())-»
d39 4
a42 4
	«EXPAND getGenericConnectedLinks(semanticElements, getOutgoingLinksMethodNameSuffix())-»
	«EXPAND getContainedLinks FOREACH semanticElements-»
	«EXPAND getIncomingLinks FOREACH semanticElements-»
	«EXPAND getOutgoingLinks FOREACH semanticElements-»
d45 1
a45 2
	«EXPAND getOutgoingLinksByTypeMethod FOREACH getAllOutgoingLinks(editorGen.diagram).select(link | null == getTypeModelFacet(link) || null != getTypeModelFacet(link).sourceMetaFeature)-»
«ENDLET-»
d174 1
a174 1
	«EXPAND getConnectedLinks(getContainedLinks(getTypeModelFacet(this), getDiagram()), getContainedLinksMethodNameSuffix(), false)-»
d178 1
a178 1
	«EXPAND getConnectedLinks(getIncomingLinks(getTypeModelFacet(this), getDiagram()), getIncomingLinksMethodNameSuffix(), true)-»
d182 1
a182 1
	«EXPAND getConnectedLinks(getOutgoingLinks(getTypeModelFacet(this), getDiagram()), getOutgoingLinksMethodNameSuffix(), false)-»
d190 1
a190 1
		«LET getTypeModelFacet(this).metaClass AS metaclass-»
@


1.16
log
@Checking visual ID whild collecting semic children..
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.15
log
@Correcting template definition context
@
text
@a31 1
	«EXPAND getSemanticChildrenOfModelElement FOREACH semanticContainers-»
a32 2
	
	«EXPAND isDomainMetaChild FOREACH semanticContainers-»
d84 1
a84 1
	«IF getSemanticChildren(this).size() > 0-»
d87 20
a106 5
	for (java.util.Iterator semanticIterator = «EXPAND getSemanticChildrenMethodName»(modelElement).iterator(); semanticIterator.hasNext();) {
		org.eclipse.emf.ecore.EObject nextElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
		int visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, nextElement);
		if («EXPAND isDomainMetaChildMethodName»(visualID)) {
			result.add(new «getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(nextElement, visualID));
d108 1
d110 1
a117 13
«DEFINE getSemanticChildrenOfModelElement FOR gmfgen::GenContainerBase-»
	«IF getSemanticChildren(this).size() > 0-»
	
	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.List «EXPAND getSemanticChildrenMethodName»(«EXPAND getModelelementType» modelElement) {
	java.util.List allValues = new java.util.LinkedList();
	«EXPAND collectAllFeatureFalues(getModelElementType()) FOR getSemanticChildrenChildFeatures(this)-»
	«EXPAND collectPotentialPhantomNodes-»
	return allValues;
}
	«ENDIF-»
«ENDDEFINE»

d122 3
a124 25
«DEFINE getModelelementType FOR gmfgen::GenContainerBase»«getQualifiedInterfaceName(getModelElementType())»«ENDDEFINE»

«DEFINE collectAllFeatureFalues(genmodel::GenClass containerGenClass) FOR Set[genmodel::GenFeature]-»
	«FOREACH this AS childFeature-»
		«IF null == childFeature-»
allValues.add(/*FIXME no containment/child feature found in the genmodel, toolsmith need to specify correct one here manually*/);
		«ELSEIF isListType(childFeature)-»
allValues.addAll(«EXPAND xpt::Common::getFeatureValue("modelElement", containerGenClass) FOR childFeature»);
		«ELSE-»
allValues.add(«EXPAND xpt::Common::getFeatureValue("modelElement", containerGenClass) FOR childFeature»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE collectPotentialPhantomNodes FOR gmfgen::GenContainerBase»«ENDDEFINE»

«DEFINE collectPotentialPhantomNodes FOR gmfgen::GenDiagram-»
	«IF !getPhantomNodes(this).isEmpty()-»
org.eclipse.emf.ecore.resource.Resource resource = modelElement.eResource();
for (java.util.Iterator semanticIterator = getPhantomNodesIterator(resource); semanticIterator.hasNext();) {
	org.eclipse.emf.ecore.EObject nextElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
	if (nextElement == modelElement) {
		continue;
	}
	«EXPAND addNextIfPhantom FOREACH getPhantomNodes(this)-»
a125 1
	«ENDIF-»
d129 2
a130 2
if («EXPAND xpt::Common::metaClassAccessor FOR modelFacet.metaClass».isSuperTypeOf(nextElement.eClass())) {
	allValues.add(nextElement);
d135 2
a146 17
«DEFINE isDomainMetaChild FOR gmfgen::GenContainerBase-»
	«EXPAND xpt::Common::generatedMemberComment»
public static boolean «EXPAND isDomainMetaChildMethodName»(int visualID) {
	«IF !getSemanticChildren(this).isEmpty()-»
	switch (visualID) {
	«EXPAND xpt::Common::caseVisualID FOREACH getSemanticChildren(this)»
		return true;
	}
	«ENDIF-»
	return false;
}
«ENDDEFINE»

«DEFINE isDomainMetaChildMethodName FOR gmfgen::GenContainerBase»is«getUniqueIdentifier()»DomainMetaChild«ENDDEFINE»

«DEFINE isDomainMetaChildMethodCall FOR gmfgen::GenContainerBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND isDomainMetaChildMethodName»«ENDDEFINE»

@


1.14
log
@Replacing static method calls with templates.
@
text
@d137 2
a138 2
«DEFINE collectPotentialPhantomNodes FOR gmfgen::GenDiagramUpdater-»
	«IF !getPhantomNodes(editorGen.diagram).isEmpty()-»
d145 1
a145 1
	«EXPAND addNextIfPhantom FOREACH getPhantomNodes(editorGen.diagram)-»
@


1.13
log
@Non-nls comment replaced by template call.
@
text
@d70 1
a70 1
	switch («editorGen.diagram.getVisualIDRegistryQualifiedClassName()».getVisualID(view)) {
d92 1
a92 1
		int visualID = «getDiagram().getVisualIDRegistryQualifiedClassName()».getNodeVisualID(view, nextElement);
d188 1
a188 1
	switch («editorGen.diagram.getVisualIDRegistryQualifiedClassName()».getVisualID(view)) {
d371 1
a371 1
if («EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink» != «genLink.getDiagram().getVisualIDRegistryQualifiedClassName()».getLinkWithClassVisualID(«EXPAND xpt::Common::castToEObject FOR metaClass»link)) {
@


1.12
log
@GenDiagramUpdater created in .gmfgen model
@
text
@d61 1
a61 1
	return view.getEAnnotation("Shortcut") != null && view.isSetElement() && (view.getElement() == null || view.getElement().eIsProxy()); //$NON-NLS-1$
d367 1
a367 1
result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»«srcVar», «EXPAND xpt::Common::castToEObject FOR getTargetType()»«dstVar», «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
d371 1
a371 1
if («genLink.getEditPartQualifiedClassName()».VISUAL_ID != «genLink.getDiagram().getVisualIDRegistryQualifiedClassName()».getLinkWithClassVisualID(«EXPAND xpt::Common::castToEObject FOR metaClass»link)) {
d462 1
a462 1
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(setting.getEObject(), «EXPAND xpt::Common::castToEObject FOR getTargetType()»target, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
d487 1
a487 1
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»source, «EXPAND xpt::Common::castToEObject FOR getTargetType()»destination, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
@


1.11
log
@[181167] - Separate sycnhronization logic from CanonicalEditPolicy / DiagramContentsInitializer
@
text
@d21 2
a22 2
«DEFINE DiagramUpdater FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::copyright FOR getDiagram().editorGen-»
d28 1
a28 1
«LET getAllContainers().select(container | hasSemanticChildren(container)) AS semanticContainers-»
d37 1
a37 1
«LET getAllSemanticElements(this) AS semanticElements-»
d47 3
a49 3
	«EXPAND getContainedLinksByTypeMethod FOREACH getAllContainedLinks(this)-»
	«EXPAND getIncomingLinksByTypeMethod FOREACH getAllIncomingLinks(this)-»
	«EXPAND getOutgoingLinksByTypeMethod FOREACH getAllOutgoingLinks(this).select(link | null == getTypeModelFacet(link) || null != getTypeModelFacet(link).sourceMetaFeature)-»
d56 2
a57 2
«DEFINE isShortcutOrphaned FOR gmfgen::GenDiagram-»
	«IF !containsShortcutsTo.isEmpty()-»
d66 1
a66 1
«DEFINE getGenericSemanticChildrenOfView(List[gmfgen::GenContainerBase] semanticContainers) FOR gmfgen::GenDiagram-»
d70 1
a70 1
	switch («getVisualIDRegistryQualifiedClassName()».getVisualID(view)) {
d94 1
a94 1
			result.add(new «getDiagram().getNodeDescriptorQualifiedClassName()»(nextElement, visualID));
d119 1
a119 1
«DEFINE getSemanticChildrenMethodCall FOR gmfgen::GenContainerBase»«getDiagram().getDiagramUpdaterQualifiedClassName()».«EXPAND getSemanticChildrenMethodName»«ENDDEFINE»
d137 2
a138 2
«DEFINE collectPotentialPhantomNodes FOR gmfgen::GenDiagram-»
	«IF !getPhantomNodes(this).isEmpty()-»
d145 1
a145 1
	«EXPAND addNextIfPhantom FOREACH getPhantomNodes(this)-»
d157 2
a158 2
«DEFINE getPhantomNodesIterator FOR gmfgen::GenDiagram-»
	«IF !getPhantomNodes(this).isEmpty()-»
d182 1
a182 1
«DEFINE isDomainMetaChildMethodCall FOR gmfgen::GenContainerBase»«getDiagram().getDiagramUpdaterQualifiedClassName()».«EXPAND isDomainMetaChildMethodName»«ENDDEFINE»
d184 1
a184 1
«DEFINE getGenericConnectedLinks(List[gmfgen::GenCommonBase] linkContainers, String methodNameSuffix) FOR gmfgen::GenDiagram-»
d188 1
a188 1
	switch («getVisualIDRegistryQualifiedClassName()».getVisualID(view)) {
d202 1
a202 1
«DEFINE getContainedLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getContainedLinksMethodNameSuffix())»«ENDDEFINE»
d205 1
a205 1
«DEFINE getIncomingLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getIncomingLinksMethodNameSuffix())»«ENDDEFINE»
d208 1
a208 1
«DEFINE getOutgoingLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getOutgoingLinksMethodNameSuffix())»«ENDDEFINE»
d367 1
a367 1
result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»«srcVar», «EXPAND xpt::Common::castToEObject FOR getTargetType()»«dstVar», «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
d462 1
a462 1
	result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(setting.getEObject(), «EXPAND xpt::Common::castToEObject FOR getTargetType()»target, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
d487 1
a487 1
	result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»source, «EXPAND xpt::Common::castToEObject FOR getTargetType()»destination, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
d526 1
a526 1
«DEFINE additions FOR gmfgen::GenContainerBase»«ENDDEFINE»@


1.10
log
@Sometimes there is no diagram nodes for link container, so creating link descriptor directly in get???OutgoingLinks() method instead of redirecting it to get???ContainedLinks() method.
@
text
@d49 1
a49 1
	«EXPAND getOutgoingLinksByTypeMethod FOREACH getAllOutgoingLinks(this)-»
d245 35
a279 1
result.addAll(«EXPAND getConnnectedLinksByTypeMethodName(methodNameSuffix)»(«EXPAND castLinkObject(methodNameSuffix, isExternalInterface) FOR modelFacet»modelElement«IF needCrossReferencer», crossReferences«ENDIF»));
d282 11
a292 6
«DEFINE castLinkObject(String methodNameSuffix, boolean isExternalInterface) FOR gmfgen::LinkModelFacet-»
«IF isExternalInterface-»
	«IF getIncomingLinksMethodNameSuffix() == methodNameSuffix-»
(«getQualifiedInterfaceName(getTargetType())») «ELSEIF getOutgoingLinksMethodNameSuffix() == methodNameSuffix-»
(«getQualifiedInterfaceName(getSourceType())») «ELSE-»
(«getQualifiedInterfaceName(getContainerClass(this))») «ENDIF-»
d296 10
a305 1
«DEFINE getContainedLinksByTypeMethod FOR gmfgen::GenLink-»
d307 1
a307 7
	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix())»(«getQualifiedInterfaceName(getContainerClass(modelFacet))» container) {
	java.util.Collection result = new java.util.LinkedList();
	«EXPAND getContainedLinksByTypeMethodBody(this) FOR modelFacet-»
	return result;	
}
«ENDDEFINE»
d319 10
a328 1
«DEFINE getContainedLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
d330 1
d334 1
d337 3
a339 2
for (java.util.Iterator links = «EXPAND xpt::Common::getFeatureValue("container", getContainerClass(this)) FOR childMetaFeature».iterator(); links.hasNext();) {
	«getQualifiedInterfaceName(metaClass)» link = («getQualifiedInterfaceName(metaClass)») links.next();
d341 6
a346 1
«getQualifiedInterfaceName(metaClass)» link = («getQualifiedInterfaceName(metaClass)») «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR childMetaFeature»;
d363 1
d376 7
d423 1
a423 16
«DEFINE getContainedLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
	«IF metaFeature.isListType()-»
for (java.util.Iterator destinations = «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR metaFeature».iterator(); destinations.hasNext();) {
	«getQualifiedInterfaceName(getTargetType())» destination = («getQualifiedInterfaceName(getTargetType())») destinations.next();
	«ELSE-»
«getQualifiedInterfaceName(getTargetType())» destination = «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR metaFeature»;
	«ENDIF-»
result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»container, «EXPAND xpt::Common::castToEObject FOR getTargetType()»destination, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
	«IF metaFeature.isListType()-»
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»
a424 1
«DEFINE getIncomingLinksByTypeMethod FOR gmfgen::GenLink-»
d454 1
a454 1
if (false == «IF metaClass.isExternalInterface()»((org.eclipse.emf.ecore.EObject) «ENDIF»link«IF metaClass.isExternalInterface()»)«ENDIF».eContainer() instanceof «getQualifiedInterfaceName(getContainerClass(this))») {
d457 1
a457 1
«getQualifiedInterfaceName(getContainerClass(this))» container = («getQualifiedInterfaceName(getContainerClass(this))») «IF metaClass.isExternalInterface()»((org.eclipse.emf.ecore.EObject) «ENDIF»link«IF metaClass.isExternalInterface()»)«ENDIF».eContainer();
d471 7
d479 13
a491 2
private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix())»(«getQualifiedInterfaceName(modelFacet.getSourceType())» source) {
	«EXPAND getOutgoingLinksByTypeMethodBody(this) FOR modelFacet-»
a494 4
«DEFINE getOutgoingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
return «EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(source);
«ENDDEFINE»

d496 16
a511 11
«DEFINE getOutgoingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
	«IF null == sourceMetaFeature-»
return «EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(source);
	«ELSE-»
«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container = null;
// Find container element for the link.
// Climb up by containment hierarchy starting from the source
// and return the first element that is instance of the container class.
for (org.eclipse.emf.ecore.EObject element = «EXPAND xpt::Common::castToEObject FOR getSourceType()» source; element != null && container == null; element = element.eContainer()) {
	if (element instanceof «getQualifiedInterfaceName(containmentMetaFeature.genClass)») {
		container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») element;
d513 2
a514 7
}
if (container == null) {
	return java.util.Collections.EMPTY_LIST;
}
java.util.Collection result = new java.util.LinkedList();
	«EXPAND getContainedLinksByTypeMethodBody(genLink, true)-»		
return result;
d518 1
a518 1
«DEFINE getOutgoingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
@


1.9
log
@Method name changed
@
text
@d278 4
d293 3
d319 2
a320 2
Object source = sources.size() == 1 ? sources.get(0) : null;
if (false == source instanceof «getQualifiedInterfaceName(getSourceType())») {
d323 1
a323 1
«getQualifiedInterfaceName(getSourceType())» src = («getQualifiedInterfaceName(getSourceType())») source;
d329 6
d338 2
a339 2
Object target = targets.size() == 1 ? targets.get(0) : null;
if (false == target instanceof «getQualifiedInterfaceName(getTargetType())») {
d342 1
a342 1
«getQualifiedInterfaceName(getTargetType())» dst = («getQualifiedInterfaceName(getTargetType())») target;
d435 1
d439 1
a439 1
for (org.eclipse.emf.ecore.EObject element = «EXPAND xpt::Common::castToEObject FOR getSourceType()» source; element != null; element = element.eContainer()) {
d441 1
a441 8
		java.util.Collection outgoingLinks = «EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»((«getQualifiedInterfaceName(containmentMetaFeature.genClass)») element);
		for (java.util.Iterator it = outgoingLinks.iterator(); it.hasNext();) {
			«genLink.getDiagram().getLinkDescriptorQualifiedClassName()» nextLinkDescriptor = («genLink.getDiagram().getLinkDescriptorQualifiedClassName()») it.next();
			if (nextLinkDescriptor.getSource() != source) {
				it.remove();
			}
		}
		return outgoingLinks;
d444 6
a449 1
return java.util.Collections.EMPTY_LIST;
@


1.8
log
@Updater was adopted to return incoming/outgoing links.
@
text
@d186 1
a186 1
public static java.util.List get«methodNameSuffix»(org.eclipse.gmf.runtime.notation.View view) {
@


1.7
log
@Template refactored to simplify custom templates creation.
@
text
@d15 1
d39 5
a43 1
	«EXPAND getGenericContainedLinks(semanticElements)-»
d45 2
d48 2
d184 1
a184 1
«DEFINE getGenericContainedLinks(List[gmfgen::GenCommonBase] linkContainers) FOR gmfgen::GenDiagram-»
d186 1
a186 1
public static java.util.List getContainedLinks(org.eclipse.gmf.runtime.notation.View view) {
d189 1
a189 1
		«EXPAND getContainedLinksCase FOREACH linkContainers-»
d196 1
a196 1
«DEFINE getContainedLinksCase FOR gmfgen::GenCommonBase-»
d198 1
a198 1
	return «EXPAND getContainedLinksMethodName»(view);
d201 5
a205 1
«DEFINE getContainedLinksMethodName FOR gmfgen::GenCommonBase»get«getUniqueIdentifier()»ContainedLinks«ENDDEFINE»
d207 4
a210 1
«DEFINE getContainedLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().getDiagramUpdaterQualifiedClassName()».«EXPAND getContainedLinksMethodName»«ENDDEFINE»
d213 12
d227 7
a233 3
public static java.util.List «EXPAND getContainedLinksMethodName»(org.eclipse.gmf.runtime.notation.View view) {
«IF !getContainedLinks(getTypeModelFacet(this), getDiagram()).isEmpty()-»
	«getTypeModelFacet(this).metaClass.getQualifiedInterfaceName()» modelElement = («getTypeModelFacet(this).metaClass.getQualifiedInterfaceName()») view.getElement();
d235 1
a235 1
	«EXPAND colectContainedLink FOREACH getContainedLinks(getTypeModelFacet(this), getDiagram())-»
d237 2
a238 1
«ELSE-»
d240 1
a240 1
«ENDIF-»
d244 11
a254 2
«DEFINE colectContainedLink FOR gmfgen::GenLink-»
result.addAll(«EXPAND getContainedLinksByTypeMethodName»(modelElement));
d260 1
a260 1
private static java.util.Collection «EXPAND getContainedLinksByTypeMethodName»(«getQualifiedInterfaceName(getContainerClass(modelFacet))» container) {
d267 1
a267 1
«DEFINE getContainedLinksByTypeMethodName FOR gmfgen::GenLink»getContained«EXPAND getContainedLinksByTypeMethodFragment FOR modelFacet»_«visualID»«ENDDEFINE»
d269 1
a269 1
«DEFINE getContainedLinksByTypeMethodFragment FOR gmfgen::TypeLinkModelFacet»TypeModelFacetLinks_«metaClass.ecoreClass.name»«ENDDEFINE»
d271 1
a271 1
«DEFINE getContainedLinksByTypeMethodFragment FOR gmfgen::FeatureLinkModelFacet»FeatureModelFacetLinks_«getFeatureAccessorName(metaFeature)»«ENDDEFINE»
d273 1
a273 1
«DEFINE getContainedLinksByTypeMethodFragment FOR gmfgen::LinkModelFacet-»
d278 2
a279 1
	«IF childMetaFeature.isListType()-»
d282 1
a282 1
	«ELSE-»
d284 10
a293 3
	«ENDIF-»
if («genLink.getEditPartQualifiedClassName()».VISUAL_ID != «genLink.getDiagram().getVisualIDRegistryQualifiedClassName()».getLinkWithClassVisualID(«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»link)) {
	«EXPAND stopLinkProcessing-»
d295 11
a305 8
	«EXPAND defineLinkDestination-»
	«IF null != sourceMetaFeature-»
		«EXPAND defineLinkSource-»
result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(sourceMetaFeature)»src, «EXPAND xpt::Common::castToEObject FOR getTargetType()»dst, «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
	«ELSE-»
result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getContainerClass(this)»container, «EXPAND xpt::Common::castToEObject FOR getTargetType()»dst, «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
	«ENDIF-»
	«IF childMetaFeature.isListType()-»
a306 1
	«ENDIF-»
d309 1
a309 1
«DEFINE defineLinkSource FOR gmfgen::TypeLinkModelFacet-»
d313 2
a314 2
if (false == source instanceof «getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))») {
	«EXPAND stopLinkProcessing-»
d316 1
a316 1
«getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))» src = («getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))») source;
d318 1
a318 1
«getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))» src = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
d322 1
a322 1
«DEFINE defineLinkDestination FOR gmfgen::TypeLinkModelFacet-»
d327 1
a327 1
	«EXPAND stopLinkProcessing-»
d335 2
a336 2
«DEFINE stopLinkProcessing FOR gmfgen::TypeLinkModelFacet-»
«IF childMetaFeature.isListType()-»
d345 2
a346 2
for (java.util.Iterator destinations = «EXPAND xpt::Common::getFeatureValue("container", getContainerClass(this)) FOR metaFeature».iterator(); destinations.hasNext();) {
	«getQualifiedInterfaceName(getTypeGenClassX(metaFeature))» destination = («getQualifiedInterfaceName(getTypeGenClassX(metaFeature))») destinations.next();
d348 1
a348 1
«getQualifiedInterfaceName(getTypeGenClassX(metaFeature))» destination = «EXPAND xpt::Common::getFeatureValue("container", getContainerClass(this)) FOR metaFeature»;
d350 1
a350 1
result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getContainerClass(this)»container, «EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(metaFeature)»destination, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «genLink.getEditPartQualifiedClassName()».VISUAL_ID));
d360 85
@


1.6
log
@Method renamed
@
text
@d242 7
a248 7
int linkVID = «genLink.getDiagram().getVisualIDRegistryQualifiedClassName()».getLinkWithClassVisualID(«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»link);
if (linkVID == «genLink.getEditPartQualifiedClassName()».VISUAL_ID) {
	«IF targetMetaFeature.isListType()-»
	java.util.List targets = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
	Object target = targets.size() == 1 ? targets.get(0) : null;
	if (target instanceof «getQualifiedInterfaceName(getTargetType())») {
		«getQualifiedInterfaceName(getTargetType())» dst = («getQualifiedInterfaceName(getTargetType())») target;
d250 1
a250 1
	«getQualifiedInterfaceName(getTargetType())» dst = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
d252 13
a264 13
	«IF null != sourceMetaFeature-»
		«IF sourceMetaFeature.isListType()-»
	java.util.List sources = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
	Object source = sources.size() == 1 ? sources.get(0) : null;
	if (source instanceof «getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))») {
		«getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))» src = («getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))») source;
		«ELSE-»
	«getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))» src = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
		«ENDIF-»
	result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(sourceMetaFeature)»src, «EXPAND xpt::Common::castToEObject FOR getTargetType()»dst, «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», linkVID));
		«IF sourceMetaFeature.isListType()-»
	}
		«ENDIF-»
d266 1
a266 1
	result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getContainerClass(this)»container, «EXPAND xpt::Common::castToEObject FOR getTargetType()»dst, «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», linkVID));
d268 3
d272 4
a275 4
	}
	«ENDIF-»
}
	«IF childMetaFeature.isListType()-»
d277 3
d283 8
@


1.5
log
@Correcting problems with link source meta feature.
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d192 1
a192 1
«DEFINE getContainedLinksMethodName FOR gmfgen::GenCommonBase»get«getUniqueIdentifier()»ContainerLinks«ENDDEFINE»
@


1.4
log
@[181167] - Separate sycnhronization logic from CanonicalEditPolicy / DiagramContentsInitializer
@
text
@d238 1
a238 1
	«getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» link = («getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))») links.next();
d240 1
a240 1
«getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» link = («getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))») «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR childMetaFeature»;
d245 1
a245 1
	java.util.List targets = «EXPAND xpt::Common::getFeatureValue("link", getTypeGenClassX(childMetaFeature)) FOR targetMetaFeature»;
d250 1
a250 1
	«getQualifiedInterfaceName(getTargetType())» dst = «EXPAND xpt::Common::getFeatureValue("link", getTypeGenClassX(childMetaFeature)) FOR targetMetaFeature»;
d254 1
a254 1
	java.util.List sources = «EXPAND xpt::Common::getFeatureValue("link", getTypeGenClassX(childMetaFeature)) FOR sourceMetaFeature»;
d257 1
a257 1
		«getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))» src = («getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))») structuralFeatureResult;
d259 1
a259 1
	«getQualifiedInterfaceName(getTypeGenClassX(sourceMetaFeature))» src = «EXPAND xpt::Common::getFeatureValue("link", getTypeGenClassX(childMetaFeature)) FOR sourceMetaFeature»;
d261 1
a261 1
	result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(sourceMetaFeature)»src, «EXPAND xpt::Common::castToEObject FOR getTargetType()»dst, «EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», linkVID));
d266 1
a266 1
	result.add(new «genLink.getDiagram().getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getContainerClass(this)»container, «EXPAND xpt::Common::castToEObject FOR getTargetType()»dst, «EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», linkVID));
@


1.3
log
@[181167] - Separate sycnhronization logic from CanonicalEditPolicy / DiagramContentsInitializer
@
text
@d17 1
a29 1

a30 1

d36 6
d60 1
d64 1
d75 1
d97 1
d175 123
@


1.2
log
@[181167] - Separate sycnhronization logic from CanonicalEditPolicy / DiagramContentsInitializer
@
text
@d26 1
a26 1
«LET getAllContainers().select(container | !container.sansDomain && !container.containedNodes.isEmpty()) AS semanticContainers-»
d33 1
d70 1
a70 1
	«IF getSemanticChildrenChildFeatures(this).size() > 0-»
a71 1
	java.util.List semanticChildren = «EXPAND getSemanticChildrenMethodName»(modelElement);
d73 1
a73 1
	for (java.util.Iterator semanticIterator = semanticChildren.iterator(); semanticIterator.hasNext();) {
d88 1
a90 1
	«IF getSemanticChildrenChildFeatures(this).size() > 0-»
d93 1
d95 1
a95 2
	«ELSE-»
	return java.util.Collections.EMPTY_LIST;
a96 1
}
d117 32
@


1.1
log
@[181167] - Separate sycnhronization logic from CanonicalEditPolicy / DiagramContentsInitializer
@
text
@d75 3
a77 2
		if («EXPAND isDomainMetaChildMethodName»(«getDiagram().getVisualIDRegistryQualifiedClassName()».getNodeVisualID(view, nextElement))) {
			result.add(nextElement);
@

