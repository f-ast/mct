head	1.12;
access;
symbols
	v20081022-1925:1.12
	v20081015-1925:1.12
	v20081008-1925:1.12
	v20081001-1925:1.12
	v20080930-1130:1.12
	v20080926-1245:1.12
	v20080924-1925:1.12
	v20080917-1925:1.12
	v20080911-1728:1.11
	v20080910-1520:1.11
	v20080903-1520:1.11
	v20080827-1520:1.11
	v20080813-1520:1.7
	v20080806-1520:1.7
	v20080722-1827:1.7
	v20080718-1731:1.7
	v20080716-1600:1.7
	v20080716-1642:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080610-1132:1.7
	v20080603-1553:1.7
	v20080528-1052:1.7
	v20080521:1.7
	v20080516-1543:1.7
	v20080516-1143:1.7
	v20080512-1200:1.7
	v20080508-2000:1.7
	v20080507-1326:1.7
	v20080503-1740:1.6
	v20080501-1739:1.6
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080411-0411:1.6
	v20080404-1111:1.6
	v20080322-0000:1.6
	v20080222-1200:1.3
	v20080215-1500:1.3
	v20080207-0207:1.3
	v20071222-1111:1.3
	v20071214-1111:1.3
	v20071130-1111:1.3
	v20071124-0000:1.3
	v20071112-0000:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070928-0000:1.3
	v20070921-0000:1.3
	v20070915-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.2
	v20070614-1400:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.12
date	2008.09.15.16.28.22;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	3a5448ce8d264567;

1.11
date	2008.08.26.20.52.27;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	3a7648b46d064567;

1.10
date	2008.08.24.22.56.40;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	77b948b1e7254567;

1.9
date	2008.08.22.19.08.35;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	d4e48af0eb24567;

1.8
date	2008.08.22.18.25.42;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	5d5b48af049e4567;

1.7
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	39124821b4de4567;

1.6
date	2008.02.26.13.53.52;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	19d047c419ed4567;

1.5
date	2008.02.21.20.18.09;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	468b47bddc804567;

1.4
date	2008.02.21.18.35.58;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	6b4047bdc48d4567;

1.3
date	2007.06.20.17.07.07;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	30b646795eba4567;

1.2
date	2007.06.12.10.58.05;	author bblajer;	state Exp;
branches;
next	1.1;
commitid	4af9466e7c3c4567;

1.1
date	2007.06.11.10.45.38;	author ashatalin;	state Exp;
branches;
next	;
commitid	2581466d27cc4567;


desc
@@


1.12
log
@extra space removed
@
text
@/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
 
«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«EXTENSION xpt::navigator::Utils»
«EXTENSION xpt::GenModelUtils»
 
«DEFINE NavigatorLabelProvider FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::copyright FOR editorGen-»
package «packageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «labelProviderClassName» extends org.eclipse.jface.viewers.LabelProvider implements org.eclipse.ui.navigator.ICommonLabelProvider, org.eclipse.jface.viewers.ITreePathLabelProvider {

	«EXPAND staticInitializer-»
	
	«EXPAND updateLabel-»
	
	«EXPAND getImage-»
	
	«EXPAND getViewImage-»
	
	«EXPAND getImageByKey-»
	
	«EXPAND getText-»
	
	«EXPAND getViewText-»
	
	«EXPAND getTextMethod FOREACH getNavigatorContainedNodes(this)-»
	
	«EXPAND getUnknownElementText-»
	
	«EXPAND getUnresolvedDomainElementProxyText-»
	
	«EXPAND init-»

	«EXPAND restoreState-»

	«EXPAND saveState-»
	
	«EXPAND getDescription-»
	
	«EXPAND isOwnView-»

	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE staticInitializer FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
static {
	«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getImageRegistry().put(«EXPAND unknownElementKey», org.eclipse.jface.resource.ImageDescriptor.getMissingImageDescriptor()); «EXPAND xpt::Common::nonNLS»
	«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getImageRegistry().put(«EXPAND notFoundElementKey», org.eclipse.jface.resource.ImageDescriptor.getMissingImageDescriptor()); «EXPAND xpt::Common::nonNLS»
}
«ENDDEFINE»

«DEFINE updateLabel FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public void updateLabel(org.eclipse.jface.viewers.ViewerLabel label, org.eclipse.jface.viewers.TreePath elementPath) {
	Object element = elementPath.getLastSegment();
	if (element instanceof «getNavigatorItemQualifiedClassName()» && !isOwnView(((«getNavigatorItemQualifiedClassName()») element).getView())) {
		return;
	}
	label.setText(getText(element));
	label.setImage(getImage(element));
}
«ENDDEFINE»

«DEFINE getImage FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public org.eclipse.swt.graphics.Image getImage(Object element) {
	«EXPAND getNavigatorGroupImage-»

	«EXPAND getNavigatorItemImage-»

	«EXPAND getAdaptableImage-»

	«EXPAND getAdditionalInputImage-»
	return super.getImage(element);
}
«ENDDEFINE»

«DEFINE getNavigatorGroupImage FOR gmfgen::GenNavigator-»
if (element instanceof «getNavigatorGroupQualifiedClassName()») {
	«getNavigatorGroupQualifiedClassName()» group = («getNavigatorGroupQualifiedClassName()») element;
	return «editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundledImage(group.getIcon());
}
«ENDDEFINE»

«DEFINE getNavigatorItemImage FOR gmfgen::GenNavigator-»
if (element instanceof «getNavigatorItemQualifiedClassName()») {
	«getNavigatorItemQualifiedClassName()» navigatorItem = («getNavigatorItemQualifiedClassName()») element;
	if (!isOwnView(navigatorItem.getView())) {
		return super.getImage(element);
	}
	return getImage(navigatorItem.getView());
}
«ENDDEFINE»

«DEFINE getAdaptableImage FOR gmfgen::GenNavigator-»
«IF editorGen.diagram.generateShortcutIcon()-»
// Due to plugin.xml content will be called only for "own" views
if (element instanceof org.eclipse.core.runtime.IAdaptable) {
	org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) ((org.eclipse.core.runtime.IAdaptable) element).getAdapter(org.eclipse.gmf.runtime.notation.View.class);
	if (view != null && isOwnView(view)) {
		return getImage(view);
	}
}
«ENDIF-»
«ENDDEFINE»

«DEFINE getAdditionalInputImage FOR gmfgen::GenNavigator-»
«ENDDEFINE»

«DEFINE getViewImage FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public org.eclipse.swt.graphics.Image getImage(org.eclipse.gmf.runtime.notation.View view) {
	«IF !getNavigatorContainedNodes(this).isEmpty()-»
	switch («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»(view)) {
		«EXPAND caseImage FOREACH getNavigatorContainedNodes(this)-»
	}
	«ENDIF-»
	return getImage(«EXPAND unknownElementKey», null); «EXPAND xpt::Common::nonNLS»
}
«ENDDEFINE»

«DEFINE caseImage FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::caseVisualID»
	return getImage("«EXPAND key»", «IF null != elementType»«getDiagram().getElementTypesQualifiedClassName()».«getUniqueIdentifier()»«ELSE»null«ENDIF»); «EXPAND xpt::Common::nonNLS»
«ENDDEFINE»

«DEFINE getImageByKey FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.swt.graphics.Image getImage(String key, org.eclipse.gmf.runtime.emf.type.core.IElementType elementType) {
	org.eclipse.jface.resource.ImageRegistry imageRegistry = «editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getImageRegistry();
	org.eclipse.swt.graphics.Image image = imageRegistry.get(key);
	if (image == null && elementType != null && «editorGen.diagram.getElementTypesQualifiedClassName()».isKnownElementType(elementType)) {
		image = «editorGen.diagram.getElementTypesQualifiedClassName()».getImage(elementType);
		imageRegistry.put(key, image);
	}
			
	if (image == null) {
		image = imageRegistry.get(«EXPAND notFoundElementKey»); «EXPAND xpt::Common::nonNLS»
		imageRegistry.put(key, image);
	}
	return image;
}
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public String getText(Object element) {
	«EXPAND getNavigatorGroupText-»

	«EXPAND getNavigatorItemText-»

	«EXPAND getAdaptableText-»

	«EXPAND getAdditionalInputText-»
	return super.getText(element);
}
«ENDDEFINE»

«DEFINE getNavigatorGroupText FOR gmfgen::GenNavigator-»
if (element instanceof «getNavigatorGroupQualifiedClassName()») {
	«getNavigatorGroupQualifiedClassName()» group = («getNavigatorGroupQualifiedClassName()») element;
	return group.getGroupName();
}
«ENDDEFINE»

«DEFINE getNavigatorItemText FOR gmfgen::GenNavigator-»
if (element instanceof «getNavigatorItemQualifiedClassName()») {
	«getNavigatorItemQualifiedClassName()» navigatorItem = («getNavigatorItemQualifiedClassName()») element;
   		if (!isOwnView(navigatorItem.getView())) {
   			return null;
   		}
   		return getText(navigatorItem.getView());
	}
«ENDDEFINE»

«DEFINE getAdaptableText FOR gmfgen::GenNavigator-»
«IF editorGen.diagram.generateShortcutIcon()-»
// Due to plugin.xml content will be called only for "own" views
if (element instanceof org.eclipse.core.runtime.IAdaptable) {
	org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) ((org.eclipse.core.runtime.IAdaptable) element).getAdapter(org.eclipse.gmf.runtime.notation.View.class);
	if (view != null && isOwnView(view)) {
		return getText(view);
	}
}
«ENDIF-»
«ENDDEFINE»

«DEFINE getAdditionalInputText FOR gmfgen::GenNavigator-»
«ENDDEFINE»

«DEFINE getViewText FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public String getText(org.eclipse.gmf.runtime.notation.View view) {
	if (view.getElement() != null && view.getElement().eIsProxy()) {
		return getUnresolvedDomainElementProxyText(view);
	}
	«IF !getNavigatorContainedNodes(this).isEmpty()-»
	switch («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»(view)) {
		«EXPAND caseText FOREACH getNavigatorContainedNodes(this)-»
	}
	«ENDIF-»
	return getUnknownElementText(view);
}
«ENDDEFINE»

«DEFINE caseText FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::caseVisualID»
	return «EXPAND getTextMethodName»(view);
«ENDDEFINE»

«DEFINE getTextMethodName FOR gmfgen::GenCommonBase»get«getUniqueIdentifier()»Text«ENDDEFINE»

«DEFINE getTextMethod FOR gmfgen::GenCommonBase-»
	«EXPAND xpt::Common::generatedMemberComment»
private String «EXPAND getTextMethodName»(org.eclipse.gmf.runtime.notation.View view) {
	«EXPAND getText-»
}
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenCommonBase»«ERROR "Incorrect GenCommonBase: " + this»«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenDiagram-»
	«EXPAND getLabelFeatureText(domainDiagramElement)-»
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenChildLabelNode-»
«EXPAND getDiagramLabelText(this, labelModelFacet)-»
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenLinkLabel»«EXPAND getDiagramLabelText(link, modelFacet)»«ENDDEFINE»
«DEFINE getText FOR gmfgen::GenNodeLabel»«EXPAND getDiagramLabelText(node, modelFacet)»«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenNode-»
«IF labels.isEmpty()-»
	«EXPAND getLabelFeatureText(modelFacet.metaClass)-»
«ELSE-»
	«EXPAND getDiagramLabelText(labels)-»
«ENDIF-»
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenLink-»
«IF labels.isEmpty()-»
	«EXPAND getText(modelFacet)-»
«ELSE-»
	«EXPAND getDiagramLabelText(labels)-»
«ENDIF-»
«ENDDEFINE»

«DEFINE getDiagramLabelText(List[gmfgen::GenLabel] labels) FOR gmfgen::GenCommonBase-»
	«IF labels.isEmpty()-»
		«ERROR "Empty list of labels passed"-»
	«ENDIF-»
	«LET (gmfgen::GenLabel) labels.first() AS label-»
	«EXPAND getDiagramLabelText(this, label.modelFacet) FOR label-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE getText(gmfgen::LinkModelFacet modelFacet) FOR gmfgen::GenLink-»
	«EXPAND returnEmptyString-»
«ENDDEFINE»

«DEFINE getText(gmfgen::TypeLinkModelFacet modelFacet) FOR gmfgen::GenLink-»
	«EXPAND getLabelFeatureText(modelFacet.metaClass)-»
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenCompartment-»
return "«title»"; «EXPAND xpt::Common::nonNLS»
«ENDDEFINE»

«REM»FIXME: Refactor. Need to reuse parts of TextAware.xpt«ENDREM»
/*
 * this/self - aka hintHolder, visual element to present a text
 * elementTypeHolder - model element being displayed
 * modelFacet - may be null 
 */
«DEFINE getDiagramLabelText(gmfgen::GenCommonBase elementTypeHolder, gmfgen::LabelModelFacet labelModelFacet) FOR gmfgen::GenCommonBase-»
org.eclipse.gmf.runtime.common.ui.services.parser.IParser parser = «EXPAND parsers::ParserProvider::accessorCall(elementTypeHolder, labelModelFacet, "view.getElement() != null ? view.getElement() : view")»;
if (parser != null) {
	return parser.getPrintString(new org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter(view.getElement() != null ? view.getElement() : view), org.eclipse.gmf.runtime.common.ui.services.parser.ParserOptions.NONE.intValue());
} else {
	«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Parser was not found for label " + «visualID»);«EXPAND xpt::Common::nonNLS»
	«EXPAND returnEmptyString-»
}
«ENDDEFINE»


«DEFINE getLabelFeatureText(genmodel::GenClass genClass) FOR gmfgen::GenCommonBase-»
	«IF null != genClass && null != genClass.labelFeature-»
«EXPAND MetaModel::DeclareAndAssign("domainModelElement", "view.getElement()") FOR genClass»
if (domainModelElement != null) {
	return «IF !isStringFeature(genClass.labelFeature)»String.valueOf(«ENDIF»«EXPAND MetaModel::getFeatureValue("domainModelElement", genClass) FOR genClass.labelFeature»«IF !isStringFeature(genClass.labelFeature)»)«ENDIF»;
} else {
	«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("No domain element for view with visualID = " + «visualID»); «EXPAND xpt::Common::nonNLS»
		«EXPAND returnEmptyString-»
}
	«ELSE-»
		«EXPAND returnEmptyString-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE returnEmptyString FOR Object-»
return ""; «EXPAND xpt::Common::nonNLS»
«ENDDEFINE»

«DEFINE getUnknownElementText FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
private String getUnknownElementText(org.eclipse.gmf.runtime.notation.View view) {
	return "<UnknownElement Visual_ID = " + view.getType() + ">"; «EXPAND xpt::Common::nonNLS(1)» «EXPAND xpt::Common::nonNLS(2)»
}
«ENDDEFINE»

«DEFINE getUnresolvedDomainElementProxyText FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
private String getUnresolvedDomainElementProxyText(org.eclipse.gmf.runtime.notation.View view) {
	return "<Unresolved domain element Visual_ID = " + view.getType() + ">"; «EXPAND xpt::Common::nonNLS(1)» «EXPAND xpt::Common::nonNLS(2)»
}
«ENDDEFINE»

«DEFINE init FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public void init(org.eclipse.ui.navigator.ICommonContentExtensionSite aConfig) {
}
«ENDDEFINE»

«DEFINE restoreState FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public void restoreState(org.eclipse.ui.IMemento aMemento) {
}
«ENDDEFINE»

«DEFINE saveState FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public void saveState(org.eclipse.ui.IMemento aMemento) {
}
«ENDDEFINE»
	
«DEFINE getDescription FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
public String getDescription(Object anElement) {
	return null;
}
«ENDDEFINE»
	
«DEFINE isOwnView FOR gmfgen::GenNavigator-»
	«EXPAND xpt::Common::generatedMemberComment»
private boolean isOwnView(org.eclipse.gmf.runtime.notation.View view) {
	return «EXPAND xpt::editor::VisualIDRegistry::modelID FOR editorGen.diagram».equals(«EXPAND xpt::editor::VisualIDRegistry::getModelIDMethodCall FOR editorGen.diagram»(view));
}
«ENDDEFINE»

«DEFINE unknownElementKey FOR Object»"«EXPAND commonKeyPrefix»UnknownElement"«ENDDEFINE»

«DEFINE notFoundElementKey FOR Object»"«EXPAND commonKeyPrefix»ImageNotFound"«ENDDEFINE»

«DEFINE key FOR gmfgen::GenCommonBase»«ERROR "Incorrect GenCommonBase: " + this»«ENDDEFINE»

«DEFINE key FOR gmfgen::GenDiagram»«EXPAND commonKeyPrefix»Diagram?«EXPAND keyFragment FOR domainDiagramElement»«ENDDEFINE»

«DEFINE key FOR gmfgen::GenNode»«EXPAND commonKeyPrefix»«EXPAND keyFragment»«IF null != modelFacet»«EXPAND keyFragment FOR modelFacet.metaClass»«ELSE»«EXPAND keyFragment FOR viewmap»«ENDIF»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::GenNode»Node?«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::GenTopLevelNode»TopLevelNode?«ENDDEFINE»

«DEFINE key FOR gmfgen::GenLink»«EXPAND commonKeyPrefix»Link?«IF null != modelFacet»«EXPAND keyFragment FOR modelFacet»«ELSE»«EXPAND keyFragment FOR viewmap»«ENDIF»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::LinkModelFacet»«ERROR "Incorrect link model facet passed: " + this»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::TypeLinkModelFacet»«EXPAND keyFragment FOR metaClass»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::FeatureLinkModelFacet»«EXPAND keyFragment FOR metaFeature»«ENDDEFINE»

«DEFINE key FOR gmfgen::GenCompartment»«EXPAND key FOR node»?Compartment?«title»«ENDDEFINE»

«DEFINE key FOR gmfgen::GenLabel»«ERROR "Incorrect GenLabel:" + this»«ENDDEFINE»

«DEFINE key FOR gmfgen::GenNodeLabel»«EXPAND key FOR node»«EXPAND keyFragment»«ENDDEFINE»

«DEFINE key FOR gmfgen::GenLinkLabel»«EXPAND key FOR link»«EXPAND keyFragment»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::GenLabel»?Label?«EXPAND keyFragment(this) FOR modelFacet»«ENDDEFINE»

«DEFINE keyFragment FOR genmodel::GenClass»«genPackage.ecorePackage.nsURI»?«ecoreClass.name»«ENDDEFINE»

«DEFINE keyFragment FOR genmodel::GenFeature»«EXPAND keyFragment FOR genClass»?«ecoreFeature.name»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::Viewmap»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::FigureViewmap»«figureQualifiedClassName»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::InnerClassViewmap»«className»«ENDDEFINE»

«DEFINE keyFragment FOR gmfgen::ParentAssignedViewmap»«figureQualifiedClassName»«ENDDEFINE»

«DEFINE keyFragment(gmfgen::GenLabel label) FOR gmfgen::LabelModelFacet»«ERROR "Incorrect label model facet: " + this»«ENDDEFINE»

«DEFINE keyFragment(gmfgen::GenLabel label) FOR gmfgen::FeatureLabelModelFacet»«EXPAND keyFragment FOREACH metaFeatures»«ENDDEFINE»

«DEFINE keyFragment(gmfgen::GenLabel label) FOR gmfgen::DesignLabelModelFacet»«EXPAND keyFragment FOR label.viewmap»«ENDDEFINE»

«DEFINE commonKeyPrefix FOR Object»Navigator?«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenNavigator-»
«ENDDEFINE»
@


1.11
log
@[235113] alternative parser access, step 2: use dedicated GenParsers entry, along with exposing parts of template as API
@
text
@d297 1
a297 1
	«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Parser was not found for label " + «visualID»); «EXPAND xpt::Common::nonNLS»
@


1.10
log
@[235113] towards alternative parser access (avoiding indirection of ParserService)
@
text
@d293 1
a293 1
org.eclipse.gmf.runtime.common.ui.services.parser.IParser parser = «EXPAND xpt::providers::ParserProvider::accessorCall(elementTypeHolder, labelModelFacet, "view.getElement() != null ? view.getElement() : view")»;
@


1.9
log
@refactored not to duplicate parser service invocations and to behave the same way on null model facet regardless of whether it came from GenLabel or GenChildLabelNode
@
text
@d293 1
a293 3
final String typeHint = «IF labelModelFacet == null»«EXPAND xpt::editor::VisualIDRegistry::typeMethodCall»«ELSE»«EXPAND hint(this) FOR labelModelFacet»;«ENDIF»
org.eclipse.core.runtime.IAdaptable hintAdapter = new «getDiagram().getParserProviderQualifiedClassName()».HintAdapter(«getDiagram().getElementTypesQualifiedClassName()».«elementTypeHolder.getUniqueIdentifier()», (view.getElement() != null ? view.getElement() : view), typeHint);
org.eclipse.gmf.runtime.common.ui.services.parser.IParser parser = org.eclipse.gmf.runtime.common.ui.services.parser.ParserService.getInstance().getParser(hintAdapter);
d295 1
a295 1
	return parser.getPrintString(hintAdapter, org.eclipse.gmf.runtime.common.ui.services.parser.ParserOptions.NONE.intValue());
a301 2
«DEFINE hint(gmfgen::GenCommonBase hintHolder) FOR gmfgen::LabelModelFacet»«EXPAND xpt::editor::VisualIDRegistry::typeMethodCall FOR hintHolder»«ENDDEFINE»
«DEFINE hint(gmfgen::GenCommonBase hintHolder) FOR gmfgen::DesignLabelModelFacet»org.eclipse.gmf.runtime.common.ui.services.parser.CommonParserHint.DESCRIPTION«ENDDEFINE»
@


1.8
log
@simplified visualId-to-viewType conversion helpers
@
text
@d243 1
a243 5
«IF labelModelFacet == null-»
	«EXPAND getDiagramLabelTextNoModelFacet(this)-»
«ELSE-»
	«EXPAND getDiagramLabelText(this, this) FOR labelModelFacet-»
«ENDIF-»
d246 2
a247 7
«DEFINE getText FOR gmfgen::GenLinkLabel-»
	«EXPAND getDiagramLabelText(link, this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE getText FOR gmfgen::GenNodeLabel-»
	«EXPAND getDiagramLabelText(node, this) FOR modelFacet-»
«ENDDEFINE»
d250 5
a254 5
	«IF labels.isEmpty()-»
		«EXPAND getLabelFeatureText(modelFacet.metaClass)-»
	«ELSE-»
		«EXPAND getDiagramLabelText(labels)-»
	«ENDIF-»
d258 5
a262 5
	«IF labels.isEmpty()-»
		«EXPAND getText(modelFacet)-»
	«ELSE-»
		«EXPAND getDiagramLabelText(labels)-»
	«ENDIF-»
d270 1
a270 5
	«IF label.modelFacet == null-»
		«EXPAND getDiagramLabelTextNoModelFacet(label)-»
	«ELSE-»
		«EXPAND getDiagramLabelText(this, label) FOR label.modelFacet-»
	«ENDIF»
a273 14
«REM»FIXME: Refactor. This is a fast copy of getDiagramLabelText template (below) to fix #193178. Need to reuse parts of TextAware.xpt«ENDREM»
«DEFINE getDiagramLabelTextNoModelFacet(gmfgen::GenCommonBase label) FOR gmfgen::GenCommonBase»
		org.eclipse.core.runtime.IAdaptable hintAdapter = new «getDiagram().getParserProviderQualifiedClassName()».HintAdapter(
			«getDiagram().getElementTypesQualifiedClassName()».«getUniqueIdentifier()», 
			(view.getElement() != null ? view.getElement() : view), 
			«EXPAND xpt::editor::VisualIDRegistry::typeMethodCall FOR label»);
		org.eclipse.gmf.runtime.common.ui.services.parser.IParser parser = org.eclipse.gmf.runtime.common.ui.services.parser.ParserService.getInstance().getParser(hintAdapter);
		if (parser != null) {
			return parser.getPrintString(hintAdapter, org.eclipse.gmf.runtime.common.ui.services.parser.ParserOptions.NONE.intValue());
		} else {
			«EXPAND returnEmptyString-»
		}
«ENDDEFINE»

d286 9
a294 2
«DEFINE getDiagramLabelText(gmfgen::GenCommonBase elementTypeHolder, gmfgen::GenCommonBase hintHolder) FOR gmfgen::LabelModelFacet-»
org.eclipse.core.runtime.IAdaptable hintAdapter = new «elementTypeHolder.getDiagram().getParserProviderQualifiedClassName()».HintAdapter(«elementTypeHolder.getDiagram().getElementTypesQualifiedClassName()».«elementTypeHolder.getUniqueIdentifier()», (view.getElement() != null ? view.getElement() : view), «EXPAND hint(hintHolder)»);
a295 1
		
d299 1
a299 1
	«hintHolder.getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Parser was not found for label " + «hintHolder.visualID»); «EXPAND xpt::Common::nonNLS»
a304 1

@


1.7
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d292 1
a292 1
			«EXPAND xpt::editor::VisualIDRegistry::getTypeMethodCall FOR label.getDiagram()»(«EXPAND xpt::editor::VisualIDRegistry::visualID FOR label»));
d325 1
a325 1
«DEFINE hint(gmfgen::GenCommonBase hintHolder) FOR gmfgen::LabelModelFacet»«EXPAND xpt::editor::VisualIDRegistry::getTypeMethodCall FOR hintHolder.getDiagram()»(«EXPAND xpt::editor::VisualIDRegistry::visualID FOR hintHolder»)«ENDDEFINE»
@


1.6
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.5
log
@[150177] phase I, refactor existing code: better name (DeclareAndAssign instead of CastAndAssign), alternative method that uses feature accessor to get initial value
@
text
@d2 1
a2 1
 * Copyright (c) 2006,2007 Borland Software Corporation
d333 1
a333 1
	return «IF !isStringFeature(genClass.labelFeature)»String.valueOf(«ENDIF»«EXPAND xpt::Common::getFeatureValue("domainModelElement", genClass) FOR genClass.labelFeature»«IF !isStringFeature(genClass.labelFeature)»)«ENDIF»;
@


1.4
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d331 1
a331 1
«EXPAND MetaModel::CastAndAssign("domainModelElement", "view.getElement()") FOR genClass»
@


1.3
log
@[193178] Generated code does not compile - no code was generated for legitimate case of plain LabelMapping (which assumes existence of custom parser provider)
@
text
@d331 1
a331 1
«getQualifiedInterfaceName(genClass)» domainModelElement = («getQualifiedInterfaceName(genClass)») view.getElement();
@


1.2
log
@[191924]: Adopt lite generator to use newly created /navigator/NavigatorLabelProvider.xpt
[191954]: Adopt lite generator to use newly created /navigator/NavigatorActionProvider.xpt
@
text
@d243 3
d247 1
d279 3
d283 1
d287 14
@


1.1
log
@[191852] - Convert /navigator/NavigatorLabelProvider.javajet template to xpand
@
text
@d83 23
a105 11
	if (element instanceof «getNavigatorGroupQualifiedClassName()») {
		«getNavigatorGroupQualifiedClassName()» group = («getNavigatorGroupQualifiedClassName()») element;
		return «editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundledImage(group.getIcon());
	}
		
	if (element instanceof «getNavigatorItemQualifiedClassName()») {
		«getNavigatorItemQualifiedClassName()» navigatorItem = («getNavigatorItemQualifiedClassName()») element;
    	if (!isOwnView(navigatorItem.getView())) {
    		return super.getImage(element);
    	}
    	return getImage(navigatorItem.getView());
d107 3
d111 7
a117 7
	«IF editorGen.diagram.generateShortcutIcon()-»
	// Due to plugin.xml content will be called only for "own" views
	if (element instanceof org.eclipse.core.runtime.IAdaptable) {
		org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) ((org.eclipse.core.runtime.IAdaptable) element).getAdapter(org.eclipse.gmf.runtime.notation.View.class);
		if (view != null && isOwnView(view)) {
			return getImage(view);
		}
a118 2
	«ENDIF-»
	return super.getImage(element);
d120 4
d164 21
a184 7
	if (element instanceof «getNavigatorGroupQualifiedClassName()») {
		«getNavigatorGroupQualifiedClassName()» group = («getNavigatorGroupQualifiedClassName()») element;
		return group.getGroupName();
	}
		
	if (element instanceof «getNavigatorItemQualifiedClassName()») {
		«getNavigatorItemQualifiedClassName()» navigatorItem = («getNavigatorItemQualifiedClassName()») element;
d190 9
a198 8
	
	«IF editorGen.diagram.generateShortcutIcon()-»
	// Due to plugin.xml content will be called only for "own" views
	if (element instanceof org.eclipse.core.runtime.IAdaptable) {
		org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) ((org.eclipse.core.runtime.IAdaptable) element).getAdapter(org.eclipse.gmf.runtime.notation.View.class);
		if (view != null && isOwnView(view)) {
			return getText(view);
		}
a199 2
	«ENDIF-»
	return super.getText(element);
d201 4
d424 1
a424 1
«ENDDEFINE»@

