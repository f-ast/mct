head	1.31;
access;
symbols
	v20081022-1925:1.31
	v20081015-1925:1.31
	v20081008-1925:1.31
	v20081001-1925:1.31
	v20080924-1925:1.31
	v20080917-1925:1.31
	v20080911-1728:1.31
	v20080910-1520:1.31
	v20080903-1520:1.31
	v20080827-1520:1.31
	v20080813-1520:1.31
	v20080806-1520:1.31
	v20070608-1300:1.30
	v20070605-1400:1.30
	v20070601-1400:1.30
	v20070525-1500:1.30
	v20070520-1200:1.30
	v20070518-1300:1.30
	v20070504-1000:1.30
	v20070427-0600:1.30
	v20070420-1000:1.30
	v20070413-1300:1.30
	v20070405-1100:1.30
	v20070403-1500:1.30
	v20070330-1300:1.30
	v20060330-1300:1.30
	v20070322-1100:1.30
	v20060316-0600:1.30
	v20070307-0700:1.30
	v20070301-1200:1.30
	v20070228-2000:1.30
	v20070221-1500:1.29
	v20070208-1800:1.29
	v20070202-0200:1.26
	v20070103-0300:1.28
	M4_20:1.28
	v20061222-1800:1.28
	v20061218-1200:1.28
	v20061214-0000:1.28
	v20061120-1300:1.28
	M3_20:1.28
	v20061117-0800:1.28
	v20061027-1200:1.26
	v20061020-1000:1.26
	v20061013-1330:1.27
	v20060919-0800:1.26
	v20060907-1100:1.26
	M1_20:1.26
	v20060904-1500:1.26
	v20060824-1600:1.26
	v20060817-1500:1.26
	v20060728-0500:1.26
	v20060713-1700:1.26
	R1_0_maintenance:1.26.0.2
	R1_0:1.26
	v20060627-1200:1.26
	v20060626-1420:1.26
	v20060620-0400:1.26
	v20060616-1400:1.26
	v20060616-1200:1.26
	v20060609-1400:1.26
	v20060531-1730:1.26
	v20060530-1930:1.26
	v20060526-1200:1.26
	v20060519-1300:1.26
	v20060519-0800:1.26
	v20060512-1000:1.26
	I20060512-1000:1.26
	I20060505-1400:1.26
	I20060428-1300:1.26
	I20060424-0500:1.26
	I20060424-0300:1.26
	M6_10:1.26
	I20060407-1200:1.22
	I20060331-1000:1.20
	I20060324-0300:1.20
	I20060317-1300:1.19
	I20060317-1200:1.19
	I20060316-1300:1.19
	I20060309-1300:1.19
	M5_10:1.18
	S20060303-1600:1.18
	I20060227-1730:1.18
	I20060216-1945:1.17
	I20060210-1715:1.17
	I20060209-1815:1.17
	I20060203-0830:1.12
	I20060202-1415:1.12
	I20060129-1145:1.11
	I20060127-0900:1.11
	I20060120-1530:1.10
	I20060113-1700:1.10
	M4_10:1.10
	I20060107-1100:1.8
	I20060105-1630:1.8
	I20051230-1230:1.8
	I20051223-1100:1.8
	I20051217-0925:1.8
	I20051208-2000:1.8
	I20051201-1800:1.7
	I20051124-2000:1.6
	M3_10:1.6
	I20051118-1245:1.6
	I20051111-1800:1.5
	I20051106-0900:1.5
	v20051030:1.5
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.31
date	2007.06.13.15.14.23;	author dstadnik;	state dead;
branches;
next	1.30;
commitid	78d4467009cd4567;

1.30
date	2007.02.22.19.49.50;	author ashatalin;	state Exp;
branches;
next	1.29;
commitid	299645ddf3da4567;

1.29
date	2007.02.07.12.05.15;	author ashatalin;	state Exp;
branches;
next	1.28;
commitid	37da45c9c07a4567;

1.28
date	2006.11.16.13.31.32;	author atikhomirov;	state Exp;
branches;
next	1.27;
commitid	5510455c68334567;

1.27
date	2006.09.28.10.52.30;	author ashatalin;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.14.18.06.24;	author atikhomirov;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.13.13.43.20;	author dstadnik;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.12.08.48.33;	author dstadnik;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.10.13.40.25;	author ashatalin;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.04.11.00.59;	author ashatalin;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.03.12.52.48;	author dstadnik;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.19.16.57.17;	author ashatalin;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.17.12.02.06;	author dstadnik;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.08.16.27.57;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.08.16.06.19;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.08.00.17.45;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.31.19.02.07;	author ashatalin;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.26.13.36.40;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.10.17.20.28;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.10.16.16.58;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.05.19.16.56;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.29.18.14.04;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.13.14.21.40;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.04.15.40.38;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.04.13.18.07;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.29.09.49.41;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.20.29;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.31
log
@[192422] Rewrite Plugin.javajet template in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.editor" class="PluginGenerator"
    imports="org.eclipse.emf.common.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenPlugin genPlugin = (GenPlugin) ((Object[]) argument)[0];
final GenDiagram genDiagram = genPlugin.getEditorGen().getDiagram();
final EList genPackages = genPlugin.getEditorGen().getAllDomainGenPackages(true);
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.edit.provider.ComposedAdapterFactory;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;
import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;
import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.swt.graphics.Image;
import org.eclipse.ui.plugin.AbstractUIPlugin;
import org.osgi.framework.BundleContext;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=genPlugin.getActivatorClassName()%> extends AbstractUIPlugin {

	/**
	 * @@generated
	 */
	public static final String ID = "<%=genPlugin.getID()%>"; //$NON-NLS-1$

	/**
	 * @@generated
	 */
	public static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(ID);

	/**
	 * @@generated
	 */
	private static <%=genPlugin.getActivatorClassName()%> instance;

	/**
	 * @@generated
	 */
	private ComposedAdapterFactory adapterFactory;	

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName())%> myDocumentProvider;

	/**
	 * @@generated
	 */
	public <%=genPlugin.getActivatorClassName()%>() {
	}

	/**
	 * @@generated
	 */
	public void start(BundleContext context) throws Exception {
		super.start(context);
		instance = this;
		PreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());
		adapterFactory = createAdapterFactory();
	}

	/**
	 * @@generated
	 */
	public void stop(BundleContext context) throws Exception {
		adapterFactory.dispose();
		adapterFactory = null;
		instance = null;
		super.stop(context);
	}

	/**
	 * @@generated
	 */
	public static <%=genPlugin.getActivatorClassName()%> getInstance() {
		return instance;
	}

	/**
	 * @@generated
	 */
	protected ComposedAdapterFactory createAdapterFactory() {
		List factories = new ArrayList();
		fillItemProviderFactories(factories);
		return new ComposedAdapterFactory(factories);
	}

	/**
	 * @@generated
	 */
	protected void fillItemProviderFactories(List factories) {
<%
for (int i = 0; i < genPackages.size(); i++) {
	GenPackage genPackage = (GenPackage) genPackages.get(i);
%>
		factories.add(new <%=importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName())%>());
<%}%>
		factories.add(new ResourceItemProviderAdapterFactory());
		factories.add(new ReflectiveItemProviderAdapterFactory());
	}
	
	/**
	 * @@generated
	 */
	public AdapterFactory getItemProvidersAdapterFactory() {
		return adapterFactory;
	}

	/**
	 * @@generated
	 */
	public ImageDescriptor getItemImageDescriptor(Object item) {
		IItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);
		if (labelProvider != null) {
<%
			// XXX dependency org.eclipse.emf.edit.ui is for ExtendedImageRegistry only. 
			// FIXME move image registry to plugin class code
%>
			return ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));
		}
		return null;
	}

	/**
	 * Returns an image descriptor for the image file at the given
	 * plug-in relative path.
	 *
	 * @@generated
	 * @@param path the path
	 * @@return the image descriptor
	 */
	public static ImageDescriptor getBundledImageDescriptor(String path) {
		return AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);
	}

	/**
	 * Respects images residing in any plug-in. If path is relative,
	 * then this bundle is looked up for the image, otherwise, for absolute 
	 * path, first segment is taken as id of plug-in with image
	 *
	 * @@generated
	 * @@param path the path to image, either absolute (with plug-in id as first segment), or relative for bundled images
	 * @@return the image descriptor
	 */
	public static ImageDescriptor findImageDescriptor(String path) {
		final IPath p = new Path(path);
		if (p.isAbsolute() && p.segmentCount() > 1) {
			return AbstractUIPlugin.imageDescriptorFromPlugin(p.segment(0), p.removeFirstSegments(1).makeAbsolute().toString());
		} else {
			return getBundledImageDescriptor(p.makeAbsolute().toString());
		} 
	}

	/**
	 * Returns string from plug-in's resource bundle
	 * @@generated
	 */
	public static String getString(String key) {
		return Platform.getResourceString(getInstance().getBundle(), "%" + key); //$NON-NLS-1$
	}
	
	/**
	 * Returns an image for the image file at the given plug-in relative path.
	 * Client do not need to dispose this image. Images will be disposed automatically.
	 *
	 * @@generated
	 * @@param path the path
	 * @@return image instance
	 */
	public Image getBundledImage(String path) {
		Image image = getImageRegistry().get(path);
		if (image == null) {
			getImageRegistry().put(path, getBundledImageDescriptor(path));
			image = getImageRegistry().get(path);
		}
		return image;
	}
	
	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName())%> getDocumentProvider() {
		if (myDocumentProvider == null) {
			myDocumentProvider = new <%=importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName())%>();
		}
		return myDocumentProvider;
	}
	
	/**
	 * @@generated
	 */
	public void logError(String error) {
		logError(error, null);
	}

	/**
	 * @@param throwable actual error or null could be passed
	 * @@generated
	 */
	public void logError(String error, Throwable throwable) {
		if (error == null && throwable != null) {
			error = throwable.getMessage();
		}
		getLog().log(new Status(IStatus.ERROR, <%=genPlugin.getActivatorClassName()%>.ID, IStatus.OK, error, throwable));
		debug(error, throwable);
	}
	
	/**
	 * @@generated
	 */
	public void logInfo(String message) {
		logInfo(message, null);
	}

	/**
	 * @@param throwable actual error or null could be passed
	 * @@generated
	 */
	public void logInfo(String message, Throwable throwable) {
		if (message == null && throwable != null) {
			message = throwable.getMessage();
		}
		getLog().log(new Status(IStatus.INFO, <%=genPlugin.getActivatorClassName()%>.ID, IStatus.OK, message, throwable));
		debug(message, throwable);
	}
	
	/**
	 * @@generated
	 */
	private void debug(String message, Throwable throwable) {
		if (!isDebugging()) {
			return;
		}
		if (message != null) {
			System.err.println(message);
		}
		if (throwable != null) {
			throwable.printStackTrace();
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.30
log
@[175169] - Double-click on diagram in Project Explorer should open corresponding diagram editor as before
@
text
@@


1.29
log
@Removing *EditorInputProxies - only EditorInputs are used in generated code from now.
@
text
@a57 1
<%if (genDiagram.getEditorGen().getApplication() == null) {%>
a62 1
<%}%>
a195 1
<%if (genDiagram.getEditorGen().getApplication() == null) {%>
a205 1
<%}%>
@


1.28
log
@[162552] - Tool descriptions that contain special characters yield uncompilable code
Refactored to use externalized strings instead (for now from plugin.xml, may later switch to new nls bundles)
@
text
@d57 8
a64 1
	private ComposedAdapterFactory adapterFactory;
d198 12
@


1.27
log
@[158991] - Generating useless / inefficient code
@
text
@d18 1
d166 8
a243 1
	
@


1.26
log
@#128404 palette factory ignores bundle name
@
text
@d214 1
a214 1
		if (message == null && message != null) {
@


1.25
log
@remove stale code
@
text
@d15 1
d17 1
d147 18
@


1.24
log
@#126200 register element types in xml
@
text
@a68 1
		//<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.register();
@


1.23
log
@#135653 Generated GMF examples use internal API
@
text
@d69 1
a69 1
		<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.register();
@


1.22
log
@Rollback of the latest changes to make running unit-tests + all the rest of the generated diagrams containing several diagram elements with the same EClass.

Original changes was made for fixing #126200.
@
text
@a68 8
<%
for (int i = 0; i < genPackages.size(); i++) {
	GenPackage genPackage = (GenPackage) genPackages.get(i);
	String domainPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
	String domainPackageEditPluginClassName = importManager.getImportedName(genPackage.getQualifiedEditPluginClassName());
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.MetamodelManager")%>.register(<%=domainPackageInterfaceName%>.eINSTANCE, <%=domainPackageEditPluginClassName%>.INSTANCE);
<%}%>
@


1.21
log
@#126200 register element types in xml
@
text
@d77 1
@


1.20
log
@#128024 Model references are not recognized as links
#131543 Obsolete code should be eliminated
@
text
@a76 1
		<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.register();
@


1.19
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@a71 1
	String domainPackageIPAFInterfaceName = importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName());
a74 1
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager")%>.register(new <%=domainPackageIPAFInterfaceName%>());
@


1.18
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d8 3
a10 2

importManager.emitPackageStatement(stringBuffer);%>
@


1.17
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d2 1
a2 1
    imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
d6 1
a6 1
final GenModel genModel = genPlugin.getEditorGen().getDomainGenModel();
a23 2
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;
a67 1
		//FIXME itemProviderAF, metaPackage and editPlugin are only for package of diagramMetaElement
d69 5
a73 4
GenPackage genPackage = genDiagram.getDomainDiagramElement().getGenPackage();
String domainPackageIPAFInterfaceName = importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName());
String domainPackageInterfaceName = genDiagram.getMetaPackageName(importManager);
String domainPackageEditPluginClassName = importManager.getImportedName(genPackage.getQualifiedEditPluginClassName());
d75 3
a77 2
		MSLAdapterFactoryManager.register(new <%=domainPackageIPAFInterfaceName%>());
		MSLMetaModelManager.register(<%=domainPackageInterfaceName%>.eINSTANCE, <%=domainPackageEditPluginClassName%>.INSTANCE);
a112 1
List genPackages = genModel.getAllGenPackagesWithClassifiers();
d114 1
a114 2
	genPackage = (GenPackage) genPackages.get(i);
	if (genPackage.getGenModel().hasEditSupport()) {
d117 1
a117 13
<%
	}
}
genPackages = genModel.getAllUsedGenPackagesWithClassifiers();
for (int i = 0; i < genPackages.size(); i++) {
	genPackage = (GenPackage) genPackages.get(i);
	if (genPackage.getGenModel().hasEditSupport()) {
%>
		factories.add(new <%=importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName())%>());
<%
	}
}
%>
@


1.16
log
@EDITOR_ID moved out from plugin to Editor
@
text
@d4 1
a4 1
final GenPlugin genPlugin = (GenPlugin) argument;
d7 3
a9 2
%>
package <%=genDiagram.getEditorGen().getEditor().getPackageName()%>;
a10 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditorGen().getEditor().getPackageName());%>
@


1.15
log
@GenEditorViewer incapsulates all Eclipse's IEditorPart-related info
@
text
@d45 1
a45 6
	public static final String EDITOR_ID = "<%=genPlugin.getEditorGen().getEditor().getID()%>";

	/**
	 * @@generated
	 */
	public static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(EDITOR_ID);
@


1.14
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d8 1
a8 1
package <%=genDiagram.getEditorPackageName()%>;
d10 1
a10 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditorPackageName());%>
d45 1
a45 1
	public static final String EDITOR_ID = "<%=genDiagram.getEditorQualifiedClassName()%>ID";
@


1.13
log
@ImportManager moved to oeg.common
@
text
@d4 3
a6 3
GenPlugin genPlugin = (GenPlugin) argument;
GenDiagram genDiagram = genPlugin.getDiagram();
GenModel genModel = genDiagram.getEMFGenModel();
d75 1
d77 1
a77 1
GenPackage genPackage = genDiagram.getDomainMetaModel();
d79 1
a79 1
String domainPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
@


1.12
log
@#125893
Logging methods
@
text
@d2 1
a2 1
    imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.ImportUtil"%>
@


1.11
log
@GenDiagram "slicing" goes on and this time attributes related to plugin activator class were moved into separate entity
@
text
@d14 3
d191 54
@


1.10
log
@As a part of implementstion
#114178,114179
"Shortcutting" diagram elements.
@
text
@d4 2
a5 1
GenDiagram genDiagram = (GenDiagram) argument;
d32 1
a32 1
public class <%=genDiagram.getPluginClassName()%> extends AbstractUIPlugin {
d37 1
a37 1
	public static final String ID = "<%=genDiagram.getPluginID()%>"; //$NON-NLS-1$
d52 1
a52 1
	private static <%=genDiagram.getPluginClassName()%> instance;
d62 1
a62 1
	public <%=genDiagram.getPluginClassName()%>() {
d97 1
a97 1
	public static <%=genDiagram.getPluginClassName()%> getInstance() {
@


1.9
log
@As a part of implementstion
#114178,114179
"Shortcutting" diagram elements.
@
text
@d12 2
d136 7
@


1.8
log
@#117731 icons defined has no effect in the generated code
@
text
@d21 1
d161 17
@


1.7
log
@#118447 new-style bundle manifest (manifest.mf)
@
text
@d157 1
a157 1
	public static ImageDescriptor getImageDescriptor(String path) {
@


1.6
log
@#116031 avoid hardcoded class names in templates
@
text
@d140 4
@


1.5
log
@[ashatalin] #112122 Action to initialize diagram for domain model.
 unique id introduced, refactoring to use it throughout the code
@
text
@a22 1
import <%=genDiagram.getProvidersPackageName()%>.ElementTypes;
d76 1
a76 1
		ElementTypes.register();
@


1.4
log
@[dstadnik]
#111455 Generate consistent names for notation view factories
#111461 Do not use 'final' keyword in method parameters
#111460 Generate dedicated edit part for the node label
#111457 Use model labels in palette factory
@
text
@d44 5
d68 1
a68 1
		PreferencesHint.registerPreferenceStore(new PreferencesHint(EDITOR_ID), getPreferenceStore());
@


1.3
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d2 5
a6 2
    imports="org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.ImportUtil"%>
<%GenDiagram genDiagram = (GenDiagram) argument;%>
d10 7
d44 6
a49 1
	private static <%=genDiagram.getPluginClassName()%> ourInstance;
d62 1
a62 1
		ourInstance = this;
d73 1
d80 3
a82 1
		ourInstance = null;
d90 49
a138 1
		return ourInstance;
@


1.2
log
@[dstadnik] Use Notation Model as runtime model
@
text
@a3 1
<%GenModel genModel = genDiagram.getEmfGenModel();%>
d50 1
a50 1
GenPackage genPackage = genDiagram.getEmfGenModel().findGenPackage(genDiagram.getDomainMetaModel());
@


1.1
log
@*** empty log message ***
@
text
@d1 2
a2 1
<%@@ jet package="org.eclipse.gmf.codegen.templates.diacanvas" class="PluginGen" imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.ImportUtil"%>
d4 1
a5 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditPartsPackageName());%>
d7 5
d14 1
a14 1

d21 11
d49 10
d75 12
d88 1
a88 1
<%importManager.emitSortedImports();%>@

