head	1.19;
access;
symbols
	v20081022-1925:1.19
	v20081015-1925:1.19
	v20081008-1925:1.19
	v20081001-1925:1.19
	v20080924-1925:1.19
	v20080917-1925:1.19
	v20080911-1728:1.19
	v20080910-1520:1.19
	v20080903-1520:1.19
	v20080827-1520:1.19
	v20080813-1520:1.19
	v20080806-1520:1.19
	v20070202-0200:1.10.2.1
	v20070103-0300:1.18
	M4_20:1.18
	v20061222-1800:1.17
	v20061218-1200:1.17
	v20061214-0000:1.17
	v20061120-1300:1.17
	M3_20:1.16
	v20061117-0800:1.16
	v20061027-1200:1.10.2.1
	v20061020-1000:1.10.2.1
	v20061013-1330:1.12
	v20060919-0800:1.10.2.1
	v20060907-1100:1.10.2.1
	M1_20:1.11
	v20060904-1500:1.11
	v20060824-1600:1.10.2.1
	v20060817-1500:1.10
	v20060728-0500:1.10
	v20060713-1700:1.10
	R1_0_maintenance:1.10.0.2
	R1_0:1.10
	v20060627-1200:1.10
	v20060626-1420:1.10
	v20060620-0400:1.10
	v20060616-1400:1.10
	v20060616-1200:1.10
	v20060609-1400:1.10
	v20060531-1730:1.10
	v20060530-1930:1.10
	v20060526-1200:1.10
	v20060519-1300:1.10
	v20060519-0800:1.10
	v20060512-1000:1.10
	I20060512-1000:1.10
	I20060505-1400:1.10
	I20060428-1300:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.10
	I20060331-1000:1.10
	I20060324-0300:1.10
	I20060317-1300:1.10
	I20060317-1200:1.10
	I20060316-1300:1.10
	I20060309-1300:1.10
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.7
	I20060216-1945:1.7
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.3
	I20060202-1415:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051208-2000:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.19
date	2007.02.02.10.49.59;	author ashatalin;	state dead;
branches;
next	1.18;
commitid	527745c317554567;

1.18
date	2007.01.02.16.46.38;	author ashatalin;	state Exp;
branches;
next	1.17;
commitid	1f8459a8c6d4567;

1.17
date	2006.11.20.19.59.27;	author ashatalin;	state Exp;
branches;
next	1.16;
commitid	5e374562091f4567;

1.16
date	2006.11.14.19.23.44;	author ashatalin;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.10.15.39.56;	author ashatalin;	state Exp;
branches;
next	1.14;
commitid	6da745549d4c4567;

1.14
date	2006.10.26.14.24.57;	author ashatalin;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.24.19.20.43;	author ashatalin;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.05.18.43.33;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.23.20.01.07;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.07.15.45.28;	author dstadnik;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2006.03.01.14.55.16;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.01.13.02.25;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.16.06.19;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.15.00.14;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.03.18.34.55;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.24.17.02.53;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.19.17.56.08;	author atikhomirov;	state Exp;
branches;
next	;

1.10.2.1
date	2006.08.23.20.11.04;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Document Provider generated using xpand templates.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.editor" class="DocumentProviderGenerator"
    imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%importManager.addImport("org.eclipse.emf.ecore.EObject");%>
<%importManager.addImport("java.io.IOException");%>
<%importManager.addImport("java.util.ArrayList");%>
<%importManager.addImport("java.util.Collection");%>
<%importManager.addImport("java.util.Collections");%>
<%importManager.addImport("java.util.HashMap");%>
<%importManager.addImport("java.util.Iterator");%>
<%importManager.addImport("java.util.Map");%>
<%importManager.addImport("java.util.Map.Entry");%>
<%importManager.addImport("org.eclipse.core.resources.IFile");%>
<%importManager.addImport("org.eclipse.core.resources.IResource");%>
<%importManager.addImport("org.eclipse.core.resources.IResourceChangeEvent");%>
<%importManager.addImport("org.eclipse.core.resources.IResourceChangeListener");%>
<%importManager.addImport("org.eclipse.core.resources.IResourceDelta");%>
<%importManager.addImport("org.eclipse.core.resources.IResourceDeltaVisitor");%>
<%importManager.addImport("org.eclipse.core.resources.IResourceStatus");%>
<%importManager.addImport("org.eclipse.core.resources.IStorage");%>
<%importManager.addImport("org.eclipse.core.resources.IWorkspace");%>
<%importManager.addImport("org.eclipse.core.resources.ResourcesPlugin");%>
<%importManager.addImport("org.eclipse.core.runtime.CoreException");%>
<%importManager.addImport("org.eclipse.core.runtime.IPath");%>
<%importManager.addImport("org.eclipse.core.runtime.IProgressMonitor");%>
<%importManager.addImport("org.eclipse.core.runtime.IStatus");%>
<%importManager.addImport("org.eclipse.core.runtime.Status");%>
<%importManager.addImport("org.eclipse.core.runtime.jobs.ISchedulingRule");%>
<%importManager.addImport("org.eclipse.core.runtime.jobs.MultiRule");%>
<%importManager.addImport("org.eclipse.emf.common.notify.Notification");%>
<%importManager.addImport("org.eclipse.emf.common.util.URI");%>
<%importManager.addImport("org.eclipse.emf.ecore.resource.Resource");%>
<%importManager.addImport("org.eclipse.emf.ecore.resource.ResourceSet");%>
<%importManager.addImport("org.eclipse.emf.ecore.util.EContentAdapter");%>
<%importManager.addImport("org.eclipse.emf.transaction.NotificationFilter");%>
<%importManager.addImport("org.eclipse.emf.transaction.TransactionalEditingDomain");%>
<%importManager.addImport("org.eclipse.emf.workspace.util.WorkspaceSynchronizer");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument");%>
<%importManager.addImport("org.eclipse.gmf.runtime.notation.Diagram");%>
<%importManager.addImport("org.eclipse.swt.widgets.Display");%>
<%importManager.addImport("org.eclipse.ui.IEditorInput");%>
<%importManager.addImport("org.eclipse.ui.IFileEditorInput");%>
<%importManager.addImport("org.eclipse.ui.IStorageEditorInput");%>
<%importManager.addImport("org.eclipse.ui.part.FileEditorInput");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.StorageDocumentProvider");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileEditorInputProxy");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.util.DiagramIOUtil");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.EditorStatusCodes");%>
<%importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocumentProvider");%>
<%importManager.registerInnerClass("ResourceSetInfo");%>
<%importManager.registerInnerClass("ResourceSetSynchronizer");%>
<%importManager.registerInnerClass("ResourceSetModificationListener");%>
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=importManager.getCompilationUnitName()%> extends StorageDocumentProvider implements IDiagramDocumentProvider {
	/**
	 * @@generated
	 */
	private final String myContentObjectURI;

	/**
	 * @@generated
	 */
	public <%=importManager.getCompilationUnitName()%>() {
		this(null);
	}

	/**
	 * @@generated
	 */
	public <%=importManager.getCompilationUnitName()%>(String rootObjectURI) {
		myContentObjectURI = rootObjectURI;
	}

	/**
	 * @@generated
	 */
	protected ElementInfo createElementInfo(Object element) throws CoreException {
		if (false == element instanceof FileEditorInputProxy) {
			throw new CoreException(new Status(IStatus.ERROR, <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.ID, 0, "Incorrect element used: " + element + " instead of FileEditorInputProxy", null));
		}
		FileEditorInputProxy editorInput = (FileEditorInputProxy) element;
		IDiagramDocument document = (IDiagramDocument) createDocument(editorInput);

		ResourceSetInfo info = new ResourceSetInfo(document, editorInput);
		info.setModificationStamp(computeModificationStamp(info));
		info.fStatus = null;
		ResourceSetModificationListener modificationListener = new ResourceSetModificationListener(info);
		info.getResourceSet().eAdapters().add(modificationListener);
		return info;
	}

	/**
	 * @@generated
	 */
	private long computeModificationStamp(ResourceSetInfo info) {
		int result = 0;
		for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
			Resource nextResource = (Resource) it.next();
			IFile file = WorkspaceSynchronizer.getFile(nextResource);
			if (file != null) {
				if (file.getLocation() != null) {
					result += file.getLocation().toFile().lastModified();
				} else {
					result += file.getModificationStamp();
				}
			}
		}
		return result;
	}

	/**
	 * @@generated
	 */
	protected IDocument createEmptyDocument() {
		return new DiagramDocument();
	}

	/**
	 * @@generated
	 */
	protected boolean setDocumentContent(IDocument document, IEditorInput editorInput) throws CoreException {
		if (editorInput instanceof FileEditorInputProxy && document instanceof IDiagramDocument) {
			FileEditorInputProxy editorInputProxy = (FileEditorInputProxy) editorInput;
			IDiagramDocument diagramDocument = (IDiagramDocument) document;
			diagramDocument.setEditingDomain(editorInputProxy.getEditingDomain());
		}
		return super.setDocumentContent(document, editorInput);
	}

	/**
	 * @@generated
	 */
	protected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {
		IDiagramDocument diagramDocument = (IDiagramDocument) document;
		Diagram diagram = diagramDocument.getDiagram();

		TransactionalEditingDomain domain = diagramDocument.getEditingDomain();
		diagram = DiagramIOUtil.load(domain, storage, true, getProgressMonitor());
		if (myContentObjectURI != null && diagram != null && diagram.eResource() != null && !diagram.eResource().getURIFragment(diagram).equals(myContentObjectURI)) {
			EObject anotherContentObject = diagram.eResource().getEObject(myContentObjectURI);
			document.setContent(anotherContentObject);
		} else {
			document.setContent(diagram);
		}
	}

	/**
	 * @@generated
	 */
	public long getModificationStamp(Object element) {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			return computeModificationStamp(info);
		}
		return super.getModificationStamp(element);
	}

	/**
	 * @@generated
	 */
	public long getSynchronizationStamp(Object element) {
		if (element instanceof FileEditorInputProxy) {
			ResourceSetInfo info = getResourceSetInfo(element);
			if (info != null) {
				return info.getModificationStamp();
			}
		}
		return super.getSynchronizationStamp(element);
	}

	/**
	 * @@generated
	 */
	public boolean isDeleted(Object element) {
		if (element instanceof IFileEditorInput) {
			IFileEditorInput input = (IFileEditorInput) element;
			IPath path = input.getFile().getLocation();
			if (path == null) {
				return true;
			}
			return !path.toFile().exists();
		}
		return super.isDeleted(element);
	}

	/**
	 * @@generated
	 */
	public ResourceSetInfo getResourceSetInfo(Object editorInput) {
		return (ResourceSetInfo) super.getElementInfo(editorInput);
	}

	/**
	 * @@generated
	 */
	protected void disposeElementInfo(Object element, ElementInfo info) {
		if (info instanceof ResourceSetInfo) {
			ResourceSetInfo resourceSetInfo = (ResourceSetInfo) info;
			resourceSetInfo.dispose();
		}
		super.disposeElementInfo(element, info);
	}

	/**
	 * @@generated
	 */
	protected void doValidateState(Object element, Object computationContext) throws CoreException {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			Collection files2Validate = new ArrayList();
			for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
				Resource nextResource = (Resource) it.next();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null && file.isReadOnly()) {
					files2Validate.add(file);
				}
			}
			ResourcesPlugin.getWorkspace().validateEdit((IFile[]) files2Validate.toArray(new IFile[files2Validate.size()]), computationContext);
		}

		super.doValidateState(element, computationContext);
	}

	/**
	 * @@generated
	 */
	public boolean isModifiable(Object element) {
		if (!isStateValidated(element)) {
			if (element instanceof FileEditorInputProxy) {
				return true;
			}
		}
		return super.isModifiable(element);
	}

	/**
	 * @@generated
	 */
	protected void updateCache(IStorageEditorInput input) throws CoreException {
		ResourceSetInfo info = getResourceSetInfo(input);
		if (info != null) {
			for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
				Resource nextResource = (Resource) it.next();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null && file.isReadOnly()) {
					info.fIsReadOnly = true;
					info.fIsModifiable = false;
					return;
				}
			}
			info.fIsReadOnly = false;
			info.fIsModifiable = true;
			return;
		}
		super.updateCache(input);
	}

	/**
	 * @@generated
	 */
	public boolean isSynchronized(Object element) {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			return info.isSynchronized();
		}
		return super.isSynchronized(element);
	}

	/**
	 * @@generated
	 */
	protected ISchedulingRule getResetRule(Object element) {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			Collection rules = new ArrayList();
			for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
				Resource nextResource = (Resource) it.next();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null) {
					rules.add(ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(file));
				}
			}
			return new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));
		}
		return null;
	}

	/**
	 * @@generated
	 */
	protected ISchedulingRule getSaveRule(Object element) {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			Collection rules = new ArrayList();
			for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
				Resource nextResource = (Resource) it.next();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null) {
					rules.add(computeSchedulingRule(file));
				}
			}
			return new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));
		}
		return null;
	}

	/**
	 * @@generated
	 */
	protected ISchedulingRule getSynchronizeRule(Object element) {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			Collection rules = new ArrayList();
			for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
				Resource nextResource = (Resource) it.next();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null) {
					rules.add(ResourcesPlugin.getWorkspace().getRuleFactory().refreshRule(file));
				}
			}
			return new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));
		}
		return null;
	}

	/**
	 * @@generated
	 */
	protected ISchedulingRule getValidateStateRule(Object element) {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			Collection files = new ArrayList();
			for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
				Resource nextResource = (Resource) it.next();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null) {
					files.add(file);
				}
			}
			return ResourcesPlugin.getWorkspace().getRuleFactory().validateEditRule((IFile[]) files.toArray(new IFile[files.size()]));
		}
		return null;
	}

	/**
	 * @@generated
	 */
	private ISchedulingRule computeSchedulingRule(IResource toCreateOrModify) {
		if (toCreateOrModify.exists())
			return ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(toCreateOrModify);

		IResource parent = toCreateOrModify;
		do {
			/*
			 * XXX This is a workaround for
			 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601
			 * IResourceRuleFactory.createRule should iterate the hierarchy
			 * itself.
			 */
			toCreateOrModify = parent;
			parent = toCreateOrModify.getParent();
		} while (parent != null && !parent.exists());

		return ResourcesPlugin.getWorkspace().getRuleFactory().createRule(toCreateOrModify);
	}

	/**
	 * @@generated
	 */
	protected void doSynchronize(Object element, IProgressMonitor monitor) throws CoreException {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null && element instanceof FileEditorInputProxy) {
			handleResourcesChanged(info, info.getResourceSet().getResources(), monitor);
			return;
		}
		super.doSynchronize(element, monitor);
	}

	/**
	 * @@generated
	 */
	protected void handleResourcesMoved(Map movedPathToResource) {
		for (Iterator it = movedPathToResource.entrySet().iterator(); it.hasNext();) {
			Entry nextEntry = (Entry) it.next();
			IPath newPath = (IPath) nextEntry.getKey();
			Resource resource = (Resource) nextEntry.getValue();
			resource.setURI(URI.createURI(newPath.toString()));
		}
	}

	/**
	 * @@generated
	 */
	protected void markWholeResourceSetAsDirty(ResourceSet resourceSet) {
		for (Iterator it = resourceSet.getResources().iterator(); it.hasNext();) {
			Resource nextResource = (Resource) it.next();
			nextResource.setModified(true);
		}
	}

	/**
	 * @@generated
	 */
	protected void handleResourcesChanged(ResourceSetInfo info, Collection changedResources, IProgressMonitor monitor) {
		info.stopResourceListening();
		for (Iterator it = changedResources.iterator(); it.hasNext();) {
			Resource nextResource = (Resource) it.next();
			IFile file = WorkspaceSynchronizer.getFile(nextResource);
			if (file != null) {
				try {
					file.refreshLocal(IResource.DEPTH_INFINITE, monitor);
				} catch (CoreException e) {
					handleCoreException(e, "FileDocumentProvider.handleElementContentChanged");
				}
			}
			nextResource.unload();
		}
		info.startResourceListening();

		fireElementContentAboutToBeReplaced(info.getEditorInput());
		removeUnchangedElementListeners(info.getEditorInput(), info);
		info.fStatus = null;
		try {
			setDocumentContent(info.fDocument, info.getEditorInput());
		} catch (CoreException e) {
			info.fStatus = e.getStatus();
		}
		if (!info.fCanBeSaved) {
			info.setModificationStamp(computeModificationStamp(info));
		}
		addUnchangedElementListeners(info.getEditorInput(), info);
		fireElementContentReplaced(info.getEditorInput());
	}

	/**
	 * @@generated
	 */
	protected void doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) throws CoreException {
		ResourceSetInfo info = getResourceSetInfo(element);
		if (info != null) {
			if (!overwrite && !info.isSynchronized()) {
				throw new CoreException(new Status(IStatus.ERROR, <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.ID, IResourceStatus.OUT_OF_SYNC_LOCAL, "The file has been changed on the file system", null));
			}
			info.stopResourceListening();
			fireElementStateChanging(element);
			try {
				monitor.beginTask("Saving diagram editor", info.getResourceSet().getResources().size());
				for (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {
					Resource nextResource = (Resource) it.next();
					monitor.setTaskName("Saving " + nextResource.getURI());
					if (nextResource.isLoaded() && (!nextResource.isTrackingModification() || nextResource.isModified())) {
						nextResource.save(Collections.EMPTY_MAP);
					}
					monitor.worked(1);
				}
				monitor.done();
			} catch (IOException e) {
				fireElementStateChangeFailed(element);
				throw new CoreException(new Status(IStatus.ERROR, <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.ID, EditorStatusCodes.RESOURCE_FAILURE, e.getLocalizedMessage(), null));
			} catch (RuntimeException x) {
				fireElementStateChangeFailed(element);
				throw x;
			} finally {
				info.startResourceListening();
			}

			if (info != null) {
				info.setModificationStamp(computeModificationStamp(info));
				info.setSynchronized();
			}
		}
		super.doSaveDocument(monitor, element, document, overwrite);
	}

	/**
	 * @@generated
	 */
	protected void handleElementMoved(FileEditorInputProxy input, IPath path) {
		IWorkspace workspace = ResourcesPlugin.getWorkspace();
		IFile newFile = workspace.getRoot().getFile(path);
		fireElementMoved(input, newFile == null ? null : new FileEditorInput(newFile));
	}

	/**
	 * @@generated
	 */
	protected void handleElementDeleted(FileEditorInputProxy input) {
		fireElementDeleted(input);
	}

	/**
	 * @@generated
	 */
	public IEditorInput createInputWithEditingDomain(IEditorInput editorInput, TransactionalEditingDomain domain) {
		if (editorInput instanceof IFileEditorInput) {
			return new FileEditorInputProxy((IFileEditorInput) editorInput, domain);
		}
		assert false;
		return null;
	}

	/**
	 * @@generated
	 */
	public IDiagramDocument getDiagramDocument(Object element) {
		IDocument doc = getDocument(element);
		if (doc instanceof IDiagramDocument) {
			return (IDiagramDocument) doc;
		}
		return null;
	}

	/**
	 * @@generated
	 */	
	protected class ResourceSetInfo extends StorageInfo {

		/**
		 * @@generated
		 */
	 	private long myModificationStamp = IResource.NULL_STAMP;

		/**
		 * @@generated
		 */
		private ResourceSetSynchronizer mySynchronizer;

		/**
		 * @@generated
		 */
		private ResourceSet myResourceSet;

		/**
		 * @@generated
		 */
		private Collection myUnSynchronizedResources = new ArrayList();

		/**
		 * @@generated
		 */
		private FileEditorInputProxy myEditorInput;

		/**
		 * @@generated
		 */
		public ResourceSetInfo(IDiagramDocument document, FileEditorInputProxy editorInput) {
			super(document);
			myResourceSet = document.getEditingDomain().getResourceSet();
			myEditorInput = editorInput;
			mySynchronizer = new ResourceSetSynchronizer(this);
			startResourceListening();
		}

		/**
		 * @@generated
		 */
		public long getModificationStamp() {
			return myModificationStamp;
		}

		/**
		 * @@generated
		 */
		public void setModificationStamp(long modificationStamp) {
			myModificationStamp = modificationStamp;
		}

		/**
		 * @@generated
		 */
		public ResourceSetSynchronizer getSynchronizer() {
			return mySynchronizer;
		}

		/**
		 * @@generated
		 */
		public ResourceSet getResourceSet() {
			return myResourceSet;
		}

		/**
		 * @@generated
		 */
		public FileEditorInputProxy getEditorInput() {
			return myEditorInput;
		}

		/**
		 * @@generated
		 */
		public void dispose() {
			stopResourceListening();
		}

		/**
		 * @@generated
		 */
		public boolean isSynchronized() {
			return myUnSynchronizedResources.size() == 0;
		}

		/**
		 * @@generated
		 */
		public void setSynchronized() {
			myUnSynchronizedResources.clear();
		}

		/**
		 * @@generated
		 */
		public void setUnSynchronized(Resource resource) {
			myUnSynchronizedResources.add(resource);
		}

		/**
		 * @@generated
		 */
		public void setSynchronized(Resource resource) {
			myUnSynchronizedResources.remove(resource);
		}

		/**
		 * @@generated
		 */
		public final void stopResourceListening() {
			ResourcesPlugin.getWorkspace().removeResourceChangeListener(mySynchronizer);
		}

		/**
		 * @@generated
		 */
		public final void startResourceListening() {
			ResourcesPlugin.getWorkspace().addResourceChangeListener(mySynchronizer, IResourceChangeEvent.POST_CHANGE);
		}

	}
	
	/**
	 * @@generated
	 */	
	protected class ResourceSetSynchronizer implements IResourceChangeListener {

		/**
		 * @@generated
		 */	
		private ResourceSetInfo myInfo;

		/**
		 * @@generated
		 */	
		protected ResourceSetSynchronizer(ResourceSetInfo info) {
			myInfo = info;
		}

		/**
		 * @@generated
		 */	
		public void resourceChanged(IResourceChangeEvent event) {
			final ResourceDeltaVisitor deltaVisitor = new ResourceDeltaVisitor();
			try {
				event.getDelta().accept(deltaVisitor);
			} catch (CoreException e) {
				handleCoreException(e, "FileDocumentProvider.resourceChanged");
			}
			synchronized (myInfo) {
				if (!myInfo.isSynchronized()) {
					return;
				}
			}

			Display.getDefault().asyncExec(new Runnable() {

				public void run() {
					if (deltaVisitor.getDeletedResources().size() > 0) {
						// Just closing editor
						handleElementDeleted(myInfo.getEditorInput());
						return;
					}

					Entry diagramEntry = getDiagramResourceEntry(deltaVisitor.getMovedResourcesMap());
					if (diagramEntry != null) {
						deltaVisitor.getMovedResourcesMap().remove(diagramEntry.getKey());
						// Setting new editor input since diagram file was
						// renamed Could be processed together with the rest of
						// moved resources if FileEditorInputProxy will wupport
						// IFileEditorInput substitution
						handleElementMoved(myInfo.getEditorInput(), (IPath) diagramEntry.getKey());
					}
					if (deltaVisitor.getMovedResourcesMap().size() > 0) {
						handleResourcesMoved(deltaVisitor.getMovedResourcesMap());
					}
					if (deltaVisitor.getChangedResources().size() > 0 || deltaVisitor.getMovedResourcesMap().size() > 0) {
						// reloading changed resources + changing URIs for moved
						// resources
						handleResourcesChanged(myInfo, deltaVisitor.getChangedResources(), null);
					}
					if (deltaVisitor.getMovedResourcesMap().size() > 0) {
						// Marking whole ResourceSet as changed to preserve
						// changes in resource URIs made by
						// handleResourcesMoved() call
						markWholeResourceSetAsDirty(myInfo.getResourceSet());
					}
				}
			});
		}

		/**
		 * @@generated
		 */	
		private Entry getDiagramResourceEntry(Map movedResources) {
			for (Iterator it = movedResources.entrySet().iterator(); it.hasNext();) {
				Entry nextEntry = (Entry) it.next();
				Resource nextResource = (Resource) nextEntry.getValue();
				IFile file = WorkspaceSynchronizer.getFile(nextResource);
				if (file != null && file.equals(myInfo.getEditorInput().getFile())) {
					return nextEntry;
				}
			}
			return null;
		}

		/**
		 * @@generated
		 */	
		private class ResourceDeltaVisitor implements IResourceDeltaVisitor {

			/**
			 * @@generated
			 */	
			private Collection myChangedResources = new ArrayList();

			/**
			 * @@generated
			 */	
			private Map myMovedResources = new HashMap();

			/**
			 * @@generated
			 */	
			private Collection myDeletedResources = new ArrayList();

			/**
			 * Can be called from any thread
			 * @@generated
			 */	
			public boolean visit(IResourceDelta delta) {
				if (delta.getFlags() != IResourceDelta.MARKERS && delta.getResource().getType() == IResource.FILE) {
					if ((delta.getKind() & (IResourceDelta.CHANGED | IResourceDelta.REMOVED)) != 0) {
						Resource resource = myInfo.getResourceSet().getResource(URI.createURI(delta.getFullPath().toString()), false);
						if (resource != null && resource.isLoaded()) {
							synchronized (myInfo) {
								if (myInfo.fCanBeSaved) {
									myInfo.setUnSynchronized(resource);
									return false;
								}
							}
							if ((delta.getKind() & IResourceDelta.REMOVED) != 0) {
								// element could be either moved/deleted or
								// changed.
								if ((IResourceDelta.MOVED_TO & delta.getFlags()) != 0) {
									IPath destination = delta.getMovedToPath();
									myMovedResources.put(destination, resource);
								} else {
									myDeletedResources.add(resource);
								}
							} else {
								myChangedResources.add(resource);
							}
						}
					}
				}

				return true;
			}

			/**
			 * @@generated
			 */	
			public Collection getChangedResources() {
				return myChangedResources;
			}

			/**
			 * @@generated
			 */	
			public Collection getDeletedResources() {
				return myDeletedResources;
			}

			/**
			 * @@generated
			 */	
			public Map getMovedResourcesMap() {
				return myMovedResources;
			}
		}

	}
	
	/**
	 * @@generated
	 */	
	private class ResourceSetModificationListener extends EContentAdapter {

		/**
		 * @@generated
		 */	
		private NotificationFilter myModifiedFilter;

		/**
		 * @@generated
		 */	
		private ResourceSetInfo myInfo;

		/**
		 * @@generated
		 */	
		public ResourceSetModificationListener(ResourceSetInfo info) {
			myInfo = info;
			myModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET).or(NotificationFilter.createEventTypeFilter(Notification.UNSET)).and(
					NotificationFilter.createFeatureFilter(Resource.class, Resource.RESOURCE__IS_MODIFIED));
		}

		/**
		 * @@generated
		 */	
		public void notifyChanged(Notification notification) {
			if (notification.getNotifier() instanceof ResourceSet) {
				super.notifyChanged(notification);
			}
			if (myModifiedFilter.matches(notification)) {
				if (notification.getNotifier() instanceof Resource) {
					Resource resource = (Resource) notification.getNotifier();
					if (resource.isLoaded()) {
						boolean modified = false;
						for (Iterator it = myInfo.getResourceSet().getResources().iterator(); it.hasNext() && !modified;) {
							Resource nextResource = (Resource) it.next();
							if (nextResource.isLoaded()) {
								modified = nextResource.isModified();
							}
						}
						boolean dirtyStateChanged = false;
						synchronized (myInfo) {
							if (modified != myInfo.fCanBeSaved) {
								myInfo.fCanBeSaved = modified;
								dirtyStateChanged = true;
							}
							if (!resource.isModified()) {
								myInfo.setSynchronized(resource);
							}
						}
						if (dirtyStateChanged) {
							fireElementDirtyStateChanged(myInfo.getEditorInput(), modified);
							if (!modified) {
								myInfo.setModificationStamp(computeModificationStamp(myInfo));
							}
						}
					}

				}
			}
		}
	}

}
<%importManager.emitSortedImports();%>
@


1.18
log
@[169303] - DocumentProvider.computeModificationStamp fails for plugin resources
@
text
@@


1.17
log
@Correcting null pointer exception
@
text
@d114 2
a116 2
				} else {
					result += file.getLocation().toFile().lastModified();
@


1.16
log
@Generating editor synchronization code
[155209] - GMF Editor does not get dirty when elements are added/removed thru custom code
@
text
@a228 2
				IWorkspace workspace = file.getWorkspace();
				workspace.validateEdit(new IFile[] { file }, computationContext);
@


1.15
log
@[155209] - GMF Editor does not get dirty when elements are added/removed thru custom code
@
text
@d10 51
a60 28
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IStorage;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.core.runtime.jobs.ISchedulingRule;
import org.eclipse.core.runtime.jobs.MultiRule;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.transaction.NotificationFilter;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.ui.IFileEditorInput;
d66 1
a66 1
public class <%=importManager.getCompilationUnitName()%> extends FileDiagramDocumentProvider {
d70 1
a70 1
	private final String contentObjectURI;
d83 57
a139 1
		this.contentObjectURI = rootObjectURI;
d146 121
a266 2
		super.setDocumentContentFromStorage(document, storage);
		if (contentObjectURI == null || false == document.getContent() instanceof EObject) {
d269 10
a278 3
		EObject currentContent = (EObject) document.getContent();
		if (currentContent.eResource().getURIFragment(currentContent) == contentObjectURI) {
			return; // already there
d280 1
a280 2
		EObject anotherContentObject = currentContent.eResource().getEObject(contentObjectURI);
		document.setContent(anotherContentObject);
d286 9
a294 17
	protected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {
		Diagram diagram = (Diagram)document.getContent();
		Resource diagramResource = diagram.eResource();
		IDiagramDocument diagramDocument = (IDiagramDocument)document;
		TransactionalEditingDomain domain = diagramDocument.getEditingDomain();
		List resources = domain.getResourceSet().getResources();

		monitor.beginTask("Saving diagram", resources.size() + 1); //$NON-NLS-1$
		super.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));
		for (Iterator it = resources.iterator(); it.hasNext();) {
			Resource nextResource = (Resource) it.next();
			monitor.setTaskName("Saving " + nextResource.getURI()); //$NON-NLS-1$
			if (nextResource != diagramResource && nextResource.isLoaded() && (!nextResource.isTrackingModification() || nextResource.isModified())) {
				try {
					nextResource.save(Collections.EMPTY_MAP);
				} catch (IOException e) {
					<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError("Unable to save resource: " + nextResource.getURI(), e); //$NON-NLS-1$
d297 1
a297 1
			monitor.worked(1);
d299 1
a299 1
		monitor.done();
d301 1
a301 1
	
d306 8
a313 10
		IDiagramDocument diagramDocument = getDiagramDocument(element);
		if (diagramDocument != null) {
			Diagram diagram = diagramDocument.getDiagram();
			if (diagram != null) {
				Collection rules = new ArrayList();
				for (Iterator it = diagramDocument.getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {
					IFile nextFile = WorkspaceSynchronizer.getFile((Resource) it.next());
					if (nextFile != null) {
						rules.add(computeSaveSchedulingRule(nextFile));	
					}
a314 1
				return new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));
d316 1
d318 1
a318 1
		return super.getSaveRule(element);
d320 1
a320 1
	
d324 15
a338 2
	protected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {
		assert document instanceof DiagramDocument;
d340 18
a357 2
		DiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);
		DiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);
a358 4
		diagramListener.startListening();
		return info;
	}
	
d362 3
a364 3
	private ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {
		if (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))
			return fResourceRuleFactory.modifyRule(toCreateOrModify);
d366 1
a366 1
		IResource parent= toCreateOrModify;
d368 5
a372 3
			 /*
			 * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601
			 * IResourceRuleFactory.createRule should iterate the hierarchy itself.
d374 3
a376 3
			toCreateOrModify= parent;
			parent= toCreateOrModify.getParent();
		} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));
d378 1
a378 1
		return fResourceRuleFactory.createRule(toCreateOrModify);
d384 37
a420 3
	public void fireElementDirtyStateChanged(TransactionalEditingDomain editingDomain, IFileEditorInput fileEditorInput) {
		boolean modified = false;
		for (Iterator it = editingDomain.getResourceSet().getResources().iterator(); it.hasNext() && !modified;) {
d422 7
a428 2
			if (nextResource.isLoaded()) {
				modified = nextResource.isModified();
d430 14
d445 39
a483 7
		ElementInfo info = getElementInfo(fileEditorInput);
		if (modified) {
			info.fCanBeSaved = modified;
		} else {
			info.fCanBeSaved= false;
			if (info instanceof FileInfo) {
				((FileInfo) info).fModificationStamp= computeModificationStamp(fileEditorInput.getFile());	
d486 28
a513 1
		fireElementDirtyStateChanged(fileEditorInput, modified);
d515 1
a515 1
	
d519 105
a623 2
	private class CustomModificationListener extends DiagramModificationListener {
	
d627 3
a629 1
		private NotificationFilter myModifiedFilter;
d634 3
a636 1
		private IFileEditorInput myFileEditorInput;
d641 2
a642 4
	 	public CustomModificationListener(<%=genDiagram.getDocumentProviderClassName()%> documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {
			super(documentProviderParameter, documentParameter);
			myFileEditorInput = inputParameter;
			myModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET).or(NotificationFilter.createEventTypeFilter(Notification.UNSET)).and(NotificationFilter.createFeatureFilter(Resource.class, Resource.RESOURCE__IS_MODIFIED));
d648 195
d844 3
d851 23
a873 1
						fireElementDirtyStateChanged(getEditingDomain(), myFileEditorInput);
d879 1
a880 2
	}
	
@


1.14
log
@Correcting isModified() usage.
@
text
@a27 1
import org.eclipse.emf.transaction.DemultiplexingListener;
a35 1
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;
d159 23
d186 1
a186 1
	private class CustomModificationListener extends FileDiagramModificationListener {
d191 1
a191 1
		private DemultiplexingListener myListener = null;
d196 1
a196 16
	 	public CustomModificationListener(<%=genDiagram.getDocumentProviderClassName()%> documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {
			super(documentProviderParameter, documentParameter, inputParameter);
	 		final DiagramDocument document = documentParameter;
			NotificationFilter diagramResourceModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET);
			myListener = new DemultiplexingListener(diagramResourceModifiedFilter) {
				protected void handleNotification(TransactionalEditingDomain domain, Notification notification) {
					if (notification.getNotifier() instanceof EObject) {
						Resource modifiedResource = ((EObject) notification.getNotifier()).eResource();
						if (modifiedResource != document.getDiagram().eResource()) {
							document.setContent(document.getContent());		
						}
					}

				}
			};
		}
d201 4
a204 3
		public void startListening() {
			super.startListening();
			getEditingDomain().addResourceSetListener(myListener);
d210 10
a219 3
		public void stopListening() {
			getEditingDomain().removeResourceSetListener(myListener);
			super.stopListening();
@


1.13
log
@Supporting EMF transfer for D&D
@
text
@d96 1
a96 1
			if (nextResource != diagramResource && nextResource.isLoaded() && nextResource.isModified()) {
@


1.12
log
@[119465] support for diagram partitioning - few hacks to use FileEditorInput because otherwise nothing gonna work
@
text
@d96 1
a96 1
			if (nextResource != diagramResource && nextResource.isLoaded()) {
@


1.11
log
@[153893] XXXDocumentProvider.saveDocumentToFile can cause loss of data
@
text
@d19 1
d45 35
a79 1
public class <%=genDiagram.getDocumentProviderClassName()%> extends FileDiagramDocumentProvider {
@


1.10
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d61 1
a61 1
			if (nextResource != diagramResource) {
@


1.10.2.1
log
@[153893] XXXDocumentProvider.saveDocumentToFile can cause loss of data
@
text
@d61 1
a61 1
			if (nextResource != diagramResource && nextResource.isLoaded()) {
@


1.9
log
@#127696 Templates should use new transaction API
@
text
@d6 3
a8 2

importManager.emitPackageStatement(stringBuffer);%>
@


1.8
log
@#127696 Templates should use new transaction API
@
text
@d24 1
d145 7
a151 1
					document.setContent(document.getContent());
@


1.7
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d9 1
a12 1
import java.util.HashSet;
a14 1
import java.util.Set;
a23 1
import org.eclipse.emf.ecore.EObject;
d25 4
a34 4
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
import org.eclipse.gmf.runtime.emf.core.edit.MFilter;
import org.eclipse.gmf.runtime.emf.core.edit.MListener;
import org.eclipse.gmf.runtime.emf.core.util.ResourceUtil;
a47 4
		monitor.beginTask("", 100); //$NON-NLS-1$
		super.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 20));

		IProgressMonitor subMonitor = new SubProgressMonitor(monitor, 20);
d49 8
a56 6
		Set externalResources = getReferencedResources(diagram);
		subMonitor.done();
		
		subMonitor = new SubProgressMonitor(monitor, 60);
		subMonitor.beginTask("Saving external resources", externalResources.size());
		for (Iterator it = externalResources.iterator(); it.hasNext();) {
d58 9
a66 3
			subMonitor.setTaskName("Saving " + nextResource.getURI());
			ResourceUtil.save(nextResource);
			subMonitor.worked(1);
d68 1
a68 1
		subMonitor.done();
d80 5
a84 10
				
				Resource resource = ((EObject)diagram).eResource();	
				IFile resourceFile = ResourceUtil.getFile(resource);
				rules.add(computeSaveSchedulingRule(resourceFile));
				
				Set externalResources = getReferencedResources(diagram);
				for (Iterator it = externalResources.iterator(); it.hasNext();) {
					Resource nextResource = (Resource) it.next();
					IFile nextResourceFile = ResourceUtil.getFile(nextResource);
					rules.add(computeSaveSchedulingRule(nextResourceFile));
a85 1
				
a107 12
	private static Set getReferencedResources(Diagram diagram) {
		Resource diagramResource = ((EObject) diagram).eResource();
		if (diagramResource == null) {
			return Collections.EMPTY_SET;
		}
		
		return new HashSet(MEditingDomain.INSTANCE.getImports(diagramResource));
	}
	
	/**
	 * @@generated
	 */
d133 1
a133 1
		private MListener myListener = null;
d141 5
a145 30
			MFilter diagramResourceSavedFilter = new MFilter() {
				public boolean matches(Notification notification) {
					Diagram diagram = document.getDiagram();
					Object notifier = notification.getNotifier();
					Resource resource = null;
					if (notifier instanceof EObject) {
						resource = ((EObject) notifier).eResource();
					} else if (notifier instanceof Resource) {
						resource = (Resource) notifier;
					}
					if (diagram != null && resource != null) {
						Set externalResources = getReferencedResources(diagram);
						for (Iterator it = externalResources.iterator(); it.hasNext();) {
							Resource nextResource = (Resource) it.next();
							if (resource == nextResource) {
								if (notifier == resource) {
									return notification.getEventType() == Notification.SET && notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_MODIFIED && notification.getNewBooleanValue() == true;
								} else {
/*
 * Handling notification from the objects stored in this resource it is necessary 
 * if setTrackingModification(true) was not called. I.e. now for all the objects 
 * stored in external resources. 
 */
									return true;
								}
							}
						}
					}
					return false;
				};
a146 8
			if (myListener == null) {
				myListener = new MListener(diagramResourceSavedFilter) {

					public void onEvent(List events) {
						document.setContent(document.getContent());
					}
				};
			}
d154 1
a154 1
			myListener.startListening();
d161 1
a161 1
			myListener.stopListening();
@


1.6
log
@GenEditorViewer incapsulates all Eclipse's IEditorPart-related info
@
text
@d3 5
a7 2
<%GenDiagram genDiagram = (GenDiagram) argument;%>
package <%=genDiagram.getEditorGen().getEditor().getPackageName()%>;
a8 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditorGen().getEditor().getPackageName());%>
@


1.5
log
@#126543
Marking editor as dirty on changes in the referenced resources.
@
text
@d4 1
a4 1
package <%=genDiagram.getEditorPackageName()%>;
d6 1
a6 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditorPackageName());%>
@


1.4
log
@ImportManager moved to oeg.common
@
text
@d159 7
a165 2
					if (diagram != null && notifier instanceof Resource) {
						Resource notifierResource = (Resource) notifier;
d169 11
a179 2
							if (notifierResource == nextResource) {
								return notification.getEventType() == Notification.SET && notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_MODIFIED && notification.getNewBooleanValue() == true;
@


1.3
log
@#122541
Saving diagram without exceptions.
@
text
@d2 1
a2 1
    imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.2
log
@[ashatalin] #113561 use MEditingDomain.getImports instead of ExternalCrossReferencer
@
text
@a12 1
import java.util.Map;
a33 1
import org.eclipse.gmf.runtime.emf.core.resources.ILogicalResource;
d75 2
d78 2
a79 11
				Collection rules = new ArrayList();
				if (resource instanceof ILogicalResource) {
					Map resourcesMap = ((ILogicalResource) resource).getMappedResources();
					for (Iterator it = resourcesMap.values().iterator(); it.hasNext();) {
						Resource nextResource = (Resource) it.next();
						IFile resourceFile = ResourceUtil.getFile(nextResource);
						rules.add(computeSaveSchedulingRule(resourceFile));
					}
				} else {
					rules.add(resource);
				}
d84 2
a85 2
					IFile resourceFile = ResourceUtil.getFile(nextResource);
					rules.add(computeSaveSchedulingRule(resourceFile));
@


1.1
log
@[ashatalin] #112988 use either same as diagram or separate file to persist domain model
@
text
@d9 1
a19 1
import org.eclipse.core.runtime.NullProgressMonitor;
a25 1
import org.eclipse.emf.ecore.util.EcoreUtil;
d32 1
d53 1
a53 1
		IProgressMonitor subMonitor = new SubProgressMonitor(monitor, 50);
d55 2
a56 1
		Set externalResources = getReferencedResources(diagram, subMonitor);
d58 1
a58 1
		subMonitor = new SubProgressMonitor(monitor, 30);
d90 1
a90 1
				Set externalResources = getReferencedResources(diagram, new NullProgressMonitor());
d119 5
a123 4
	private static Set getReferencedResources(Diagram diagram, IProgressMonitor monitor) {
		monitor.beginTask("Collecting referenced resources", 3);
		Map externalReferences = EcoreUtil.ExternalCrossReferencer.find(diagram);
		monitor.worked(2);
d125 1
a125 14
		IProgressMonitor subMonitor = new SubProgressMonitor(monitor, 1);
		subMonitor.beginTask("Collecting external resources", externalReferences.size());
		Set externalResources = new HashSet();
		for (Iterator it = externalReferences.keySet().iterator(); it.hasNext();) {
			EObject nextExternalObject = (EObject) it.next();
			Resource resource = nextExternalObject.eResource();
			if (resource != null) {
				externalResources.add(resource);
			}
			subMonitor.worked(1);
		}
		subMonitor.done();
		monitor.done();
		return externalResources;
d170 1
a170 1
						Set externalResources = getReferencedResources(diagram, new NullProgressMonitor());
@

