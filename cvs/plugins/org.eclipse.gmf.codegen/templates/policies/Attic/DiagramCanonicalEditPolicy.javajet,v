head	1.17;
access;
symbols
	v20081022-1925:1.17
	v20081015-1925:1.17
	v20081008-1925:1.17
	v20081001-1925:1.17
	v20080924-1925:1.17
	v20080917-1925:1.17
	v20080911-1728:1.17
	v20080910-1520:1.17
	v20080903-1520:1.17
	v20080827-1520:1.17
	v20080813-1520:1.17
	v20080806-1520:1.17
	v20070420-1000:1.16
	v20070413-1300:1.16
	v20070405-1100:1.16
	v20070403-1500:1.16
	v20070330-1300:1.16
	v20060330-1300:1.16
	v20070322-1100:1.16
	v20060316-0600:1.16
	v20070307-0700:1.16
	v20070301-1200:1.16
	v20070228-2000:1.16
	v20070221-1500:1.16
	v20070208-1800:1.16
	v20070202-0200:1.15
	v20070103-0300:1.15
	M4_20:1.15
	v20061222-1800:1.15
	v20061218-1200:1.15
	v20061214-0000:1.15
	v20061120-1300:1.15
	M3_20:1.15
	v20061117-0800:1.15
	v20061027-1200:1.15
	v20061020-1000:1.15
	v20061013-1330:1.15
	v20060919-0800:1.15
	v20060907-1100:1.15
	M1_20:1.15
	v20060904-1500:1.15
	v20060824-1600:1.15
	v20060817-1500:1.15
	v20060728-0500:1.15
	v20060713-1700:1.15
	R1_0_maintenance:1.15.0.2
	R1_0:1.15
	v20060627-1200:1.15
	v20060626-1420:1.15
	v20060620-0400:1.15
	v20060616-1400:1.14
	v20060616-1200:1.14
	v20060609-1400:1.14
	v20060531-1730:1.14
	v20060530-1930:1.14
	v20060526-1200:1.13
	v20060519-1300:1.12
	v20060519-0800:1.12
	v20060512-1000:1.10
	I20060512-1000:1.10
	I20060505-1400:1.10
	I20060428-1300:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.10
	I20060331-1000:1.10
	I20060324-0300:1.10
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.9
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.7
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.4
	I20060202-1415:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.3
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.1
	I20051223-1100:1.1
	I20051217-0925:1.1
	I20051208-2000:1.1
	I20051201-1800:1.1
	I20051124-2000:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.17
date	2007.04.24.18.22.42;	author ashatalin;	state dead;
branches;
next	1.16;
commitid	1456462e4af04567;

1.16
date	2007.01.29.19.30.15;	author ashatalin;	state Exp;
branches;
next	1.15;
commitid	7ac145be4b464567;

1.15
date	2006.06.19.14.02.19;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.29.13.55.19;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.24.11.47.59;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.15.17.18.16;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.19.16.57.17;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.17.12.02.06;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.13.09.29;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.23.19.58.06;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.19.00.10.43;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.03.17.25.14;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.23.10.11.53;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.17
log
@DiagramCanonicalEditpolicy template is in XPAND now.
[182556] - getSemanticChildrenList.jetinc generates empty switch statement causing generation to fail
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.policies" class="DiagramCanonicalEditPolicyGenerator"
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"
	skeleton="../common.skeleton"%>
<%
/*
	This template should be called only for non-design diagrams (domainDiagramElement != null) 
	because *CanonicalEditPolicy responsible for dealing with semantic model 
	elements and meaningless (should not be generated) for pure design diagrams.  
*/

final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import java.util.List;
import java.util.Collection;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.emf.ecore.EObject;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=genDiagram.getCanonicalEditPolicyClassName()%> extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalConnectionEditPolicy")%> {
	
<%List genNodes = genDiagram.getTopLevelNodes();%>
<%@@ include file="../semanticSync.jetinc/getSemanticChildrenList.jetinc"%>

	/**
	 * @@generated
	 */
	protected List getSemanticConnectionsList() {
		return <%=importManager.getImportedName("java.util.Collections")%>.EMPTY_LIST;
	}

	/**
	 * @@generated
	 */
	protected EObject getSourceElement(EObject relationship) {
		return null;
	}

	/**
	 * @@generated
	 */
	protected EObject getTargetElement(EObject relationship) {
		return null;
	}

	/**
	 * @@generated
	 */
	protected boolean shouldIncludeConnection(Edge connector, Collection children) {
		return false;
	}

<%@@ include file="../semanticSync.jetinc/refreshSemanticDiagram.jetinc"%>

}
<%importManager.emitSortedImports();%>
@


1.16
log
@[172032] - Do not generate ??CanonicalEditPolicy for pure-design elements
@
text
@@


1.15
log
@#145734 Generate "delete from view" popup menu action for not-synchronized diagrams
@
text
@d5 6
d28 1
a28 5
<%
GenClass modelElementInterface = genDiagram.getDomainDiagramElement();
if (modelElementInterface != null) {
	List genNodes = genDiagram.getTopLevelNodes();
%>
a29 1
<%}%>
a58 1
<%if (modelElementInterface != null) {%>
a59 1
<%}%>
@


1.14
log
@avoid generating unused imports in pure pure design projects
@
text
@d24 1
a24 1
if (modelElementInterface != null && genDiagram.isSynchronized()) {
a27 8
<%} else {%>

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("java.util.List")%> getSemanticChildrenList() {
		return <%=importManager.getImportedName("java.util.Collections")%>.EMPTY_LIST;
	}	
@


1.13
log
@#142211 Handle metamodel names that may have clashes with existing class names
@
text
@a13 1
import org.eclipse.gmf.runtime.notation.View;
@


1.12
log
@use importAssistant to emit package statement instead of handcoding
@
text
@a12 1
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalConnectionEditPolicy;
d21 1
a21 1
public class <%=genDiagram.getCanonicalEditPolicyClassName()%> extends CanonicalConnectionEditPolicy {
@


1.11
log
@#131543 Obsolete code should be eliminated
@
text
@d5 2
a6 1
GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
d9 1
a9 1
package <%=genDiagram.getEditPoliciesPackageName()%>;
a10 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditPoliciesPackageName());%>
@


1.10
log
@#128024 Model references are not recognized as links
#131543 Obsolete code should be eliminated
@
text
@a4 3
// TODO: move this attribute to the genmodel
final boolean isSynchronizedDiagram = true;

d26 1
a26 1
if (modelElementInterface != null && isSynchronizedDiagram) {
@


1.9
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d5 3
a13 2
import java.util.Iterator;
import java.util.LinkedList;
a16 1
import org.eclipse.gmf.runtime.notation.Diagram;
d26 1
d29 2
a30 2
if (modelElementInterface != null) {
	Collection genNodes = genDiagram.getTopLevelNodes();
d32 9
a40 1
<%@@ include file="getSemanticChildrenList.jetinc"%>
d47 1
a47 18
		List result = new LinkedList();
<%
if (modelElementInterface != null) {
	String modelElementInterfaceName = importManager.getImportedName(modelElementInterface.getQualifiedInterfaceName());
%>
		Diagram diagram = (Diagram) getHost().getModel();
		<%=modelElementInterfaceName%> modelElement = (<%=modelElementInterfaceName%>) diagram.getElement();
		for (Iterator diagramElements = modelElement.eContents().iterator(); diagramElements.hasNext();) {
			EObject nextDiagramElement = (EObject) diagramElements.next();
			for (Iterator childElements = nextDiagramElement.eContents().iterator(); childElements.hasNext();) {
				EObject nextChild = (EObject) childElements.next();
				if (<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getLinkWithClassVisualID(nextChild) != -1) {
					result.add(nextChild);
				}
			}
		}
<%}%>
		return result;
d54 1
a54 1
		return relationship.eContainer();
a60 16
		int vID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getLinkWithClassVisualID(relationship);
		switch (vID) {
<%
for (Iterator it = genDiagram.getLinks().iterator(); it.hasNext();) {
	GenLink nextGenLink = (GenLink) it.next();
	if (nextGenLink.getModelFacet() instanceof TypeLinkModelFacet) {
		TypeLinkModelFacet typeLinkFacet = (TypeLinkModelFacet) nextGenLink.getModelFacet(); 
		GenFeature nextLinkTargetFeature = typeLinkFacet.getTargetMetaFeature();
%>
		case <%=nextGenLink.getVisualID()%>:
			return <%=nextLinkTargetFeature.isListType() ? "(EObject) " : ""%><%=getFeatureValueGetter("relationship", nextLinkTargetFeature, true, importManager)%><%=nextLinkTargetFeature.isListType() ? ".get(0)" : ""%>;
<%
	}
}
%>
		}
a64 4
	 * For now we are skipping links which was generated based on "GenLinkReferenceOnly" classes
	 * since they do not handle any domain model objects inside, so we can not process them using
	 * CanonicalConnectionEditPolicy class
	 *
d68 1
a68 1
		return super.shouldIncludeConnection(connector, children) && connector.getElement() != null;
d70 5
a74 11
<%
{
	GenClass domainMetaclass = genDiagram.getDomainDiagramElement();
	GenContainerBase genContainerBase = genDiagram;
	if (domainMetaclass != null) {
%>
<%@@ include file="refreshSemantic.jetinc" %>
<%
	}
}
%>
@


1.8
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d7 1
@


1.7
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d27 1
a27 1
{
d31 1
a31 4
<%
}
String modelElementInterfaceName = importManager.getImportedName(modelElementInterface.getQualifiedInterfaceName());
%>
d37 5
a43 1
		List result = new LinkedList();
d53 1
d101 1
d105 1
a107 1

@


1.6
log
@#126896
generating CanonicalEditPolicy for visualizing containment reference as diagram link.
@
text
@d5 1
a5 1
GenDiagram genDiagram = (GenDiagram) argument;
@


1.5
log
@ImportManager moved to oeg.common
@
text
@d26 1
a26 1
String modelElementInterfaceName = importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName());
d31 4
a34 1
<%}%>
d95 10
@


1.4
log
@- Border should be defined in gmfgraph model
- Setter for features with "isList() == true" corrected
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"
@


1.3
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@d73 1
a73 1
			return <%=getFeatureValueGetter("relationship", nextLinkTargetFeature, true, importManager)%><%=nextLinkTargetFeature.isListType() ? ".get(0)" : ""%>;
@


1.2
log
@#122537
Removing usages of deprecated API.
@
text
@d28 1
a28 1
	Collection genNodes = genDiagram.getNodes();
@


1.1
log
@#117660 move canonical edit policy into separate class to shorten it's file name
@
text
@d13 1
d89 1
a89 1
	protected boolean shouldIncludeConnection(Edge connector, List children) {
@

