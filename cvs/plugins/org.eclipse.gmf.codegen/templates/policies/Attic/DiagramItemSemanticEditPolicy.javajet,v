head	1.18;
access;
symbols
	v20081022-1925:1.18
	v20081015-1925:1.18
	v20081008-1925:1.18
	v20081001-1925:1.18
	v20080924-1925:1.18
	v20080917-1925:1.18
	v20080911-1728:1.18
	v20080910-1520:1.18
	v20080903-1520:1.18
	v20080827-1520:1.18
	v20080813-1520:1.18
	v20080806-1520:1.18
	v20070608-1300:1.17
	v20070605-1400:1.17
	v20070601-1400:1.17
	v20070525-1500:1.17
	v20070520-1200:1.17
	v20070518-1300:1.17
	v20070504-1000:1.17
	v20070427-0600:1.17
	v20070420-1000:1.17
	v20070413-1300:1.16
	v20070405-1100:1.15
	v20070403-1500:1.15
	v20070330-1300:1.15
	v20060330-1300:1.15
	v20070322-1100:1.15
	v20060316-0600:1.15
	v20070307-0700:1.15
	v20070301-1200:1.15
	v20070228-2000:1.15
	v20070221-1500:1.15
	v20070208-1800:1.15
	v20070202-0200:1.14
	v20070103-0300:1.14
	M4_20:1.14
	v20061222-1800:1.14
	v20061218-1200:1.14
	v20061214-0000:1.14
	v20061120-1300:1.14
	M3_20:1.14
	v20061117-0800:1.14
	v20061027-1200:1.14
	v20061020-1000:1.14
	v20061013-1330:1.14
	v20060919-0800:1.14
	v20060907-1100:1.14
	M1_20:1.14
	v20060904-1500:1.14
	v20060824-1600:1.14
	v20060817-1500:1.14
	v20060728-0500:1.14
	v20060713-1700:1.14
	R1_0_maintenance:1.14.0.2
	R1_0:1.14
	v20060627-1200:1.14
	v20060626-1420:1.14
	v20060620-0400:1.14
	v20060616-1400:1.14
	v20060616-1200:1.14
	v20060609-1400:1.14
	v20060531-1730:1.14
	v20060530-1930:1.14
	v20060526-1200:1.13
	v20060519-1300:1.13
	v20060519-0800:1.13
	v20060512-1000:1.12
	I20060512-1000:1.12
	I20060505-1400:1.12
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.12
	I20060331-1000:1.12
	I20060324-0300:1.12
	I20060317-1300:1.12
	I20060317-1200:1.12
	I20060316-1300:1.12
	I20060309-1300:1.12
	M5_10:1.11
	S20060303-1600:1.11
	I20060227-1730:1.11
	I20060216-1945:1.10
	I20060210-1715:1.9
	I20060209-1815:1.9
	I20060203-0830:1.7
	I20060202-1415:1.7
	I20060129-1145:1.7
	I20060127-0900:1.7
	I20060120-1530:1.7
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.6
	I20051217-0925:1.6
	I20051208-2000:1.6
	I20051201-1800:1.5
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.18
date	2007.06.13.16.02.39;	author ashatalin;	state dead;
branches;
next	1.17;
commitid	314d4670151f4567;

1.17
date	2007.04.13.13.59.50;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	37e3461f8cd54567;

1.16
date	2007.04.10.18.52.28;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	58c0461bdcea4567;

1.15
date	2007.01.29.18.09.13;	author ashatalin;	state Exp;
branches;
next	1.14;
commitid	21cf45be38464567;

1.14
date	2006.05.29.13.55.19;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.17.12.02.06;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.14.13.58.45;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.19.00.10.43;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.05.15.01.14;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.28.16.09.46;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.11.15.38.06;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.08.16.19.21;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.08.15.36.54;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.18
log
@[192464] - Convert /policies/CompartmentItemSemapticEditPolicy and DiagramItemSemanticEditPolicy .javajet template to xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.policies" class="DiagramItemSemanticEditPolicyGenerator"
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"
	skeleton="../common.skeleton"%>
<%
/*
	This template should be called only for non-design diagrams (domainDiagramElement != null) 
	because *ItemSemanticEditPolicy responsible for dealing with semantic model 
	elements and meaningless (should not be generated) for pure design diagrams.  
*/

final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.commands.Command;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.emf.commands.core.commands.DuplicateEObjectsCommand;
import org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=genDiagram.getItemSemanticEditPolicyClassName()%> extends <%=importManager.getImportedName(genDiagram.getBaseItemSemanticEditPolicyQualifiedClassName())%> {
<%Collection<GenTopLevelNode> childNodes = genDiagram.getTopLevelNodes();%>

<%@@ include file="childContainerCreateCommand.jetinc"%>

	/**
	 * @@generated
	 */
	protected Command getDuplicateCommand(DuplicateElementsRequest req) {
		TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost()).getEditingDomain();
		return getGEFWrapper(new DuplicateAnythingCommand(editingDomain, req));
	}

	/**
	 * @@generated
	 */
	private static class DuplicateAnythingCommand extends DuplicateEObjectsCommand {

		/**
		 * @@generated
		 */
		public DuplicateAnythingCommand(TransactionalEditingDomain editingDomain, DuplicateElementsRequest req) {
			super(editingDomain, req.getLabel(), req.getElementsToBeDuplicated(), req.getAllDuplicatedElementsMap());
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.17
log
@renamed getMSLWrapper into getGEFWrapper to better reflect what's going on and to avoid unknown acronym
@
text
@@


1.16
log
@[181771] Generator should tolerate absence of both containment and child meta features
@
text
@d37 1
a37 1
		return getMSLWrapper(new DuplicateAnythingCommand(editingDomain, req));
@


1.15
log
@[167466] - Do not generate ??ItemSemanticEditPolicy for pure-design elements
@
text
@d28 1
a28 1
<%Collection childNodes = genDiagram.getTopLevelNodes();%>
@


1.14
log
@avoid generating unused imports in pure pure design projects
@
text
@d5 6
d28 1
a28 5
<%
Collection childNodes = genDiagram.getTopLevelNodes();
GenClass containerGenClass = genDiagram.getDomainDiagramElement();
if (containerGenClass != null) {
%>
a30 1
<%}%>
@


1.13
log
@use importAssistant to emit package statement instead of handcoding
@
text
@a10 2
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
a14 1
import org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest;
a15 1
import org.eclipse.gmf.runtime.notation.View;
@


1.12
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d5 2
a6 1
GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
d9 1
a9 1
package <%=genDiagram.getEditPoliciesPackageName()%>;
a10 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditPoliciesPackageName());%>
@


1.11
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d7 1
@


1.10
log
@use new transactional emf api
@
text
@d28 1
d32 1
@


1.9
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d12 1
d14 1
a15 1
import org.eclipse.gmf.runtime.emf.commands.core.commands.MSLCreateElementCommand;
d36 2
a37 1
		return getMSLWrapper(new DuplicateAnythingCommand(req));
d48 2
a49 2
		public DuplicateAnythingCommand(DuplicateElementsRequest req) {
			super(req.getLabel(), req.getElementsToBeDuplicated(), req.getAllDuplicatedElementsMap());
@


1.8
log
@ImportManager moved to oeg.common
@
text
@d5 1
a5 1
GenDiagram genDiagram = (GenDiagram) argument;
@


1.7
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"
@


1.6
log
@#119243
Checking upper bound limit for diagram elements.
@
text
@d25 1
a25 1
Collection childNodes = genDiagram.getNodes();
@


1.5
log
@#117749 & #118040 generate unique names for the shared elements in mapping model
@
text
@d2 2
a3 1
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
d25 2
a26 2
GenPackage genPackage = genDiagram.getDomainMetaModel();
String semanticPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
d29 1
a29 69
	/**
	 * @@generated
	 */
	protected Command getCreateCommand(CreateElementRequest req) {
<%
for (Iterator nodes = genDiagram.getNodes().iterator(); nodes.hasNext(); ) {
	GenNode genNode = (GenNode) nodes.next();
	TypeModelFacet modelFacet = genNode.getModelFacet();
%>
		if (<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genNode.getUniqueIdentifier()%> == req.getElementType()) {
			if (req.getContainmentFeature() == null) {
				req.setContainmentFeature(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=modelFacet.getContainmentMetaFeature().getFeatureAccessorName()%>());
			}
			return getMSLWrapper(new Create<%=genNode.getUniqueIdentifier()%>Command(req));
		}
<%}%>
		return super.getCreateCommand(req);
	}
<%
for (Iterator nodes = genDiagram.getNodes().iterator(); nodes.hasNext(); ) {
	GenNode genNode = (GenNode) nodes.next();
	TypeModelFacet modelFacet = genNode.getModelFacet();
%>

	/**
	 * @@generated
	 */
	private static class Create<%=genNode.getUniqueIdentifier()%>Command extends MSLCreateElementCommand {

		/**
		 * @@generated
		 */
		public Create<%=genNode.getUniqueIdentifier()%>Command(CreateElementRequest req) {
			super(req);
		}

		/**
		 * @@generated
		 */
		protected EClass getEClassToEdit() {
			return <%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>();
		};

		/**
		 * @@generated
		 */
		protected EObject getElementToEdit() {
			EObject container = ((CreateElementRequest) getRequest()).getContainer();
			if (container instanceof View) {
				container = ((View) container).getElement();
			}
			return container;
		}
<%	if (modelFacet.getModelElementInitializer() != null) { %>

		/**
		 * @@generated
		 */
		protected EObject doDefaultElementCreation() {
<%		String metaClassName = importManager.getImportedName(modelFacet.getMetaClass().getQualifiedInterfaceName());%>
			<%=metaClassName%> newElement = (<%=metaClassName%>) super.doDefaultElementCreation();
			if (newElement != null) {
				<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.Initializers.<%=genNode.getUniqueIdentifier()%>.init(newElement);
			}
			return newElement;
		}
<%	}%>
	}
<%}%>
@


1.4
log
@#116031 avoid hardcoded class names in templates
@
text
@d41 1
a41 1
			return getMSLWrapper(new Create<%=modelFacet.getMetaClass().getName()%>Command(req));
d55 1
a55 1
	private static class Create<%=modelFacet.getMetaClass().getName()%>Command extends MSLCreateElementCommand {
d60 1
a60 1
		public Create<%=modelFacet.getMetaClass().getName()%>Command(CreateElementRequest req) {
@


1.3
log
@#114351 support elements cloning
@
text
@a8 1
import <%=genDiagram.getProvidersPackageName()%>.ElementTypes;
d37 1
a37 1
		if (ElementTypes.<%=genNode.getUniqueIdentifier()%> == req.getElementType()) {
d90 1
a90 1
				ElementTypes.Initializers.<%=genNode.getUniqueIdentifier()%>.init(newElement);
@


1.2
log
@unused casts removed
@
text
@d13 1
d16 1
d98 20
@


1.1
log
@[dstadnik] #115466 custom semantic edit policies to control link creation
@
text
@d34 1
a34 1
	TypeModelFacet modelFacet = (TypeModelFacet) genNode.getModelFacet();
d48 1
a48 1
	TypeModelFacet modelFacet = (TypeModelFacet) genNode.getModelFacet();
@

