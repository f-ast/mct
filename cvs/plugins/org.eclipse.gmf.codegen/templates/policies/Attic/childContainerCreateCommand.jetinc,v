head	1.18;
access;
symbols
	v20081022-1925:1.18
	v20081015-1925:1.18
	v20081008-1925:1.18
	v20081001-1925:1.18
	v20080924-1925:1.18
	v20080917-1925:1.18
	v20080911-1728:1.18
	v20080910-1520:1.18
	v20080903-1520:1.18
	v20080827-1520:1.18
	v20080813-1520:1.18
	v20080806-1520:1.18
	RC3_20:1.17
	v20070614-1400:1.17
	v20070608-1300:1.17
	v20070605-1400:1.17
	v20070601-1400:1.17
	v20070525-1500:1.17
	v20070520-1200:1.17
	v20070518-1300:1.17
	v20070504-1000:1.17
	v20070427-0600:1.17
	v20070420-1000:1.17
	v20070413-1300:1.16
	v20070405-1100:1.15
	v20070403-1500:1.15
	v20070330-1300:1.15
	v20060330-1300:1.15
	v20070322-1100:1.15
	v20060316-0600:1.15
	v20070307-0700:1.15
	v20070301-1200:1.15
	v20070228-2000:1.15
	v20070221-1500:1.15
	v20070208-1800:1.15
	v20070202-0200:1.14
	v20070103-0300:1.15
	M4_20:1.15
	v20061222-1800:1.15
	v20061218-1200:1.15
	v20061214-0000:1.15
	v20061120-1300:1.14
	M3_20:1.14
	v20061117-0800:1.14
	v20061027-1200:1.14
	v20061020-1000:1.14
	v20061013-1330:1.14
	v20060919-0800:1.14
	v20060907-1100:1.14
	M1_20:1.14
	v20060904-1500:1.14
	v20060824-1600:1.14
	v20060817-1500:1.14
	v20060728-0500:1.14
	v20060713-1700:1.14
	R1_0_maintenance:1.14.0.2
	R1_0:1.14
	v20060627-1200:1.14
	v20060626-1420:1.14
	v20060620-0400:1.14
	v20060616-1400:1.14
	v20060616-1200:1.14
	v20060609-1400:1.14
	v20060531-1730:1.14
	v20060530-1930:1.14
	v20060526-1200:1.13
	v20060519-1300:1.13
	v20060519-0800:1.13
	v20060512-1000:1.12
	I20060512-1000:1.12
	I20060505-1400:1.12
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.11
	I20060407-1200:1.11
	I20060331-1000:1.11
	I20060324-0300:1.11
	I20060317-1300:1.11
	I20060317-1200:1.11
	I20060316-1300:1.11
	I20060309-1300:1.11
	M5_10:1.11
	S20060303-1600:1.11
	I20060227-1730:1.10
	I20060216-1945:1.10
	I20060210-1715:1.9
	I20060209-1815:1.9
	I20060203-0830:1.7
	I20060202-1415:1.7
	I20060129-1145:1.7
	I20060127-0900:1.7
	I20060120-1530:1.7
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.7
	I20051208-2000:1.7
	I20051201-1800:1.6
	I20051124-2000:1.5
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.18
date	2007.06.15.12.37.50;	author dstadnik;	state dead;
branches;
next	1.17;
commitid	43ba4672881e4567;

1.17
date	2007.04.13.13.59.50;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	37e3461f8cd54567;

1.16
date	2007.04.10.18.52.28;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	58c0461bdcea4567;

1.15
date	2006.12.11.18.42.43;	author ashatalin;	state Exp;
branches;
next	1.14;
commitid	34a457da6a14567;

1.14
date	2006.05.29.13.55.18;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.18.14.03.44;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.20.17.08.07;	author ashatalin;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.03.15.34.18;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.14.13.58.45;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.06.11.52.36;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.05.15.01.14;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.28.16.09.46;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.23.13.29.37;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.17.12.38.37;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.16.15.45.26;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.10.17.21.40;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.18
log
@remove stale code
@
text
@	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> getCreateCommand(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest")%> req) {
<%for (Iterator<? extends GenNode> nodes = childNodes.iterator(); nodes.hasNext(); ) {
	GenNode genChildNode = nodes.next();
	TypeModelFacet modelFacet = genChildNode.getModelFacet();
	if (modelFacet == null) {
		continue;
	}%>
		if (<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genChildNode.getUniqueIdentifier()%> == req.getElementType()) {
<%	if (!modelFacet.isPhantomElement()) {%>		
			if (req.getContainmentFeature() == null) {
				req.setContainmentFeature(<%if (modelFacet.getContainmentMetaFeature() != null) {%><%=importManager.getImportedName(modelFacet.getContainmentMetaFeature().getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=modelFacet.getContainmentMetaFeature().getFeatureAccessorName()%>()
<%										} else {%>/* FIXME no containment feature found in the genmodel, toolsmith need to specify correct one here manually */<%}%>);
			}
<%	}%>
			return getGEFWrapper(new <%=importManager.getImportedName(genChildNode.getCreateCommandQualifiedClassName())%>(req));
		}
<%}%>
		return super.getCreateCommand(req);
	}@


1.17
log
@renamed getMSLWrapper into getGEFWrapper to better reflect what's going on and to avoid unknown acronym
@
text
@@


1.16
log
@[181771] Generator should tolerate absence of both containment and child meta features
@
text
@d18 1
a18 1
			return getMSLWrapper(new <%=importManager.getImportedName(genChildNode.getCreateCommandQualifiedClassName())%>(req));
@


1.15
log
@[157683] - Generate link creation/initialization command in single separate classes instead of duplication of the code in different SemanticEditPolicy'ies
@
text
@d5 2
a6 2
<%for (Iterator nodes = childNodes.iterator(); nodes.hasNext(); ) {
	GenNode genChildNode = (GenNode) nodes.next();
d14 2
a15 1
				req.setContainmentFeature(<%=importManager.getImportedName(modelFacet.getContainmentMetaFeature().getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=modelFacet.getContainmentMetaFeature().getFeatureAccessorName()%>());
@


1.14
log
@avoid generating unused imports in pure pure design projects
@
text
@d5 1
a5 2
<%
for (Iterator nodes = childNodes.iterator(); nodes.hasNext(); ) {
d10 1
a10 2
	}
%>
d12 1
a12 45
<%
	GenFeature containmentMetaFeature = modelFacet.getContainmentMetaFeature();
	GenFeature childMetaFeature = modelFacet.getChildMetaFeature();
	if (!modelFacet.isPhantomElement()) {
		int upperContainmentBound = containmentMetaFeature.getEcoreFeature().getUpperBound();
		int upperChildBound = childMetaFeature.getEcoreFeature().getUpperBound();
		boolean processChildMetafeature = !childMetaFeature.equals(containmentMetaFeature) && upperChildBound > 0;
		if (upperContainmentBound > 0 || processChildMetafeature) {
			String containerInterfaceName = importManager.getImportedName(containerGenClass.getQualifiedInterfaceName());
%>		
			<%=containerInterfaceName%> container = (<%=containerInterfaceName%>) (req.getContainer() instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> ? ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) req.getContainer()).getElement() : req.getContainer());
<%
			if (upperContainmentBound > 0) {
				if (upperContainmentBound == 1) {
%>
			if (<%=getFeatureValueGetter("container", containmentMetaFeature, false, importManager)%> != null) {
<%
				} else {
%>
			if (<%=getFeatureValueGetter("container", containmentMetaFeature, false, importManager)%>.size() >= <%=upperContainmentBound%>) {
<%
				}
%>
				return super.getCreateCommand(req);
			}
<%
			}
		
			if (processChildMetafeature) {
				if (upperChildBound == 1) {
%>
			if (<%=getFeatureValueGetter("container", childMetaFeature, false, importManager)%> != null) {
<%
				} else {
%>
			if (<%=getFeatureValueGetter("container", childMetaFeature, false, importManager)%>.size() >= <%=upperChildBound%>) {
<%
				}
%>
				return super.getCreateCommand(req);
			}
<%
			}
		}
%>
d16 2
a17 4
<%
	}
%>
			return getMSLWrapper(new Create<%=genChildNode.getUniqueIdentifier()%>Command(req));
d19 1
a19 3
<%
}
%>
d21 1
a21 124
	}
<%
for (Iterator nodes = childNodes.iterator(); nodes.hasNext(); ) {
	GenNode genChildNode = (GenNode) nodes.next();
	TypeModelFacet modelFacet = genChildNode.getModelFacet();
	if (modelFacet == null) {
		continue;
	}
%>

	/**
	 * @@generated
	 */
	private static class Create<%=genChildNode.getUniqueIdentifier()%>Command extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.commands.CreateElementCommand")%> {

		/**
		 * @@generated
		 */
		public Create<%=genChildNode.getUniqueIdentifier()%>Command(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest")%> req) {
			super(req);
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.ecore.EClass")%> getEClassToEdit() {
			return <%=importManager.getImportedName(containerGenClass.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=containerGenClass.getClassifierAccessorName()%>();
		};

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> getElementToEdit() {
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> container = ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest")%>) getRequest()).getContainer();
			if (container instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) {
				container = ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) container).getElement();
			}
			return container;
		}
<%
	boolean processChildMetafeature = !modelFacet.isPhantomElement() && !modelFacet.getChildMetaFeature().isDerived() && !modelFacet.getChildMetaFeature().equals(modelFacet.getContainmentMetaFeature());
	if (modelFacet.getModelElementInitializer() != null || processChildMetafeature) { 
		String metaClassName = importManager.getImportedName(modelFacet.getMetaClass().getQualifiedInterfaceName());
%>

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> doDefaultElementCreation() {
			<%=metaClassName%> newElement = (<%=metaClassName%>) super.doDefaultElementCreation();
			if (newElement != null) {
<%
		if (processChildMetafeature) {
			String containerMetaClass = importManager.getImportedName(modelFacet.getChildMetaFeature().getGenClass().getQualifiedInterfaceName());
%>
				 <%=containerMetaClass%> container = (<%=containerMetaClass%>) getElementToEdit();
				 if (container != null) {
<%
			if (modelFacet.getChildMetaFeature().isListType()) {
%>
					<%=importManager.getImportedName("java.util.Collection")%> featureValues = container.<%=modelFacet.getChildMetaFeature().getGetAccessor()%>();
					featureValues.add(newElement);
<%
			} else {
%>
				 	<%=getFeatureValueSetterPrefix("container", modelFacet.getChildMetaFeature(), false, importManager)%>newElement);
<%
			}
%>
				 }
<%
		}
		if (modelFacet.getModelElementInitializer() != null) {
%>		
				<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.Initializers.<%=genChildNode.getUniqueIdentifier()%>.init(newElement);
<%
		}
%>
			}
			return newElement;
		}
<%
	}
	
	if (modelFacet.isPhantomElement()) {
%>

		/**
		 * @@generated
		 */
		public boolean canExecute() {
			if (getEClass() != null) {
				return getEClass().isSuperTypeOf(getEClassToEdit());
			}
			return true;
		}
		
		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.ecore.EReference")%> getContainmentFeature() {
			return null;
		}
		
		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> doDefaultElementCreation() {
			// Uncomment to put "phantom" objects into the diagram file.		
			//<%=importManager.getImportedName("org.eclipse.emf.ecore.resource.Resource")%> resource = ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest")%>) getRequest()).getContainer().eResource();
			//if (resource == null) {
			//	return null;
			//}
			<%=importManager.getImportedName("org.eclipse.emf.ecore.resource.Resource")%> resource = getElementToEdit().eResource();
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EClass")%> eClass = getElementType().getEClass();
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> eObject = eClass.getEPackage().getEFactoryInstance().create(eClass);
			resource.getContents().add(eObject);
			return eObject;
		}
<%
	}
%>
	}
<%}%>@


1.13
log
@#114175 Allow a diagram definition to be mapped to zero or more domain models.
@
text
@d89 1
a89 1
		public Create<%=genChildNode.getUniqueIdentifier()%>Command(CreateElementRequest req) {
d104 1
a104 1
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> container = ((CreateElementRequest) getRequest()).getContainer();
d180 1
a180 1
			//<%=importManager.getImportedName("org.eclipse.emf.ecore.resource.Resource")%> resource = ((CreateElementRequest) getRequest()).getContainer().eResource();
@


1.12
log
@Removing obsolete code to get rid of compilation warnings.
@
text
@d8 4
a14 1
	TypeModelFacet modelFacet = genChildNode.getModelFacet();
d76 3
@


1.11
log
@#127696 Templates should use new transaction API
In case of phantom nodes.
@
text
@d180 1
a180 7
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.resources.IResourceHelper")%> helper = <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.Util")%>.getHelper(resource);
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> eObject;
			if (helper != null) {
				eObject = helper.create(eClass);
			} else {
				eObject = eClass.getEPackage().getEFactoryInstance().create(eClass);
			}
@


1.10
log
@use new transactional emf api
@
text
@d155 1
a155 1
		public boolean isExecutable() {
d180 6
a185 3
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.domain.MSLEditingDomain")%> domain = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.domain.MSLEditingDomain")%>) <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.domain.MSLEditingDomain")%>.getEditingDomain(resource);
			if (domain == null) {
				domain = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.domain.MSLEditingDomain")%>) <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain")%>.INSTANCE;
a186 1
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> eObject = <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.MSLUtil")%>.create(domain, eClass, true);
@


1.9
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d78 1
a78 1
	private static class Create<%=genChildNode.getUniqueIdentifier()%>Command extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.commands.core.commands.MSLCreateElementCommand")%> {
@


1.8
log
@#126537
Possibility to visualize child-parent relachipchip as a link implemented
@
text
@a5 1
GenPackage genPackage = genDiagram.getDomainMetaModel();
d57 1
a57 1
				req.setContainmentFeature(<%=importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=modelFacet.getContainmentMetaFeature().getFeatureAccessorName()%>());
d91 1
a91 1
			return <%=importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=containerGenClass.getClassifierAccessorName()%>();
@


1.7
log
@#119243
Checking upper bound limit for diagram elements.
@
text
@d9 3
d15 6
a20 8
	int upperContainmentBound = containmentMetaFeature.getEcoreFeature().getUpperBound();
	int upperChildBound = childMetaFeature.getEcoreFeature().getUpperBound();
	boolean processChildMetafeature = !childMetaFeature.equals(containmentMetaFeature) && upperChildBound > 0;
%>
		if (<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genChildNode.getUniqueIdentifier()%> == req.getElementType()) {
<%
	if (upperContainmentBound > 0 || processChildMetafeature) {
		String containerInterfaceName = importManager.getImportedName(containerGenClass.getQualifiedInterfaceName());
d24 2
a25 2
		if (upperContainmentBound > 0) {
			if (upperContainmentBound == 1) {
d29 1
a29 1
			} else {
d33 1
a33 1
			}
d38 1
a38 1
		}
d40 2
a41 2
		if (processChildMetafeature) {
			if (upperChildBound == 1) {
d45 1
a45 1
			} else {
d49 1
a49 1
			}
d54 1
a55 1
	}
d60 3
d106 1
a106 1
	boolean processChildMetafeature = !modelFacet.getChildMetaFeature().isDerived() && !modelFacet.getChildMetaFeature().equals(modelFacet.getContainmentMetaFeature());
d149 42
@


1.6
log
@#117749 & #118040 generate unique names for the shared elements in mapping model
@
text
@d7 1
a7 1
for (Iterator nodes = childContainer.getChildNodes().iterator(); nodes.hasNext(); ) {
d19 1
a19 1
		String containerInterfaceName = importManager.getImportedName(containerNode.getModelFacet().getMetaClass().getQualifiedInterfaceName());
d21 1
a21 1
			<%=containerInterfaceName%> container = (<%=containerInterfaceName%>) req.getContainer();
d67 1
a67 1
for (Iterator nodes = childContainer.getChildNodes().iterator(); nodes.hasNext(); ) {
d88 1
a88 1
			return <%=importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=containerNode.getModelFacet().getMetaClass().getClassifierAccessorName()%>();
@


1.5
log
@#116448
- Setting Child Meta Feature value if specified feature !isDerived()
- Checking Upper limit for Child Meta Feature
@
text
@d59 1
a59 1
			return getMSLWrapper(new Create<%=modelFacet.getMetaClass().getName()%>Command(req));
d75 1
a75 1
	private static class Create<%=modelFacet.getMetaClass().getName()%>Command extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.commands.core.commands.MSLCreateElementCommand")%> {
d80 1
a80 1
		public Create<%=modelFacet.getMetaClass().getName()%>Command(CreateElementRequest req) {
@


1.4
log
@#116655

Generating correct access for all the features.
@
text
@d11 4
a14 1
	int upperBound = containmentMetaFeature.getEcoreFeature().getUpperBound();
d18 1
a18 1
	if (upperBound > 0) {
d23 2
a24 1
		if (upperBound == 1) {
d28 1
a28 1
		} else {
d30 6
a35 1
			if (<%=getFeatureValueGetter("container", containmentMetaFeature, false, importManager)%>.size() >= <%=upperBound%>) {
d38 11
d53 1
d101 5
a105 1
<%	if (modelFacet.getModelElementInitializer() != null) { %>
a110 1
<%		String metaClassName = importManager.getImportedName(modelFacet.getMetaClass().getQualifiedInterfaceName());%>
d113 23
d137 3
d143 3
a145 1
<%	}%>
@


1.3
log
@#116448
Correcting CanonicalEditPolicy + SemanticEditPolicy to support references with multiplicities "1","n".
@
text
@d22 1
a22 1
			if (container.<%=containmentMetaFeature.getGetAccessor()%>() != null) {
d26 1
a26 1
			if (container.<%=containmentMetaFeature.getGetAccessor()%>().size() >= <%=upperBound%>) {
@


1.2
log
@#116031 avoid hardcoded class names in templates
@
text
@d10 2
d14 21
@


1.1
log
@#115861
ChildNode could be created not only in the compartment, but directly in it's parent.
@
text
@d11 1
a11 1
		if (<%=importManager.getImportedName(genDiagram.getProvidersPackageName() + ".ElementTypes")%>.<%=genChildNode.getUniqueIdentifier()%> == req.getElementType()) {
d66 1
a66 1
				<%=importManager.getImportedName(genDiagram.getProvidersPackageName() + ".ElementTypes")%>.Initializers.<%=genChildNode.getUniqueIdentifier()%>.init(newElement);
@

