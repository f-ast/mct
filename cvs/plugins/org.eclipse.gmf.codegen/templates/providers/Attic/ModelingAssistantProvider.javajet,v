head	1.24;
access;
symbols
	v20081022-1925:1.24
	v20081015-1925:1.24
	v20081008-1925:1.24
	v20081001-1925:1.24
	v20080924-1925:1.24
	v20080917-1925:1.24
	v20080911-1728:1.24
	v20080910-1520:1.24
	v20080903-1520:1.24
	v20080827-1520:1.24
	v20080813-1520:1.24
	v20080806-1520:1.24
	v20070608-1300:1.23
	v20070605-1400:1.23
	v20070601-1400:1.23
	v20070525-1500:1.23
	v20070520-1200:1.23
	v20070518-1300:1.23
	v20070504-1000:1.23
	v20070427-0600:1.23
	v20070420-1000:1.23
	v20070413-1300:1.23
	v20070405-1100:1.23
	v20070403-1500:1.23
	v20070330-1300:1.23
	v20060330-1300:1.23
	v20070322-1100:1.23
	v20060316-0600:1.23
	v20070307-0700:1.23
	v20070301-1200:1.23
	v20070228-2000:1.23
	v20070221-1500:1.23
	v20070208-1800:1.23
	v20070202-0200:1.22
	v20070103-0300:1.22
	M4_20:1.22
	v20061222-1800:1.22
	v20061218-1200:1.22
	v20061214-0000:1.22
	v20061120-1300:1.22
	M3_20:1.22
	v20061117-0800:1.22
	v20061027-1200:1.22
	v20061020-1000:1.22
	v20061013-1330:1.22
	v20060919-0800:1.22
	v20060907-1100:1.22
	M1_20:1.22
	v20060904-1500:1.22
	v20060824-1600:1.22
	v20060817-1500:1.22
	v20060728-0500:1.22
	v20060713-1700:1.22
	R1_0_maintenance:1.22.0.2
	R1_0:1.22
	v20060627-1200:1.22
	v20060626-1420:1.22
	v20060620-0400:1.22
	v20060616-1400:1.22
	v20060616-1200:1.22
	v20060609-1400:1.22
	v20060531-1730:1.22
	v20060530-1930:1.22
	v20060526-1200:1.22
	v20060519-1300:1.22
	v20060519-0800:1.22
	v20060512-1000:1.21
	I20060512-1000:1.21
	I20060505-1400:1.21
	I20060428-1300:1.21
	I20060424-0500:1.21
	I20060424-0300:1.21
	M6_10:1.21
	I20060407-1200:1.21
	I20060331-1000:1.21
	I20060324-0300:1.21
	I20060317-1300:1.21
	I20060317-1200:1.21
	I20060316-1300:1.21
	I20060309-1300:1.21
	M5_10:1.20
	S20060303-1600:1.20
	I20060227-1730:1.20
	I20060216-1945:1.20
	I20060210-1715:1.20
	I20060209-1815:1.20
	I20060203-0830:1.17
	I20060202-1415:1.17
	I20060129-1145:1.16
	I20060127-0900:1.14
	I20060120-1530:1.8
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.6
	I20051217-0925:1.6
	I20051208-2000:1.6
	I20051201-1800:1.6
	I20051124-2000:1.6
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.4
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.24
date	2007.06.12.23.41.58;	author dstadnik;	state dead;
branches;
next	1.23;
commitid	2e6e466f2f424567;

1.23
date	2007.01.17.13.12.34;	author ashatalin;	state Exp;
branches;
next	1.22;
commitid	3d0045ae20c04567;

1.22
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.31.13.23.03;	author ashatalin;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.27.21.19.10;	author ashatalin;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.27.14.07.12;	author dstadnik;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.27.12.18.26;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.26.12.54.08;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.26.12.24.07;	author ashatalin;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.25.16.43.38;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.24.12.01.20;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.24.10.23.26;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.19.17.33.05;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.19.00.10.43;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.21.11.49.45;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.10.18.32.55;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.07.15.26.40;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.27.16.12.20;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.19.13.51.49;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.24
log
@[192029] Rewrite modeling assistant provider in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.providers" class="ModelingAssistantProviderGenerator"
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantProvider;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.window.Window;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.dialogs.ElementListSelectionDialog;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=genDiagram.getModelingAssistantProviderClassName()%> extends ModelingAssistantProvider {

	/**
	 * @@generated
	 */
	public List getTypesForPopupBar(IAdaptable host) {
		IGraphicalEditPart editPart = (IGraphicalEditPart) host.getAdapter(IGraphicalEditPart.class);
<%
for (Iterator contents = genDiagram.getAllContainers().iterator(); contents.hasNext(); ) {
	GenContainerBase genContainer = (GenContainerBase) contents.next();
	if (genContainer instanceof GenCompartment && ((GenCompartment) genContainer).isListLayout()) {
		continue;
	}
	List children = new ArrayList(genContainer.getContainedNodes());
	if (genContainer instanceof GenNode) {
		for (Iterator compartments = ((GenNode) genContainer).getCompartments().iterator(); compartments.hasNext(); ) {
			GenCompartment compartment = (GenCompartment) compartments.next();
			if (compartment.isListLayout()) {
				children.addAll(compartment.getContainedNodes());
			}
		}
	}
	if (!children.isEmpty()) {
%>
		if (editPart instanceof <%=importManager.getImportedName(genContainer.getEditPartQualifiedClassName())%>) {
			List types = new ArrayList();
<%
			for (int i = 0; i < children.size(); i++) {
				String id = ((GenNode) children.get(i)).getUniqueIdentifier();
%>
			types.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=id%>);
<%			}%>
			return types;
		}
<%
	}
}
%>
		return Collections.EMPTY_LIST;
	}
<%
Map outgoingLinks = new LinkedHashMap(); // source -> links going from the source
Map incomingLinks = new LinkedHashMap(); // target -> links coming to the target
for (Iterator links = genDiagram.getLinks().iterator(); links.hasNext(); ) {
	GenLink genLink = (GenLink) links.next();
	for (Iterator sources = genLink.getAssistantSources().iterator(); sources.hasNext(); ) {
		GenCommonBase source = (GenCommonBase) sources.next();
		Collection value = (Collection) outgoingLinks.get(source);
		if (value == null) {
			value = new LinkedHashSet();
			outgoingLinks.put(source, value);
		}
		value.add(genLink);
	}
	for (Iterator targets = genLink.getAssistantTargets().iterator(); targets.hasNext(); ) {
		GenCommonBase target = (GenCommonBase) targets.next();
		Collection value = (Collection) incomingLinks.get(target);
		if (value == null) {
			value = new LinkedHashSet();
			incomingLinks.put(target, value);
		}
		value.add(genLink);
	}
}
%>

	/**
	 * @@generated
	 */
	public List getRelTypesOnSource(IAdaptable source) {
<%if (!outgoingLinks.isEmpty()) {%>
		IGraphicalEditPart sourceEditPart = (IGraphicalEditPart) source.getAdapter(IGraphicalEditPart.class);
<%
	for (Iterator sources = outgoingLinks.keySet().iterator(); sources.hasNext(); ) {
		GenCommonBase source = (GenCommonBase) sources.next();
%>
		if (sourceEditPart instanceof <%=importManager.getImportedName(source.getEditPartQualifiedClassName())%>) {
			List types = new ArrayList();
<%
		for (Iterator links = ((Collection) outgoingLinks.get(source)).iterator(); links.hasNext(); ) {
			GenLink genLink = (GenLink) links.next();
%>
			types.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>);
<%		}%>
			return types;
		}
<%
	}
}
%>
		return Collections.EMPTY_LIST;
	}

	/**
	 * @@generated
	 */
	public List getRelTypesOnTarget(IAdaptable target) {
<%if (!incomingLinks.isEmpty()) {%>
		IGraphicalEditPart targetEditPart = (IGraphicalEditPart) target.getAdapter(IGraphicalEditPart.class);
<%
	for (Iterator targets = incomingLinks.keySet().iterator(); targets.hasNext(); ) {
		GenCommonBase target = (GenCommonBase) targets.next();
%>
		if (targetEditPart instanceof <%=importManager.getImportedName(target.getEditPartQualifiedClassName())%>) {
			List types = new ArrayList();
<%
		for (Iterator links = ((Collection) incomingLinks.get(target)).iterator(); links.hasNext(); ) {
			GenLink genLink = (GenLink) links.next();
%>
			types.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>);
<%		}%>
			return types;
		}
<%
	}
}
%>
		return Collections.EMPTY_LIST;
	}

	/**
	 * @@generated
	 */
	public List getRelTypesOnSourceAndTarget(IAdaptable source, IAdaptable target) {
<%if (!outgoingLinks.isEmpty()) {%>
		IGraphicalEditPart sourceEditPart = (IGraphicalEditPart) source.getAdapter(IGraphicalEditPart.class);
		IGraphicalEditPart targetEditPart = (IGraphicalEditPart) target.getAdapter(IGraphicalEditPart.class);
<%
	for (Iterator sources = outgoingLinks.keySet().iterator(); sources.hasNext(); ) {
		GenCommonBase source = (GenCommonBase) sources.next();
%>
		if (sourceEditPart instanceof <%=importManager.getImportedName(source.getEditPartQualifiedClassName())%>) {
			List types = new ArrayList();
<%
		for (Iterator links = ((Collection) outgoingLinks.get(source)).iterator(); links.hasNext(); ) {
			GenLink genLink = (GenLink) links.next();
			for (Iterator targets = genLink.getAssistantTargets().iterator(); targets.hasNext(); ) {
				GenCommonBase target = (GenCommonBase) targets.next();
%>
			if (targetEditPart instanceof <%=importManager.getImportedName(target.getEditPartQualifiedClassName())%>) {
				types.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>);
			}
<%
			}
		}
%>
			return types;
		}
<%
	}
}
%>
		return Collections.EMPTY_LIST;
	}

	/**
	 * @@generated
	 */
	public List getTypesForSource(IAdaptable target, IElementType relationshipType) {
<%if (!incomingLinks.isEmpty()) {%>
		IGraphicalEditPart targetEditPart = (IGraphicalEditPart) target.getAdapter(IGraphicalEditPart.class);
<%
	for (Iterator targets = incomingLinks.keySet().iterator(); targets.hasNext(); ) {
		GenCommonBase target = (GenCommonBase) targets.next();
%>
		if (targetEditPart instanceof <%=importManager.getImportedName(target.getEditPartQualifiedClassName())%>) {
			List types = new ArrayList();
<%
		for (Iterator links = ((Collection) incomingLinks.get(target)).iterator(); links.hasNext(); ) {
			GenLink genLink = (GenLink) links.next();
			for (Iterator sources = genLink.getAssistantSources().iterator(); sources.hasNext(); ) {
				GenCommonBase source = (GenCommonBase) sources.next();
%>
			if (relationshipType == <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>) {
				types.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=source.getUniqueIdentifier()%>);
			}
<%
			}
		}
%>
			return types;
		}
<%
	}
}
%>
		return Collections.EMPTY_LIST;
	}

	/**
	 * @@generated
	 */
	public List getTypesForTarget(IAdaptable source, IElementType relationshipType) {
<%if (!outgoingLinks.isEmpty()) {%>
		IGraphicalEditPart sourceEditPart = (IGraphicalEditPart) source.getAdapter(IGraphicalEditPart.class);
<%
	for (Iterator sources = outgoingLinks.keySet().iterator(); sources.hasNext(); ) {
		GenCommonBase source = (GenCommonBase) sources.next();
%>
		if (sourceEditPart instanceof <%=importManager.getImportedName(source.getEditPartQualifiedClassName())%>) {
			List types = new ArrayList();
<%
		for (Iterator links = ((Collection) outgoingLinks.get(source)).iterator(); links.hasNext(); ) {
			GenLink genLink = (GenLink) links.next();
			for (Iterator targets = genLink.getAssistantTargets().iterator(); targets.hasNext(); ) {
				GenCommonBase target = (GenCommonBase) targets.next();
%>
			if (relationshipType == <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>) {
				types.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=target.getUniqueIdentifier()%>);
			}
<%
			}
		}
%>
			return types;
		}
<%
	}
}
%>
		return Collections.EMPTY_LIST;
	}

	/**
	 * @@generated
	 */
	public EObject selectExistingElementForSource(IAdaptable target, IElementType relationshipType) {
		return selectExistingElement(target, getTypesForSource(target, relationshipType));
	}

	/**
	 * @@generated
	 */
	public EObject selectExistingElementForTarget(IAdaptable source, IElementType relationshipType) {
		return selectExistingElement(source, getTypesForTarget(source, relationshipType));
	}

	/**
	 * @@generated
	 */
	protected EObject selectExistingElement(IAdaptable host, Collection types) {
		if (types.isEmpty()) {
			return null;
		}
		IGraphicalEditPart editPart = (IGraphicalEditPart) host.getAdapter(IGraphicalEditPart.class);
		if (editPart == null) {
			return null;
		}
		Diagram diagram = (Diagram) editPart.getRoot().getContents().getModel();
		Collection elements = new HashSet();
		for (Iterator it = diagram.getElement().eAllContents(); it.hasNext();) {
			EObject element = (EObject) it.next();
			if (isApplicableElement(element, types)) {
				elements.add(element);
			}
		}
		if (elements.isEmpty()) {
			return null;
		}
		return selectElement((EObject[]) elements.toArray(new EObject[elements.size()]));
	}

	/**
	 * @@generated
	 */
	protected boolean isApplicableElement(EObject element, Collection types) {
		IElementType type = ElementTypeRegistry.getInstance().getElementType(element);
		return types.contains(type);
	}

	/**
	 * @@generated
	 */
	protected EObject selectElement(EObject[] elements) {
		Shell shell = Display.getCurrent().getActiveShell();
		ILabelProvider labelProvider = new AdapterFactoryLabelProvider(<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemProvidersAdapterFactory());
		ElementListSelectionDialog dialog = new ElementListSelectionDialog(shell, labelProvider);
		dialog.setMessage("Available domain model elements:");
		dialog.setTitle("Select domain model element");
		dialog.setMultipleSelection(false);
		dialog.setElements(elements);
		EObject selected = null;
		if (dialog.open() == Window.OK) {
			selected = (EObject) dialog.getFirstResult();
		}
		return selected;
	}
}
<%importManager.emitSortedImports();%>
@


1.23
log
@NodeItemSemanticEditPolicy template reimplemented using xpand.
@
text
@@


1.22
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d80 1
a80 1
	for (Iterator sources = genLink.getSources().iterator(); sources.hasNext(); ) {
d89 1
a89 1
	for (Iterator targets = genLink.getTargets().iterator(); targets.hasNext(); ) {
d171 1
a171 1
			for (Iterator targets = genLink.getTargets().iterator(); targets.hasNext(); ) {
d205 1
a205 1
			for (Iterator sources = genLink.getSources().iterator(); sources.hasNext(); ) {
d239 1
a239 1
			for (Iterator targets = genLink.getTargets().iterator(); targets.hasNext(); ) {
@


1.21
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d3 4
a6 1
<%GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];%>
d8 1
a8 1
package <%=genDiagram.getProvidersPackageName()%>;
a9 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());%>
@


1.20
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d4 1
@


1.19
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d3 1
a3 1
<%GenDiagram genDiagram = (GenDiagram) argument;%>
@


1.18
log
@ImportManager moved to oeg.common
@
text
@d307 1
a307 1
		ILabelProvider labelProvider = new AdapterFactoryLabelProvider(<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemProvidersAdapterFactory());
@


1.17
log
@Fixing the sequence of iterration.
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.16
log
@Fixing the sequence of iterration.
@
text
@d81 1
a81 1
			value = new HashSet();
d90 1
a90 1
			value = new HashSet();
@


1.15
log
@do not provide assistance for list compartments since they delegate to the host nodes
@
text
@d73 2
a74 2
Map outgoingLinks = new HashMap(); // source -> links going from the source
Map incomingLinks = new HashMap(); // target -> links coming to the target
@


1.14
log
@#124829 Support links in generated ModelingAssistantProvider
@
text
@d42 3
d46 1
a46 1
	if (genContainer instanceof GenNode && ((GenNode) genContainer).isListLayout()) {
d48 4
a51 1
			children.addAll(((GenCompartment) compartments.next()).getContainedNodes());
@


1.13
log
@#124829 Support links in generated ModelingAssistantProvider
@
text
@d8 1
d10 2
d16 1
d19 8
d248 65
@


1.12
log
@REadable names should present in popup bar
@
text
@d13 1
d26 1
a26 1
		Object editPart = host.getAdapter(IGraphicalEditPart.class);
d28 1
a28 2
Collection containers = genDiagram.getAllContainers();
for (Iterator contents = containers.iterator(); contents.hasNext(); ) {
d39 1
a39 1
			List children = new ArrayList();
d44 1
a44 1
			children.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=id%>);
d46 1
a46 1
			return children;
d55 2
a56 2
Map linksForSources = new HashMap();
Map linksForTargets = new HashMap();
d61 1
a61 1
		List value = (List) linksForSources.get(source);
d63 2
a64 2
			value = new ArrayList();
			linksForSources.put(source, value);
d70 1
a70 1
		List value = (List) linksForTargets.get(target);
d72 2
a73 2
			value = new ArrayList();
			linksForTargets.put(target, value);
d84 2
a85 2
<%if (!linksForSources.isEmpty()) {%>
		Object sourceEditPart = source.getAdapter(IGraphicalEditPart.class);
d87 1
a87 1
	for (Iterator sources = linksForSources.keySet().iterator(); sources.hasNext(); ) {
a88 1
		List sourceLinks = (List) linksForSources.get(source);
d91 1
a91 1
			List children = new ArrayList();
d93 1
a93 1
		for (Iterator links = sourceLinks.iterator(); links.hasNext(); ) {
d96 1
a96 1
			children.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>);
d98 1
a98 1
			return children;
d111 2
a112 2
<%if (!linksForTargets.isEmpty()) {%>
		Object targetEditPart = target.getAdapter(IGraphicalEditPart.class);
d114 1
a114 1
	for (Iterator targets = linksForTargets.keySet().iterator(); targets.hasNext(); ) {
a115 1
		List targetLinks = (List) linksForTargets.get(target);
d118 1
a118 1
			List children = new ArrayList();
d120 1
a120 1
		for (Iterator links = targetLinks.iterator(); links.hasNext(); ) {
d123 1
a123 1
			children.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>);
d125 1
a125 1
			return children;
d138 3
a140 3
<%if (!linksForSources.isEmpty()) {%>
		Object sourceEditPart = source.getAdapter(IGraphicalEditPart.class);
		Object targetEditPart = target.getAdapter(IGraphicalEditPart.class);
d142 1
a142 1
	for (Iterator sources = linksForSources.keySet().iterator(); sources.hasNext(); ) {
a143 1
		List sourceLinks = (List) linksForSources.get(source);
d146 1
a146 1
			List children = new ArrayList();
d148 1
a148 1
		for (Iterator links = sourceLinks.iterator(); links.hasNext(); ) {
d154 1
a154 1
				children.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>);
d160 69
a228 1
			return children;
@


1.11
log
@#124829 Support links in generated ModelingAssistantProvider
@
text
@d27 1
a27 3
List containers = new ArrayList();
containers.add(genDiagram);
containers.addAll(genDiagram.getAllNodes());
@


1.10
log
@rename GenContainerEditPart -> GenContainerBase
@
text
@d56 117
@


1.9
log
@#124830 Add all children of the list compartment to the popup bar of the parent node
@
text
@d31 1
a31 1
	GenContainerEditPart genContainer = (GenContainerEditPart) contents.next();
@


1.8
log
@#124413
Cleaning up the gmfgen model
@
text
@d27 4
a30 1
for (Iterator contents = genDiagram.getAllContainerEditParts().iterator(); contents.hasNext(); ) {
d32 6
a37 1
	List children = genContainer.getContainedNodes();
d42 5
a46 2
<%			for (int i = 0; i < children.size(); i++) {%>
			children.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=((GenNode) children.get(i)).getUniqueIdentifier()%>);
@


1.7
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@d27 1
a27 3
Collection allContainers = new LinkedList(genDiagram.getAllContainers());
allContainers.add(genDiagram);
for (Iterator contents = allContainers.iterator(); contents.hasNext(); ) {
@


1.6
log
@#117301 child nodes creation in compartment is not supported by modeling assistant
@
text
@a25 9
		if (editPart instanceof <%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>) {
			List children = new ArrayList();
<%
List children = genDiagram.getNodes();
for (int i = 0; i < children.size(); i++) {
%>
			children.add(<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=((GenNode) children.get(i)).getUniqueIdentifier()%>);
<%}%>
			return children;
d27 6
a32 6
for (Iterator contents = genDiagram.eAllContents(); contents.hasNext(); ) {
	Object next = contents.next();
	if (next instanceof GenChildContainer) {
		GenChildContainer genContainer = (GenChildContainer) next;
		children = genContainer.getChildNodes();
		if (!children.isEmpty()) {
d34 1
a34 1
		} else if (editPart instanceof <%=importManager.getImportedName(genContainer.getEditPartQualifiedClassName())%>) {
d40 1
a41 1
		}
a44 1
		}
@


1.5
log
@#116031 avoid hardcoded class names in templates
@
text
@d38 3
a40 3
	if (next instanceof GenNode) {
		GenNode genNode = (GenNode) next;
		children = AccessUtil.getAllChildNodes(genNode);
d43 1
a43 1
		} else if (editPart instanceof <%=importManager.getImportedName(genNode.getEditPartQualifiedClassName())%>) {
@


1.4
log
@#115622 use genDiagram.eAllContents() to iterate over diagram contents instead of using custom iterator
@
text
@d32 1
a32 1
			children.add(ElementTypes.<%=((GenNode) children.get(i)).getUniqueIdentifier()%>);
d46 1
a46 1
			children.add(ElementTypes.<%=((GenNode) children.get(i)).getUniqueIdentifier()%>);
@


1.3
log
@[dstadnik] #115273 reflect class name change
@
text
@d3 2
a4 2
<%GenDiagram diagram = (GenDiagram) argument;%>
package <%=diagram.getProvidersPackageName()%>;
d6 1
a6 1
<%ImportUtil importManager = new ImportUtil(diagram.getProvidersPackageName());%>
d19 1
a19 1
public class <%=diagram.getModelingAssistantProviderClassName()%> extends ModelingAssistantProvider {
d26 2
d29 13
a41 13
Iterator entities = AccessUtil.getGenEntities(diagram);
while (entities.hasNext()) {
	GenCommonBase entity = (GenCommonBase) entities.next();
	List children = Collections.EMPTY_LIST;
	if (entity instanceof GenDiagram) {
		children = diagram.getNodes();
	} else if (entity instanceof GenNode) {
		children = AccessUtil.getAllChildNodes((GenNode) entity);
	}
	if (children.isEmpty()) {
		continue;
	}
	String editPartClassName = importManager.getImportedName(entity.getEditPartQualifiedClassName());
d43 1
a43 1
		if (editPart instanceof <%=editPartClassName%>) {
d45 1
a45 1
<%	for (int i = 0; i < children.size(); i++) {%>
d47 1
a47 1
<%	}%>
d49 5
a54 1
<%}%>
@


1.2
log
@[ashatalin] #113892 flexible compartment hierarchy
@
text
@d24 1
a24 1
	public List getTypesForActionBar(IAdaptable host) {
@


1.1
log
@[dstadnik] #112901 modeling assistant provider
@
text
@d34 1
a34 1
		children = ((GenNode) entity).getChildNodes();
@

