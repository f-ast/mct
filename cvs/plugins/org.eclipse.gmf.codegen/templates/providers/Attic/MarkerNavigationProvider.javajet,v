head	1.9;
access;
symbols
	v20081022-1925:1.9
	v20081015-1925:1.9
	v20081008-1925:1.9
	v20081001-1925:1.9
	v20080924-1925:1.9
	v20080917-1925:1.9
	v20080911-1728:1.9
	v20080910-1520:1.9
	v20080903-1520:1.9
	v20080827-1520:1.9
	v20080813-1520:1.9
	v20080806-1520:1.9
	v20070504-1000:1.7
	v20070427-0600:1.7
	v20070420-1000:1.7
	v20070413-1300:1.7
	v20070405-1100:1.7
	v20070403-1500:1.7
	v20070330-1300:1.7
	v20060330-1300:1.7
	v20070322-1100:1.7
	v20060316-0600:1.7
	v20070307-0700:1.7
	v20070301-1200:1.7
	v20070228-2000:1.7
	v20070221-1500:1.7
	v20070208-1800:1.7
	v20070202-0200:1.6
	v20070103-0300:1.7
	M4_20:1.7
	v20061222-1800:1.7
	v20061218-1200:1.7
	v20061214-0000:1.7
	v20061120-1300:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061027-1200:1.6
	v20061020-1000:1.6
	v20061013-1330:1.6
	v20060919-0800:1.6
	v20060907-1100:1.6
	M1_20:1.6
	v20060904-1500:1.6
	v20060824-1600:1.6
	v20060817-1500:1.6
	v20060728-0500:1.6
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060626-1420:1.6
	v20060620-0400:1.6
	v20060616-1400:1.6
	v20060616-1200:1.6
	v20060609-1400:1.6
	v20060531-1730:1.6
	v20060530-1930:1.6
	v20060526-1200:1.6
	v20060519-1300:1.6
	v20060519-0800:1.6
	v20060512-1000:1.5
	I20060512-1000:1.5
	I20060505-1400:1.5
	I20060428-1300:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.1
	I20060202-1415:1.1
	I20060129-1145:1.1
	I20060127-0900:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.9
date	2007.05.10.09.23.21;	author dstadnik;	state dead;
branches;
next	1.8;
commitid	59a14642e4894567;

1.8
date	2007.05.08.14.49.25;	author dstadnik;	state Exp;
branches;
next	1.7;
commitid	475646408df44567;

1.7
date	2006.12.11.09.58.32;	author radvorak;	state Exp;
branches;
next	1.6;
commitid	5d2a457d2bc44567;

1.6
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.01.13.14.08;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.25.14.27.29;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.9
log
@rewrite marker navigation provider in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.providers" class="MarkerNavigationProviderGenerator"
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram)((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
final String pluginActivatorClass = importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName());
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%
importManager.markImportLocation(stringBuffer);

importManager.addImport("java.util.ArrayList");
importManager.addImport("java.util.Arrays");
importManager.addImport("java.util.Iterator");
importManager.addImport("java.util.List");
importManager.addImport("java.util.Map");
importManager.addImport("java.util.HashSet");
importManager.addImport("java.util.Set");
importManager.addImport("org.eclipse.core.resources.IFile");
importManager.addImport("org.eclipse.core.resources.IMarker");
importManager.addImport("org.eclipse.core.resources.IResource");
importManager.addImport("org.eclipse.core.runtime.CoreException");
importManager.addImport("org.eclipse.core.runtime.IStatus");
importManager.addImport("org.eclipse.emf.common.util.Diagnostic");
importManager.addImport("org.eclipse.emf.ecore.EObject");
importManager.addImport("org.eclipse.emf.validation.model.IConstraintStatus");
importManager.addImport("org.eclipse.gef.EditPart");
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart");
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor");
importManager.addImport("org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil");
importManager.addImport("org.eclipse.gmf.runtime.emf.ui.providers.marker.AbstractModelMarkerNavigationProvider");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
%>

/**
 * @@generated
 */	
public class <%=genDiagram.getMarkerNavigationProviderClassName()%> extends AbstractModelMarkerNavigationProvider {
	/**
	 * @@generated
	 */
	public static final String MARKER_TYPE = <%=pluginActivatorClass%>.ID + ".<%=genDiagram.getValidationDiagnosticMarkerType()%>"; //$NON-NLS-1$

	/**
	 * @@generated
	 */		
	protected void doGotoMarker(IMarker marker) {
		String elementId = marker.getAttribute(org.eclipse.gmf.runtime.common.core.resources.IMarker.ELEMENT_ID, null);
		if(elementId == null || !(getEditor() instanceof DiagramEditor)) {
			return;
		}
		
		DiagramEditor editor = (DiagramEditor) getEditor();
		Map editPartRegistry = editor.getDiagramGraphicalViewer().getEditPartRegistry();
		EObject targetView = editor.getDiagram().eResource().getEObject(elementId);
		if(targetView == null) {
			return;
		}
		EditPart targetEditPart = (EditPart)editPartRegistry.get(targetView);
		if (targetEditPart != null) {
			<%=importManager.getImportedName(genDiagram.getDiagramEditorUtilQualifiedClassName())%>.selectElementsInDiagram(editor, Arrays.asList(new EditPart[] { targetEditPart }));
		}
	}

	/**
	 * @@generated
	 */
	public static void deleteMarkers(IResource resource) {
		try {
			resource.deleteMarkers(MARKER_TYPE, true, IResource.DEPTH_ZERO);
		} catch (CoreException e) {
			<%=pluginActivatorClass%>.getInstance().logError("Failed to delete validation markers", e); //$NON-NLS-1$
		}
	}
	
	/**
	 * @@generated
	 */
	public static IMarker addMarker(IFile file, String elementId, String location, String message, int statusSeverity) {
		IMarker marker = null;
		try {
			marker = file.createMarker(MARKER_TYPE);
			marker.setAttribute(IMarker.MESSAGE, message);
			marker.setAttribute(IMarker.LOCATION, location);
			marker.setAttribute(org.eclipse.gmf.runtime.common.ui.resources.IMarker.ELEMENT_ID, elementId);
			int markerSeverity = IMarker.SEVERITY_INFO;
			if(statusSeverity == IStatus.WARNING) {
				markerSeverity = IMarker.SEVERITY_WARNING;    						
			} else if(statusSeverity == IStatus.ERROR || statusSeverity == IStatus.CANCEL) {
				markerSeverity = IMarker.SEVERITY_ERROR;
			}
			marker.setAttribute(IMarker.SEVERITY, markerSeverity);
		} catch (CoreException e) {
			<%=pluginActivatorClass%>.getInstance().logError("Failed to create validation marker", e); //$NON-NLS-1$
		}
		return marker;		
	}	
}
<%importManager.emitSortedImports();%>
@


1.8
log
@[178958] move code that iterates over diagnostics to location reusable in rcp
@
text
@@


1.7
log
@[166814] Refactor diagram editor Audits&Metrics support
@
text
@a65 49
	
	/**
	 * @@generated
	 */
	public static void createMarkers(IFile diagramFile, IStatus validationStatus, DiagramEditPart diagramEditPart) {
		if(validationStatus.isOK()) return;
		
		final IStatus rootStatus = validationStatus;
		List allStatuses = new ArrayList();
		<%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap element2ViewMap = new <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap(
			diagramEditPart.getDiagramView(), collectTargetElements(rootStatus, new HashSet(), allStatuses));
		
		for (Iterator it = allStatuses.iterator(); it.hasNext();) {
			IConstraintStatus nextStatus = (IConstraintStatus)it.next();
			View view = <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.findView(diagramEditPart, nextStatus.getTarget(), element2ViewMap);			
			IMarker newMarker = addMarker(diagramFile, view.eResource().getURIFragment(view), 
					EMFCoreUtil.getQualifiedName(nextStatus.getTarget(), true), 
					nextStatus.getMessage(), nextStatus.getSeverity());
			if (newMarker != null) {
				adjustMarker(newMarker, nextStatus);
			}
		}
	}
	
	/**
	 * @@generated
	 */
	public static void createMarkers(IFile diagramFile, Diagnostic emfValidationStatus, DiagramEditPart diagramEditPart) {
		if(emfValidationStatus.getSeverity() == Diagnostic.OK) return;
		
		final Diagnostic rootStatus = emfValidationStatus;
		List allDiagnostics = new ArrayList();
		<%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap element2ViewMap = new <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap(diagramEditPart.getDiagramView(), collectTargetElements(rootStatus, new HashSet(), allDiagnostics));
		
		for (Iterator it = emfValidationStatus.getChildren().iterator(); it.hasNext();) {
			Diagnostic nextDiagnostic = (Diagnostic) it.next();
			List data = nextDiagnostic.getData();
			if (data != null && !data.isEmpty() && data.get(0) instanceof EObject) {
				EObject element = (EObject) data.get(0);
				View view = <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.findView(diagramEditPart, element, element2ViewMap);
				IMarker newMarker = addMarker(diagramFile, view.eResource().getURIFragment(view),
						EMFCoreUtil.getQualifiedName(element, true), nextDiagnostic.getMessage(),
						diagnosticToStatusSeverity(nextDiagnostic.getSeverity()));
				if (newMarker != null) {
					adjustMarker(newMarker, emfValidationStatus);
				}
			}
		}
	}
d81 1
a81 15
	public static void adjustMarker(IMarker marker, Diagnostic sourceDiagnostic) {
		assert marker != null && sourceDiagnostic != null;
	}

	/**
	 * @@generated
	 */
	public static void adjustMarker(IMarker marker, IConstraintStatus sourceStatus) {
		assert marker != null && sourceStatus != null;		
	}
	
	/**
	 * @@generated
	 */
	private static IMarker addMarker(IFile file, String elementId, String location, String message, int statusSeverity) {
a99 53
		
	/**
	 * @@generated
	 */
	private static int diagnosticToStatusSeverity(int diagnosticSeverity) {
		if (diagnosticSeverity == Diagnostic.OK) {
			return IStatus.OK;
		} else if (diagnosticSeverity == Diagnostic.INFO) {
			return IStatus.INFO;
		} else if (diagnosticSeverity == Diagnostic.WARNING) {
			return IStatus.WARNING;
		} else if (diagnosticSeverity == Diagnostic.ERROR
				|| diagnosticSeverity == Diagnostic.CANCEL) {
			return IStatus.ERROR;
		}
		return IStatus.INFO;
	}	

	/**
	 * @@generated
	 */	
	private static Set collectTargetElements(IStatus status, Set targetElementCollector, List allConstraintStatuses) {
		if(status instanceof IConstraintStatus) {
			targetElementCollector.add(((IConstraintStatus)status).getTarget());
			allConstraintStatuses.add(status);
		}
		if(status.isMultiStatus()) {
			IStatus[] children = status.getChildren();
			for (int i = 0; i < children.length; i++) {
				collectTargetElements(children[i], targetElementCollector, allConstraintStatuses);				
			}
		}
		return targetElementCollector;
	}

	/**
	 * @@generated
	 */	
	private static Set collectTargetElements(Diagnostic diagnostic, Set targetElementCollector, List allDiagnostics) {
		List data = diagnostic.getData();
		EObject target = null;
		if (data != null && !data.isEmpty() && data.get(0) instanceof EObject) {
			target = (EObject)data.get(0);
			targetElementCollector.add(target);	
			allDiagnostics.add(diagnostic);
		}
		if(diagnostic.getChildren() != null && !diagnostic.getChildren().isEmpty()) {
			for (Iterator it = diagnostic.getChildren().iterator(); it.hasNext();) {
				collectTargetElements((Diagnostic)it.next(), targetElementCollector, allDiagnostics);
			}
		}
		return targetElementCollector;
	}
@


1.6
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d6 1
d13 3
d17 1
d19 3
d23 6
d30 1
a30 1
importManager.addImport("org.eclipse.gmf.runtime.diagram.core.util.ViewUtil");
d32 1
d43 5
d50 1
a50 1
		String elementId = marker.getAttribute(org.eclipse.gmf.runtime.common.ui.resources.IMarker.ELEMENT_ID, null);
d54 58
a111 12
		EditPart targetEditPart = null;
		DiagramEditor editor = (DiagramEditor)getEditor();
		Map epartRegistry = editor.getDiagramGraphicalViewer().getEditPartRegistry();
		for (Iterator it = epartRegistry.entrySet().iterator(); it.hasNext();) {
			Map.Entry entry = (Map.Entry) it.next();
			if(entry.getKey() instanceof View) {
				View view = (View)entry.getKey();
				String viewId = ViewUtil.getIdStr(view);
				if(viewId.equals(elementId)) {
					targetEditPart = (EditPart)entry.getValue();
					break;
				} 
d114 99
a212 3
		if(targetEditPart != null) {
			editor.getDiagramGraphicalViewer().select(targetEditPart);			
			editor.getDiagramGraphicalViewer().reveal(targetEditPart);
d214 1
@


1.5
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d8 1
a8 1
package <%=genDiagram.getProvidersPackageName()%>;
@


1.4
log
@[rdvorak] #129766 Remove deprecated API usage
@
text
@d7 1
@


1.3
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d4 2
a5 2
GenDiagram genDiagram = (GenDiagram)((Object[]) argument)[0];
ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());
d9 11
a19 11
import java.util.Iterator;
import java.util.Map;

import org.eclipse.core.resources.IMarker;
import org.eclipse.gef.EditPart;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
import org.eclipse.gmf.runtime.emf.ui.providers.marker.AbstractModelMarkerNavigationProvider;
import org.eclipse.gmf.runtime.notation.View;

<%importManager.markImportLocation(stringBuffer);%>
d40 1
a40 1
				String viewId = EObjectUtil.getID(view);
@


1.2
log
@ImportManager moved to oeg.common
@
text
@d4 1
a4 1
GenDiagram genDiagram = (GenDiagram)argument;
@


1.1
log
@[rdvorak] #114189 Provide support for batch validation
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@

