head	1.28;
access;
symbols
	v20081022-1925:1.28
	v20081015-1925:1.28
	v20081008-1925:1.28
	v20081001-1925:1.28
	v20080924-1925:1.28
	v20080917-1925:1.28
	v20080911-1728:1.28
	v20080910-1520:1.28
	v20080903-1520:1.28
	v20080827-1520:1.28
	v20080813-1520:1.28
	v20080806-1520:1.28
	v20070903-0000:1.27
	v20070809-0000:1.27
	R2_0_maintenance:1.27.0.2
	R2_0:1.27
	R4_20:1.27
	v20070621-0000:1.27
	RC3_20:1.27
	v20070614-1400:1.27
	v20070608-1300:1.27
	v20070605-1400:1.27
	v20070601-1400:1.27
	v20070525-1500:1.27
	v20070520-1200:1.27
	v20070518-1300:1.27
	v20070504-1000:1.25
	v20070427-0600:1.25
	v20070420-1000:1.25
	v20070413-1300:1.25
	v20070405-1100:1.25
	v20070403-1500:1.25
	v20070330-1300:1.25
	v20060330-1300:1.25
	v20070322-1100:1.25
	v20060316-0600:1.25
	v20070307-0700:1.25
	v20070301-1200:1.25
	v20070228-2000:1.25
	v20070221-1500:1.25
	v20070208-1800:1.25
	v20070202-0200:1.21
	v20070103-0300:1.22
	M4_20:1.22
	v20061222-1800:1.22
	v20061218-1200:1.22
	v20061214-0000:1.22
	v20061120-1300:1.21
	M3_20:1.21
	v20061117-0800:1.21
	v20061027-1200:1.21
	v20061020-1000:1.21
	v20061013-1330:1.21
	v20060919-0800:1.21
	v20060907-1100:1.21
	M1_20:1.21
	v20060904-1500:1.21
	v20060824-1600:1.21
	v20060817-1500:1.21
	v20060728-0500:1.21
	v20060713-1700:1.21
	R1_0_maintenance:1.21.0.2
	R1_0:1.21
	v20060627-1200:1.21
	v20060626-1420:1.21
	v20060620-0400:1.20
	v20060616-1400:1.20
	v20060616-1200:1.20
	v20060609-1400:1.16
	v20060531-1730:1.16
	v20060530-1930:1.16
	v20060526-1200:1.15
	v20060519-1300:1.15
	v20060519-0800:1.15
	v20060512-1000:1.14
	I20060512-1000:1.14
	I20060505-1400:1.13
	I20060428-1300:1.13
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.11
	I20060407-1200:1.9
	I20060331-1000:1.9
	I20060324-0300:1.9
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.9
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.7
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.3
	I20060202-1415:1.3
	I20060129-1145:1.2
	I20060127-0900:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.28
date	2007.09.13.18.19.02;	author dstadnik;	state dead;
branches;
next	1.27;
commitid	51ec46e97f104567;

1.27
date	2007.05.10.13.12.15;	author dstadnik;	state Exp;
branches
	1.27.2.1;
next	1.26;
commitid	52b46431a2d4567;

1.26
date	2007.05.08.14.49.25;	author dstadnik;	state Exp;
branches;
next	1.25;
commitid	475646408df44567;

1.25
date	2007.02.08.18.06.48;	author atikhomirov;	state Exp;
branches;
next	1.24;
commitid	56b45cb66aa4567;

1.24
date	2007.02.07.00.37.48;	author atikhomirov;	state Exp;
branches;
next	1.23;
commitid	c5d45c91f504567;

1.23
date	2007.01.11.15.30.00;	author dstadnik;	state Exp;
branches;
next	1.22;
commitid	3f6d45a657f64567;

1.22
date	2006.12.11.09.58.32;	author radvorak;	state Exp;
branches;
next	1.21;
commitid	5d2a457d2bc44567;

1.21
date	2006.06.21.22.26.21;	author radvorak;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.16.10.16.29;	author radvorak;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.15.15.39.44;	author radvorak;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.14.13.56.50;	author radvorak;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.09.19.39.00;	author radvorak;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.29.20.07.49;	author radvorak;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.11.18.37.54;	author radvorak;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.25.19.16.05;	author radvorak;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.20.19.36.27;	author radvorak;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.14.15.01.28;	author radvorak;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.13.22.22.22;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.01.13.14.08;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.24.20.23.27;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.31.19.02.07;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.26.13.36.40;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.25.14.27.29;	author atikhomirov;	state Exp;
branches;
next	;

1.27.2.1
date	2007.09.13.18.16.19;	author dstadnik;	state dead;
branches;
next	;
commitid	485346e97e6f4567;


desc
@@


1.28
log
@rewrite validation prov in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.providers" class="ValidationProviderGenerator"
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.* org.eclipse.gmf.internal.common.codegen.* org.eclipse.emf.codegen.ecore.genmodel.*"%>
<%
final GenDiagram genDiagram = (GenDiagram)((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
final String pluginActivatorClass = importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName());
final GenAuditRoot audits = genDiagram.getEditorGen().getAudits();
final boolean hasNotationModelAudit;
{
 boolean hasDiagramElementRule = false;
 if (audits != null) {
  for (java.util.Iterator it = audits.getRules().iterator(); it.hasNext();) {
   GenAuditRule r = (GenAuditRule) it.next();
   if (r.getTarget() instanceof GenDiagramElementTarget || r.getTarget() instanceof GenNotationElementTarget) {
    hasDiagramElementRule = true;
    break;
   }
  }
 }
 hasNotationModelAudit = audits != null && hasDiagramElementRule;
}
final boolean rcp = genDiagram.getEditorGen().getApplication() != null;
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%
final java.util.HashSet<String> innerClasses = new java.util.HashSet<String>();
final String __javaOperationContainer = "JavaAudits";
if(audits != null) {
	innerClasses.add(__javaOperationContainer);
	//innerClasses.addAll(audits.getAllRequiredConstraintAdaptersLocalClassNames());
	for (java.util.Iterator it = audits.getRules().iterator(); it.hasNext();) {
		GenAuditRule nextAudit = (GenAuditRule) it.next();
		if (nextAudit.isRequiresConstraintAdapter()) {
			String nextClassName = nextAudit.getConstraintAdapterLocalClassName();
			if (nextClassName != null) {
				innerClasses.add(nextClassName);
			}
		}
	}
	//innerClasses.addAll(audits.getAllContextSelectorsLocalClassNames());
	for (java.util.Iterator it = audits.getRules().iterator(); it.hasNext();) {
		String nextClassName = ((GenAuditRule) it.next()).getContextSelectorLocalClassName();
		if(nextClassName != null) {
			innerClasses.add(nextClassName);
		}			
	}	
}
innerClasses.add("CtxSwitchStrategy");
innerClasses.add("ValidateAction");
for(java.util.Iterator it = innerClasses.iterator(); it.hasNext();) importManager.registerInnerClass((String)it.next()); 

importManager.markImportLocation(stringBuffer);

if (!rcp) {
importManager.addImport("org.eclipse.core.resources.IFile");
importManager.addImport("org.eclipse.emf.workspace.util.WorkspaceSynchronizer");
}
importManager.addImport("java.util.ArrayList");
importManager.addImport("java.util.Arrays");
importManager.addImport("java.util.Iterator");
importManager.addImport("java.util.List");
importManager.addImport("java.util.Map");
importManager.addImport("java.util.HashSet");
importManager.addImport("java.util.Set");
importManager.addImport("org.eclipse.core.runtime.IStatus");
importManager.addImport("org.eclipse.emf.common.util.Diagnostic");
importManager.addImport("org.eclipse.emf.ecore.EObject");
importManager.addImport("org.eclipse.emf.ecore.util.Diagnostician");
importManager.addImport("org.eclipse.emf.transaction.TransactionalEditingDomain");
importManager.addImport("org.eclipse.emf.transaction.util.TransactionUtil");
importManager.addImport("org.eclipse.emf.validation.model.EvaluationMode");
importManager.addImport("org.eclipse.emf.validation.service.IBatchValidator");
importManager.addImport("org.eclipse.emf.validation.service.ModelValidationService");
importManager.addImport("org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor");
importManager.addImport("org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.AbstractContributionItemProvider");
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart");
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart");
importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.OffscreenEditPartFactory");
importManager.addImport("org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil");
importManager.addImport("org.eclipse.emf.validation.model.IConstraintStatus");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
importManager.addImport("org.eclipse.jface.action.Action");
importManager.addImport("org.eclipse.jface.action.IAction");
importManager.addImport("org.eclipse.ui.IWorkbenchPart");
importManager.addImport("org.eclipse.ui.IEditorPart");
importManager.addImport("org.eclipse.ui.PlatformUI");
%>

/**
 * @@generated
 */
public class <%=genDiagram.getValidationProviderClassName()%> extends AbstractContributionItemProvider {

	/**
	 * @@generated
	 */
	private static boolean constraintsActive = false;	

	/**
	 * @@generated
	 */
	public static boolean shouldConstraintsBePrivate() {
		return false;
	}

	/**
	 * @@generated
	 */
	protected IAction createAction(String actionId, IWorkbenchPartDescriptor partDescriptor) {
		if (<%=genDiagram.getEditorGen().getEditor().getPackageName()%>.ValidateAction.VALIDATE_ACTION_KEY.equals(actionId)) {
			return new <%=genDiagram.getEditorGen().getEditor().getPackageName()%>.ValidateAction(partDescriptor);
		}
		return super.createAction(actionId, partDescriptor);
	}

		/**
		 * @@generated
		 */
		public static void runWithConstraints(View view, Runnable op) {
			final Runnable fop = op;
			Runnable task = new Runnable() {

				public void run() {
					try {
						constraintsActive = true;
						fop.run();
					} finally {
						constraintsActive = false;
					}
				}
			};
			TransactionalEditingDomain txDomain = TransactionUtil.getEditingDomain(view);
			if (txDomain != null) {
				try {
					txDomain.runExclusive(task);
				} catch (Exception e) {
					<%=pluginActivatorClass%>.getInstance().logError("Validation action failed", e); //$NON-NLS-1$
				}
			} else {
				task.run();
			}
		}

	/**
	* @@generated
	*/
	static boolean isInDefaultEditorContext(Object object) {
		if(shouldConstraintsBePrivate() && !constraintsActive) {
			return false;
		}
		if (object instanceof View) {
			return constraintsActive && <%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getModelID((View)object));
		}
		return true;
	}	
<%
boolean usesNotationContextSwitch = false;
java.util.List allAudits = (audits != null) ? audits.getRules() : java.util.Collections.EMPTY_LIST;
// mere pairs
java.util.HashMap<String, GenAuditRule> contextId2Audit = new java.util.HashMap<String, GenAuditRule>();
java.util.Map<GenCommonBase, String> view2SelectorMap = new java.util.IdentityHashMap<GenCommonBase, String>();
for(java.util.Iterator it = allAudits.iterator(); it.hasNext();) {
	GenAuditRule audit = (GenAuditRule)it.next();
	String contextID = (audit.getTarget() != null) ? audit.getTarget().getClientContextID() : null;
	if(contextID == null || contextId2Audit.containsKey(contextID)) continue;
	contextId2Audit.put(contextID, audit);
}
for (GenAuditRule audit : contextId2Audit.values()) {
	String selectorClassName = audit.getContextSelectorLocalClassName();
%>
	/**
	* @@generated
	*/
	public static class <%=selectorClassName%> implements <%=importManager.getImportedName("org.eclipse.emf.validation.model.IClientSelector")%> {
<%
	if(audit.getTarget() instanceof GenDiagramElementTarget) {
		usesNotationContextSwitch = true;
		GenDiagramElementTarget	diagramElement = (GenDiagramElementTarget)audit.getTarget();
		for(java.util.Iterator diagramElementIt = diagramElement.getElement().iterator(); diagramElementIt.hasNext();) {
			GenCommonBase nextElement = (GenCommonBase) diagramElementIt.next();
			view2SelectorMap.put(nextElement, selectorClassName);
		}
%>
		/**
		* @@generated
		*/
		public boolean selects(Object object) {		
			if(isInDefaultEditorContext(object) && object instanceof View) {
				String id = ((View) object).getType();
				return id != null && semanticCtxIdMap.get(id) == <%=selectorClassName%>.class;
			}
			return false;
		}
	}
<%	} else {%>
		/**
		* @@generated
		*/
		public boolean selects(Object object) {
			return isInDefaultEditorContext(object);	
		}	
	}		
<%
	} 
} // end of audits iteration
		
if(usesNotationContextSwitch) {
%>

	/**
	* @@generated
	*/
	static final <%=importManager.getImportedName("java.util.Map")%> semanticCtxIdMap = new <%=importManager.getImportedName("java.util.HashMap")%>();
	/**
	* @@generated
	*/
	static {
<%
	for(java.util.Iterator it = view2SelectorMap.keySet().iterator(); it.hasNext();) {
		GenCommonBase nextView = (GenCommonBase)it.next();
%>
		semanticCtxIdMap.put(String.valueOf(<%=importManager.getImportedName(nextView.getEditPartQualifiedClassName()) + ".VISUAL_ID"%>), <%=view2SelectorMap.get(nextView)%>.class); //$NON-NLS-1$
<%	} // end of view ID iteration %>
	}
<%
} // end of context map generation //usesNotationContextSwitch 
%>

<%if(hasNotationModelAudit) {%>
	/**
	 * @@generated
	 */
	public static <%=importManager.getImportedName("org.eclipse.emf.validation.service.ITraversalStrategy")%> getNotationTraversalStrategy(IBatchValidator validator) {
<%	if(usesNotationContextSwitch) {%>	
		return new CtxSwitchStrategy(validator);
<%} else {%>			
		return validator.getDefaultTraversalStrategy();
<%	} // end of usesNotationContextSwitch %>
	}
<%} // end of hasNotationModelAudit			

if(usesNotationContextSwitch) {%>
	/**
	 * @@generated
	 */
	private static class CtxSwitchStrategy implements <%=importManager.getImportedName("org.eclipse.emf.validation.service.ITraversalStrategy")%> {
		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.validation.service.ITraversalStrategy")%> defaultStrategy;
		/**
		 * @@generated
		 */
		private String currentSemanticCtxId;
		/**
		 * @@generated
		 */
		private boolean ctxChanged = true;
		/**
		 * @@generated
		 */
		private EObject currentTarget;	
		/**
		 * @@generated
		 */
		private EObject preFetchedNextTarget;		
	
		/**
		 * @@generated
		 */
		CtxSwitchStrategy(IBatchValidator validator) {
			this.defaultStrategy = validator.getDefaultTraversalStrategy();
		}
		
		/**
		 * @@generated
		 */
		public void elementValidated(EObject element, IStatus status) {
			defaultStrategy.elementValidated(element, status);
		}

		/**
		 * @@generated
		 */
		public boolean hasNext() {
			return defaultStrategy.hasNext();
		}

		/**
		 * @@generated
		 */
		public boolean isClientContextChanged() {
			if(preFetchedNextTarget == null) {
				preFetchedNextTarget = next();
				prepareNextClientContext(preFetchedNextTarget);				
			}			  			
			return ctxChanged;
		}

		/**
		 * @@generated
		 */
		public EObject next() {
			EObject nextTarget = preFetchedNextTarget;
			if(nextTarget == null) {
				nextTarget = defaultStrategy.next();
			}
			this.preFetchedNextTarget = null;
			return this.currentTarget = nextTarget;
		}

		/**
		 * @@generated
		 */
		public void startTraversal(<%=importManager.getImportedName("java.util.Collection")%> traversalRoots,
				<%=importManager.getImportedName("org.eclipse.core.runtime.IProgressMonitor")%> monitor) {
			defaultStrategy.startTraversal(traversalRoots, monitor);
		}
		
		/**
		 * @@generated
		 */
		private void prepareNextClientContext(EObject nextTarget) { 
			if (nextTarget != null && currentTarget != null) {
				if (nextTarget instanceof View) {
					String id = ((View) nextTarget).getType();
					String nextSemanticId = id != null
							&& semanticCtxIdMap.containsKey(id) ? id : null;
					if ((currentSemanticCtxId != null && !currentSemanticCtxId
							.equals(nextSemanticId))
							|| (nextSemanticId != null && !nextSemanticId
									.equals(currentSemanticCtxId))) {
						this.ctxChanged = true;
					}
					currentSemanticCtxId = nextSemanticId;
				} else {
					// context of domain model
					this.ctxChanged = currentSemanticCtxId != null;
					currentSemanticCtxId = null;
				}
			} else {
				this.ctxChanged = false;
			}
		}		
	}// CtxSwitchStrategy
<%} // end of usesNotationContextSwitch

final GenExpressionProviderContainer expressionProviders = genDiagram.getEditorGen().getExpressionProviders();
final java.util.Map __exprEnvVariables = java.util.Collections.EMPTY_MAP;
final String __outEnvVarName = ""; // no env to setup //$NON-NLS-1$ 
for(java.util.Iterator it = allAudits.iterator(); it.hasNext();) {
	GenAuditRule nextAudit = (GenAuditRule)it.next();
	if(nextAudit.isRequiresConstraintAdapter() && nextAudit.getRule() != null && nextAudit.getTarget() != null && nextAudit.getTarget().getContext() != null) {
		GenClassifier __genExprContext = nextAudit.getTarget().getContext();		 
		ValueExpression __genValueExpression = nextAudit.getRule();
		String importedExpressionBase = (expressionProviders != null) ? importManager.getImportedName(expressionProviders.getAbstractExpressionQualifiedClassName()) : "null"; //$NON-NLS-1$
%>
	/**
	 * @@generated
	 */
	public static class <%=nextAudit.getConstraintAdapterLocalClassName()%> extends <%=importManager.getImportedName("org.eclipse.emf.validation.AbstractModelConstraint")%> {
		/**
		 * @@generated
		 */
		private <%=importedExpressionBase%> expression;
		/**
		 * @@generated
		 */
		public <%=nextAudit.getConstraintAdapterLocalClassName()%>() {
			expression = <%@@ include file="../expressions/getExpression.jetinc"%>;		
		}		
		/**
		 * @@generated
		 */
		public IStatus validate(<%=importManager.getImportedName("org.eclipse.emf.validation.IValidationContext")%> ctx) {
			Object evalCtx = ctx.getTarget();
<%		if(nextAudit.getTarget() instanceof GenDomainAttributeTarget) {
			GenDomainAttributeTarget attrTarget = (GenDomainAttributeTarget) nextAudit.getTarget();
			if(attrTarget.getAttribute() != null) {
				String fGetter = (attrTarget.getAttribute() != null) ? importManager.getImportedName(attrTarget.getAttribute().getGenPackage().getQualifiedPackageInterfaceName()) + ".eINSTANCE.get" + attrTarget.getAttribute().getFeatureAccessorName() : ""; //$NON-NLS-1$ //$NON-NLS-2$
%>
			if(evalCtx instanceof EObject) evalCtx = ((EObject)evalCtx).eGet(<%=fGetter%>());
			if(evalCtx == null) {
<%				if(attrTarget.isNullAsError()) { %>
				return ctx.createFailureStatus(new Object[] { EMFCoreUtil.getQualifiedName(ctx.getTarget(), true) });
<%				} else {%>
				return <%=importManager.getImportedName("org.eclipse.core.runtime.Status")%>.OK_STATUS;
<%				} %>
			}			
<%			}
		} else if(nextAudit.getTarget() instanceof GenAuditedMetricTarget) {
			GenAuditedMetricTarget metricTarget = (GenAuditedMetricTarget)nextAudit.getTarget();
			String metricKey = (metricTarget.getMetric() != null) ? metricTarget.getMetric().getKey() : "";
			String metricProviderClassName = importManager.getImportedName(genDiagram.getMetricProviderQualifiedClassName());%>			
			evalCtx = <%=metricProviderClassName%>.calculateMetric(<%=Conversions.toStringLiteral(metricKey)%>, evalCtx);
<%
		}
%>		
			Object result = expression.evaluate(evalCtx);
			if(result instanceof Boolean && ((Boolean)result).booleanValue()) {
				return <%=importManager.getImportedName("org.eclipse.core.runtime.Status")%>.OK_STATUS;
			}
			return ctx.createFailureStatus(new Object[] { EMFCoreUtil.getQualifiedName(ctx.getTarget(), true) }); 
		}
	}
<%
	}
} /*end of Adapters iteration*/

final java.util.List<GenAuditRule> javaExpressions = new java.util.ArrayList<GenAuditRule>();
if (audits != null && audits.getEditorGen().getExpressionProviders() != null) {
  GenExpressionProviderContainer exprProviders = audits.getEditorGen().getExpressionProviders();
  for (java.util.Iterator it = audits.getRules().iterator(); it.hasNext();) {
    GenAuditRule nextAudit = (GenAuditRule) it.next();
    if(nextAudit.getRule() != null && exprProviders.getProvider(nextAudit.getRule()) instanceof GenJavaExpressionProvider) {
      javaExpressions.add(nextAudit);
    }
  }
}

if(!javaExpressions.isEmpty()) {
%>
/**
 * @@generated
 */
static class <%=__javaOperationContainer%> {
<%
	for (GenAuditRule nextJavaRule : javaExpressions) {
		GenClassifier __genExprContext = nextJavaRule.getTarget().getContext();		
		ValueExpression __genValueExpression = nextJavaRule.getRule();
		String __genExprResultType = "java.lang.Boolean"; //$NON-NLS-1$
%>
<%@@ include file="../expressions/javaExpressionOperation.jetinc"%>
<%
	}
%>
} //<%=__javaOperationContainer%>
<%
} /* end of Java expression methods */
%>
} //<%=genDiagram.getValidationProviderClassName()%>
<%importManager.emitSortedImports();%>
@


1.27
log
@extract validate action from provider
@
text
@@


1.27.2.1
log
@rewrite validation prov in xpand
@
text
@@


1.26
log
@[178958] move code that iterates over diagnostics to location reusable in rcp
@
text
@d95 1
d100 1
a100 1
	
d107 1
a107 1
	
d112 2
a113 2
		if (ValidateAction.VALIDATE_ACTION_KEY.equals(actionId)) {
			return new ValidateAction(partDescriptor);
a116 42
	
	/**
	 * @@generated
	 */
	public static class ValidateAction extends Action {
		/**
		 * @@generated
		 */		
		public static final String VALIDATE_ACTION_KEY = "validateAction"; //$NON-NLS-1$
		/**
		 * @@generated
		 */
		private IWorkbenchPartDescriptor workbenchPartDescriptor;
		/**
		 * @@generated
		 */
		public ValidateAction(IWorkbenchPartDescriptor workbenchPartDescriptor) {
			setId(VALIDATE_ACTION_KEY);
			setText("Validate");
			this.workbenchPartDescriptor = workbenchPartDescriptor;
		}
		/**
		 * @@generated
		 */
		public void run() {
			IWorkbenchPart workbenchPart = workbenchPartDescriptor.getPartPage().getActivePart();
			if(workbenchPart instanceof IDiagramWorkbenchPart) {
				final IDiagramWorkbenchPart part = (IDiagramWorkbenchPart)workbenchPart;
				try {
					<%if (!rcp) {%>new <%=importManager.getImportedName("org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation")%>(<%}%>
						new <%=importManager.getImportedName("org.eclipse.jface.operation.IRunnableWithProgress")%>() {
							public void run(<%=importManager.getImportedName("org.eclipse.core.runtime.IProgressMonitor")%> monitor) throws InterruptedException, <%=importManager.getImportedName("java.lang.reflect.InvocationTargetException")%> {
								runValidation(part.getDiagramEditPart(), part.getDiagram());
							}
						}
					<%if (!rcp) {%>)<%}%>
					.run(new <%=importManager.getImportedName("org.eclipse.core.runtime.NullProgressMonitor")%>());			
				} catch (Exception e) {
					<%=pluginActivatorClass%>.getInstance().logError("Validation action failed", e); //$NON-NLS-1$
				}
			}
		}
a117 18
		/** 
		 * @@generated
		 */
		public static void runValidation(View view) {
			try {
				if(<%=importManager.getImportedName(genDiagram.getDiagramEditorUtilQualifiedClassName())%>.openDiagram(view.eResource())) {
					IEditorPart editorPart = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
					if(editorPart instanceof IDiagramWorkbenchPart) {
						runValidation(((IDiagramWorkbenchPart)editorPart).getDiagramEditPart(), view);
					} else {
						runNonUIValidation(view);
					}
				}
			} catch(Exception e) {
				<%=pluginActivatorClass%>.getInstance().logError("Validation action failed", e); //$NON-NLS-1$
			}
		}
		
d121 3
a123 4
		public static void runNonUIValidation(View view) {
			DiagramEditPart diagramEditPart = OffscreenEditPartFactory.getInstance().createDiagramEditPart(view.getDiagram());
			runValidation(diagramEditPart, view);
		}		
a124 7
		/**
		 * @@generated
		 */
		public static void runValidation(DiagramEditPart diagramEditPart, View view) {
			final View target = view;
			final DiagramEditPart diagramPart = diagramEditPart;
			Runnable task = new Runnable() {
d128 1
a128 1
						validate(diagramPart, target);
d134 2
a135 2
			TransactionalEditingDomain txDomain = TransactionUtil.getEditingDomain(target);
			if(txDomain != null) {
a145 188
		/**
		 * @@generated
		 */
		private static Diagnostic runEMFValidator(View target) {
			if(target.isSetElement() && target.getElement() != null) {
				return new Diagnostician() {
					public String getObjectLabel(EObject eObject) {
						return EMFCoreUtil.getQualifiedName(eObject, true);
					}
				}.validate(target.getElement());
			}
			return Diagnostic.OK_INSTANCE;
		}
	
		/**
		 * @@generated
		 */
		private static void validate(DiagramEditPart diagramEditPart, View target) {
<%if (!rcp) {%>
			IFile diagramFile = (target.eResource() != null) ? WorkspaceSynchronizer.getFile(target.eResource()) : null;
			if (diagramFile != null) {
				<%=importManager.getImportedName(genDiagram.getMarkerNavigationProviderQualifiedClassName())%>.deleteMarkers(diagramFile);
			}
<%}%>
			Diagnostic diagnostic = runEMFValidator(target);
<%if (rcp) {%>
			if (diagnostic.getSeverity() != Diagnostic.OK) {
				<%=importManager.getImportedName("org.eclipse.jface.dialogs.ErrorDialog")%>.openError(
					<%=importManager.getImportedName("org.eclipse.swt.widgets.Display")%>.getCurrent().getActiveShell(), "Validation", "Validation failed.",
					<%=importManager.getImportedName("org.eclipse.emf.common.util.BasicDiagnostic")%>.toIStatus(diagnostic));
				return;
			}
<%} else {%>
			createMarkers(diagramFile, diagnostic, diagramEditPart);
<%}%>
			IBatchValidator validator = (IBatchValidator)ModelValidationService.getInstance().newValidator(EvaluationMode.BATCH);
			validator.setIncludeLiveConstraints(true);
			if (target.isSetElement() && target.getElement() != null) {
				IStatus status = validator.validate(target.getElement());
<%if (rcp) {%>
				if (status.getSeverity() != IStatus.OK) {
					<%=importManager.getImportedName("org.eclipse.jface.dialogs.ErrorDialog")%>.openError(
						<%=importManager.getImportedName("org.eclipse.swt.widgets.Display")%>.getCurrent().getActiveShell(), "Validation", "Validation failed.", status);
					return;
				}
<%} else {%>
				createMarkers(diagramFile, status, diagramEditPart);
<%}%>
			}
<%if (hasNotationModelAudit) {%>
			validator.setTraversalStrategy(getNotationTraversalStrategy(validator));
			IStatus status = validator.validate(target);
<%	if (rcp) {%>
			if (status.getSeverity() != IStatus.OK) {
				<%=importManager.getImportedName("org.eclipse.jface.dialogs.ErrorDialog")%>.openError(
					<%=importManager.getImportedName("org.eclipse.swt.widgets.Display")%>.getCurrent().getActiveShell(), "Validation", "Validation failed.", status);
				return;
			}
<%	} else {%>
			createMarkers(diagramFile, status, diagramEditPart);
<%	}%>
<%}%>
<%if (rcp) {%>
			<%=importManager.getImportedName("org.eclipse.swt.widgets.MessageBox")%> mb =
				new <%=importManager.getImportedName("org.eclipse.swt.widgets.MessageBox")%>(
					<%=importManager.getImportedName("org.eclipse.swt.widgets.Display")%>.getCurrent().getActiveShell(),
					<%=importManager.getImportedName("org.eclipse.swt.SWT")%>.OK);
			mb.setText("Validation");
			mb.setMessage("Model is valid.");
			mb.open();
<%}%>
		}
<%if (!rcp) {%>

	/**
	 * @@generated
	 */
	private static void createMarkers(IFile diagramFile, IStatus validationStatus, DiagramEditPart diagramEditPart) {
		if (validationStatus.isOK()) {
			return;
		}
		final IStatus rootStatus = validationStatus;
		List allStatuses = new ArrayList();
		<%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap element2ViewMap =
				new <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap(
						diagramEditPart.getDiagramView(), collectTargetElements(rootStatus, new HashSet(), allStatuses));
		for (Iterator it = allStatuses.iterator(); it.hasNext();) {
			IConstraintStatus nextStatus = (IConstraintStatus) it.next();
			View view = <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.findView(
					diagramEditPart, nextStatus.getTarget(), element2ViewMap);			
			addMarker(diagramFile, view.eResource().getURIFragment(view), 
					EMFCoreUtil.getQualifiedName(nextStatus.getTarget(), true), 
					nextStatus.getMessage(), nextStatus.getSeverity());
		}
	}

	/**
	 * @@generated
	 */
	private static void createMarkers(IFile diagramFile, Diagnostic emfValidationStatus, DiagramEditPart diagramEditPart) {
		if (emfValidationStatus.getSeverity() == Diagnostic.OK) {
			return;
		}
		final Diagnostic rootStatus = emfValidationStatus;
		List allDiagnostics = new ArrayList();
		<%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap element2ViewMap =
				new <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.LazyElement2ViewMap(
						diagramEditPart.getDiagramView(), collectTargetElements(rootStatus, new HashSet(), allDiagnostics));
		for (Iterator it = emfValidationStatus.getChildren().iterator(); it.hasNext();) {
			Diagnostic nextDiagnostic = (Diagnostic) it.next();
			List data = nextDiagnostic.getData();
			if (data != null && !data.isEmpty() && data.get(0) instanceof EObject) {
				EObject element = (EObject) data.get(0);
				View view = <%=genDiagram.getDiagramEditorUtilQualifiedClassName()%>.findView(
						diagramEditPart, element, element2ViewMap);
				addMarker(diagramFile, view.eResource().getURIFragment(view),
						EMFCoreUtil.getQualifiedName(element, true), nextDiagnostic.getMessage(),
						diagnosticToStatusSeverity(nextDiagnostic.getSeverity()));
			}
		}
	}

	/**
	 * @@generated
	 */
	private static void addMarker(IFile file, String elementId, String location, String message, int statusSeverity) {
		if (file == null) {
			return;
		}
		<%=importManager.getImportedName(genDiagram.getMarkerNavigationProviderQualifiedClassName())%>.addMarker(
				file, elementId, location, message, statusSeverity);
	}

	/**
	 * @@generated
	 */
	private static int diagnosticToStatusSeverity(int diagnosticSeverity) {
		if (diagnosticSeverity == Diagnostic.OK) {
			return IStatus.OK;
		} else if (diagnosticSeverity == Diagnostic.INFO) {
			return IStatus.INFO;
		} else if (diagnosticSeverity == Diagnostic.WARNING) {
			return IStatus.WARNING;
		} else if (diagnosticSeverity == Diagnostic.ERROR
				|| diagnosticSeverity == Diagnostic.CANCEL) {
			return IStatus.ERROR;
		}
		return IStatus.INFO;
	}	

	/**
	 * @@generated
	 */	
	private static Set collectTargetElements(IStatus status, Set targetElementCollector, List allConstraintStatuses) {
		if (status instanceof IConstraintStatus) {
			targetElementCollector.add(((IConstraintStatus)status).getTarget());
			allConstraintStatuses.add(status);
		}
		if (status.isMultiStatus()) {
			IStatus[] children = status.getChildren();
			for (int i = 0; i < children.length; i++) {
				collectTargetElements(children[i], targetElementCollector, allConstraintStatuses);				
			}
		}
		return targetElementCollector;
	}

	/**
	 * @@generated
	 */	
	private static Set collectTargetElements(Diagnostic diagnostic, Set targetElementCollector, List allDiagnostics) {
		List data = diagnostic.getData();
		EObject target = null;
		if (data != null && !data.isEmpty() && data.get(0) instanceof EObject) {
			target = (EObject) data.get(0);
			targetElementCollector.add(target);	
			allDiagnostics.add(diagnostic);
		}
		if (diagnostic.getChildren() != null && !diagnostic.getChildren().isEmpty()) {
			for (Iterator it = diagnostic.getChildren().iterator(); it.hasNext();) {
				collectTargetElements((Diagnostic) it.next(), targetElementCollector, allDiagnostics);
			}
		}
		return targetElementCollector;
	}
<%}%>
	}

d233 3
a235 3
	* @@generated
	*/
	static <%=importManager.getImportedName("org.eclipse.emf.validation.service.ITraversalStrategy")%> getNotationTraversalStrategy(IBatchValidator validator) {
@


1.25
log
@refactor GenAuditContainer: flatten hierarchy as it fits most for templates we write
@
text
@d60 7
d82 1
d246 1
a246 3
			if (diagramFile != null) {
				<%=importManager.getImportedName(genDiagram.getMarkerNavigationProviderQualifiedClassName())%>.createMarkers(diagramFile, diagnostic, diagramEditPart);
			}
d259 1
a259 3
				if (diagramFile != null) {
					<%=importManager.getImportedName(genDiagram.getMarkerNavigationProviderQualifiedClassName())%>.createMarkers(diagramFile, status, diagramEditPart);
				}				
d262 1
a262 2

<%if(hasNotationModelAudit) {%>
d265 1
a265 1
<%if (rcp) {%>
d271 3
a273 5
<%} else {%>
			if (diagramFile != null) {
				<%=importManager.getImportedName(genDiagram.getMarkerNavigationProviderQualifiedClassName())%>.createMarkers(diagramFile, status, diagramEditPart);
			}
<%}%>
d285 114
@


1.24
log
@complete migration of plugin.xml template to xpand version - constraint providers rewritten
@
text
@d7 15
a21 2
final GenAuditContainer audits = genDiagram.getEditorGen().getAudits();
final boolean hasNotationModelAudit = audits != null && audits.hasDiagramElementRule();
d28 1
a28 1
final java.util.List innerClasses = new java.util.ArrayList();
d32 17
a48 2
	innerClasses.addAll(audits.getAllRequiredConstraintAdaptersLocalClassNames());
	innerClasses.addAll(audits.getAllContextSelectorsLocalClassNames());
d300 4
a303 3
java.util.Map ctx2Rules = (audits != null) ? audits.getAllRulesToTargetContextMap() : new java.util.HashMap();
java.util.List allAudits = (audits != null) ? audits.getAllAuditRules() : java.util.Collections.EMPTY_LIST;
java.util.Map view2SelectorMap = new java.util.IdentityHashMap();
d307 4
a310 1
	if(contextID == null || null == ctx2Rules.remove(contextID)) continue;
d552 11
a562 1
final java.util.List javaExpressions = (audits != null) ? audits.getAllJavaLangAudits() : java.util.Collections.EMPTY_LIST;
d570 1
a570 2
	for (java.util.Iterator it = javaExpressions.iterator(); it.hasNext();) {
		GenAuditRule nextJavaRule = (GenAuditRule) it.next();
@


1.23
log
@[169964] Missing dependency on generating RCP app with validation
@
text
@d463 1
a463 1
	if(nextAudit.requiresConstraintAdapter() && nextAudit.getRule() != null && nextAudit.getTarget() != null && nextAudit.getTarget().getContext() != null) {
@


1.22
log
@[166814] Refactor diagram editor Audits&Metrics support
@
text
@d9 1
d28 1
d30 2
a37 1

a40 1
importManager.addImport("org.eclipse.emf.workspace.util.WorkspaceSynchronizer");
d109 1
a109 1
					new <%=importManager.getImportedName("org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation")%>(
d115 2
a116 1
					).run(new <%=importManager.getImportedName("org.eclipse.core.runtime.NullProgressMonitor")%>());			
d122 1
a122 1
		
d195 1
d197 1
a197 1
			if(diagramFile != null) {
d200 1
a200 1
			
d202 9
a210 1
			if(diagramFile != null) {
d212 2
a213 2
			}			
			
d216 10
a225 4
			IStatus status = <%=importManager.getImportedName("org.eclipse.core.runtime.Status")%>.OK_STATUS;
			if(target.isSetElement() && target.getElement() != null) {
				status = validator.validate(target.getElement());
				if(diagramFile != null) {
d228 1
d233 9
a241 2
			status = validator.validate(target);
			if(diagramFile != null) {
d244 11
a254 1
<%} // end of diagram element validation %>
d257 1
a257 1
	
@


1.21
log
@#148124 Diagram Validation action should be run as WorkspaceModifyOperation
@
text
@d26 1
a26 8
importManager.addImport("java.util.HashMap");
importManager.addImport("java.util.HashSet");
importManager.addImport("java.util.Iterator");
importManager.addImport("java.util.List");
importManager.addImport("java.util.ArrayList");
importManager.addImport("java.util.Arrays");
importManager.addImport("java.util.Map");
importManager.addImport("java.util.Set");
a27 3
importManager.addImport("org.eclipse.core.resources.IMarker");
importManager.addImport("org.eclipse.core.resources.IResource");
importManager.addImport("org.eclipse.core.runtime.CoreException");
a35 1
importManager.addImport("org.eclipse.emf.validation.model.IConstraintStatus");
d41 1
d43 1
a43 1
importManager.addImport("org.eclipse.gmf.runtime.diagram.core.util.ViewUtil");
a44 1
importManager.addImport("org.eclipse.gmf.runtime.notation.Diagram");
d49 2
a84 4
		 */
		public static final String MARKER_TYPE = <%=pluginActivatorClass%>.ID + ".<%=genDiagram.getValidationDiagnosticMarkerType()%>"; //$NON-NLS-1$
		/**
		 * @@generated
d110 1
a110 1
								runValidation(part.getDiagram());
d119 26
d149 1
a149 1
		public static void runValidation(View view) {
d151 1
d156 1
a156 1
						validate(target);
d191 1
a191 1
		private static void validate(View target) {
d193 2
a194 4
			try {
				if(diagramFile != null) diagramFile.deleteMarkers(MARKER_TYPE, true, IResource.DEPTH_ZERO);
			} catch (CoreException e) {
				<%=pluginActivatorClass%>.getInstance().logError(null, e);
d196 1
d198 3
d207 3
d211 1
a211 2
			List allStatuses = new ArrayList();			
			allStatuses.addAll(Arrays.asList(status.isMultiStatus() ? status.getChildren() : new IStatus[] { status }));
d215 3
a217 1
			allStatuses.addAll(Arrays.asList(status.isMultiStatus() ? status.getChildren() : new IStatus[] { status }));
a218 32

			HashSet targets = new HashSet();
			for (Iterator it = diagnostic.getChildren().iterator(); it.hasNext();) {
				targets.add(getDiagnosticTarget((Diagnostic)it.next()));
			}			
			
			for (Iterator it = allStatuses.iterator(); it.hasNext();) {			
				Object nextStatus = it.next();
				if(nextStatus instanceof IConstraintStatus) {
					targets.add(((IConstraintStatus)nextStatus).getTarget());
				}
			}
			
			Map viewMap = buildElement2ViewMap(target, targets);
			for (Iterator it = diagnostic.getChildren().iterator(); it.hasNext();) {
				Diagnostic nextDiagnostic = (Diagnostic) it.next();
				List data = nextDiagnostic.getData();
				if (!data.isEmpty() && data.get(0) instanceof EObject) {
					EObject element = (EObject)data.get(0);
					View view = findTargetView(element, viewMap);
					if(diagramFile != null) addMarker(diagramFile, view != null ? view : target, element, nextDiagnostic.getMessage(), diagnosticToStatusSeverity(nextDiagnostic.getSeverity()));
				}
			}

			for (Iterator it = allStatuses.iterator(); it.hasNext();) {
				Object nextStatusObj = it.next();
				if(nextStatusObj instanceof IConstraintStatus) {
					IConstraintStatus nextStatus = (IConstraintStatus)nextStatusObj;
					View view = findTargetView(nextStatus.getTarget(), viewMap);
					if(diagramFile != null) addMarker(diagramFile, view != null ? view : target, nextStatus.getTarget(), nextStatus.getMessage(), nextStatus.getSeverity());
				}
			}
d220 1
a220 95
		/**
		 * @@generated
		 */		
		private static View findTargetView(EObject targetElement, Map viewMap) {
			if(targetElement instanceof View) {
				return (View)targetElement;
			}		
			for(EObject container = targetElement; container != null; container = container.eContainer()) {
				if(viewMap.containsKey(container)) return (View)viewMap.get(container); 
			}
			return null;
		}		
		/**
		 * @@generated
		 */
		private static Map buildElement2ViewMap(View view, Set targets) {
			HashMap map = new HashMap();
			getElement2ViewMap(view, map, targets);
			if(!targets.isEmpty()) {
				Set path = new HashSet();
				for (Iterator it = targets.iterator(); it.hasNext();) {
					EObject nextNotMapped = (EObject) it.next();
					for (EObject container = nextNotMapped.eContainer(); container != null; container = container.eContainer()) {
						if(!map.containsKey(container)) { 
							path.add(container);
						} else break;
					}
				}
				getElement2ViewMap(view, map, path);
			}
			return map;
		}
		/**
		 * @@generated
		 */
		private static void getElement2ViewMap(View view, Map map, Set targets) {
			if (!map.containsKey(view.getElement()) && targets.remove(view.getElement())) {
				map.put(view.getElement(), view);
			}
			for (Iterator it = view.getChildren().iterator(); it.hasNext();) {
				getElement2ViewMap((View) it.next(), map, targets);
			}			
			if (view instanceof Diagram) {
				for (Iterator it = ((Diagram)view).getEdges().iterator(); it.hasNext();) {
					getElement2ViewMap((View) it.next(), map, targets);
				}
			}
		}
		/**
		 * @@generated
		 */
		private static void addMarker(IFile file, View view, EObject element, String message, int statusSeverity) {
			try {
				IMarker marker = file.createMarker(MARKER_TYPE);
				marker.setAttribute(IMarker.MESSAGE, message);
				marker.setAttribute(IMarker.LOCATION, EMFCoreUtil.getQualifiedName(element, true));
				marker.setAttribute(org.eclipse.gmf.runtime.common.ui.resources.IMarker.ELEMENT_ID, ViewUtil.getIdStr(view));
				int markerSeverity = IMarker.SEVERITY_INFO;
				if(statusSeverity == IStatus.WARNING) {
					markerSeverity = IMarker.SEVERITY_WARNING;    						
				} else if(statusSeverity == IStatus.ERROR || statusSeverity == IStatus.CANCEL) {
					markerSeverity = IMarker.SEVERITY_ERROR;
				}
				marker.setAttribute(IMarker.SEVERITY, markerSeverity);				
			} catch (CoreException e) {
				<%=pluginActivatorClass%>.getInstance().logError(null, e);
			}
		}
				
		/**
		 * @@generated
		 */		
		private static EObject getDiagnosticTarget(Diagnostic diagnostic) {
			if(!diagnostic.getData().isEmpty()) {
				Object target = diagnostic.getData().get(0);
				return target instanceof EObject ? (EObject)target : null;
			}
			return null;
		}
		/**
		 * @@generated
		 */
		private static int diagnosticToStatusSeverity(int diagnosticSeverity) {
			if(diagnosticSeverity == Diagnostic.OK) {
				return IStatus.OK;    						
			} else if(diagnosticSeverity == Diagnostic.INFO) {
				return IStatus.INFO;
			} else if(diagnosticSeverity == Diagnostic.WARNING) {
				return IStatus.WARNING; 
			} else if(diagnosticSeverity == Diagnostic.ERROR || diagnosticSeverity == Diagnostic.CANCEL) {
				return IStatus.ERROR; 
			}
			return IStatus.INFO;
		}
	}	
d287 1
a287 1
	static final Map semanticCtxIdMap = new HashMap();
@


1.20
log
@#147422 ValidationProvider.jet  template should handle diagram without domain models
@
text
@d119 11
a129 2
				part.getDiagramEditPart().getEditingDomain();
				runValidation(part.getDiagram());
d344 1
a344 1
java.util.Map viewID2SelectorMap = new java.util.HashMap();
d361 1
a361 2
			String viewID = Integer.toString(nextElement.getVisualID());
			viewID2SelectorMap.put(viewID, selectorClassName);
d399 2
a400 2
	for(java.util.Iterator it = viewID2SelectorMap.keySet().iterator(); it.hasNext();) {
		String viewID = (String)it.next();
d402 1
a402 1
		semanticCtxIdMap.put("<%=viewID%>", <%=viewID2SelectorMap.get(viewID)%>.class); //$NON-NLS-1$
@


1.19
log
@#147280 ValidationProvider template should not restrict only to single domain model package
@
text
@d42 3
d119 22
d142 2
a143 7
					part.getDiagramEditPart().getEditingDomain().runExclusive(
						new Runnable() {
							public void run() {
								runValidation(part.getDiagram());
							}
						});
				}catch (Exception e) {
d146 2
d154 7
a160 6
		public static void runValidation(Diagram diagram) {
			try {
				constraintsActive = true;
				validate(diagram);
			} finally {
				constraintsActive = false;
d162 1
d168 2
a169 2
		private static void validate(Diagram diagram) {
			IFile diagramFile = WorkspaceSynchronizer.getFile(diagram.eResource());
d171 1
a171 1
				diagramFile.deleteMarkers(MARKER_TYPE, true, IResource.DEPTH_ZERO);
d175 1
a175 5
			Diagnostic diagnostic = new Diagnostician() {
				public String getObjectLabel(EObject eObject) {
					return EMFCoreUtil.getQualifiedName(eObject, true);
				}
			}.validate(diagram.getElement());
d179 4
a182 1
			IStatus status = validator.validate(diagram.getElement());
d187 1
a187 1
			status = validator.validate(diagram);
d203 1
a203 1
			Map viewMap = buildElement2ViewMap(diagram, targets);
d210 1
a210 1
					addMarker(diagramFile, view != null ? view : diagram, element, nextDiagnostic.getMessage(), diagnosticToStatusSeverity(nextDiagnostic.getSeverity()));
d219 1
a219 1
					addMarker(diagramFile, view != null ? view : diagram, nextStatus.getTarget(), nextStatus.getMessage(), nextStatus.getSeverity());
d238 1
a238 1
		private static Map buildElement2ViewMap(Diagram diagram, Set targets) {
d240 1
a240 1
			getElement2ViewMap(diagram, map, targets);
d251 1
a251 1
				getElement2ViewMap(diagram, map, path);
@


1.18
log
@#140401 Escape all String literals in the generated code according to java rules, escape strings used  in plugins.xml
@
text
@a40 1
importManager.addImport("org.eclipse.emf.ecore.EPackage");
d66 12
d120 1
a120 1
								validate(part.getDiagram());
d128 1
d132 13
a144 1
		public static void validate(Diagram diagram) {
d158 1
d300 1
a300 7
		EObject domainElement = null;
		if(object instanceof View) {
			View view = (View)object;
			domainElement = view.getElement() != null ? view.getElement() : view.getDiagram().getElement();
		} else if(object instanceof EObject) {
			domainElement = (EObject)object;
		} else {
d303 4
a306 8
		EPackage domainPackage = domainElement.eClass().getEPackage();				
		return <%
for(java.util.Iterator packageIt = genDiagram.getEditorGen().getDomainGenModel().getGenPackages().iterator(); packageIt.hasNext();) {
	GenPackage nextGenPackage = (GenPackage)packageIt.next();			
			%>domainPackage == <%=nextGenPackage.getQualifiedPackageInterfaceName()%>.eINSTANCE<%=packageIt.hasNext() ? " || " : ";"%>									 
<%
} // domainPackage iteration 
%>			
@


1.17
log
@#144485 Do not generate "o.e.e.v.constraintBindings" extension in plugin.xml if !genDiagram.isValidationEnabled
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.* org.eclipse.emf.codegen.ecore.genmodel.*"%>
d529 1
a529 1
			evalCtx = <%=metricProviderClassName%>.calculateMetric("<%=metricKey%>", evalCtx);
@


1.16
log
@#136701 [GMFGen] GenDiagramElementTarget should allow to target more then one element
@
text
@d120 1
a120 1
		private void validate(Diagram diagram) {
d178 1
a178 1
		private View findTargetView(EObject targetElement, Map viewMap) {
d190 1
a190 1
		private Map buildElement2ViewMap(Diagram diagram, Set targets) {
d210 1
a210 1
		private void getElement2ViewMap(View view, Map map, Set targets) {
d226 1
a226 1
		private void addMarker(IFile file, View view, EObject element, String message, int statusSeverity) {
d247 1
a247 1
		private EObject getDiagnosticTarget(Diagnostic diagnostic) {
d257 1
a257 1
		private int diagnosticToStatusSeverity(int diagnosticSeverity) {
@


1.15
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d312 5
a316 2
		String viewID = Integer.toString(diagramElement.getElement().getVisualID());
		viewID2SelectorMap.put(viewID, selectorClassName);
@


1.14
log
@#141340  Audit rule targeted to a metric definition is not registered as valid constraint
@
text
@d11 1
a11 1
package <%=genDiagram.getProvidersPackageName()%>;
@


1.13
log
@#138464 Support EAttribute based target in AuditRule element
@
text
@d496 7
a502 1
		private <%=importedExpressionBase%> expression = <%@@ include file="../expressions/getExpression.jetinc"%>;
d522 7
a528 1
		} 
@


1.12
log
@#136672 use common expression accessor with audits
@
text
@d501 18
a518 1
			Object result = expression.evaluate(ctx.getTarget());
@


1.11
log
@#136834 Generated diagram validation problem markers do not navigate to diagram visual elements
@
text
@d14 11
d476 31
d508 27
a534 2
<%} // end of usesNotationContextSwitch%>
}
@


1.10
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d200 1
a200 2
			String type = view.getType();
			if ((type == null || "".equals(type)) && targets.remove(view.getElement())) { //$NON-NLS-1$
@


1.9
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d310 1
a310 1
				String id = getViewSemanticId((View) object);
d330 1
a330 9
	/**
	* @@generated
	*/
	static String getViewSemanticId(View view) {
		String id = Integer.toString(getVisualID(view));
		return id != null && id.length() > 0 ? id : null; 
	}
<%@@ include file="../editor/getVisualID.jetinc"%>			
		
d447 1
a447 1
					String id = getViewSemanticId((View) nextTarget);
@


1.8
log
@[rdvorak] #129766 Remove deprecated API usage
@
text
@d10 1
@


1.7
log
@[rdvorak] #127446 Enable audit rules on diagram (notation model) elements in gmfgen model
@
text
@d12 35
a46 36
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.util.Diagnostician;
import org.eclipse.emf.validation.model.EvaluationMode;
import org.eclipse.emf.validation.model.IConstraintStatus;
import org.eclipse.emf.validation.service.IBatchValidator;
import org.eclipse.emf.validation.service.ModelValidationService;
import org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramContributionItemProvider;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
import org.eclipse.gmf.runtime.emf.core.util.OperationUtil;
import org.eclipse.gmf.runtime.emf.core.util.ResourceUtil;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.IAction;
import org.eclipse.ui.IWorkbenchPart;

<%importManager.markImportLocation(stringBuffer);%>
d51 1
a51 1
public class <%=genDiagram.getValidationProviderClassName()%> extends DiagramContributionItemProvider {
d94 6
a99 6
					OperationUtil.runAsRead(new MRunnable() {
						public Object run() {
							validate(part.getDiagram());
							return null;
						}
					});
d101 1
a101 1
					<%=pluginActivatorClass%>.getInstance().logError(null, e);
d109 1
a109 1
			IFile diagramFile = ResourceUtil.getFile(diagram.eResource());
d117 1
a117 1
					return EObjectUtil.getQName(eObject, true);
d219 2
a220 2
				marker.setAttribute(IMarker.LOCATION, EObjectUtil.getQName(element, true));
				marker.setAttribute(org.eclipse.gmf.runtime.common.ui.resources.IMarker.ELEMENT_ID, EObjectUtil.getID(view));
d296 1
a296 1
	public static class <%=selectorClassName%> implements org.eclipse.emf.validation.model.IClientSelector {
@


1.6
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
d4 5
a8 3
GenDiagram genDiagram = (GenDiagram)((Object[]) argument)[0];
ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());
String pluginActivatorClass = importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName());
d16 2
d28 1
d32 1
d121 10
a131 3
			IStatus status = ModelValidationService.getInstance().newValidator(EvaluationMode.BATCH).validate(diagram.getElement());
			IStatus[] statuses = status.isMultiStatus() ? status.getChildren() : new IStatus[] { status };
			
d135 6
a140 3
			}			for (int i = 0; i < statuses.length; i++) {
				if(statuses[i] instanceof IConstraintStatus) {
					targets.add(((IConstraintStatus)statuses[i]).getTarget());
d155 4
a158 3
			for (int i = 0; i < statuses.length; i++) {
				if(statuses[i] instanceof IConstraintStatus) {
					IConstraintStatus nextStatus = (IConstraintStatus) statuses[i];
d160 1
a160 1
					addMarker(diagramFile, view != null ? view : diagram, nextStatus.getTarget(), nextStatus.getMessage(), Diagnostic.ERROR);
d168 3
d260 216
@


1.5
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d4 1
a4 1
GenDiagram genDiagram = (GenDiagram)argument;
@


1.4
log
@ImportManager moved to oeg.common
@
text
@d6 1
d64 1
a64 1
		public static final String MARKER_TYPE = "<%=genDiagram.getPlugin().getID() + "." + genDiagram.getValidationDiagnosticMarkerType()%>"; //$NON-NLS-1$
d96 1
a96 1
					<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError(null, e);
d108 1
a108 1
				<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError(null, e);
d210 1
a210 1
				<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError(null, e);
@


1.3
log
@#125893
Logging methods
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.2
log
@GenDiagram "slicing" goes on and this time attributes related to plugin activator class were moved into separate entity
@
text
@d95 1
a95 1
					e.printStackTrace();
d107 1
a107 1
				e.printStackTrace();
d209 1
a209 1
				e.printStackTrace();
@


1.1
log
@[rdvorak] #114189 Provide support for batch validation
@
text
@d63 1
a63 1
		public static final String MARKER_TYPE = "<%=genDiagram.getPluginID() + "." + genDiagram.getValidationDiagnosticMarkerType()%>"; //$NON-NLS-1$
@

