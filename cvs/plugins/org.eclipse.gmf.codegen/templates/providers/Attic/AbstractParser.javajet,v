head	1.16;
access;
symbols
	v20081022-1925:1.16
	v20081015-1925:1.16
	v20081008-1925:1.16
	v20081001-1925:1.16
	v20080924-1925:1.16
	v20080917-1925:1.16
	v20080911-1728:1.16
	v20080910-1520:1.16
	v20080903-1520:1.16
	v20080827-1520:1.16
	v20080813-1520:1.16
	v20080806-1520:1.16
	v20070420-1000:1.15
	v20070413-1300:1.15
	v20070405-1100:1.15
	v20070403-1500:1.15
	v20070330-1300:1.15
	v20060330-1300:1.15
	v20070322-1100:1.15
	v20060316-0600:1.15
	v20070307-0700:1.15
	v20070301-1200:1.15
	v20070228-2000:1.15
	v20070221-1500:1.15
	v20070208-1800:1.15
	v20070202-0200:1.14
	v20070103-0300:1.15
	M4_20:1.15
	v20061222-1800:1.15
	v20061218-1200:1.15
	v20061214-0000:1.15
	v20061120-1300:1.15
	M3_20:1.15
	v20061117-0800:1.15
	v20061027-1200:1.14
	v20061020-1000:1.14
	v20061013-1330:1.15
	v20060919-0800:1.14
	v20060907-1100:1.14
	M1_20:1.15
	v20060904-1500:1.15
	v20060824-1600:1.14
	v20060817-1500:1.14
	v20060728-0500:1.14
	v20060713-1700:1.14
	R1_0_maintenance:1.14.0.2
	R1_0:1.14
	v20060627-1200:1.14
	v20060626-1420:1.14
	v20060620-0400:1.14
	v20060616-1400:1.14
	v20060616-1200:1.14
	v20060609-1400:1.14
	v20060531-1730:1.13
	v20060530-1930:1.13
	v20060526-1200:1.13
	v20060519-1300:1.13
	v20060519-0800:1.13
	v20060512-1000:1.12
	I20060512-1000:1.12
	I20060505-1400:1.12
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.12
	I20060331-1000:1.12
	I20060324-0300:1.12
	I20060317-1300:1.12
	I20060317-1200:1.12
	I20060316-1300:1.12
	I20060309-1300:1.12
	M5_10:1.11
	S20060303-1600:1.11
	I20060227-1730:1.11
	I20060216-1945:1.11
	I20060210-1715:1.8
	I20060209-1815:1.8
	I20060203-0830:1.3
	I20060202-1415:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.16
date	2007.04.27.08.33.37;	author dstadnik;	state dead;
branches;
next	1.15;
commitid	15c64631b5604567;

1.15
date	2006.08.29.17.03.35;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.01.09.40.47;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.15.13.27.40;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.14.13.06.38;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.13.16.49.10;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.06.13.14.41;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.11.34.23;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.01.11.04.26;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.31.11.00.48;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.30.18.26.46;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.16
log
@rewrite AbstractParser in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.providers" class="AbstractParserGenerator"
  imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import java.text.MessageFormat;
import java.text.ParsePosition;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;
import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;
import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;
import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;
import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;
import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;
import org.eclipse.jface.text.contentassist.IContentAssistProcessor;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public abstract class <%=genDiagram.getAbstractParserClassName()%> implements IParser {

	/**
	 * @@generated
	 */
	private String viewPattern;

	/**
	 * @@generated
	 */
	private MessageFormat viewProcessor;

	/**
	 * @@generated
	 */
	private String editPattern;

	/**
	 * @@generated
	 */
	private MessageFormat editProcessor;

	/**
	 * @@generated
	 */
	public String getViewPattern() {
		return viewPattern;
	}

	/**
	 * @@generated
	 */
	protected MessageFormat getViewProcessor() {
		return viewProcessor;
	}

	/**
	 * @@generated
	 */
	public void setViewPattern(String viewPattern) {
		this.viewPattern = viewPattern;
		viewProcessor = createViewProcessor(viewPattern);
	}

	/**
	 * @@generated
	 */
	protected MessageFormat createViewProcessor(String viewPattern) {
		return new MessageFormat(viewPattern);
	}

	/**
	 * @@generated
	 */
	public String getEditPattern() {
		return editPattern;
	}

	/**
	 * @@generated
	 */
	protected MessageFormat getEditProcessor() {
		return editProcessor;
	}

	/**
	 * @@generated
	 */
	public void setEditPattern(String editPattern) {
		this.editPattern = editPattern;
		editProcessor = createEditProcessor(editPattern);
	}

	/**
	 * @@generated
	 */
	protected MessageFormat createEditProcessor(String editPattern) {
		return new MessageFormat(editPattern);
	}

	/**
	 * @@generated
	 */
	public String getPrintString(IAdaptable adapter, int flags) {
		return getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());
	}

	/**
	 * @@generated
	 */
	public String getEditString(IAdaptable adapter, int flags) {
		return getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());
	}

	/**
	 * @@generated
	 */
	protected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern, MessageFormat processor);

	/**
	 * @@generated
	 */
	public IParserEditStatus isValidEditString(IAdaptable element, String editString) {
		ParsePosition pos = new ParsePosition(0);
		Object[] values = getEditProcessor().parse(editString, pos);
		if (values == null) {
			return new ParserEditStatus(<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.ID,
				IParserEditStatus.UNEDITABLE, "Invalid input at " + pos.getErrorIndex());
		}
		return validateNewValues(values);
	}

	/**
	 * @@generated
	 */
	protected IParserEditStatus validateNewValues(Object[] values) {
		return ParserEditStatus.EDITABLE_STATUS;
	}

	/**
	 * @@generated
	 */
	public ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {
		Object[] values = getEditProcessor().parse(newString, new ParsePosition(0));
		if (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {
			return UnexecutableCommand.INSTANCE;
		}
		return getParseCommand(adapter, values);
	}

	/**
	 * @@generated
	 */
	protected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);

	/**
	 * @@generated
	 */
	public IContentAssistProcessor getCompletionProcessor(IAdaptable element) {
		return null;
	}

	/**
	 * @@generated
	 */
	protected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {
		value = getValidNewValue(feature, value);
		if (value instanceof InvalidValue) {
			return UnexecutableCommand.INSTANCE;
		}
		SetRequest request = new SetRequest(element, feature, value);
		return new SetValueCommand(request);
	}

	/**
	 * @@generated
	 */
	protected Object getValidValue(EStructuralFeature feature, Object value) {
		EClassifier type = feature.getEType();
		if (type instanceof EDataType) {
			Class iClass = type.getInstanceClass();
			if (String.class.equals(iClass)) {
				if (value == null) {
					value = ""; //$NON-NLS-1$
				}
			}
		}
		return value;
	}

	/**
	 * @@generated
	 */
	protected Object getValidNewValue(EStructuralFeature feature, Object value) {
		EClassifier type = feature.getEType();
		if (type instanceof EDataType) {
			Class iClass = type.getInstanceClass();
			if (Boolean.TYPE.equals(iClass)) {
				if (value instanceof Boolean) {
					// ok
				} else if (value instanceof String) {
					value = Boolean.valueOf((String) value);
				} else {
					value = new InvalidValue("Value of type Boolean is expected");
				}
			} else if (Character.TYPE.equals(iClass)) {
				if (value instanceof Character) {
					// ok
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						value = new Character(s.charAt(0));
					}
				} else {
					value = new InvalidValue("Value of type Character is expected");
				}
			} else if (Byte.TYPE.equals(iClass)) {
				if (value instanceof Byte) {
					// ok
				} else if (value instanceof Number) {
					value = new Byte(((Number) value).byteValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Byte.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Byte value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Byte is expected");
				}
			} else if (Short.TYPE.equals(iClass)) {
				if (value instanceof Short) {
					// ok
				} else if (value instanceof Number) {
					value = new Short(((Number) value).shortValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Short.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Short value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Short is expected");
				}
			} else if (Integer.TYPE.equals(iClass)) {
				if (value instanceof Integer) {
					// ok
				} else if (value instanceof Number) {
					value = new Integer(((Number) value).intValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Integer.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Integer value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Integer is expected");
				}
			} else if (Long.TYPE.equals(iClass)) {
				if (value instanceof Long) {
					// ok
				} else if (value instanceof Number) {
					value = new Long(((Number) value).longValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Long.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Long value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Long is expected");
				}
			} else if (Float.TYPE.equals(iClass)) {
				if (value instanceof Float) {
					// ok
				} else if (value instanceof Number) {
					value = new Float(((Number) value).floatValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Float.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Float value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Float is expected");
				}
			} else if (Double.TYPE.equals(iClass)) {
				if (value instanceof Double) {
					// ok
				} else if (value instanceof Number) {
					value = new Double(((Number) value).doubleValue());
				} else if (value instanceof String) {
					String s = (String) value;
					if (s.length() == 0) {
						value = null;
					} else {
						try {
							value = Double.valueOf(s);
						} catch (NumberFormatException nfe) {
							value = new InvalidValue("String value does not convert to Double value");
						}
					}
				} else {
					value = new InvalidValue("Value of type Double is expected");
				}
			} else if (type instanceof EEnum) {
				if (value instanceof String) {
					EEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);
					if (literal == null) {
						value = new InvalidValue("Unknown literal: " + value);
					} else {
						value = literal.getInstance();
					}
				} else {
					value = new InvalidValue("Value of type String is expected");
				}
			}
		}
		return value;
	}

	/**
	 * @@generated
	 */
	protected class InvalidValue {

		/**
		 * @@generated
		 */
		private String description;

		/**
		 * @@generated
		 */
		public InvalidValue(String description) {
			this.description = description;
		}

		/**
		 * @@generated
		 */
		public String toString() {
			return description;
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.15
log
@[155561] Correcting templates in accordance with unit-test.
@
text
@@


1.14
log
@fix some nls markers
@
text
@d366 3
d371 3
d378 3
@


1.13
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d196 1
a196 1
					value = "";
@


1.12
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d3 4
a6 1
<%GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];%>
d8 1
a8 1
package <%=genDiagram.getProvidersPackageName()%>;
a9 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());%>
@


1.11
log
@get editing domain from eobject
@
text
@d4 1
@


1.10
log
@use new transactional emf api
@
text
@a16 1
import org.eclipse.emf.transaction.TransactionalEditingDomain;
a34 5
	private TransactionalEditingDomain editingDomain;

	/**
	 * @@generated
	 */
a54 14
	public TransactionalEditingDomain getEditingDomain() {
		return editingDomain;
	}

	/**
	 * @@generated
	 */
	public void setEditingDomain(TransactionalEditingDomain editingDomain) {
		this.editingDomain = editingDomain;
	}

	/**
	 * @@generated
	 */
@


1.9
log
@#127336 add convertion from string
@
text
@d17 1
d36 5
d61 14
@


1.8
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d218 7
d233 11
d252 11
d271 11
d290 11
d309 11
d328 11
@


1.7
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d3 1
a3 1
<%GenDiagram genDiagram = (GenDiagram) argument;%>
@


1.6
log
@#126541 Support features with enumeration-based types for label model facets
@
text
@d136 1
a136 1
			return new ParserEditStatus(<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.ID,
@


1.5
log
@do not show 'null' for strings when they are not set in model
@
text
@d13 2
d269 11
@


1.4
log
@ImportManager moved to oeg.common
@
text
@d185 16
@


1.3
log
@#121534 Support link labels based on attributes that are not strings
@
text
@d2 1
a2 1
  imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.2
log
@#125729 Support labels based on multiple structural features
@
text
@d11 2
d151 2
a152 2
		Object[] newValues = getEditProcessor().parse(newString, new ParsePosition(0));
		if (newValues == null || validateNewValues(newValues).getCode() != IParserEditStatus.EDITABLE) {
d155 1
a155 1
		return getParseCommand(adapter, newValues);
d161 1
a161 1
	protected abstract ICommand getParseCommand(IAdaptable adapter, Object[] newValues);
d174 4
d181 90
@


1.1
log
@#125729 Support labels based on multiple structural features
@
text
@d2 1
a2 1
  imports="org.eclipse.gmf.codegen.gmfgen.*"%>
d6 1
d8 1
a8 1
import java.text.ParseException;
d11 2
a12 2
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
d14 1
d18 2
a19 1
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractModelCommand;
d21 1
d31 1
a31 1
	private static final Object[] NO_VALUES = new Object[0];
d36 1
a36 1
	private String viewPattern;
d46 5
d58 7
d67 8
d87 7
d96 8
d110 1
a110 1
		return getStringByPattern(adapter, flags, getViewPattern());
d117 1
a117 1
		return getStringByPattern(adapter, flags, getEditPattern());
d123 1
a123 1
	protected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern);
d128 6
a133 6
	protected Object[] getValuesFromEditString(String editString, String pattern) {
		Object[] values;
		try {
			values = new MessageFormat(pattern).parse(editString);
		} catch (ParseException pe) {
			values = NO_VALUES;
d135 1
a135 1
		return values;
d141 1
a141 1
	public IParserEditStatus isValidEditString(IAdaptable element, String editString) {
d148 16
d171 3
a173 9
	protected ICommand getModelCommand(ICommand semanticCommand) {
		final ICommand command = semanticCommand;
		return new AbstractModelCommand(command.getLabel(), command.getAffectedObjects()) {

			protected CommandResult doExecute(IProgressMonitor progressMonitor) {
				command.execute(progressMonitor);
				return command.getCommandResult();
			}
		};
d176 1
@

