64a65,67
> // Revision 1.23  2001/11/12 21:57:29  gorban
> // fixed more typo bugs
> //
246d248
< wire [7:0] 								counter_b;
254c256
< 	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
---
> 	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
269c271
< 			wb_dat_o <= #1 rf_data_out[9:2];
---
> 			wb_dat_o <= #1 rf_data_out[10:3];
298c300
< wire	thre_write;
---
> wire	fifo_write;
304c306
< assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
---
> assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
453c455
< assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
---
> assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
457c459
< assign lsr4 = (counter_b==8'b0); // break counter reached 0
---
> assign lsr4 = rf_data_out[2]; // break error in the character
462a465,470
> reg 	 lsr0_d;
> 
> always @(posedge clk or posedge wb_rst_i)
> 	if (wb_rst_i) lsr0_d <= #1 0;
> 	else lsr0_d <= #1 lsr0;
> 
465c473,474
< 	else lsr0r <= #1 lsr0;
---
> 	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
> 					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
476c485
< 	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
---
> 	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
487c496
< 	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
---
> 	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
498c507
< 	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
---
> 	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
509c518
< 	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
---
> 	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
517c526
< 	if (wb_rst_i) lsr5_d <= #1 0;
---
> 	if (wb_rst_i) lsr5_d <= #1 1;
521,522c530,531
< 	if (wb_rst_i) lsr5r <= #1 0;
< 	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
---
> 	if (wb_rst_i) lsr5r <= #1 1;
> 	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
528c537
< 	if (wb_rst_i) lsr6_d <= #1 0;
---
> 	if (wb_rst_i) lsr6_d <= #1 1;
532,533c541,542
< 	if (wb_rst_i) lsr6r <= #1 0;
< 	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
---
> 	if (wb_rst_i) lsr6r <= #1 1;
> 	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
544c553
< 	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
---
> 	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
576d584
< //assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
584a593
> reg 	 rda_int_d;
591a601,604
> 	if (wb_rst_i) rda_int_d <= #1 0;
> 	else rda_int_d <= #1 rda_int;
> 
> always  @(posedge clk or posedge wb_rst_i)
608a622
> wire 	 rda_int_rise;
609a624
> assign rda_int_rise    = rda_int & ~rda_int_d;
616a632
> reg	rda_int_pnd;
629a646,652
> 	if (wb_rst_i) rda_int_pnd <= #1 0; 
> 	else 
> 		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
> 							rda_int_rise ? 1 :						// latch condition
> 							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
> 
> always  @(posedge clk or posedge wb_rst_i)
632c655
< 		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
---
> 		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
659c682
< 					rda_int			? 1								:
---
> 					rda_int_pnd		? 1								:
661c684
< 					thre_int_pnd	? !(thre_write & iir_read) :
---
> 					thre_int_pnd	? !(fifo_write & iir_read) :
