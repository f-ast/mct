/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

import "http://www.eclipse.org/gmf/2008/GenModel";
import "http://www.eclipse.org/emf/2002/Ecore";
import "http://www.eclipse.org/emf/2002/GenModel";

extension xpt::GenModelUtils;

// all diagram nodes
List[gmfgen::GenNode] getNodes(gmfgen::GenDiagram diagram) :
	{}.addAll(diagram.topLevelNodes).addAll(diagram.childNodes)
;

// all elements that may have element type: diagram, nodes and links
List[gmfgen::GenCommonBase] getElements(gmfgen::GenDiagram diagram) :
	{ diagram }.addAll(diagram.topLevelNodes).addAll(diagram.childNodes).addAll(diagram.links)
;

boolean hasExplicitChildFeature(gmfgen::TypeModelFacet facet) :
	!isDerived(facet.childMetaFeature) && facet.childMetaFeature != facet.containmentMetaFeature
;

// true when link is contained in an object other than link's source,
// (1) sourceMetaFeature is specified
// (2) childMetaFeature is not the same as containment and belongs to a different class than container
// for (2), consider scenario from bug #226882, container "A", that holds link "L" and link's source and target, 
// "N1" and "N2". "N1" has a reference to "L" which is being used as childMetaFeature. Hence, link's container, "C"
// is different from link's source, "N1". As nothing can prevent "C" from subclassing "N1", there's no sure way to
// tell if container is really different from the source or not, and we'd better assume they are different.  
boolean hasContainerOtherThanSource(gmfgen::TypeLinkModelFacet facet) :
	facet.sourceMetaFeature != null || facet.childMetaFeature != facet.containmentMetaFeature
;

List[gmfgen::GenPreferencePage] allPreferencePages(gmfgen::GenDiagram genDiagram) :
	recursePages(genDiagram.preferencePages)
;

private List[gmfgen::GenPreferencePage] recursePages(List[GenPreferencePage] pages) :
	pages.isEmpty() ? pages : pages.union(recursePages(pages.children))
;