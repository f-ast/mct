F ? integrate with NiCAD's near miss clone detection tool or Xing's GenericDiff

F ? create the Java JAR manifest grammar
F ? create user defined functon for the privacy code 
F ? create the Verilog grammar according to the ISO 3194 standard

F ? create the LDAP dump grammar
F ? create the Gentoo metadata grammar
F ? create HLA grammar for mainframe IBM/zOS

U ? counting the difference cases
F ? create argument grammar -- argumentation
U ? convert xtext grammar into TXL

U ? classify the identifiers by their roles in the syntax

U v output identifiers for C programs (source/norm/C/cid.norm) (for Simon)
U v prompt from possible annotation pairs (contexts, terms): -d PROMPT (repeat only), -d PROMPT_OPTION_ANNOATION (also optional ones)
U v specify annotations in a simplified way (annotate [id] [typeSpec]) to avoid copy/pasting the concrete syntax in the production rules
F v create q7 grammar -- i*
U v separate different languages into different subfolders
F v allow prefer with replacement functions
F v create event grammar -- event calculus
F v create the AndroidManifest.xml grammar
F v handle javadoc @model tags: model.norm
U v creating Mac services to make the mct diff useable services in the Finder 
F v handle javadoc @generated NOT tags: mdsd.norm
F v keep line number/filename of the kept entity in normalised results
U v create xtext grammar 
F v supporting multiple ignored terms in one production rule
F v expand redefine into define statements recursively
U v retaining the removed clones for references
U v rename the temp files so that the mct can be parallelised by make -jN
F v create problem grammar -- problem frames
U v create the main script "mct" to delegate the normalisation/clone_removal to the right command depending on the file extension of the 1st argument
F ! Java grammar does not allow void foo(@SuppressWarnings ...)
F ! Java grammar has problem with 'public 'enum types (gmf) or using 'enum as variable names (jhotdraw)
F ! Java5 grammar does not allow Collections.<...>() access (gmf)
F v Count the diff of any two structures 
F v Compute the preferred literal constants
F v Create the verilog grammar and normalisations
F v Remove the clones in the kept structures 
F v Process the `ignored by rule' to perform the transformations selectively
U v Process the `redefine' rules such that adding annotations does not require substantial change of the original grammars
M v Generate binary (bytecode) of the TXL transformations based on the platform of choice (Darwin, Linux, etc.)
M v Generalise the rules in Makefile such that it is easy to extend it to more grammars
F v Process the `ordered by rule' to perform user-defined reorderings
===
? problem identified
! won't fix (problem is circumvented)
v problem solved
F functional requirement
-ilities quality requirement
  M maintainability
  U usability
