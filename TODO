F ? create HLA grammar for mainframe IBM/zOS
F ? integrate with NiCAD's near miss clone detection tool
F ? create user defined functon for the privacy code 
F ? create the LDAP dump grammar
F ? create the Java JAR manifest grammar
F ? create the Verilog grammar according to the ISO 3194 standard
F ? create argument grammar -- argumentation
F ? create q7 grammar -- i*
F ? create the Gentoo metadata grammar
U ? counting the difference cases
U ? convert xtext grammar into TXL
F v create event grammar -- event calculus
F v create the AndroidManifest.xml grammar
F v handle javadoc @model tags: model.norm
U v creating Mac services to make the mct diff useable services in the Finder 
F v handle javadoc @generated NOT tags: mdsd.norm
F v keep line number/filename of the kept entity in normalised results
U v create xtext grammar 
F v supporting multiple ignored terms in one production rule
F v expand redefine into define statements recursively
U v retaining the removed clones for references
U v rename the temp files so that the mct can be parallelised by make -jN
F v create problem grammar -- problem frames
U v create the main script "mct" to delegate the normalisation/clone_removal to the right command depending on the file extension of the 1st argument
F ! Java grammar does not allow void foo(@SuppressWarnings ...)
F ! Java grammar has problem with 'public 'enum types (gmf) or using 'enum as variable names (jhotdraw)
F ! Java5 grammar does not allow Collections.<...>() access (gmf)
F v Count the diff of any two structures 
F v Compute the preferred literal constants
F v Create the verilog grammar and normalisations
F v Remove the clones in the kept structures 
F v Process the `ignored by rule' to perform the transformations selectively
U v Process the `redefine' rules such that adding annotations does not require substantial change of the original grammars
M v Generate binary (bytecode) of the TXL transformations based on the platform of choice (Darwin, Linux, etc.)
M v Generalise the rules in Makefile such that it is easy to extend it to more grammars
F v Process the `ordered by rule' to perform user-defined reorderings
===
? problem identified
! won't fix (problem is circumvented)
v problem solved
F functional requirement
-ilities quality requirement
  M maintainability
  U usability
