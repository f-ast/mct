From 3f0230db0c7bd3da0c6bfe678c6bfc1121e7faa6 Mon Sep 17 00:00:00 2001
From: Yijun Yu <y.yu@open.ac.uk>
Date: Sat, 7 May 2011 21:58:34 +0100
Subject: + reimplement the clone_removal parts to detect differences across two files,
 rather than inside one single file

---
 Makefile                              |   26 +-
 README.html                           |   70 ++--
 Txl/api_clone_java.Txl                |  199 +++++---
 Txl/java.Txl                          |  381 ++++++++++-----
 Txl/norm.Txl                          |   93 +++--
 Txl/verilog2.Txl                      |   80 +++-
 bin.Darwin_i386/api_javac             |  Bin 281144 -> 0 bytes
 bin.Darwin_i386/java-apic             |  Bin 281144 -> 0 bytes
 bin.Darwin_i386/verilogc              |  Bin 236088 -> 244280 bytes
 cvs/uart16650/raminfr.r106.v          |  111 ++++
 cvs/uart16650/raminfr.r79.v           |  162 ++++++
 cvs/uart16650/raminfr.r84.v           |  111 ++++
 cvs/uart16650/timescale.r106.v        |   64 +++
 cvs/uart16650/timescale.r27.v         |    3 +
 cvs/uart16650/timescale.r29.v         |   64 +++
 cvs/uart16650/uart_debug_if.r106.v    |  126 +++++
 cvs/uart16650/uart_debug_if.r49.v     |   98 ++++
 cvs/uart16650/uart_debug_if.r55.v     |  107 ++++
 cvs/uart16650/uart_debug_if.r65.v     |  107 ++++
 cvs/uart16650/uart_debug_if.r79.v     |  110 ++++
 cvs/uart16650/uart_debug_if.r84.v     |  126 +++++
 cvs/uart16650/uart_defines.r106.v     |  247 +++++++++
 cvs/uart16650/uart_defines.r27.v      |  177 +++++++
 cvs/uart16650/uart_defines.r29.v      |  186 +++++++
 cvs/uart16650/uart_defines.r45.v      |  190 +++++++
 cvs/uart16650/uart_defines.r48.v      |  207 ++++++++
 cvs/uart16650/uart_defines.r53.v      |  217 ++++++++
 cvs/uart16650/uart_defines.r75.v      |  222 ++++++++
 cvs/uart16650/uart_defines.r79.v      |  227 +++++++++
 cvs/uart16650/uart_defines.r87.v      |  243 +++++++++
 cvs/uart16650/uart_defines.r89.v      |  247 +++++++++
 cvs/uart16650/uart_receiver.r100.v    |  482 ++++++++++++++++++
 cvs/uart16650/uart_receiver.r103.v    |  482 ++++++++++++++++++
 cvs/uart16650/uart_receiver.r106.v    |  482 ++++++++++++++++++
 cvs/uart16650/uart_receiver.r27.v     |  341 +++++++++++++
 cvs/uart16650/uart_receiver.r29.v     |  348 +++++++++++++
 cvs/uart16650/uart_receiver.r33.v     |  355 +++++++++++++
 cvs/uart16650/uart_receiver.r35.v     |  360 +++++++++++++
 cvs/uart16650/uart_receiver.r37.v     |  360 +++++++++++++
 cvs/uart16650/uart_receiver.r39.v     |  363 +++++++++++++
 cvs/uart16650/uart_receiver.r40.v     |  367 ++++++++++++++
 cvs/uart16650/uart_receiver.r45.v     |  380 ++++++++++++++
 cvs/uart16650/uart_receiver.r46.v     |  389 ++++++++++++++
 cvs/uart16650/uart_receiver.r47.v     |  409 +++++++++++++++
 cvs/uart16650/uart_receiver.r48.v     |  413 +++++++++++++++
 cvs/uart16650/uart_receiver.r50.v     |  423 ++++++++++++++++
 cvs/uart16650/uart_receiver.r51.v     |  436 ++++++++++++++++
 cvs/uart16650/uart_receiver.r57.v     |  439 ++++++++++++++++
 cvs/uart16650/uart_receiver.r61.v     |  441 ++++++++++++++++
 cvs/uart16650/uart_receiver.r63.v     |  446 ++++++++++++++++
 cvs/uart16650/uart_receiver.r64.v     |  448 +++++++++++++++++
 cvs/uart16650/uart_receiver.r66.v     |  463 +++++++++++++++++
 cvs/uart16650/uart_receiver.r67.v     |  467 +++++++++++++++++
 cvs/uart16650/uart_receiver.r69.v     |  458 +++++++++++++++++
 cvs/uart16650/uart_receiver.r79.v     |  455 +++++++++++++++++
 cvs/uart16650/uart_receiver.r84.v     |  471 +++++++++++++++++
 cvs/uart16650/uart_regs.r105.v        |  893 +++++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r106.v        |  893 +++++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r27.v         |  532 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r29.v         |  531 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r31.v         |  535 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r32.v         |  539 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r33.v         |  545 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r34.v         |  548 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r35.v         |  551 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r36.v         |  554 ++++++++++++++++++++
 cvs/uart16650/uart_regs.r37.v         |  681 +++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r39.v         |  686 +++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r40.v         |  692 +++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r41.v         |  695 +++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r42.v         |  698 ++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r43.v         |  701 ++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r44.v         |  704 ++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r45.v         |  727 +++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r47.v         |  735 +++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r48.v         |  761 ++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r50.v         |  754 ++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r52.v         |  762 ++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r54.v         |  765 ++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r56.v         |  768 ++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r58.v         |  773 ++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r59.v         |  782 +++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r60.v         |  816 ++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r63.v         |  821 ++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r64.v         |  827 ++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r66.v         |  830 ++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r68.v         |  833 ++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r79.v         |  854 +++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r84.v         |  870 ++++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r87.v         |  873 ++++++++++++++++++++++++++++++++
 cvs/uart16650/uart_regs.r99.v         |  890 ++++++++++++++++++++++++++++++++
 cvs/uart16650/uart_rfifo.r106.v       |  320 ++++++++++++
 cvs/uart16650/uart_rfifo.r79.v        |  267 ++++++++++
 cvs/uart16650/uart_rfifo.r84.v        |  283 +++++++++++
 cvs/uart16650/uart_rfifo.r87.v        |  285 +++++++++++
 cvs/uart16650/uart_rfifo.r88.v        |  320 ++++++++++++
 cvs/uart16650/uart_sync_flops.r106.v  |  122 +++++
 cvs/uart16650/uart_sync_flops.r98.v   |  122 +++++
 cvs/uart16650/uart_tfifo.r106.v       |  243 +++++++++
 cvs/uart16650/uart_tfifo.r79.v        |  227 +++++++++
 cvs/uart16650/uart_tfifo.r84.v        |  243 +++++++++
 cvs/uart16650/uart_top.r106.v         |  340 +++++++++++++
 cvs/uart16650/uart_top.r27.v          |  170 +++++++
 cvs/uart16650/uart_top.r29.v          |  178 +++++++
 cvs/uart16650/uart_top.r30.v          |  182 +++++++
 cvs/uart16650/uart_top.r33.v          |  187 +++++++
 cvs/uart16650/uart_top.r37.v          |  190 +++++++
 cvs/uart16650/uart_top.r48.v          |  280 +++++++++++
 cvs/uart16650/uart_top.r50.v          |  294 +++++++++++
 cvs/uart16650/uart_top.r65.v          |  295 +++++++++++
 cvs/uart16650/uart_top.r79.v          |  324 ++++++++++++
 cvs/uart16650/uart_top.r84.v          |  340 +++++++++++++
 cvs/uart16650/uart_transmitter.r106.v |  351 +++++++++++++
 cvs/uart16650/uart_transmitter.r27.v  |  288 +++++++++++
 cvs/uart16650/uart_transmitter.r29.v  |  297 +++++++++++
 cvs/uart16650/uart_transmitter.r33.v  |  304 +++++++++++
 cvs/uart16650/uart_transmitter.r34.v  |  308 ++++++++++++
 cvs/uart16650/uart_transmitter.r37.v  |  311 ++++++++++++
 cvs/uart16650/uart_transmitter.r39.v  |  315 ++++++++++++
 cvs/uart16650/uart_transmitter.r48.v  |  319 ++++++++++++
 cvs/uart16650/uart_transmitter.r61.v  |  326 ++++++++++++
 cvs/uart16650/uart_transmitter.r70.v  |  333 ++++++++++++
 cvs/uart16650/uart_transmitter.r74.v  |  336 +++++++++++++
 cvs/uart16650/uart_transmitter.r79.v  |  335 ++++++++++++
 cvs/uart16650/uart_transmitter.r84.v  |  351 +++++++++++++
 cvs/uart16650/uart_wb.r101.v          |  317 ++++++++++++
 cvs/uart16650/uart_wb.r106.v          |  317 ++++++++++++
 cvs/uart16650/uart_wb.r27.v           |  125 +++++
 cvs/uart16650/uart_wb.r29.v           |  134 +++++
 cvs/uart16650/uart_wb.r33.v           |  140 +++++
 cvs/uart16650/uart_wb.r48.v           |  201 ++++++++
 cvs/uart16650/uart_wb.r50.v           |  267 ++++++++++
 cvs/uart16650/uart_wb.r64.v           |  271 ++++++++++
 cvs/uart16650/uart_wb.r73.v           |  285 +++++++++++
 cvs/uart16650/uart_wb.r75.v           |  295 +++++++++++
 cvs/uart16650/uart_wb.r79.v           |  274 ++++++++++
 cvs/uart16650/uart_wb.r84.v           |  290 +++++++++++
 norm/api_clone_java.norm              |  132 -----
 norm/java.norm                        |  123 -----
 norm/problem.norm                     |   34 --
 norm/verilog.norm                     |   51 --
 norm/verilog2.norm                    |   21 -
 source/java/HelloWorld-2.java         |   11 +
 source/java/HelloWorld2.java          |   11 -
 source/java/HelloWorld3.java          |   23 -
 source/java/HelloWorld4.java          |   14 -
 source/java/abc.java                  |    5 -
 source/norm/api_clone_java.norm       |  132 +++++
 source/norm/java.norm                 |  119 +++++
 source/norm/problem.norm              |   34 ++
 source/norm/verilog.norm              |   51 ++
 source/norm/verilog2.norm             |   21 +
 source/v/raminfr.r106.v               |  111 ----
 source/v/raminfr.r79.v                |  162 ------
 source/v/raminfr.r84.v                |  111 ----
 source/v/timescale.r106.v             |   64 ---
 source/v/timescale.r27.v              |    3 -
 source/v/timescale.r29.v              |   64 ---
 source/v/uart_debug_if.r106.v         |  126 -----
 source/v/uart_debug_if.r49.v          |   98 ----
 source/v/uart_debug_if.r55.v          |  107 ----
 source/v/uart_debug_if.r65.v          |  107 ----
 source/v/uart_debug_if.r79.v          |  110 ----
 source/v/uart_debug_if.r84.v          |  126 -----
 source/v/uart_defines.r106.v          |  247 ---------
 source/v/uart_defines.r27.v           |  177 -------
 source/v/uart_defines.r29.v           |  186 -------
 source/v/uart_defines.r45.v           |  190 -------
 source/v/uart_defines.r48.v           |  207 --------
 source/v/uart_defines.r53.v           |  217 --------
 source/v/uart_defines.r75.v           |  222 --------
 source/v/uart_defines.r79.v           |  227 ---------
 source/v/uart_defines.r87.v           |  243 ---------
 source/v/uart_defines.r89.v           |  247 ---------
 source/v/uart_receiver.r100.v         |  482 ------------------
 source/v/uart_receiver.r103.v         |  482 ------------------
 source/v/uart_receiver.r106.v         |  482 ------------------
 source/v/uart_receiver.r27.v          |  341 -------------
 source/v/uart_receiver.r29.v          |  348 -------------
 source/v/uart_receiver.r33.v          |  355 -------------
 source/v/uart_receiver.r35.v          |  360 -------------
 source/v/uart_receiver.r37.v          |  360 -------------
 source/v/uart_receiver.r39.v          |  363 -------------
 source/v/uart_receiver.r40.v          |  367 --------------
 source/v/uart_receiver.r45.v          |  380 --------------
 source/v/uart_receiver.r46.v          |  389 --------------
 source/v/uart_receiver.r47.v          |  409 ---------------
 source/v/uart_receiver.r48.v          |  413 ---------------
 source/v/uart_receiver.r50.v          |  423 ----------------
 source/v/uart_receiver.r51.v          |  436 ----------------
 source/v/uart_receiver.r57.v          |  439 ----------------
 source/v/uart_receiver.r61.v          |  441 ----------------
 source/v/uart_receiver.r63.v          |  446 ----------------
 source/v/uart_receiver.r64.v          |  448 -----------------
 source/v/uart_receiver.r66.v          |  463 -----------------
 source/v/uart_receiver.r67.v          |  467 -----------------
 source/v/uart_receiver.r69.v          |  458 -----------------
 source/v/uart_receiver.r79.v          |  455 -----------------
 source/v/uart_receiver.r84.v          |  471 -----------------
 source/v/uart_regs.r105.v             |  893 ---------------------------------
 source/v/uart_regs.r106.v             |  893 ---------------------------------
 source/v/uart_regs.r27.v              |  532 --------------------
 source/v/uart_regs.r29.v              |  531 --------------------
 source/v/uart_regs.r31.v              |  535 --------------------
 source/v/uart_regs.r32.v              |  539 --------------------
 source/v/uart_regs.r33.v              |  545 --------------------
 source/v/uart_regs.r34.v              |  548 --------------------
 source/v/uart_regs.r35.v              |  551 --------------------
 source/v/uart_regs.r36.v              |  554 --------------------
 source/v/uart_regs.r37.v              |  681 -------------------------
 source/v/uart_regs.r39.v              |  686 -------------------------
 source/v/uart_regs.r40.v              |  692 -------------------------
 source/v/uart_regs.r41.v              |  695 -------------------------
 source/v/uart_regs.r42.v              |  698 --------------------------
 source/v/uart_regs.r43.v              |  701 --------------------------
 source/v/uart_regs.r44.v              |  704 --------------------------
 source/v/uart_regs.r45.v              |  727 ---------------------------
 source/v/uart_regs.r47.v              |  735 ---------------------------
 source/v/uart_regs.r48.v              |  761 ----------------------------
 source/v/uart_regs.r50.v              |  754 ----------------------------
 source/v/uart_regs.r52.v              |  762 ----------------------------
 source/v/uart_regs.r54.v              |  765 ----------------------------
 source/v/uart_regs.r56.v              |  768 ----------------------------
 source/v/uart_regs.r58.v              |  773 ----------------------------
 source/v/uart_regs.r59.v              |  782 -----------------------------
 source/v/uart_regs.r60.v              |  816 ------------------------------
 source/v/uart_regs.r63.v              |  821 ------------------------------
 source/v/uart_regs.r64.v              |  827 ------------------------------
 source/v/uart_regs.r66.v              |  830 ------------------------------
 source/v/uart_regs.r68.v              |  833 ------------------------------
 source/v/uart_regs.r79.v              |  854 -------------------------------
 source/v/uart_regs.r84.v              |  870 --------------------------------
 source/v/uart_regs.r87.v              |  873 --------------------------------
 source/v/uart_regs.r99.v              |  890 --------------------------------
 source/v/uart_rfifo.r106.v            |  320 ------------
 source/v/uart_rfifo.r79.v             |  267 ----------
 source/v/uart_rfifo.r84.v             |  283 -----------
 source/v/uart_rfifo.r87.v             |  285 -----------
 source/v/uart_rfifo.r88.v             |  320 ------------
 source/v/uart_sync_flops.r106.v       |  122 -----
 source/v/uart_sync_flops.r98.v        |  122 -----
 source/v/uart_tfifo.r106.v            |  243 ---------
 source/v/uart_tfifo.r79.v             |  227 ---------
 source/v/uart_tfifo.r84.v             |  243 ---------
 source/v/uart_top.r106.v              |  340 -------------
 source/v/uart_top.r27.v               |  170 -------
 source/v/uart_top.r29.v               |  178 -------
 source/v/uart_top.r30.v               |  182 -------
 source/v/uart_top.r33.v               |  187 -------
 source/v/uart_top.r37.v               |  190 -------
 source/v/uart_top.r48.v               |  280 -----------
 source/v/uart_top.r50.v               |  294 -----------
 source/v/uart_top.r65.v               |  295 -----------
 source/v/uart_top.r79.v               |  324 ------------
 source/v/uart_top.r84.v               |  340 -------------
 source/v/uart_transmitter.r106.v      |  351 -------------
 source/v/uart_transmitter.r27.v       |  288 -----------
 source/v/uart_transmitter.r29.v       |  297 -----------
 source/v/uart_transmitter.r33.v       |  304 -----------
 source/v/uart_transmitter.r34.v       |  308 ------------
 source/v/uart_transmitter.r37.v       |  311 ------------
 source/v/uart_transmitter.r39.v       |  315 ------------
 source/v/uart_transmitter.r48.v       |  319 ------------
 source/v/uart_transmitter.r61.v       |  326 ------------
 source/v/uart_transmitter.r70.v       |  333 ------------
 source/v/uart_transmitter.r74.v       |  336 -------------
 source/v/uart_transmitter.r79.v       |  335 ------------
 source/v/uart_transmitter.r84.v       |  351 -------------
 source/v/uart_wb.r101.v               |  317 ------------
 source/v/uart_wb.r106.v               |  317 ------------
 source/v/uart_wb.r27.v                |  125 -----
 source/v/uart_wb.r29.v                |  134 -----
 source/v/uart_wb.r33.v                |  140 -----
 source/v/uart_wb.r48.v                |  201 --------
 source/v/uart_wb.r50.v                |  267 ----------
 source/v/uart_wb.r64.v                |  271 ----------
 source/v/uart_wb.r73.v                |  285 -----------
 source/v/uart_wb.r75.v                |  295 -----------
 source/v/uart_wb.r79.v                |  274 ----------
 source/v/uart_wb.r84.v                |  290 -----------
 test/java/HelloWorld.java             |    5 -
 test/java/HelloWorld2.java            |    5 -
 test/java/HelloWorld4.java            |    5 -
 test/java/LabelImpl-2.java            |   76 ---
 test/java/abc.java                    |    5 -
 285 files changed, 52487 insertions(+), 52342 deletions(-)
 delete mode 100755 bin.Darwin_i386/api_javac
 delete mode 100755 bin.Darwin_i386/java-apic
 create mode 100755 cvs/uart16650/raminfr.r106.v
 create mode 100755 cvs/uart16650/raminfr.r79.v
 create mode 100755 cvs/uart16650/raminfr.r84.v
 create mode 100755 cvs/uart16650/timescale.r106.v
 create mode 100755 cvs/uart16650/timescale.r27.v
 create mode 100755 cvs/uart16650/timescale.r29.v
 create mode 100755 cvs/uart16650/uart_debug_if.r106.v
 create mode 100755 cvs/uart16650/uart_debug_if.r49.v
 create mode 100755 cvs/uart16650/uart_debug_if.r55.v
 create mode 100755 cvs/uart16650/uart_debug_if.r65.v
 create mode 100755 cvs/uart16650/uart_debug_if.r79.v
 create mode 100755 cvs/uart16650/uart_debug_if.r84.v
 create mode 100755 cvs/uart16650/uart_defines.r106.v
 create mode 100755 cvs/uart16650/uart_defines.r27.v
 create mode 100755 cvs/uart16650/uart_defines.r29.v
 create mode 100755 cvs/uart16650/uart_defines.r45.v
 create mode 100755 cvs/uart16650/uart_defines.r48.v
 create mode 100755 cvs/uart16650/uart_defines.r53.v
 create mode 100755 cvs/uart16650/uart_defines.r75.v
 create mode 100755 cvs/uart16650/uart_defines.r79.v
 create mode 100755 cvs/uart16650/uart_defines.r87.v
 create mode 100755 cvs/uart16650/uart_defines.r89.v
 create mode 100755 cvs/uart16650/uart_receiver.r100.v
 create mode 100755 cvs/uart16650/uart_receiver.r103.v
 create mode 100755 cvs/uart16650/uart_receiver.r106.v
 create mode 100755 cvs/uart16650/uart_receiver.r27.v
 create mode 100755 cvs/uart16650/uart_receiver.r29.v
 create mode 100755 cvs/uart16650/uart_receiver.r33.v
 create mode 100755 cvs/uart16650/uart_receiver.r35.v
 create mode 100755 cvs/uart16650/uart_receiver.r37.v
 create mode 100755 cvs/uart16650/uart_receiver.r39.v
 create mode 100755 cvs/uart16650/uart_receiver.r40.v
 create mode 100755 cvs/uart16650/uart_receiver.r45.v
 create mode 100755 cvs/uart16650/uart_receiver.r46.v
 create mode 100755 cvs/uart16650/uart_receiver.r47.v
 create mode 100755 cvs/uart16650/uart_receiver.r48.v
 create mode 100755 cvs/uart16650/uart_receiver.r50.v
 create mode 100755 cvs/uart16650/uart_receiver.r51.v
 create mode 100755 cvs/uart16650/uart_receiver.r57.v
 create mode 100755 cvs/uart16650/uart_receiver.r61.v
 create mode 100755 cvs/uart16650/uart_receiver.r63.v
 create mode 100755 cvs/uart16650/uart_receiver.r64.v
 create mode 100755 cvs/uart16650/uart_receiver.r66.v
 create mode 100755 cvs/uart16650/uart_receiver.r67.v
 create mode 100755 cvs/uart16650/uart_receiver.r69.v
 create mode 100755 cvs/uart16650/uart_receiver.r79.v
 create mode 100755 cvs/uart16650/uart_receiver.r84.v
 create mode 100755 cvs/uart16650/uart_regs.r105.v
 create mode 100755 cvs/uart16650/uart_regs.r106.v
 create mode 100755 cvs/uart16650/uart_regs.r27.v
 create mode 100755 cvs/uart16650/uart_regs.r29.v
 create mode 100755 cvs/uart16650/uart_regs.r31.v
 create mode 100755 cvs/uart16650/uart_regs.r32.v
 create mode 100755 cvs/uart16650/uart_regs.r33.v
 create mode 100755 cvs/uart16650/uart_regs.r34.v
 create mode 100755 cvs/uart16650/uart_regs.r35.v
 create mode 100755 cvs/uart16650/uart_regs.r36.v
 create mode 100755 cvs/uart16650/uart_regs.r37.v
 create mode 100755 cvs/uart16650/uart_regs.r39.v
 create mode 100755 cvs/uart16650/uart_regs.r40.v
 create mode 100755 cvs/uart16650/uart_regs.r41.v
 create mode 100755 cvs/uart16650/uart_regs.r42.v
 create mode 100755 cvs/uart16650/uart_regs.r43.v
 create mode 100755 cvs/uart16650/uart_regs.r44.v
 create mode 100755 cvs/uart16650/uart_regs.r45.v
 create mode 100755 cvs/uart16650/uart_regs.r47.v
 create mode 100755 cvs/uart16650/uart_regs.r48.v
 create mode 100755 cvs/uart16650/uart_regs.r50.v
 create mode 100755 cvs/uart16650/uart_regs.r52.v
 create mode 100755 cvs/uart16650/uart_regs.r54.v
 create mode 100755 cvs/uart16650/uart_regs.r56.v
 create mode 100755 cvs/uart16650/uart_regs.r58.v
 create mode 100755 cvs/uart16650/uart_regs.r59.v
 create mode 100755 cvs/uart16650/uart_regs.r60.v
 create mode 100755 cvs/uart16650/uart_regs.r63.v
 create mode 100755 cvs/uart16650/uart_regs.r64.v
 create mode 100755 cvs/uart16650/uart_regs.r66.v
 create mode 100755 cvs/uart16650/uart_regs.r68.v
 create mode 100755 cvs/uart16650/uart_regs.r79.v
 create mode 100755 cvs/uart16650/uart_regs.r84.v
 create mode 100755 cvs/uart16650/uart_regs.r87.v
 create mode 100755 cvs/uart16650/uart_regs.r99.v
 create mode 100755 cvs/uart16650/uart_rfifo.r106.v
 create mode 100755 cvs/uart16650/uart_rfifo.r79.v
 create mode 100755 cvs/uart16650/uart_rfifo.r84.v
 create mode 100755 cvs/uart16650/uart_rfifo.r87.v
 create mode 100755 cvs/uart16650/uart_rfifo.r88.v
 create mode 100755 cvs/uart16650/uart_sync_flops.r106.v
 create mode 100755 cvs/uart16650/uart_sync_flops.r98.v
 create mode 100755 cvs/uart16650/uart_tfifo.r106.v
 create mode 100755 cvs/uart16650/uart_tfifo.r79.v
 create mode 100755 cvs/uart16650/uart_tfifo.r84.v
 create mode 100755 cvs/uart16650/uart_top.r106.v
 create mode 100755 cvs/uart16650/uart_top.r27.v
 create mode 100755 cvs/uart16650/uart_top.r29.v
 create mode 100755 cvs/uart16650/uart_top.r30.v
 create mode 100755 cvs/uart16650/uart_top.r33.v
 create mode 100755 cvs/uart16650/uart_top.r37.v
 create mode 100755 cvs/uart16650/uart_top.r48.v
 create mode 100755 cvs/uart16650/uart_top.r50.v
 create mode 100755 cvs/uart16650/uart_top.r65.v
 create mode 100755 cvs/uart16650/uart_top.r79.v
 create mode 100755 cvs/uart16650/uart_top.r84.v
 create mode 100755 cvs/uart16650/uart_transmitter.r106.v
 create mode 100755 cvs/uart16650/uart_transmitter.r27.v
 create mode 100755 cvs/uart16650/uart_transmitter.r29.v
 create mode 100755 cvs/uart16650/uart_transmitter.r33.v
 create mode 100755 cvs/uart16650/uart_transmitter.r34.v
 create mode 100755 cvs/uart16650/uart_transmitter.r37.v
 create mode 100755 cvs/uart16650/uart_transmitter.r39.v
 create mode 100755 cvs/uart16650/uart_transmitter.r48.v
 create mode 100755 cvs/uart16650/uart_transmitter.r61.v
 create mode 100755 cvs/uart16650/uart_transmitter.r70.v
 create mode 100755 cvs/uart16650/uart_transmitter.r74.v
 create mode 100755 cvs/uart16650/uart_transmitter.r79.v
 create mode 100755 cvs/uart16650/uart_transmitter.r84.v
 create mode 100755 cvs/uart16650/uart_wb.r101.v
 create mode 100755 cvs/uart16650/uart_wb.r106.v
 create mode 100755 cvs/uart16650/uart_wb.r27.v
 create mode 100755 cvs/uart16650/uart_wb.r29.v
 create mode 100755 cvs/uart16650/uart_wb.r33.v
 create mode 100755 cvs/uart16650/uart_wb.r48.v
 create mode 100755 cvs/uart16650/uart_wb.r50.v
 create mode 100755 cvs/uart16650/uart_wb.r64.v
 create mode 100755 cvs/uart16650/uart_wb.r73.v
 create mode 100755 cvs/uart16650/uart_wb.r75.v
 create mode 100755 cvs/uart16650/uart_wb.r79.v
 create mode 100755 cvs/uart16650/uart_wb.r84.v
 delete mode 100644 norm/api_clone_java.norm
 delete mode 100644 norm/java.norm
 delete mode 100644 norm/problem.norm
 delete mode 100644 norm/verilog.norm
 delete mode 100644 norm/verilog2.norm
 create mode 100644 source/java/HelloWorld-2.java
 delete mode 100644 source/java/HelloWorld2.java
 delete mode 100644 source/java/HelloWorld3.java
 delete mode 100644 source/java/HelloWorld4.java
 delete mode 100644 source/java/abc.java
 create mode 100644 source/norm/api_clone_java.norm
 create mode 100644 source/norm/java.norm
 create mode 100644 source/norm/problem.norm
 create mode 100644 source/norm/verilog.norm
 create mode 100644 source/norm/verilog2.norm
 delete mode 100755 source/v/raminfr.r106.v
 delete mode 100755 source/v/raminfr.r79.v
 delete mode 100755 source/v/raminfr.r84.v
 delete mode 100755 source/v/timescale.r106.v
 delete mode 100755 source/v/timescale.r27.v
 delete mode 100755 source/v/timescale.r29.v
 delete mode 100755 source/v/uart_debug_if.r106.v
 delete mode 100755 source/v/uart_debug_if.r49.v
 delete mode 100755 source/v/uart_debug_if.r55.v
 delete mode 100755 source/v/uart_debug_if.r65.v
 delete mode 100755 source/v/uart_debug_if.r79.v
 delete mode 100755 source/v/uart_debug_if.r84.v
 delete mode 100755 source/v/uart_defines.r106.v
 delete mode 100755 source/v/uart_defines.r27.v
 delete mode 100755 source/v/uart_defines.r29.v
 delete mode 100755 source/v/uart_defines.r45.v
 delete mode 100755 source/v/uart_defines.r48.v
 delete mode 100755 source/v/uart_defines.r53.v
 delete mode 100755 source/v/uart_defines.r75.v
 delete mode 100755 source/v/uart_defines.r79.v
 delete mode 100755 source/v/uart_defines.r87.v
 delete mode 100755 source/v/uart_defines.r89.v
 delete mode 100755 source/v/uart_receiver.r100.v
 delete mode 100755 source/v/uart_receiver.r103.v
 delete mode 100755 source/v/uart_receiver.r106.v
 delete mode 100755 source/v/uart_receiver.r27.v
 delete mode 100755 source/v/uart_receiver.r29.v
 delete mode 100755 source/v/uart_receiver.r33.v
 delete mode 100755 source/v/uart_receiver.r35.v
 delete mode 100755 source/v/uart_receiver.r37.v
 delete mode 100755 source/v/uart_receiver.r39.v
 delete mode 100755 source/v/uart_receiver.r40.v
 delete mode 100755 source/v/uart_receiver.r45.v
 delete mode 100755 source/v/uart_receiver.r46.v
 delete mode 100755 source/v/uart_receiver.r47.v
 delete mode 100755 source/v/uart_receiver.r48.v
 delete mode 100755 source/v/uart_receiver.r50.v
 delete mode 100755 source/v/uart_receiver.r51.v
 delete mode 100755 source/v/uart_receiver.r57.v
 delete mode 100755 source/v/uart_receiver.r61.v
 delete mode 100755 source/v/uart_receiver.r63.v
 delete mode 100755 source/v/uart_receiver.r64.v
 delete mode 100755 source/v/uart_receiver.r66.v
 delete mode 100755 source/v/uart_receiver.r67.v
 delete mode 100755 source/v/uart_receiver.r69.v
 delete mode 100755 source/v/uart_receiver.r79.v
 delete mode 100755 source/v/uart_receiver.r84.v
 delete mode 100755 source/v/uart_regs.r105.v
 delete mode 100755 source/v/uart_regs.r106.v
 delete mode 100755 source/v/uart_regs.r27.v
 delete mode 100755 source/v/uart_regs.r29.v
 delete mode 100755 source/v/uart_regs.r31.v
 delete mode 100755 source/v/uart_regs.r32.v
 delete mode 100755 source/v/uart_regs.r33.v
 delete mode 100755 source/v/uart_regs.r34.v
 delete mode 100755 source/v/uart_regs.r35.v
 delete mode 100755 source/v/uart_regs.r36.v
 delete mode 100755 source/v/uart_regs.r37.v
 delete mode 100755 source/v/uart_regs.r39.v
 delete mode 100755 source/v/uart_regs.r40.v
 delete mode 100755 source/v/uart_regs.r41.v
 delete mode 100755 source/v/uart_regs.r42.v
 delete mode 100755 source/v/uart_regs.r43.v
 delete mode 100755 source/v/uart_regs.r44.v
 delete mode 100755 source/v/uart_regs.r45.v
 delete mode 100755 source/v/uart_regs.r47.v
 delete mode 100755 source/v/uart_regs.r48.v
 delete mode 100755 source/v/uart_regs.r50.v
 delete mode 100755 source/v/uart_regs.r52.v
 delete mode 100755 source/v/uart_regs.r54.v
 delete mode 100755 source/v/uart_regs.r56.v
 delete mode 100755 source/v/uart_regs.r58.v
 delete mode 100755 source/v/uart_regs.r59.v
 delete mode 100755 source/v/uart_regs.r60.v
 delete mode 100755 source/v/uart_regs.r63.v
 delete mode 100755 source/v/uart_regs.r64.v
 delete mode 100755 source/v/uart_regs.r66.v
 delete mode 100755 source/v/uart_regs.r68.v
 delete mode 100755 source/v/uart_regs.r79.v
 delete mode 100755 source/v/uart_regs.r84.v
 delete mode 100755 source/v/uart_regs.r87.v
 delete mode 100755 source/v/uart_regs.r99.v
 delete mode 100755 source/v/uart_rfifo.r106.v
 delete mode 100755 source/v/uart_rfifo.r79.v
 delete mode 100755 source/v/uart_rfifo.r84.v
 delete mode 100755 source/v/uart_rfifo.r87.v
 delete mode 100755 source/v/uart_rfifo.r88.v
 delete mode 100755 source/v/uart_sync_flops.r106.v
 delete mode 100755 source/v/uart_sync_flops.r98.v
 delete mode 100755 source/v/uart_tfifo.r106.v
 delete mode 100755 source/v/uart_tfifo.r79.v
 delete mode 100755 source/v/uart_tfifo.r84.v
 delete mode 100755 source/v/uart_top.r106.v
 delete mode 100755 source/v/uart_top.r27.v
 delete mode 100755 source/v/uart_top.r29.v
 delete mode 100755 source/v/uart_top.r30.v
 delete mode 100755 source/v/uart_top.r33.v
 delete mode 100755 source/v/uart_top.r37.v
 delete mode 100755 source/v/uart_top.r48.v
 delete mode 100755 source/v/uart_top.r50.v
 delete mode 100755 source/v/uart_top.r65.v
 delete mode 100755 source/v/uart_top.r79.v
 delete mode 100755 source/v/uart_top.r84.v
 delete mode 100755 source/v/uart_transmitter.r106.v
 delete mode 100755 source/v/uart_transmitter.r27.v
 delete mode 100755 source/v/uart_transmitter.r29.v
 delete mode 100755 source/v/uart_transmitter.r33.v
 delete mode 100755 source/v/uart_transmitter.r34.v
 delete mode 100755 source/v/uart_transmitter.r37.v
 delete mode 100755 source/v/uart_transmitter.r39.v
 delete mode 100755 source/v/uart_transmitter.r48.v
 delete mode 100755 source/v/uart_transmitter.r61.v
 delete mode 100755 source/v/uart_transmitter.r70.v
 delete mode 100755 source/v/uart_transmitter.r74.v
 delete mode 100755 source/v/uart_transmitter.r79.v
 delete mode 100755 source/v/uart_transmitter.r84.v
 delete mode 100755 source/v/uart_wb.r101.v
 delete mode 100755 source/v/uart_wb.r106.v
 delete mode 100755 source/v/uart_wb.r27.v
 delete mode 100755 source/v/uart_wb.r29.v
 delete mode 100755 source/v/uart_wb.r33.v
 delete mode 100755 source/v/uart_wb.r48.v
 delete mode 100755 source/v/uart_wb.r50.v
 delete mode 100755 source/v/uart_wb.r64.v
 delete mode 100755 source/v/uart_wb.r73.v
 delete mode 100755 source/v/uart_wb.r75.v
 delete mode 100755 source/v/uart_wb.r79.v
 delete mode 100755 source/v/uart_wb.r84.v
 delete mode 100644 test/java/HelloWorld.java
 delete mode 100644 test/java/HelloWorld2.java
 delete mode 100644 test/java/HelloWorld3.java
 delete mode 100644 test/java/HelloWorld4.java
 delete mode 100644 test/java/LabelImpl-2.java
 delete mode 100644 test/java/abc.java

diff --git a/Makefile b/Makefile
index 32a41bf5ab82f3ee900dbfda92a6f0d70af666e7..b411172f41810c25c288e93a33606e3a1ef52dcd 100755
--- a/Makefile
+++ b/Makefile
@@ -3,10 +3,10 @@ bin=bin.$(shell uname -s -m | sed 's/ /_/')
 txl=$(bin)/txl
 txlc=$(bin)/txlc
 #==== T A R G E T S ====
-norm=$(wildcard norm/*.norm)
-extensions+=$(norm:norm/%.norm=%)
+norm=$(wildcard source/norm/*.norm)
+extensions+=$(norm:source/norm/%.norm=%)
 languages+=$(wildcard Txl/*.Txl)
-generated_language=$(norm:norm/%.norm=Txl/%.Txl)
+generated_language=$(norm:source/norm/%.norm=Txl/%.Txl)
 extensions+=$(languages:Txl/%.Txl=%)
 program+=$(extensions:%=$(bin)/%c)
 source+=$(foreach ext,$(extensions),$(wildcard source/$(ext)/*.$(ext)))
@@ -21,7 +21,6 @@ package=/home/share/sead/mct/mct-$(shell uname).tar.gz
 #==== R U L E S ====
 .PHONEY: all clean install
 all: $(target)
-#	echo $(target)
 	@if [ -f error.log ]; then cat error.log; fi
 
 define example
@@ -42,17 +41,8 @@ result/v/%.v: $(bin)/vc source/v/%.v
 
 result/verilog2/%.v: $(bin)/verilog2c source/v/%.v
 	@mkdir -p result/verilog2
-	sed "s/'/?/g" source/v/$*.v > result/v/$*.v.tmp
-	$(bin)/verilog2c result/v/$*.v.tmp -o $@
-	rm -f result/v/$*.v.tmp
-	if [ -e test/v/$*.v ]; then diff $@ test/v/$*.v; fi
-
-result/verilog/%.v: $(bin)/verilogc source/v/%.v
-	@mkdir -p result/verilog
-	sed "s/'/?/g" source/v/$*.v > result/v/$*.v.tmp
-	$(bin)/verilogc result/v/$*.v.tmp -o $@
-	rm -f result/v/$*.v.tmp
-	if [ -e test/v/$*.v ]; then diff $@ test/v/$*.v; fi
+	$(bin)/verilog2c result/v/$*.v -o $@
+	if [ -e test/verilog2/$*.v ]; then diff $@ test/verilog2/$*.v; fi
 
 $(bin)/%c: Txl/%.Txl
 	$(txlc) Txl/$*.Txl 
@@ -63,7 +53,7 @@ $(bin)/%cc: Txl/%.Txl
 	mv $*.x $@
 
 # normalise 
-Txl/%.Txl: $(bin)/normc norm/%.norm
+Txl/%.Txl: $(bin)/normc source/norm/%.norm
 	/usr/bin/time $^ -o t.t
 	sed -e 's/\/\*//' t.t | sed -e 's/*\//\/* *\//g' > $@
 	rm -f t.t
@@ -75,9 +65,9 @@ $(package): README.html $(program) $(norm) $(source) $(target) cvs
 	tar cfz $@ $^
 	tar xfz $@ -C $(dir $(package))
 
-norm/java.norm : Txl/java.grm Txl/javaCommentOverridesNorm.grm
+source/norm/java.norm : Txl/java.grm Txl/javaCommentOverridesNorm.grm
 	touch -f $@
-norm/problem.norm : Txl/problem.grm
+source/norm/problem.norm : Txl/problem.grm
 	touch -f $@
 
 clean:
diff --git a/README.html b/README.html
index c6f61e4bb6b240b20ba7ae88b3d03394040b452a..5eaffd0446929e46e02829dbc0caecdb0060da08 100644
--- a/README.html
+++ b/README.html
@@ -1,28 +1,34 @@
+<h1>Frequently asked questions</h1>
 <pre>
+
 Q. What are in the folder?
 
 bin.* -- binaries
-source/norm -- user-defined normalisations
-source/java -- Java program examples
-source/problem -- Problem Frames examples
-source/clone -- Concatenate two Java programs
-source/v -- Verilog examples
-result/norm -- normalisations transformed 
-result/java -- normalised Java program examples
-result/problem -- normalised Problem Frames examples
-result/clone -- clone removed results
-result/v -- unparsed Verilog examples
-result/verilog -- normalised Verilog examples
+
+source -- source examples
+  source/norm -- user-defined normalisations
+  source/java -- Java program examples
+  source/v -- Verilog examples
+  source/problem -- Problem Frames examples
+
+result -- result of normalisations
+  result/norm -- normalisations transformed 
+  result/java -- normalised Java program examples
+  result/verilog2 -- normalised Verilog examples
+  result/v -- unparsed Verilog examples
+  result/problem -- normalised Problem Frames examples
+
 cvs -- experiments on analysing the CVS of java projects
-cvs/plugins -- GMF 
-cvs/jhotdraw -- jHotDraw
+  cvs/uart1660 -- UArt 1660 (Verilog)
+  cvs/jhotdraw -- JHotDraw (Java)
+  cvs/gmf -- GMF (Java)
 
 Q. How to define annotations?
 
-Given a TXL grammar, enter the following annotations 
-in the end of any non-terminal rule [...]:
+Given a TXL grammar, enter the following annotations in the end of any
+non-terminal rule [...]:
 
-	... [kept] [ordered by X] [ignored when Y] [preferred with Z]
+  ... [kept] [ordered by X] [ignored when Y] [preferred with Z]
 
 where X is an optional user-defined ordering rule, Y is an optional
 user-defined selection rule, and Z is one to many literal constants
@@ -30,23 +36,29 @@ to be used to replace the term.
 
 Q. How to generate normalisation transformations from the annotations? 
 
-> bin.*/normc norm/java.norm -o result/norm/java.norm
-> bin.*/normc norm/problem.norm -o result/norm/problem.norm
-> bin.*/normc norm/verilog.norm -o result/norm/verilog.norm
+First apply the `normc' to create the normalisation tools, e.g.,
+
+> bin.*/mct source/norm/api_clone_java.norm -o result/norm/api_clone_java.norm
+> bin.*/mct source/norm/verilog2.norm -o result/norm/verilog2.norm
 
-Note the following two commands generate the binary tools to be used by the
-normalisations.
+Then apply the following commands to generate the binary tools:
 
-> bin.*/txlc result/norm/problem.norm -o bin.*/problemc
-> bin.*/txlc result/norm/java.norm -o bin.*/javac
-> bin.*/txlc result/norm/verilog.norm -o bin.*/verilogc
+> bin.*/txlc result/norm/api_clone_java.norm -o bin.*/api_clone_javac
+> bin.*/txlc result/norm/verilog2.norm -o bin.*/verilog2c
 
-Q. How to run the examples normalisations?
+Q. How to normalise the examples?
 
 E.g.,
 
-> bin.*/javac source/java/abc.java -o result/java/abc.java
-> bin.*/javac source/java/HelloWorld.java -o result/java/HelloWorld.java
-> bin.*/javac source/java/HelloWorld2.java -o result/java/HelloWorld2.java
-> bin.*/problemc source/problem/CommandedBehaviour1.problem -o result/problem/CommandedBehaviour1.problem
+> bin.*/api_clone_javac source/java/HelloWorld.java -o result/java/HelloWorld.java
+> bin.*/api_clone_javac source/java/HelloWorld-2.java -o result/java/HelloWorld-2.java
+
+Q. How to remove clones in the normalised examples?
+
+Either use the original sources, e.g.,
+> bin.*/api_clone_javac source/java/HelloWorld.java -diff source/java/HelloWorld-2.java 
+
+or use the normalised source:
+> bin.*/api_clone_javac result/java/HelloWorld.java -diff result/java/HelloWorld-2.java 
+
 </pre>
diff --git a/Txl/api_clone_java.Txl b/Txl/api_clone_java.Txl
index 6ad46e147aca2c4b8d328a2ae9def2f26f82fca1..f9edffc06dbad47638e36dbc8ef6d8266eac6d0b 100644
--- a/Txl/api_clone_java.Txl
+++ b/Txl/api_clone_java.Txl
@@ -130,47 +130,68 @@ end define
 function find_replace_package_header
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [package_header *]
-        _  [ find_clones_package_header  P ] 
+        _  [ find_clones_package_header  P  P2 ] 
     by
         P  [mark_clones_package_header  each  S]
  
 end function
 
-rule mark_clones_package_header S  [package_header]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [package_header]
-        S 
-    by
-
-end rule
-
-function find_clones_package_header P  [program]
+function find_clones_package_header P  [program] P2  [program]
     construct S  [package_header *]
         _  [ ^  P ] 
+    construct S2  [package_header *]
+        _  [ ^  P2 ] 
     replace  [package_header *]
 
     by
-        _  [add_if_clones_package_header  S  each  S]
+        _  [add_if_clones_package_header1  S2  each  S]  [add_if_clones_package_header2  S2  each  S]
  
 end function
 
-function add_if_clones_package_header SS  [package_header *] Stmt  [package_header]
-    deconstruct * SS
-        Stmt  Rest  [ package_header  * ] 
-    deconstruct * [package_header] Rest
-        Stmt 
+function add_if_clones_package_header1 S2  [package_header *] Stmt  [package_header]
     replace  [package_header *]
         StructuredClones  [ package_header  * ] 
+    deconstruct S2
+        Stmt2  [ package_header ]  Rest  [ package_header  * ] 
+    construct d_S2  [package_header]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [package_header] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_package_header2 S2  [package_header *] Stmt  [package_header]
+    replace  [package_header *]
+        StructuredClones  [ package_header  * ] 
+    deconstruct S2
+        Stmt2  [ package_header ]  Rest  [ package_header  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_package_header1  Rest  Stmt ]  [ add_if_clones_package_header2  Rest  Stmt ] 
+end function
+
+rule mark_clones_package_header S  [package_header]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [package_header]
+        S 
+    by
+
+end rule
+
 redefine type_declaration
         ...
     |    [empty] 
@@ -179,47 +200,68 @@ end define
 function find_replace_type_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [type_declaration *]
-        _  [ find_clones_type_declaration  P ] 
+        _  [ find_clones_type_declaration  P  P2 ] 
     by
         P  [mark_clones_type_declaration  each  S]
  
 end function
 
-rule mark_clones_type_declaration S  [type_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [type_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_type_declaration P  [program]
+function find_clones_type_declaration P  [program] P2  [program]
     construct S  [type_declaration *]
         _  [ ^  P ] 
+    construct S2  [type_declaration *]
+        _  [ ^  P2 ] 
     replace  [type_declaration *]
 
     by
-        _  [add_if_clones_type_declaration  S  each  S]
+        _  [add_if_clones_type_declaration1  S2  each  S]  [add_if_clones_type_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_type_declaration SS  [type_declaration *] Stmt  [type_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ type_declaration  * ] 
-    deconstruct * [type_declaration] Rest
-        Stmt 
+function add_if_clones_type_declaration1 S2  [type_declaration *] Stmt  [type_declaration]
     replace  [type_declaration *]
         StructuredClones  [ type_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ type_declaration ]  Rest  [ type_declaration  * ] 
+    construct d_S2  [type_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [type_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_type_declaration2 S2  [type_declaration *] Stmt  [type_declaration]
+    replace  [type_declaration *]
+        StructuredClones  [ type_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ type_declaration ]  Rest  [ type_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_type_declaration1  Rest  Stmt ]  [ add_if_clones_type_declaration2  Rest  Stmt ] 
+end function
+
+rule mark_clones_type_declaration S  [type_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [type_declaration]
+        S 
+    by
+
+end rule
+
 redefine class_body_declaration
         ...
     |    [empty] 
@@ -228,47 +270,69 @@ end define
 function find_replace_class_body_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [class_body_declaration *]
-        _  [ find_clones_class_body_declaration  P ] 
+        _  [ find_clones_class_body_declaration  P  P2 ] 
     by
         P  [mark_clones_class_body_declaration  each  S]
  
 end function
 
-rule mark_clones_class_body_declaration S  [class_body_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [class_body_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_class_body_declaration P  [program]
+function find_clones_class_body_declaration P  [program] P2  [program]
     construct S  [class_body_declaration *]
         _  [ ^  P ] 
+    construct S2  [class_body_declaration *]
+        _  [ ^  P2 ] 
     replace  [class_body_declaration *]
 
     by
-        _  [add_if_clones_class_body_declaration  S  each  S]
+        _  [add_if_clones_class_body_declaration1  S2  each  S]  [add_if_clones_class_body_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_class_body_declaration SS  [class_body_declaration *] Stmt  [class_body_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ class_body_declaration  * ] 
-    deconstruct * [class_body_declaration] Rest
-        Stmt 
+function add_if_clones_class_body_declaration1 S2  [class_body_declaration *] Stmt  [class_body_declaration]
     replace  [class_body_declaration *]
         StructuredClones  [ class_body_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ class_body_declaration ]  Rest  [ class_body_declaration  * ] 
+    construct d_S2  [class_body_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [class_body_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_class_body_declaration2 S2  [class_body_declaration *] Stmt  [class_body_declaration]
+    replace  [class_body_declaration *]
+        StructuredClones  [ class_body_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ class_body_declaration ]  Rest  [ class_body_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_class_body_declaration1  Rest  Stmt ]  [ add_if_clones_class_body_declaration2  Rest 
+          Stmt ] 
+end function
+
+rule mark_clones_class_body_declaration S  [class_body_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [class_body_declaration]
+        S 
+    by
+
+end rule
+
 function normalise_preferred_tokens_method_body_block1 B  [method_body]
     replace  [method_body *]
         A  [method_body *] 
@@ -587,7 +651,7 @@ rule normalise_list_single_annotation_value_expression_or_nested_annotation
         N2 ,  N1 ,  Rest 
 end rule
 
-function main
+function program_normalise
     replace  [program]
         Prg  [ program ] 
     export CloneNumber [number]
@@ -602,7 +666,22 @@ function main
           normalise_list_constructor_declaration_modifier ]  [ normalise_list_variable_declaration_modifier ]  [ 
           normalise_list_variable_declarators_variable_declarator ]  [ normalise_list_method_declaration_modifier ]  [ 
           normalise_list_throws_qualified_name ]  [ normalise_list_annotation_value_list_keyed_annotation_value ]  [ 
-          normalise_list_single_annotation_value_expression_or_nested_annotation ]  [ find_replace_package_header ]  [ 
-          find_replace_type_declaration ]  [ find_replace_class_body_declaration ] 
+          normalise_list_single_annotation_value_expression_or_nested_annotation ] 
+end function
+
+function program_remove_clone
+    replace  [program]
+        Prg  [ program ] 
+    export CloneNumber [number]
+        0 
+    by
+        Prg  [ find_replace_package_header ]  [ find_replace_type_declaration ]  [ find_replace_class_body_declaration ] 
+end function
+
+function main
+    replace  [program]
+        Prg  [ program ] 
+    by
+        Prg  [ program_normalise ]  [ program_remove_clone ] 
 end function
 
diff --git a/Txl/java.Txl b/Txl/java.Txl
index e0d73867bb1e3d99d4a03a186c54489363acc6e9..1bfa64d4eb3b1b33858e0cd330803ba83566a734 100644
--- a/Txl/java.Txl
+++ b/Txl/java.Txl
@@ -8,10 +8,6 @@ redefine constructor_body
         [repeat block] 
 end define
 
-redefine program
-        [package_declaration *] 
-end define
-
 redefine type_declaration
         [class_declaration]  [NL] [NL] 
     |    [interface_declaration]  [NL] [NL] 
@@ -119,47 +115,68 @@ end define
 function find_replace_class_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [class_declaration *]
-        _  [ find_clones_class_declaration  P ] 
+        _  [ find_clones_class_declaration  P  P2 ] 
     by
         P  [mark_clones_class_declaration  each  S]
  
 end function
 
-rule mark_clones_class_declaration S  [class_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [class_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_class_declaration P  [program]
+function find_clones_class_declaration P  [program] P2  [program]
     construct S  [class_declaration *]
         _  [ ^  P ] 
+    construct S2  [class_declaration *]
+        _  [ ^  P2 ] 
     replace  [class_declaration *]
 
     by
-        _  [add_if_clones_class_declaration  S  each  S]
+        _  [add_if_clones_class_declaration1  S2  each  S]  [add_if_clones_class_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_class_declaration SS  [class_declaration *] Stmt  [class_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ class_declaration  * ] 
-    deconstruct * [class_declaration] Rest
-        Stmt 
+function add_if_clones_class_declaration1 S2  [class_declaration *] Stmt  [class_declaration]
     replace  [class_declaration *]
         StructuredClones  [ class_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ class_declaration ]  Rest  [ class_declaration  * ] 
+    construct d_S2  [class_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [class_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_class_declaration2 S2  [class_declaration *] Stmt  [class_declaration]
+    replace  [class_declaration *]
+        StructuredClones  [ class_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ class_declaration ]  Rest  [ class_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_class_declaration1  Rest  Stmt ]  [ add_if_clones_class_declaration2  Rest  Stmt ] 
+end function
+
+rule mark_clones_class_declaration S  [class_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [class_declaration]
+        S 
+    by
+
+end rule
+
 redefine interface_declaration
         ...
     |    [empty] 
@@ -168,47 +185,69 @@ end define
 function find_replace_interface_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [interface_declaration *]
-        _  [ find_clones_interface_declaration  P ] 
+        _  [ find_clones_interface_declaration  P  P2 ] 
     by
         P  [mark_clones_interface_declaration  each  S]
  
 end function
 
-rule mark_clones_interface_declaration S  [interface_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [interface_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_interface_declaration P  [program]
+function find_clones_interface_declaration P  [program] P2  [program]
     construct S  [interface_declaration *]
         _  [ ^  P ] 
+    construct S2  [interface_declaration *]
+        _  [ ^  P2 ] 
     replace  [interface_declaration *]
 
     by
-        _  [add_if_clones_interface_declaration  S  each  S]
+        _  [add_if_clones_interface_declaration1  S2  each  S]  [add_if_clones_interface_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_interface_declaration SS  [interface_declaration *] Stmt  [interface_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ interface_declaration  * ] 
-    deconstruct * [interface_declaration] Rest
-        Stmt 
+function add_if_clones_interface_declaration1 S2  [interface_declaration *] Stmt  [interface_declaration]
     replace  [interface_declaration *]
         StructuredClones  [ interface_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ interface_declaration ]  Rest  [ interface_declaration  * ] 
+    construct d_S2  [interface_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [interface_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_interface_declaration2 S2  [interface_declaration *] Stmt  [interface_declaration]
+    replace  [interface_declaration *]
+        StructuredClones  [ interface_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ interface_declaration ]  Rest  [ interface_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_interface_declaration1  Rest  Stmt ]  [ add_if_clones_interface_declaration2  Rest 
+          Stmt ] 
+end function
+
+rule mark_clones_interface_declaration S  [interface_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [interface_declaration]
+        S 
+    by
+
+end rule
+
 redefine enum_declaration
         ...
     |    [empty] 
@@ -217,47 +256,68 @@ end define
 function find_replace_enum_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [enum_declaration *]
-        _  [ find_clones_enum_declaration  P ] 
+        _  [ find_clones_enum_declaration  P  P2 ] 
     by
         P  [mark_clones_enum_declaration  each  S]
  
 end function
 
-rule mark_clones_enum_declaration S  [enum_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [enum_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_enum_declaration P  [program]
+function find_clones_enum_declaration P  [program] P2  [program]
     construct S  [enum_declaration *]
         _  [ ^  P ] 
+    construct S2  [enum_declaration *]
+        _  [ ^  P2 ] 
     replace  [enum_declaration *]
 
     by
-        _  [add_if_clones_enum_declaration  S  each  S]
+        _  [add_if_clones_enum_declaration1  S2  each  S]  [add_if_clones_enum_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_enum_declaration SS  [enum_declaration *] Stmt  [enum_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ enum_declaration  * ] 
-    deconstruct * [enum_declaration] Rest
-        Stmt 
+function add_if_clones_enum_declaration1 S2  [enum_declaration *] Stmt  [enum_declaration]
     replace  [enum_declaration *]
         StructuredClones  [ enum_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ enum_declaration ]  Rest  [ enum_declaration  * ] 
+    construct d_S2  [enum_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [enum_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_enum_declaration2 S2  [enum_declaration *] Stmt  [enum_declaration]
+    replace  [enum_declaration *]
+        StructuredClones  [ enum_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ enum_declaration ]  Rest  [ enum_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_enum_declaration1  Rest  Stmt ]  [ add_if_clones_enum_declaration2  Rest  Stmt ] 
+end function
+
+rule mark_clones_enum_declaration S  [enum_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [enum_declaration]
+        S 
+    by
+
+end rule
+
 redefine class_body_declaration
         ...
     |    [empty] 
@@ -266,47 +326,69 @@ end define
 function find_replace_class_body_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [class_body_declaration *]
-        _  [ find_clones_class_body_declaration  P ] 
+        _  [ find_clones_class_body_declaration  P  P2 ] 
     by
         P  [mark_clones_class_body_declaration  each  S]
  
 end function
 
-rule mark_clones_class_body_declaration S  [class_body_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [class_body_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_class_body_declaration P  [program]
+function find_clones_class_body_declaration P  [program] P2  [program]
     construct S  [class_body_declaration *]
         _  [ ^  P ] 
+    construct S2  [class_body_declaration *]
+        _  [ ^  P2 ] 
     replace  [class_body_declaration *]
 
     by
-        _  [add_if_clones_class_body_declaration  S  each  S]
+        _  [add_if_clones_class_body_declaration1  S2  each  S]  [add_if_clones_class_body_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_class_body_declaration SS  [class_body_declaration *] Stmt  [class_body_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ class_body_declaration  * ] 
-    deconstruct * [class_body_declaration] Rest
-        Stmt 
+function add_if_clones_class_body_declaration1 S2  [class_body_declaration *] Stmt  [class_body_declaration]
     replace  [class_body_declaration *]
         StructuredClones  [ class_body_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ class_body_declaration ]  Rest  [ class_body_declaration  * ] 
+    construct d_S2  [class_body_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [class_body_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_class_body_declaration2 S2  [class_body_declaration *] Stmt  [class_body_declaration]
+    replace  [class_body_declaration *]
+        StructuredClones  [ class_body_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ class_body_declaration ]  Rest  [ class_body_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_class_body_declaration1  Rest  Stmt ]  [ add_if_clones_class_body_declaration2  Rest 
+          Stmt ] 
+end function
+
+rule mark_clones_class_body_declaration S  [class_body_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [class_body_declaration]
+        S 
+    by
+
+end rule
+
 redefine package_header
         ...
     |    [empty] 
@@ -315,47 +397,68 @@ end define
 function find_replace_package_header
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [package_header *]
-        _  [ find_clones_package_header  P ] 
+        _  [ find_clones_package_header  P  P2 ] 
     by
         P  [mark_clones_package_header  each  S]
  
 end function
 
-rule mark_clones_package_header S  [package_header]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [package_header]
-        S 
-    by
-
-end rule
-
-function find_clones_package_header P  [program]
+function find_clones_package_header P  [program] P2  [program]
     construct S  [package_header *]
         _  [ ^  P ] 
+    construct S2  [package_header *]
+        _  [ ^  P2 ] 
     replace  [package_header *]
 
     by
-        _  [add_if_clones_package_header  S  each  S]
+        _  [add_if_clones_package_header1  S2  each  S]  [add_if_clones_package_header2  S2  each  S]
  
 end function
 
-function add_if_clones_package_header SS  [package_header *] Stmt  [package_header]
-    deconstruct * SS
-        Stmt  Rest  [ package_header  * ] 
-    deconstruct * [package_header] Rest
-        Stmt 
+function add_if_clones_package_header1 S2  [package_header *] Stmt  [package_header]
     replace  [package_header *]
         StructuredClones  [ package_header  * ] 
+    deconstruct S2
+        Stmt2  [ package_header ]  Rest  [ package_header  * ] 
+    construct d_S2  [package_header]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [package_header] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_package_header2 S2  [package_header *] Stmt  [package_header]
+    replace  [package_header *]
+        StructuredClones  [ package_header  * ] 
+    deconstruct S2
+        Stmt2  [ package_header ]  Rest  [ package_header  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_package_header1  Rest  Stmt ]  [ add_if_clones_package_header2  Rest  Stmt ] 
+end function
+
+rule mark_clones_package_header S  [package_header]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [package_header]
+        S 
+    by
+
+end rule
+
 redefine import_declaration
         ...
     |    [empty] 
@@ -364,47 +467,68 @@ end define
 function find_replace_import_declaration
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [import_declaration *]
-        _  [ find_clones_import_declaration  P ] 
+        _  [ find_clones_import_declaration  P  P2 ] 
     by
         P  [mark_clones_import_declaration  each  S]
  
 end function
 
-rule mark_clones_import_declaration S  [import_declaration]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [import_declaration]
-        S 
-    by
-
-end rule
-
-function find_clones_import_declaration P  [program]
+function find_clones_import_declaration P  [program] P2  [program]
     construct S  [import_declaration *]
         _  [ ^  P ] 
+    construct S2  [import_declaration *]
+        _  [ ^  P2 ] 
     replace  [import_declaration *]
 
     by
-        _  [add_if_clones_import_declaration  S  each  S]
+        _  [add_if_clones_import_declaration1  S2  each  S]  [add_if_clones_import_declaration2  S2  each  S]
  
 end function
 
-function add_if_clones_import_declaration SS  [import_declaration *] Stmt  [import_declaration]
-    deconstruct * SS
-        Stmt  Rest  [ import_declaration  * ] 
-    deconstruct * [import_declaration] Rest
-        Stmt 
+function add_if_clones_import_declaration1 S2  [import_declaration *] Stmt  [import_declaration]
     replace  [import_declaration *]
         StructuredClones  [ import_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ import_declaration ]  Rest  [ import_declaration  * ] 
+    construct d_S2  [import_declaration]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [import_declaration] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_import_declaration2 S2  [import_declaration *] Stmt  [import_declaration]
+    replace  [import_declaration *]
+        StructuredClones  [ import_declaration  * ] 
+    deconstruct S2
+        Stmt2  [ import_declaration ]  Rest  [ import_declaration  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_import_declaration1  Rest  Stmt ]  [ add_if_clones_import_declaration2  Rest  Stmt ] 
+end function
+
+rule mark_clones_import_declaration S  [import_declaration]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [import_declaration]
+        S 
+    by
+
+end rule
+
 function normalise_preferred_tokens_method_body_block1 B  [method_body]
     replace  [method_body *]
         A  [method_body *] 
@@ -699,7 +823,7 @@ rule normalise_list_catch_clause_modifier
         N2  N1  Rest 
 end rule
 
-function main
+function program_normalise
     replace  [program]
         Prg  [ program ] 
     export CloneNumber [number]
@@ -714,8 +838,23 @@ function main
           normalise_list_variable_declaration_modifier ]  [ normalise_list_variable_declarators_variable_declarator ]  [ 
           normalise_list_method_declaration_modifier ]  [ normalise_list_throws_qualified_name ]  [ 
           normalise_list_annotation_value_list_keyed_annotation_value ]  [ 
-          normalise_list_single_annotation_value_expression_or_nested_annotation ]  [ normalise_list_catch_clause_modifier ]  [ 
-          find_replace_class_declaration ]  [ find_replace_interface_declaration ]  [ find_replace_enum_declaration ]  [ 
+          normalise_list_single_annotation_value_expression_or_nested_annotation ]  [ normalise_list_catch_clause_modifier ] 
+end function
+
+function program_remove_clone
+    replace  [program]
+        Prg  [ program ] 
+    export CloneNumber [number]
+        0 
+    by
+        Prg  [ find_replace_class_declaration ]  [ find_replace_interface_declaration ]  [ find_replace_enum_declaration ]  [ 
           find_replace_class_body_declaration ]  [ find_replace_package_header ]  [ find_replace_import_declaration ] 
 end function
 
+function main
+    replace  [program]
+        Prg  [ program ] 
+    by
+        Prg  [ program_normalise ]  [ program_remove_clone ] 
+end function
+
diff --git a/Txl/norm.Txl b/Txl/norm.Txl
index 8064a65a74734163690dcfff0256531032f8e1d3..a520ee8bbd3e19d9abe16ed4e00310865263d6ab 100644
--- a/Txl/norm.Txl
+++ b/Txl/norm.Txl
@@ -87,7 +87,8 @@ function update_id I [typeid]
  construct find_replace_I [id] find_replace [_ TypeID]
  construct mark_clones_I [id] mark_clones [_ TypeID]
  construct find_clones_I [id] find_clones [_ TypeID]
- construct add_if_clones_I [id] add_if_clones [_ TypeID]
+ construct add_if_clones_1 [id] add_if_clones [_ TypeID] [!]
+ construct add_if_clones_2 [id] add_if_clones [_ TypeID] [!]
  construct S1 [statement*]
      'redefine TypeID 
          '... 
@@ -95,26 +96,39 @@ function update_id I [typeid]
      'end 'define
      'function find_replace_I 
 	    'replace '[ 'program '] 'P '[ 'program ']
-	    'construct 'S '[ TypeID '* '] '_ '[ find_clones_I 'P ']
+	    'import 'TXLargs '[ 'repeat 'stringlit '] 
+	    'deconstruct '* 'TXLargs
+		"-diff" 'Filename '[ 'stringlit '] 
+	    'construct 'P2 '[ 'program '] _ '[ 'read 'Filename '] '[ 'program_normalise ']
+	    'construct 'S '[ TypeID '* '] '_ '[ find_clones_I 'P 'P2 ']
 	    'by 'P '[ mark_clones_I 'each 'S ']
      'end 'function
+     'function find_clones_I 'P '[ 'program '] 'P2 '[ 'program ']
+	    'construct 'S '[ TypeID '* '] '_ '[ '^ 'P ']
+	    'construct 'S2 '[ TypeID '* '] '_ '[ '^ 'P2 ']
+	    'replace '[ TypeID '* '] 'by '_ '[ add_if_clones_1 'S2 'each 'S '] 
+					    '[ add_if_clones_2 'S2 'each 'S '] 
+     'end 'function
+     'function add_if_clones_1 'S2 '[ TypeID '* '] 'Stmt '[ TypeID ']
+	    'replace '[ TypeID '* '] 'StructuredClones '[ TypeID '* ']
+	    'deconstruct 'S2 'Stmt2 '[ TypeID '] 'Rest '[ TypeID '* '] 
+	      'construct 'd_S2 '[ TypeID '] 'Stmt2 '[ 'print ']
+            'deconstruct 'Stmt2 'Stmt
+	    'deconstruct 'not '* '[ TypeID '] 'StructuredClones 'Stmt 
+	    'by 'StructuredClones '[ '. 'Stmt '] 
+     'end 'function
+     'function add_if_clones_2 'S2 '[ TypeID '* '] 'Stmt '[ TypeID ']
+	    'replace '[ TypeID '* '] 'StructuredClones '[ TypeID '* ']
+	    'deconstruct 'S2 'Stmt2 '[ TypeID '] 'Rest '[ TypeID '* '] 
+            'deconstruct 'not 'Stmt2 'Stmt
+	    'by 'StructuredClones '[ add_if_clones_1 'Rest 'Stmt '] 
+				  '[ add_if_clones_2 'Rest 'Stmt '] 
+     'end 'function
      'rule mark_clones_I 'S '[ TypeID ']
 	    'import 'CloneNumber '['number']
 	    'export 'CloneNumber 'CloneNumber '['+ '1']
 	    'replace '[ TypeID '] 'S 'by
      'end 'rule
-     'function find_clones_I 'P '[ 'program '] 
-	    'construct 'S '[ TypeID '* '] '_ '[ '^ 'P ']
-	    'replace '[ TypeID '* '] 'by '_ 
-	    '[ add_if_clones_I 'S 'each 'S '] 
-     'end 'function
-     'function add_if_clones_I 'SS '[ TypeID '* '] 'Stmt '[ TypeID ']
-	    'deconstruct '* 'SS 'Stmt 'Rest '[ TypeID '* ']
-	    'deconstruct '* '[ TypeID '] 'Rest 'Stmt
-	    'replace '[ TypeID '* '] 'StructuredClones '[ TypeID '* ']
-	    'deconstruct 'not '* '[ TypeID '] 'StructuredClones 'Stmt
-	    'by 'StructuredClones '[ '. 'Stmt ']
-     'end 'function
  export Rules Rules [. S1] 
  export KeepRuleIDs KeepRuleIDs [. find_replace_I] 
  export TypeIDs TypeIDs [. TypeID] 
@@ -142,10 +156,6 @@ function typeSpec_repeat DS [redefineStatement] T [typeSpec]
     'rule ruleID
 	'replace '[ 'repeat I '] 
 	   'N1 '[ I '] 'N2 '[ I '] 'Rest '[ 'repeat I '] 
-%	   'construct 't1 '[ I '] 'N1 '[ 'write "t.1" '] 
-%           'construct 'T1 '[ 'stringlit '] '_ '[ 'fgets "t.1" ']
-%	   'construct 't2 '[ I '] 'N2 '[ 'write "t.2" '] 
-%           'construct 'T2 '[ 'stringlit '] '_ '[ 'fgets "t.2" ']
            'construct 'T1 '[ 'stringlit '] '_ '[ 'quote 'N1 ']
            'construct 'T2 '[ 'stringlit '] '_ '[ 'quote 'N2 ']
 	'where 'T1 '[ '> 'T2 ']
@@ -203,10 +213,6 @@ function typeSpec_list DS [redefineStatement] T [typeSpec]
     'rule ruleID
 	'replace '[ 'list I '] 
 	   'N1 '[ I '] ', 'N2 '[ I '] ', 'Rest '[ 'list I '] 
-%	   'construct 't1 '[ I '] 'N1 '[ 'write "t.1" '] 
-%           'construct 'T1 '[ 'stringlit '] '_ '[ 'fgets "t.1" ']
-%	   'construct 't2 '[ I '] 'N2 '[ 'write "t.2" '] 
-%           'construct 'T2 '[ 'stringlit '] '_ '[ 'fgets "t.2" ']
            'construct 'T1 '[ 'stringlit '] '_ '[ 'quote 'N1 ']
            'construct 'T2 '[ 'stringlit '] '_ '[ 'quote 'N2 ']
 	'where 'T1 '[ '> 'T2 ']
@@ -261,7 +267,6 @@ function typeSpec_ignore_LoT TID [typeid] T [typeSpec] LoT [literalOrType*]
  export Expression [literalOrExpression*] _
  construct TT [type] '[ T ']
  construct Pat [literalOrVariable*] _ [pattern_replacement TT each LoT]
- % import Expression
  construct Pattern [pattern] Pat
  construct Replacement [replacement] Expression
  deconstruct I TypeID [id] 
@@ -582,19 +587,45 @@ function main
  import OrderRuleIDs
  import IgnoreRuleIDs
  import PreferRuleIDs
- construct PL2 [literalOrExpression*] _ [id_to_type each IgnoreRuleIDs] [id_to_type each PreferRuleIDs] [id_to_type each OrderRuleIDs] [id_to_type each KeepRuleIDs]
- construct L [literalOrExpression*] _ [. PL] [. PL2]
- construct R [replacement] L
- construct RULE [statement]
- 	'function 'main 'replace '[ 'program '] 'Prg '[ 'program '] 
-    	'export 'CloneNumber '['number'] '0
-	'by R
+ construct PL2 [literalOrExpression*] _ [id_to_type each IgnoreRuleIDs] [id_to_type each PreferRuleIDs] [id_to_type each OrderRuleIDs] 
+ construct PL3 [literalOrExpression*] _ [id_to_type each KeepRuleIDs]
+ construct lOfE_Normalise [literalOrExpression*] _ [. PL] [. PL2]
+ construct lOfE_RemoveClone [literalOrExpression*] _ [. PL] [. PL3]
+ construct R_Normalise [replacement] lOfE_Normalise
+ construct R_RemoveClone [replacement] lOfE_RemoveClone
+ construct statements_Rule [statement*]
+ 	'function 'program_normalise 'replace '[ 'program '] 'Prg '[ 'program '] 
+    	  'export 'CloneNumber '['number'] '0
+	  'by R_Normalise
+	'end 'function
+ 	'function 'program_remove_clone 'replace '[ 'program '] 'Prg '[ 'program '] 
+    	  'export 'CloneNumber '['number'] '0
+	  'by R_RemoveClone
+	'end 'function
+	'function 'main 'replace '[ 'program '] 'Prg '[ 'program '] 
+	  'by 'Prg '[ 'program_normalise ']
+		   '[ 'program_remove_clone ']
 	'end 'function
  deconstruct P0 S0 [statement*]
  import Rules
- construct P1 [program] S0 [. Rules] [. RULE ]
+ construct P1 [program] S0 [. Rules] [. statements_Rule ]
  by  P1 [typeSpec_eliminateKeptAnnotations] 
 	[typeSpec_eliminateOrderedAnnotations]
 	[typeSpec_eliminateIgnoredAnnotations]
 	[typeSpec_eliminatePreferredAnnotations]
 end function
+
+% Yijun Yu: TXL program is hard to read, some conventions I try to adopt: 
+%%%% Variable names:
+%   Type_VariableName, or more commonly 
+%   T<number>? where T is the abbreviation of the Type name (often the
+%	first letter) and the <number> is to differentiate the variables
+%	function/rule names   type_FunctionName
+%   d_VariableNameAbove -- for debug purposes:
+%	construct d_VariableNameAbove [Type] VariableNameAbove [print]
+%%%% Function names, except for `main' whose type is always [program]:
+%   function type_FunctionName ...
+%     replace [type] FunctionName [type]
+%     by _
+%   end function
+
diff --git a/Txl/verilog2.Txl b/Txl/verilog2.Txl
index b54be82c92c9a0616e81bae8f021465158629d87..0a63e035087ca1e1b9e13e13a9937fa1d41ddf0d 100644
--- a/Txl/verilog2.Txl
+++ b/Txl/verilog2.Txl
@@ -27,47 +27,68 @@ end define
 function find_replace_module
     replace  [program]
         P  [ program ] 
+    import TXLargs [repeat stringlit]
+
+    deconstruct * TXLargs
+        "-diff"  Filename  [ stringlit ] 
+    construct P2  [program]
+        _  [ read  Filename ]  [ program_normalise ] 
     construct S  [module *]
-        _  [ find_clones_module  P ] 
+        _  [ find_clones_module  P  P2 ] 
     by
         P  [mark_clones_module  each  S]
  
 end function
 
-rule mark_clones_module S  [module]
-    import CloneNumber [number]
-
-    export CloneNumber
-        CloneNumber  [ +  1 ] 
-    replace  [module]
-        S 
-    by
-
-end rule
-
-function find_clones_module P  [program]
+function find_clones_module P  [program] P2  [program]
     construct S  [module *]
         _  [ ^  P ] 
+    construct S2  [module *]
+        _  [ ^  P2 ] 
     replace  [module *]
 
     by
-        _  [add_if_clones_module  S  each  S]
+        _  [add_if_clones_module1  S2  each  S]  [add_if_clones_module2  S2  each  S]
  
 end function
 
-function add_if_clones_module SS  [module *] Stmt  [module]
-    deconstruct * SS
-        Stmt  Rest  [ module  * ] 
-    deconstruct * [module] Rest
-        Stmt 
+function add_if_clones_module1 S2  [module *] Stmt  [module]
     replace  [module *]
         StructuredClones  [ module  * ] 
+    deconstruct S2
+        Stmt2  [ module ]  Rest  [ module  * ] 
+    construct d_S2  [module]
+        Stmt2  [ print ] 
+    deconstruct Stmt2
+        Stmt 
     deconstruct not * [module] StructuredClones
         Stmt 
     by
         StructuredClones  [ . Stmt ] 
 end function
 
+function add_if_clones_module2 S2  [module *] Stmt  [module]
+    replace  [module *]
+        StructuredClones  [ module  * ] 
+    deconstruct S2
+        Stmt2  [ module ]  Rest  [ module  * ] 
+    deconstruct not Stmt2
+        Stmt 
+    by
+        StructuredClones  [ add_if_clones_module1  Rest  Stmt ]  [ add_if_clones_module2  Rest  Stmt ] 
+end function
+
+rule mark_clones_module S  [module]
+    import CloneNumber [number]
+
+    export CloneNumber
+        CloneNumber  [ +  1 ] 
+    replace  [module]
+        S 
+    by
+
+end rule
+
 function normalise_ignore_by3_module_statement1 E1  [module]
     replace  [module *]
         Seq  [module *] 
@@ -106,13 +127,28 @@ rule normalise_list_module_declaration_part_module_declaration
         N2 ,  N1 ,  Rest 
 end rule
 
-function main
+function program_normalise
     replace  [program]
         Prg  [ program ] 
     export CloneNumber [number]
         0 
     by
-        Prg  [ normalise_ignore_by4_module_statement1 ]  [ normalise_list_module_declaration_part_module_declaration ]  [ 
-          find_replace_module ] 
+        Prg  [ normalise_ignore_by4_module_statement1 ]  [ normalise_list_module_declaration_part_module_declaration ] 
+end function
+
+function program_remove_clone
+    replace  [program]
+        Prg  [ program ] 
+    export CloneNumber [number]
+        0 
+    by
+        Prg  [ find_replace_module ] 
+end function
+
+function main
+    replace  [program]
+        Prg  [ program ] 
+    by
+        Prg  [ program_normalise ]  [ program_remove_clone ] 
 end function
 
diff --git a/bin.Darwin_i386/api_javac b/bin.Darwin_i386/api_javac
deleted file mode 100755
index 5c8af0b88e5b5b1df572af52a86fa82c9203faa1..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 281144
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%0D+2p3PF_zE8<KZuO}J;~
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

diff --git a/bin.Darwin_i386/java-apic b/bin.Darwin_i386/java-apic
deleted file mode 100755
index c52e8f75c804f5e6f6025aa9935b41a0118f4eaf..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 281144
zcmeEv33L=i_wP(H4N1r_0TN{=ASnAH1T&C<3`}4GVNo^}HDDluvI#Q?3NbMmq-|P*
zA1E%k0dBZ}pF}``B*08SL{LOjWK&_ru!#$+%=_J{?wU>r-}2r$@166`Kj%!ktLj(x
z-nw<`R&`Z%^_Q1UU9D|0nWIgn{3w&jR0qGawM-@-uJqRkKR15a*~6U!Gw#l~V;IF&
z{WDh$))*o>bHE@wdt}C)BdbDK{x!ti@TY|#n@PftuJo6k?U^{o!|!>xD!n2UfavuY
z!|74D3T2BaKa!j1&6+#){^?V)XL-E$ce_@;_4h|HdVVdF9@c5ZX!M{m_6K?(ls#$U
zlo=CeBBpwI^Kv-7yEUazxXRx(^5x9(%$z*!0S#20-hm06-p@@rfWoLt@mGyH<jI*n
zZB|5q)#;TMaC!+E1qvJK3BuY<cD8rgBa^31$euhccRJ##)7zubYpMxCVM}!)hH!TF
z#7Wt?GsjPz$Rn%MJ6ov9*O8}F*eD;Wdz^tBv){Jhot^D+j&vGQU|*~Xj@0Gi==Rr@
zR}9%3(T&vWG}s6?l^LFy*QGaHX90Rf-4mUbdK#|T*;B^<D|*8<`C_;@CJGzrk$fGh
z(3>%H`UB8g_U!R9XI)#~acg;b+iH0zOzrA=f7#g+#(Ty`QmgClHH}`^c3eOT|7&_V
z)2B|IK24`so!*h}qgj27ORgo%!$?n4gPtAwyMGpnDgLU{OTQdzp*$-W>z;%A5j{h7
zdJ#XDl{s{9hAUI|QN{Hb9n%ag=MipgsSolnQ8&_R1wYzVXF^xt?=*z(L^uHzIq6um
zDHTkqP8;I)+U01|I0W{zvX~~_!u_yrOZ$;dzX@Q}3z(a6f4#rgT3Sq5H6+$WTrz&~
z_;vBln%QN_<oml!m^)<x!t~b!Kayj@t*@#-eX?PD;Nw3Yje7A8h3a5EepD&#@%w-M
zr~CJRCkK@?6+bEy={PQGKK`2{Wk>l(%$?<#IJI-X&d|f;`;q)VfB&O_|IxtzXyE^{
z1|BrI<zL)|Kc96g^JCnqH$lEsSZ*#m7VS2lbIW@xE$+gy7<ZxF<o%28g73i@%YopH
z7~=jh3RyQ(2egH}T<|f(xeG6tJ+{qM2p*Y>NRA;d9vo8*!y@|$OblVVSHrN#<^mH(
z7+W<Ai@Y>i=Y^4&DOic1Q63h#ACWt@lH?=Yg(qX=%hbV`g5AR5aN*@TwkQ8UNIu|J
zlL+n3u{_~6?+G8tEk1%E{iuJX>nQC?_w;*IyS|Jo72mB$omPOq60@-ZMUk4^s^ci+
z4mO1hp|?3GMgt`pKzj&ueiT539Q4y0oDvNbbV{WJ`U;@R@!(aaAxIB8Vm%?&5TY*-
zuWE=J4T#qX@iZZt$=|!xl+_3W>S54Su9-1NcB@j;J<+DZRFfwW_wipw1D4=co?S-r
z$q9(Ng17)1jX-ymy9p2_H*_n#+=T&)d??rpWUATAV4_U+QV*;jyc!O3i|N4_rrbpl
z%sg)55pIfLwoso(+(r?s;>|qbW{P07e0HQ>%g&J_<ja}zA7G(=K~hPtyiSFL*tOiM
z^@UxCQ>BllB2G3#^ht>D6F|z-aRbmUq)*70WM_=OpBXSIgc1f==MJPxAW0KTI5NTC
zFUq_T`a!nyZh1GD#glqf%Qq}C;7X<O0aCNNHgt!}-G!HK@E%2eKPgX5dW)o$quhaf
zQZoGo*nc338FLEpDq4whBl<28jX*xjUhXa^uK>=i<t;3YaohKJ&#L{AA?cpaqfOwT
zN@H=8B_|hNHs_5*Fdl@Igu+V=A0Ln<AK$`ER~ZnKpW4aO41%gsC5WTebG~vbLrFO!
zkl!uG?+FL&hduQXu@e9oNTELlRPrdxdc=fHW1aW##)oP_<Yks`YnJ-j8WK`@tfAW%
z_DI1kcR*2vTVt~9KY2rLwb?(ZmXzL<7{`nJg@yo;=O|HPrL=GL9^mQYFNec|8IL;s
zH`CHEMk|%fGPns;e5IZy954Ys0Q5RDfJsRW-il<NR5(u8bzgwCKv+{S5vj$+WYf+u
z&e6_MRHTBF4e_v*DPPT$&pYLPPWcO%hvQYUrv$e=s-oLhxdC4(sw>0fEWBd&-l_%1
zm=F#5+Kw4NGvM2XyJ>jrMq&kS+a>#bJ8?CIc7tz*?`NBD1|9^oteJY&%xQ?BtkY*s
z9nW)mCQqlxT^f<yjED>(8n=;mX7Mb^lc&z$S*A>!I+5p?<{9q^`1T+Vs3Zq``*1g9
z^3=%z-vQit+9jJRohZZ&-rm<zn}(bu`ox*jAPVuHk~|S5BWg3J&uj;wh+HxWawQyw
z942SM-zQM2$Looxu72M(B%1ubQq(5e#HP|q;V?q@Zz^>B9gMX^d2dF;-nSbQ7kx~g
z#-tKJJ3?XQlw~71q+s^&D57x@5l+C?Cqn_bHW!P@mDy!8bzrPod3|3PLM^q~*d1hd
zkD*mtD^T0KHLEGxgkAIkX}7A9M1<1;D+HjC27ok1z!L&+VHg<)W1;>OYtbo;7l3ag
zfRTvQ0qFuzLIB7BRT){d5P+o`1(zJsbJrJ%bF|##LJTE1db@7=V>AHNX9ScAKu?W)
zmi(JeeuYSEq$NUwZz56$JRtxVhH~j)4My_g1>jo(K(Z|PqMq9&5;wBMSqZ!w_y{3b
zWP>~p*gb^0!?4BE7)^R?1=XXW!wQg3gVv-BphUOTgTbP-Fz>opXBwOb$}k}aNerTF
zMV~_3xJ$D6F5)iq9#g(F;w6%GRE4{H0=(D{WJCqq$RofNIq!Ae=gj8b&#f-KVq^S|
zE{(CE1J#_O!H=XuLZ^HM?&Io<L{xJh=u57+17&bRVP>i4K5(Dk>sFm%U#abB^3-nm
zcTitL)hRE18<#BgeR4QMY+J5`E3#BiEwim8dZCXHe&1UB=dHx8tYc{TOt1^&wryr^
zsxa89@Iq7Dljor=xfESSEU8T&6@7@nFNPn@?0s$s8`J(z?#W|Oei~b$g+u0>$4{L>
z-VV3DO_ld(kyAXq;WDU5m6=-91CgknTGYed=~`Aw^D}s3o$L%fZI+$}e>=y{{DVtA
z!M(%xnWzy}a%_(_4N~S^fN6?`^$rY$gIZ)^Sk)S^8vt`Fb7BmrLV>zC7^K2mv+Tdy
zd=nrF>bvd>RNuN0Jx73oZDbDBjEIe2t2?f~OtfZiY!i;_Ht^CLP94FwfXFI(!<kDV
z)tc&$G?}(c>YAENeV{~>F*8_AO(qjG#W1_Nn9JP6u-WCULd;?qoi64C+-sU1WEAr&
z3KedP8LPD-`Q8Ir^28%q^3-6K>^++$&%b~kxEQ`XQ~n!0aHhO}q52H-EYkYtiIUce
zY$df9`d&kV-}gGTX>=_VLRWGZSO<54589J2fZ=DBd`53@tgU6K<HMQgx@`;IL8{YM
za<4i6@+40K<ZXkzfCm+p-FqJ|!Ud{T)p`&$qPwGAtk^Z_wgf1l+f@u!lWtF;mh&%<
zw)tK`i>R*Kw1G^wua*nlz6?{;bsK|wE?6F!iZFrM%y6tJ1~J=QS4^8x%&Ux1O=1pU
zV$Sw9MJpKoxy58FSxU9BaCq&auWU=wV?w#;@bfP}%m7`CfEWg-9m-&U>E4^2;abl8
zz9w5ycf_!6Jxjid=cz`=VlBZuSW~DmgFa&O-AJBOhg%R!0|!)so+~&EaOY>xoGG6r
zfa)g*@Te?x(;8+9%s$+*FCQVzhi0kks0*-_EGK#kmlF^^6#u~^B@YIlC5MBHK;Bn6
z=YfUGt5{e{E^Bg|h+c3K!#v*KR`PX!)w0s1PUyFX`~wX`*u!&{e4f|Rfxc9CC{mXE
z7a7;Hs9jxb-%NA^=!Fv3)6=8VHe?$-bj~&lAJiY(VbFNJ&?V5wzdXz48;cuQaMbKh
zu-=R)bOpv@Xr)gng%JnKz>FF~x>2QT5g?T!mr&`I0Zb~=gso_gQJKYvbE~>C=OCnM
zQPU|Y6Ojv-6VUHljQ^y}ZeUN!?8_v$R+){E?p8Jty<iiDsjkf5jLJO2m8tX*$~+AX
z2Qv&}GiAcr=OsD|t|Z)o@jm^N%bm8N`zoc4C^Y1fc6=9WkrU*k*N?<n5PY=4pyR~Q
za{%REp5ui#kg|<QEi3b~)Rd;E8mCgL@Is5nr-w_Oa;+?N6<HDuTXAWnS2Sch5nPc$
z&6p`iQ}c1Rd^q?lqFES9YE5kxadQ|{>U6?la(5zI$;|2FE;|w9HV52z^fsfE=vPXf
zrHkIL^r1Wo9H;^Zs=$FNaG=Wk3)hZB=Aa3|pMrviQP4*ss`N9I;WwFd|HyRAoMd>1
ztS-Wk$hX7x^n=Lm{EVy5w}!?^Xj8bLq0x|)tN~@mn1##$W0pAtQGG9S<O~*C`Wg!@
zorFuJ)n#8r#BGagBw5Zjn6XO=!;TS&=7|4fLC?S{U?IdRc+th}ct6?~nwd*JrZuu~
za88;qiK}E1w*sn-^gv`Mh(wwqpz>C<hoTY`N1YX>5ib=ChRW@$s2Z_f`bU}isfjm%
zr_PWAqYOYYV-j*bz+gFs%S}-nJ04g(qz*z_@9Jq8NK<EE)Swc+sxaq!M@pvi7zrMg
zGqunaMqe9EvU;<X6j?W;8qhg{96Cq*Cz(EH7PN`fAABDqe5Kw_MxL8#JW9>AeGNR1
z^kWr40$$5ey$h9{GK<q^YM2QUG%3^)@%<z5To<EwqRsaXHAk(~%xP*8aM%j0RO!A+
zFZx{&qtc7YyjBQSY#3qnV((*ZgcrL6**^tSDti~b;`MTKuAK~A$&^kwwJbF<%}^)A
zhXc&c$%Zzt7NRU=2Cu9mRS=ED^WiYuJ$Xf2Q8X@vo2X@&ZBPG&%K&x4P3F)^+&RPB
zLO<h*R=WFX(zo8uM?(mVAE^;n8$Y72=)Zx+2vN3@bj!lp{6<<h(9G{@EgTrd?`kg`
z7=5i@n1t~U*kv<z5vNcaG+j#94BubgZd@<J{-hQy4c%%n`O{;}0pELg8fL{+rC3by
z@wutc1=J&8x6}kXwpoXPuI=eB0A<rs)QLbTnjg&!1jr2FJ;<}b&lJ;RH#`en<fRK)
z$hU@teEB?$WFfDEOO||^3;b)O&t<N-c{+K46Wnm{9LgWM!aLlB7cmZ8gxa%}Fb@tN
z1Um3R_)qPo4mD}`AOwS65P|KCS6K0#c7I+sb&gr^oDH734QRrEC6~tr1%}F@F(Uxv
zKZ8vQ(64_0v>YHL{DUV1&5Wnb_aj79mQzu~Tb=epwnd8=PEs~mObS|CvaRS*#AK<R
z<{~EIi<cn>`Du1pMM|Y^D+6U(M@jNwF5gCUtJ>5{E3I?l0CEXGMEYDf*b~9MdKhx%
zXmWmnI8^<VBaselzDeuBFasIv3+1@*h*Y!>1#v1FTx7DF@Yc{|R^^T_Kf@$YUz4|q
zHahau*SpQ&eIOrt0%$yPECWo5rY_hME|sH6Y!piq8@y0mWHrIoLQG{HGb3da*-x;(
zh*wiqQrptv|8TG(ymMGDf;*?T-Uln|Sk}47s%&Dl5Rlo`X}@YyeK24Y-bV7Ln!GpQ
zzHo1>h3>V<&bsFa(ac(k2Gl>!oTawu2Y{&gE+|0$V~Kz}6-#Sbk`7>OqDcOyNIKmQ
z3?=yrwo#+K#t%q2pOPJ*lSz}yoa<o;Fa>Mg+ZI!0ZF#TDUN*CJKh<KE{d-TVqr>tZ
zuqm)#c;x3<wOr}|bLAnHqf%nVpg)>jx^`6H4)5^o$m?P&iONswYVx#TEf`J68(Y~J
z6X5nQJq^METS-4NC3{aXa-d4$XjD~c`FgetVe`>22bxkhSm13;N=ov#Y(N&fgUTKQ
z@h?}zTAYg6WiR#4-tZ0F-$q(0fYH^08u8@tIBbfWul-k2ueH}FktekFCFB@udO}MC
zN<5)OGZ-Fy5D7e6>)1^9!NJrq52uxaS&&0cu%CPU26s-myX=T1KP@KC_H+}-AG!yo
zE8i$5<?M&lNL7<Efp#nP3Fo&Y#JO{7BeF*%GT=&xM=?yHWBBJ%teq&QDlJ&g)PTDf
zhV6>GRuDvqamhQw<t}?UQ=@Iz9!&_h`K;X??`;-HXXNA?kzq$5))F?!N#A`FYhlgB
zW#8#7-|($LcRS&Sp}YRDWUjlvgG_f<*F|)9`s3^A?f_6icL4^gNq07M^74%#6O<$B
zeHAo~<tLkuEflEI(Y3HxT5Xx~iN(}A0abj!Am&ZXi#c9~&2uqFb1}yl#2k2CF}oSX
zOxDGO;fX4y``{#W_iQy}6lB3O!Hu*YqDsRM!tzqUQq1b<YhF+CK2}egOZ0kb%V1Pb
zkAhvz^`u%B*kinnc>l<%=+`wCtfI(Cy+E$=F{+=P8?bpv*miq35!BBLSRXI=y(d`x
z+=o)=vkyc6dA<5c1xnP<EewYGxu)RL?P76_FMHtW083n|WFqxaB^^bf5l(}&N`l&h
zjBDFE)Kk~I*&BW^i2E4)4#fQf70$)|;5ZZaL-5wcef6X3i7Nvo#GS)nHHllAil#Wo
z?39O)OmBaP%Ia$0ZCiAiJV;I%+Skj7L!%2=sE;rqt>`fGE{;MZgv;DHd)-QHtwQa;
z*^0`LT6scA`S>eVsiBXlQj<Y^1n^l(L)@)`Z177%)L9m%{F|DM0a_V+XdRdRNS@6F
z7HTaJak36QlY~h05${2&rLoHn4IW0IFl_d=;FX`jg|Ga8s^2ABdx3MP7bp~lqrB+@
zdRuPwrf?*9e*qL(peqW_9t%c1?}vyjG(|a8r&*RRq5lY7LL$Vfob6OI&Co<fZ%d&!
zH$zQq<b+|}Q7O6Xd%c5^;0#y_iIUU4!_&$sV-~sDWKeU4D>8HTWGc~`YBKB<-b$Ce
zL(_C0K+LHwIY}jED)N&m85hqgCty&e?-vZaH~eTYiAiwiFo~nEF>Vqs{me|_<+Tx$
zShVJPCNUc*VG<J=tR|Cqzh{)*3+nyVy_iCrh$+OW7qBfL*)3mo(wed3yFIZMF2`e7
z0CCzjBQmKJk$CRr@k=n~a_1zip*S@~F2_Zw>n=NHQKV&vlU;Fe?b2dOruZWkB`Kfc
zN5;e;elCl@f#O{YTVqL8dLR;$3vZ8+E+X%UMCv^N9^UcL4w03q+Cw`p%75}dvS5iV
z5Kj53Q@!u9?+4yR3_XycPLp6pAG}Y4f^db?zTIUT7TgR;j7wzS+={`c+9vgbXj7&#
z52CBqkI~ZfdB)dn(<|_X6dJr$=Jl>l;UA!&XDu*fohY*Y&;tXvE->@V9DkOY#+ryz
zKA2(u!{(#8mg*FppooFe%J<1W*qT~516`}2TL`)+;grW&Lvbo2YhOX|mp&}$R^s;<
zm!kH=Sa?-uQ8rHZC}`<LT_*q?0I2j<muhu4lrv`^I9$$S9F&p8#LsKsr#3tD9v51t
znk}e)(_OIbWnkM!06qpF!+z2eLr;N+(W0tL&<+wnFN-u5sHy^F);ax&3gQKPh;h<a
z1#&1v)9uw3uWFulPp9c{nI1rg<deLSC&G!VEhc;F;}d8$3&QcquJN8^tTWSM&9n*0
zwCGZS+gvQ%?!?uUi?KU26rD!;>PmB5OHj2NXoXfE#yx-%h(<X32p)dw!BDbt&S#b#
z$DRhp3T<`Hd?FErN1Fj~&Q2w())jfDTv2wZh4cJ;ll-k){*F;(>wH`b&vzipUPTX<
zkQM)@OrACo64Kgwvi5u<AEIZOFw^UDdV<g&Hb~afh-P6pgac46#qC2J5ydkEPvR7|
zG73`T-n^g%r}?-xscaq-8>R_)_h{0(m%&e9R?n|7I}yx7_6?;5tvn2N;=y3t;c(cc
z&rMk%Br1L+Y(Vc?U8}F>M>_*0{Ae=<gCB){p-Vo>rTgGSu%|U1cg-d-T%wsn+6w`z
zxGk@WRivCiTjBc7Z^veQY`z6VpHF$x3=8e`Vbf-!nm=zVl!%&vDyK}I<)NCvZPl8Y
z*cIHk5g2P`B%<}2nMSP{HPefrR2$*ox3~@cMDrS$heI-EV7Q1sf-xqgykoVQhAQF-
zeRl+km_nNCiAPVE;OXxoc;*n#>6~XJTAbiHne(*yp48L=vc#8d@j_I@`aiyft3@=f
znG<JdjSJ1Jip35g#$3fly`&*p*UM;X_K>kvM8+++4Pmbi(~D8Y?chv$xkqa+Rpb+T
zNd!u(4Bq%_kWW+0`<;bi1`*TIoas60Z1l<)&Y60ep_Yys6K>-PHs3#BomxeZL|A~Y
zW=K!mEHuW8&0Av%xbr4IeTE0Vh*~_Y@zuh_4%>RNmbRW?@q<F({t&naUq&WO?4<IH
z<2|04!dGO;M<c5cq|-R?H8R}RNoWS-T7w)=+~ghv6sqObPxD-;esWf#Fjx)Z$aQUq
z2wR$>YJg~3)t(4W0DZk)>yih8(;B4ltmd@rIuuh<B<f8B<ISQJx1n83r;H1!R?kh)
zs~x!jus^MEhl4*;9M4`r*;ST3#mR)wTGf*foE5PM6+}e@(JJ*NiuhG)USB91)QtaA
zCbRm%ohV;tG$bnDgG?IM3N<~jCU+O2wJ<AR|A>G`a2q;FElN#!n^DmOJPx)@z->%G
zrdtvaMrqoN(n4Boimn@wn#CEJ{*0~!8oG8a#HCJ#0WBvxa)!Ui%-N1PXo;%0nx&;A
zLmtv`Psj)>!xJVenO4zc5afwnGMlKhKnf%KiHtpSZC7wxS%)nmhJ$A)UXfPLp^H94
z)R9I0Co4j2vB#1|jq-VU>1UXB%#yc)+Gs{i>-Kp&hxeJzJNcQ()8LV)j~_p?7c?ae
zU%>_itp%`#(LgV4G@#A$$~)12rKeEGh$-qcESPHZwR15vCxyU#Ko0*$%%u%zw0Ug&
z92#a+;BF@Nonb2)?viKFCc8bjo5eTT?W0J|j<_SZxji()HEq;q5~5ichVl&aREL9?
z(R&%29W(k9!Cw)rWo1>f4`HGRQH>P0>M&5u&?vscD865MK{O}S;F;huMuDxCX%x-`
z^B8nhDOL$ka{Qk$bK(S)9Cs6QCr?Ak>25+YJkl=Qd8g&jmOk9kmOe!8!|hmD&n0N~
zcy~>+J@#nyPXwDYp36)Bsw%Y=(F_BrpJ#sJaPW7nZ^m3TPvV+9hG>OZ30M@?z~WP_
z(}W#qY*}-C7tuP4ER97m;x?4Q+*u#U{S<eBv-i_TM{Bi>e`h0|2UkQ!I(NTuy^)R!
zC^6FM&R{i-bRGk18tL$-tH|?H!O6C8$b8&8%1h1ZKWzZRUi;4*0Ig`CD{{-e^{^k*
zGy=o%svT+?cN3FYP2<ipaVFU~?z}TRu=_o@o6s>Ch8Hm#H+Jt2L`OL!GE#>5W28KE
zCL3~Mq}+7ne>hT}n#^tAFyP@MWkghMP~V_8BlCy9GuHAp(I2WQA5fcvr+XK1)S&d1
zqBW=&7zOEU7m~88Ta1*Sf0&8=??%cak$uB<-FC2mL7EiqyXQW`NcsD-%zoOx9<iUs
zuU*f6EI<kS`TbRb)nq@t!M^%d;kL25<usY~-&ju4EB}q<upI<&xMSWRJ*B$K&cxO5
z%(J37S2|1q=7s+wJmYh?3w<cr3qvCpIx%?)cK?zKor>-k?t^@2TdkS$=6<T?e(<2)
zF~MOhAfJMIE@x2Io0DPdE(X<2Ci*T*HJGiki6Fs6h&PxnDiNmp4~(DrL*Dq;|3lOL
zs2MLXoGc2A|N287ZmXJZV<yRR@~%eHjYYKXpnj(TE{b&KCQj5)78;QpLNsb1rBgN2
zJvi+@GTj%DeFM$z@kd{nF6ax>eQdA6bX%NeraS$Wi0Ni8zn<x40wqj0mBDH<-F&bo
z)7?M|8yjh-5h`&nl~{H3f?0D9{Kp<KTOW`DjyOEf=v(HuL?-g(lr>1&97$Ut(v0&~
zign_qSd0DQyuQA0UK_vkEHWiyI@Hq$mAwD~HdPfa_4hL;)5_5W@9*xMZ=vD`k%n~>
zlk6B*TE|l9z<Lw1k6_s^^6Uez&0ay-v5Qvfpl7$XM0PGwyS*;;c5{aBtGw=Nzp#6m
zt;AAmVQpvOC9|hhrhLJ<fePbPE%kVkb78s}ld73mD7EkKp2*B8_giXf>sOI(qwr)~
zr~Ic|9kmNwf1Hdxz<430-5!)~4H~z*chu~W=q}%WIZ}<wUb<d2J^_@d#)laU)ySUK
zv}bj?4{m6Q8q2|kpsnt*pJ>hK(EBtci4}<W?k-!2*_nT#iS5Z3@z9M2o>EA{mdo_5
zzQr_IGy}iR7;etN&j(;lzZgst))fEW#O<n0HYQ2SsCi&c)ETd&JwdW#mK5*L)XGma
zd$HP*er>b|dwaA&p@Oky=nlMktlS=N`@|WQOFN|dAuNBLh56<8uz;$jT!OlmVfS5B
z*q!q=H2&=K#L}#!6@y)-awD6sbtPDwy=!^#mXh=ooM=AAxwfJURyOM9#@_<GT=t)A
zMaK{u-dg#Q;*7`KsEerO9Du%~GO;qNq(uwqPN8R}ICqXK+QQ3~Gz2oaqoeXu<7`DQ
zfRK_NUs<Z$70*PI&Ob+@fu5_FWxygSa1R3qPTx~v&JQ(lDrB4zTe}O(sn&z5sn#*|
zY-zv>cTWuHZ)ID$p<T8%S=5x54d}b!6%_47uwEck`J!?=QMscnt-9HY&SCWs!GFFO
z&4NGiU<D8QzJ$HxJHD{P8F;Muj_q_~^KAww!*^=VNH$C9(w|~|O|dJ}w&lmdt(dH9
zbM$$bd(ID;O4>nG%Ri7)pRF7SJLX#7ggz@%>2Z*6{$GbsWlzj<zDZe?$M9Z~b*v$u
zP2}?diH)x@Jl}kT{8CpYTZz;X*M(A3{P#<V_-_tK^*^h_oLNZXrThK`R#=~(mF`R`
zD^v)NL^Tv@O%r3G;;R&DGji&Mnu&oFFH{iyQlwBv5MqVe`<y7$0z<xDBHtPyBZYb!
zA-^=1$yOp|;kr;7i2r`6FaD!Yj!(5hb%o%l!B|!(Zz66xV~>DhGE4P=4AtYwhn7*9
zy<L=~E4N`i19%3qm(R1dE0>c_ATo3u4kI8Pz%3MG3Vn+pfO~k(u1eDGjddvJ))$!R
zsGm?eTQOaSEV%(oRI({7y#r9_WuEl~meuBa2IQ2KXOJSF!%S$|ugz4;4TVQ)w<}i%
z#i&iY!Ca<+C~bbQZ_Vo|m$m!NorBH6(mf=rIl!Kf(Pwq~L|@BkO^@AduY{fWb!4JY
zj`me^TrSaboWnpvZdQlTS21h@^b9H!Dv9??r+cEvp%Xm%posn!(dN(|9{oOx#?m1V
zKC1;k;=xz7;0hjGqy?8CDAStq;G0?7&r&RVGHfLY&iqRwZA(hwwJV&3W!MN3xORd8
zn=Q}**`65=8d&o~#|5|E!<23-*$;wGw1OW?OMoBiigZN!)!}<+d9SNW-i^%@_anWs
zo|^b9k^<_;;d{b<`)+J<&+&sw8f6GL^V7^G??K;JwxW~NX^>35@#q;`>ddf`a%6oS
zi_`vBUW&Z8-EY_`#VX|UlqwbS@;Y6;|G=orC8w-LrcfMcK*Scy$<-#CJl#RYR`dsq
z0I@!})ZSff>Ms<`p`ttjn!5EoMEQ3jDc>;$(Qr1jN>oF;Y}nA)E<OJ+I-8r3Q*W2w
z!zuB0IlQs4UAhrs?b1$JxwARlBa-h8k*^_;k#?DYkYD-?NIZ1&&7&~PB_G2ltB&^(
z&6yQptO<3z{7D_OSe4Ki10j$cDnQo=RcCtZn3EnxLTCn$$gufxai>W4Aktnw-`Z}E
zEDa~XFhmC=ClSG4C>_BX6jJ*}qe60?H7X<td3A;CfJ5Ul_HATT$ZZHQg|wxtTp>Sp
zkK|h{^3?`1qL45u!Y_RUq{&tyt-y7m^a}p_rRVS;j%rDX=BS>;bGC9jy>05aiT8v`
z;vT$HxxR|+yX9}$?mU+|H;netD&H}bXnPVAM?c&IU!kpZk3tnLCB*^KAb0Ch_`8_?
zs;iILUV)dWFjzwDYcG=dS+S`qe@-j3li{#R(wlQLt%HhQ>&ql)!M0^P#!H<SQ_1I*
z(@N;ETO&n(4t35|7LUSKwgvHM2AxA))OrJQia;Jibr@bp3}SM`FZlq4Wj{_ATM_nJ
zkenCb`Iwyd*h-S7uVW>eFg6A~IkoO$fY4%T?Qz&WJd*kNV=HJB02dIQX!AWplyZ_f
z^USw^yxyLgAS#r_7$tp}%&I6JQTb_6pxuMh-o`^WGn6!$iPHitFNsq<@G%o<Z?_25
z?T8Bf1vTb7{)uQ{Uu4St%hS!N&c;ZLn)Pc)K^c-g&7AUIZrNX%;KbfD>|V-GtCftE
zPI*7=Fs;N&Ua*C^V($f){cK*l4YXH9clWbla%ff0!``_1Z{LPirKAi1dqd;94U7Qm
z+P#j}_-aGhHMEdl8W>xM^BH3c`Tf>9qJ_MLO6L5U-C%4XNeHnPQj4<k7V@bf-*l1h
z7uZy!h5U#Rdbr}XaTdk;)IZ@>)zMfRO?kX)Tx1L22uyh?j&X>Jc8tb<F2Gvs8}v&<
z5k~zwh9WP9M*|Ubn-9~r${;bSX?7Z&hiq*Qd}x?v_SFV!2kIM@(c@{OGLCnN*#3*K
zV=hYqH54&ei$RDf<Dx2*@qr=V{UYCiM58kHAf!0v02%F=hX0)Qj^C)9xd@v=ub_42
zJI2zzt!Oa<u%&$%9kVuq_id5}f5Z$j{Z8H-JTtWR(d90!ec(l-3yI#lGMO1R0wKLM
zSdp{RiI%>y8EXn=gvt0l^db#w2A-S1Ethd?ft{S3#Qx3^5<Ay2=39zsW0ceWt?lUm
zMBIQa)52`ezz$%KM_?|zbT8s<PqN3`t9qVM^^8@pc2T4Xlp*VNcimV}DTet*^uG|H
z%I>g+xs;EL(U6JkkFy>NSi}-XAmo?AouFF9@dqv(G#Jxmp%8P57ow%$nmW|~*yL|r
z?X(vd+S7bmj$=1cz%hV~us^rrT_1b^6kTS=$4K!@s~BPFEd;_9>|r{3p|l*KG^-~j
zEzahn?H@I`;H(7Uf>$e48t#I#K~7gg15qLwhRa-VK7%qBoMJ$RU|_sh*+BZGdQ2!s
zEnIl?y=PFE!fkD<ZHh2H+BbB{e`EI$T$KI1&4;;blajRe!#bA2a-29JZGD=Jf1iGj
zmF6$;7^F>J=h;}b9^#Kd-#-<pR@J(wW28vwLeLTzLZoItK!~-hS1BuZGb0W8Vnn_?
zAS0DK8zH~c3P@D$jkrWRtoY9hJqgoFXgUcf1WF){(wa{De8+Dckipv$-N%^^SYi+n
zdV@KLD8KX_{wHG(({5bx<Q)JY%X}eVn%AdKpWHyYWghsxLu3l2cL9-H@?WBR^@FjJ
zv;@(G<+LYhfy$Nlwx+z{TAR?6=d5c~-f~$e&+zhiZP*+y)qFA>;gY-vF~#LlHm<lP
z5KFhAFJTWnUj~p7#W@i2OQH5maffh;cI?A{4()P^Okeu?ebP<RF2v(F85BJ&EsYnw
zP%1&1<d@ze0-=1&PgI$tvA;|mb+t*F*)gnFF9k`A-jP8&rG^H(G)H5F)4m(O`+=+J
zclKYT)r7Ap?j4LH-8r|%qf+i&z{X>kG;zu2T=H>V^y8Qt4z0mVf^q)kHH6vxO98AC
z6E9QriI+x<hBonnVUhDCDtEoe{7Y>%{}Q*DJUNX%MuU=(-6LR!U1qi-2NEy^^ER7;
z=~U*UzE7Ki$uO}gn23!1kSP<d6BuV<0xyEIHVg9`p7?1NW|NqOd6?*3GYhi=IINqD
zWX!Z#m}{7QgGG@{WfZnlv5A;$;`47NVjc!vUP!2UH$0X;7bAmK<q|#@<G+Emi6R%k
zfZYP~rKy<|9!%pwZ7#;y7FI@cF?PDK`Dima#!=Os(8V}oI~uh>v?J6^ZRFJ3#HVmp
zytcbpjcutNLaZ${rmVazeR)eHU!ll%G2YmgenZGFtpt*u2A1NwP%6fMzqAnl@iegD
zUF~UL44;=6y3jZmlfyFldLyldLba|^sC=KXP`4tdUZ~@6BD_%dK%9t!7>N)oR0d_`
zg}QWeB;N-jU+XG`YRU@rC6H98Qd}2GpW?q?`X~OQP;1}O3iSk^_n7}An^~Z_m^Vhl
z9b+zL0g#~_o_q&S#$3z{!~!&*f%LhUu>?&8G$3W+7Vf|lYR7ZBcuvg4^aD%eylo*f
z9W|EH*<4IJWYOJsGk`*;;bDNZvaB{=5y&Z0G*VP|j9kvAW6XPKHfE2!lg$OaO{A>{
zpM>OQdwE`C>{?Tk_O?NRF)^=T^YL~dLeGJ&ytnLPi?R@=bK;0V8J#qigQaL`1<;0x
z8_z0zp5P(u;}4DHB29yB@d=ozfSW=t9z9k>k4CgP)QLxTWYM;w<~&$W3)*<FxfV3>
zU>z;^8yqN`fZ3VIn*IOI1kC&7tgo4XG1r45V~=Pm(lMV>Z35<K!hbUXlSw=b6EF{A
z0w(({nt=JU>IBT7)>RbSWTmdy`gl*kC3k9%O!@@OD+>8qJ^}Nmn1HdsQCFRS`Rk^L
z$^7~z^6!L=<U95wT1>!P<6)k!W%Mw=7Z@AkD&*7~<6U+1#`q;x79x!?fDmhp>nSU5
zj8hHyT8ezn0~zV9pFzkk^(NWqI2?3@u<n!w^f;_KIwG34{Aj#~0ChA$ar{y|p)nLh
zAUSl1mix5{n6s_W)V|;mn1I<zGZfMfh}0)wz9hhVhz>}lxCJv)XgPv4c&7!DQ6b0j
zjS5+Uyt+c%@M2uX&9#jRDM5%S<Soj|6>^UuUxLWD0LX|!@(}V%-AFokr&hQwl$znc
zUrNG%c&7%dH1G5?c60Ixn9pFm=mfK{2dB#93${>dlP{CQn5VoY-?6tP=+flNcH9J8
zVk>_Ly9`W<wQMDGKqZCn5?%YLu6AboS=-a}_>Sh^TGpP|s?5FoCFWkV(cTCP6kyxp
zhkN<xaVj()_~(L^uC2zgy0(g8aBSfJB!jYnf0_Y#7KXv~nhT_1?q$kP^l%wV1<7|r
z)5TVVJ?|vvJh)FW_wxG+R-#~L49!~rgpOCAd--}0k7RQ%xzAF^ug$$oAWAt&AMwnq
zlOs*(RYbA#FHpShHdZ^uh~l#?oj7gw&}l1b!NoZRmzzI_=3eS@s`qfJqYP9tiRu|P
z_i`Jefu+5Yz8#*9m@wmOs5c{?&Ac>{FJdLWvaWhNpLeO9?5QR1_3iMUme10x%h|mb
z>=k)!H+%|idP_3H%+Qir32h$y2qSpwS8w2<u1p@XOUIS9psvfYv86uiviKN1<zC|_
zrbii@#pm;l&0;<>>lNJ%X3VSaEwTzRs(%$B)+~xCD{mGVhI|)M**xELAS2D<0faE?
z()cx+bxDNu3N6*9#6fJa@_y(jO}bPzry>7Q{O5Gi5Q~Q%gi*1M?_MXXX!aF?+N8@Y
z;&a_emv?~ICS9)4MUL61i!Jkvx_B52bX~L&WqK*vsEdCf#B@<aS-CFkhJ2^sf_NEn
zfQ;y3EJBJS8pvqJ#b$arM`FvpU-}JUebVJP-HS<=Yz&6Qq|5%-SmXG70B;9k(q-d7
ztzl@BE_@k&B?#$*kY&ipCSAJ3vo^2@;Tk4gek<a(kJo3}O8$5QiBX*SAiV8ClP=%b
zo-T(Y-td{hY#$|`s5%}J8fdeIn`5;H%p+klEmCSv=V_0LDlj}?zKIIvYHSMQjhJF0
zLY23|7$nLD^&9fc6nTQE<cR8zAmo=8HHBgoM*%LJ@PR`Z{*Q6V!DwmDtC9H@Z9niv
zq{8&>LkhT!K`v%`SA!Qo&1LSCfds$QlM$6t5r|B;bf!Fo+ZtA%-Ovs<B<}L2H0;@s
z*QMhB!lk$2KOEGhN2y3rZaD)-r*2B8NV!+QM>o{zvBMUJgF79bLDM(|4D&f^z}spA
z&A4w&BAA-e2)2ugI0lpBMSb}LVqjeko$0SFsEk=nFXui2l)e?hn#*AI6efinrL1FO
zDRw5zY7=&POC6d(vG~KYTUXrrrFIk%kXpRL`#istfC#f+isKgxztl!@GW`DqyrfZ(
zYRWg6@@ioo4_8F~gh(X;?`*(B?%8`mmR`hzp2F0nFxByLo&1r`av&v|YzyCn4Ec_g
zjj8?kt|GvuH58W2;Sc<6HrclL2wzxA3*@D9$o3A<0=eN}vG%Yrp5ZlEYW^mw9+RzT
zbxkA_K~h^^pM`9?_c(!S;w0_`iHP}*La1_LzT;{mNa?)?mgOK3m>rAb&)yZ8lOy~+
zT{LGCZ(x%zkbhmp3v^;R{xpTuq<0u?oIk-%Kc#a}Rq2JfRJ-(t7uiWfW~F?WPK|G%
z6rSuVf9;fa2c&)^H2yIEG!VCbDV-t$QqPz5ioOLAsOXmb(u7}{Bbh4N_E-%SeF@7*
zRVsSzGQ8IJJ=a~Z5~tt%U|aYCnC3fnHe@w>3ISHL`X2wqcn8(CWh<-EPN!$%5Z0U{
zgOz!|U?00U>~IV$mDBtJ6_!ziwa``7>12Wq%ZHZo7VvsqHW7IjBky3v^NWdZdRT~H
z<@kI@HxkTyCn|FWxL0#ZKcWgb=MkK<sL1{X9-jzQC!it~*@lJw{dV%glXzd2?SuNp
zW!MMx_FVLz+CHe)9*H#mVkT!zjsH=g^v0hwnZat>2etMJ8JKirA&tViid{wVUA0Y6
zakeMz7$0FuzZ7<e=Rq_xZGMfu`Op!+Kk>ujw+XK=)cErw4J<Nd(J=YH+`q&X{vB;z
zY5>1zoIHz0m`$FY#26Zzmztpn@LWAnZn1|cQ>m?QUScnmDs1yohKbFd?ZUfoeD-WT
zB<Gx_gHwTHXk+xQ`8da<=oO@}txQXCgL$;od@Ivj+8nIUqp___JbPDUufC7T_as!S
z&7chf6`DcYDrV5S5T$Eo&~5<^UadZ3W8BBY+3cvgiRmWd@NeeMzTuUy430#fHKVOi
zm9Ozxvs4%eW)E6m@I9(gJUU8g=(0Lu)X@)7A^sMTREs0A(L+i?YYENcgn#$)si&z3
z`lVkJX|92`Kk!GS7c9J#N)N12*KlMf&ONe~)XjH%gnZCCHQ0Q|3KsCaj{xLpj*f&4
zphjToed+UT0QHnZf4W!*kgbF^Eza&!Wehb_k%}6|TO8rXahUEzcMdicO0$q#A5cAj
z#L6Ks?L$#)K-C**Y(QnVm6Wj?%r;A}!{gDjg!d*zN)hBRxFT|`4dfakQAw(g|Ei^d
zgY|{2H<TKB^yisFcO;<M@w(jkCTgJ}pXmAiITXtr2;O(mY%(|7bt7m=e*C8q2}Jx9
z$=GihwNP4$JHPZq18A#;@d-N$6DObgrEx&OjgRG*`;aTyFU`UQ&VDioLu;BCvoVE=
z0mq$4qpiCKFTgEC&X%mQo}>AvlyrlCit$1c%|DrDMf}s*hslrD<e$EuY4A@w7_27$
zRF4F~=0mwOlWljDdKNKHm8r&e&9~oZd-6Ug7yC7#9!%awoRh7E=`DoE;nxUeIF76o
z$eMm{A$}zqoH6ZJ;H&=z0%QE4>K|rXmjAbW+A8vCCa^a8w6kErd|E>ghEK~ZWIpYF
z=;}Z7X&2^@q0)-LDv;t9)*GCd4|^6-@L`{FAGU5Ps;mYd7GHx8D|;g1!?Hl7st<dJ
zC|%>jS_20kHk7fs)`zXC>cg^$!@u!iUr{Au{TlYA`><^0!_d#$pfIIgxLmHsXKp_n
zM>3)9IwVH9wo`GLEVAplEAE_bAo6%RrNb~;LX7PC2nn>ObpT5+`CU<ATZoyBYW)ah
zFcQB*5P!RX#I8=f)%A#n`Z7%s@x)LxD^9afM7#kc$9^)}-S%fTVXzs-F}Mox#SpL#
z(zi1j2Fag7LU(9-5fU<$_|{CGktTBD^}^Kr&_3WaTy^mn)PQ=Y{CQE~MmAp|wHK0o
zo=JO<x>6Dj7nORaYB;8Y%4}$N?UbqtxSh$E3WxDlJ}ID<rrqZuiXD7g>N2tfXm=wL
zVv!JJFZo0GS{PASObcE0X!-b>2P|>&GY(`x$!-OEoVw8(0&6z?0Nj;RNo*Z1cgonz
z%M|z7eVXE=@++_qlk8f2B{K)9Xs3)VtJF9Izk;{QpVI)Xq#Lh;f+?gYeGly1-)ZE=
zw#=r(6YImrgMaEi`wj-s;e!y$P<pg>ssqBbtD24%b8Z4*?Vv}DvS0Wc^wp$a9VB5C
z&dqRH=rL~4gHUT?0Y)j>DGM<=uNi{Z@pD3$&*2Moz%T*WP5@Qfd@nPte#*$#uGB!V
zg}^V35RCgPLh$Mzdg(k2pqFk6LeB8^%<#4h`=2&nPdq}gj-l!)2-;%@-mB?_$GaH3
zXn-C2(o=bGUu4Qj>Alcd<V4W|W<UG97>md1Tu&OJ^R8~FY|8^KxmM*(v>xcRS9lVg
z;Zk=_KeoA>W%2$}c_>f|?6qT%ILk=S#NR!`o0kXs(42w(;+b?*j%EEEKSUvAb2@vZ
zo_;>s6dd^*m7keF%9~CW|Hwtery(BV)46e=qe}fQun#<7zoj0Ns>eK{$F$O8ChIY6
zr&BKOgLemsVp6OfYM`gLln>F3`D^Li9m#lQC%7Fe(HwsK4a_F7GxT_chs$jx<^Cdx
z4vaA6UkZCq;~8Zaics}cw!^_cK*Ha@tJzH-Z5a{kPw!@SLy!2##UIG=D4BVcm*4Q-
z5zFC34!mgeom=f6<9GH$rZTs^%vKag!`VKk{po`_8N^iZn0_M>Q|`8x+ls!>F!u}0
zZY|~^5%VRF8Q?*T-)%p~#HoZhXx%?Q6wURZz4YFdNtBH)y;&w|!}yj_l9qJ+B0fUH
zgK9-Qe1?=lMf}b!<HIf}Vm~S(7vH4`s}&Ii%Ftq{h(dSG7ZBl;8$q9&3`R){7~yR5
z^~HJn0kq0$;tXfG##a%CbjQUx+?#7$(;dV)qQ#KzggC<{6X6s$=nHYqpQdvDD{<zg
z#NZie6`7Gyt(#fKmMF(f__fBb4SqM{*B-wP_;tju6MmiX>w;e|{L=7q;MWJgzWAl%
zcOQNvz&QNo;g?6Xxb;I#NUeg0F?O6Zl3lQUqcmMba$m~5s%s3_xR$#fB}apHEPiqL
z#p7qiFPYGfbgzp3=@jXtM(7lHUnAf33`!bki(fnZ^wLx5#^QGme)kfW->~1`m~}p7
zEu^U`Gl^FCF1stFi6(^J;}?36LFfa1p|1rXw1!{S^2<m3@=t#Gm|xcMO9{Ww+1$uS
zegc=z_+=Bn(3@n4q~#i1O8JG>9})VTUv}}!7yPoDU+B#gK)&afANb`Uzff<6B1_G?
z#o%;fx=Tcb;Ewe~S=j%C1T2g&7v=QhkSo05WhNhW%IQy!HQ`?z{j<`)Wct^R{&l2(
zz3E?P`gbq=n{V<DjKwbwKP!I8__f8aGk#<7dkhvYJ%>S&pN#{vCSn~DbEOcFn!<b<
zEy-m}j)jS}7A7(w&T7fl`;e^mb1rnnji;tocq!I<_9Nu8X0U`oNO-VnLPwS`0tvHt
zLX4K<>j@T<+HX7(oK<sdWC;%<VNlhC*IB|WB#aQGP?owdR=)|8htk<e_|6i$>q+Bf
z8LN2iHdIV%@fF@b{R7Y{2PETJE(MPS-1boBb_igg*a}W5_#~cJNI$<}>_eT_<Ok>+
zKHN;f836$k^?}S}k!|K#>Ia(DnNJ!!92~-P&Vy0wGe(Xxv&qlZf&@4+yCVanyab<P
z=(84~{RHdryg~HzyjGeMf1>_AsLRo^<YOM0y+@->SE|zAkWB=d{;p4C^3Ly#xA79H
zG!)rPF?iI7E;|ypf$kjiFRuf;*DKu(CY80r<)}_iJu|lHHbFL}7P8nY9uK1MV{)N|
z7<p&eG1@SfL7@cIBCGKbG3jm!#%+8cH#b+VIR9(er6_EmzR&{iXp{lmnq_5gnHF5!
zim9)>1{=Q~a(@DcS{Sq)PN|eCVTerA=Ws*A9qBiUiBX-=IPyEQtn31M{G>99i<&Gw
zj5-^>l}tA25Q|bR>3c6Aw1$Psj$+rx4tD_to+dVUNO0TwSGZ+s2CHkykJd+{n}T1F
zj`M_ex$Qe`g%vc2k&{{yrU0+=^flQQJj>!L+<SxQrf1T#&G)FW{5iET?p=no4cK`t
zRw^HXSA`|bsnmxcw?0RwNU)EkxD`hQ9-?SsJq}i6I2-D*qm+xkQ*AssN-PTA4M3H%
zDDIe;<K-_>&zv<Gr(w{G)YFn@;T#5fk$Qa2L-@23y+_SItwcvrc#>!0-Tec&o8ZmC
z-9frb&c&PkM{qZNYO-e5{Eh3!PH>6vd|-6Y4<cH({-5Ej$?S(Cu7;y3`sz@es6ekP
zx6>%<FW_t4P(vMt_Vl7g@#=B2X~SaDD)UJgQK^ob(LlIeA6bH#o>m*^B?SGw;mMRy
zbwmlwXTZ3Xq`SzM;X7<O<O`?`ufZMOR#&CNx5J83%T7eObHc$(;0M=>=u$+x<y3qU
z%-bGA;Ii&C1diD_M6WI|83JCxHOR3Ab#DqzpuB2I_wi`1wcI%sFu<|n;1=Yxoj3`Y
zw&tekJjZr3@LV8xrXkwEb4U$5zdH$@X@ck3Ul`9V;G^?AkzIvn#r;}216_$H6*5UM
zT#Yyb!-Kb8TgXYo@N=-?g?yYd9BN=VyDGymI>TJXP*d#dl#eNPU{#)zYT)??+Dvea
z;8}<B{2qMtLPk~Pc^N!~_xoVHR^m>l@wkARMe`2_lZ60v5p5{+iEh^xdKL+=|7X3>
zPvH(VdzV3g0?d*bYIe3!fQiPy3}fH{V_-An5JG1dQ-&kpH#LXFv^Pd~GX|#IV<>U}
z(<e%5nCv!ntiiN8kl;+~jSy`p^trCr7CH}YCV2EGz0gZ>heA(4L3OP!y0=Q9AC7Rn
zG#y<N85fSEwgf+>tc>mVh&Ql(tOmBViS2`eZFA1{6j<qOld7_P0yMeauwN6s74r<L
z)aCAoLLB=sor2lE4{^Z<F{0^^<5?((9CaQ~aY;q&7Rve%H#(`l8mWL}*Y3z!vqL-#
zURvqPUC-A)2v>*W9ne1v^LpTDx8ZJjZZdtH4tFyrPDI=;+|8Onr(Nv9-NfWhIQVNH
z?zsEZd}7iu()KlnN?8!Cd)dw*((2*hujm1I9CL@yqmv6Bq;A95UpSRMT+sFqv<3+u
z;u21tkc_i8NJ0om2fE-60t))%t{>I;!B5jUK{NC)tYagd!YOXF9!H1fsE%li&Vp`|
zNtJHGB$AR^z{WucUa6!;NiFheN@rGb5OD@88Aaz5Rr9q+(K!TN$idyvg(E~eB``K(
zC1>ugVw}aGsgJ#+6`0Cl&VCx>UUnjy1h5JL23HkeAKs~`F2FbvU@O>i0UqH33@`{V
zt*QWBbe_k5)l2*`Wnv}Xi8w=vb829C23|UNhhSKXGyDcj^mg(0T~$i_G-wKcvKH=v
zm3SHBu6f}mLV&qd1vu96+7eGA0rno&OYFlPR6f!mz&wKh+}hR*Hk&rnkOoGu8Tona
zC5%5Yew`nL?9xwjX%wp@9mW;*FaeQr!sa?W&$A+rA9<9d5)Qfz9zae|l2-FzYZgR9
zejee?HlB4190zB2{{S=Ih<S`-58Ojpfqlq;?Jn5#WY}RGI|F57*uDm=O<>~~_9l+)
zp<^2uu$Aa!xD1CfNQU!sSQ+DW><NT*c>@Cb5yO7YvHPG?Cc~!&><WQhz_71Y!#-oc
zQV-2#xSL^TaqN3K-5djUtiX0=*nu4D(XqD~u(t_p6vH;**eo4e$AE1hu=`!4hck~b
zJ)FE#E8Ag&bv>L%AI0T;mtnVZ>_Hv-PXqRAfz4ys=Q(zzj(yUA{ZL@<VAzK^c8QK1
zYry_PU~gvFz8pJ2$96Gb9}(C~{i$pXIM$=raWr8ybH0o=!^^gtVNc*05H=rNjy{@f
z@>_&;Jv@)L$+2%R?57-ia0Z$SVOJAYqx;e!9Xp$0pW)b!)b|tiaRc2if6}po7&eDv
zSKh2)M;NfH1-3cE-o~+Wj%xLGivjzLz@F<zdZ@#(9d$ii_D0G!OJH%L4zP!j20hFe
zpvmy10Xs}!Uu4*Sa;)b8O%E#!*bV|ajbWeU*oHrA@;+j~))rVyRYHcb96Ro1O@_e+
zY~?XsXE!ix7mn>QTBF;7uv%SwDX_mfiEcE<F8oQu{_crjR}1WBhW!?4&_h<M7+%K#
z1NKRQeU@QYb8K6k?n?%2j=<(J?Bg73(y`MG*uDbWi(yA_>}O*%dHWl%O$4?s!`{NN
z6Gmy+8wsoV-|$ggXUEcMY}95!%NVS-|1k@n$&hgnjhYm~t&Tn_&>u5&Cl~l*ZJwd=
z!W7o#4d_n=dI3YH+&>YM64Ek;#*<aj(+2Q!0(=((J0utSLg^s}rjg)y1NdP9?g+4g
zJvCG#N&E523#}?7r5Lb71lGi`jTqLtn_35^@seT<*lq&5uP@O(HIvc3^$@T`_eX?v
zT_g$Y+YDRAu+~BSAp_A}YrtMSqHB2`!!G4?XCKq(`V81_1a>&XPUdtMkQEc%yA0U1
z0^6El9h`0+jq6F?P6q5!fxXa&%2tol9ZFcDYc^mX7T8@3`^&>j56AD&^!p9Mx*kRe
z>}w3WfnlvBgeAJ~7_i+0*2AzWr+d0NS`x`S-+)aLSU1Ct=X5s{mgwGYz+OD8>$fSx
zrf|BA@6zOLW59kRuxA~lhgeQGZ=|N*i*Vg~+13i|HirEXX<%J4RHOTa0lQRSmoe;G
zhPB>*Sfl&80XtV<r!cIK)2*xP!E3<YE3oMddl#pBj%<?jkZHg=1vZgkJ8`<_hG_CO
zGho{YY!JKF6v@o#HplT=jP7qR3|$Yg0{a=meuFfyep9Er-GDuHNUw`xhJA-&t+~3q
zFBq_U1$F|%&gXO&Jg3P!)qs6pU{e|Pc1|}=r|UFe7Yl4W!?xjcFJ)<TlML9Y0(+!4
z>EYruDw}mbVM)IsgmpdKF0dan>=z81^y?(8y=^jJQv`M)!@kbx)}5lYx5Wl*BZ0k#
zVZEF#!&1ALXu$scqpshs44cX6{`!zc*KWWb6<7<yHsf^52}^XX2JCi$J<yBv@Y__T
zhZl9aM-kTb@Q%Q~$FSQOHfg3#cbx&N3T!^ZzQE}Y(&@?u?85>(lCVir8CGgVSQ;VS
zYru{Y*tQJo<k(9OYS?ZDtX*KQ*okfu$KI`DB?GpZ!0ut#5GoA4{jECoJA`#Tm<4tv
z!*1f(I34@G0sG5Az24?9>|%~RHd&Lmz<}K$uvrW{kz+UN*ii=T`vRNHuy&4pR>!t8
zU>6JQAE~4VE5|;lWB-Pt^|E;dwt``gA`N=zr(^dTuy+aU%M81YV;k$(RR*j>U}rF_
z%(3UF4N)D>HDFr`tczjq<=EXic8CEh32Z}#?Z&Zh>e!YBZ0HBQE>7M?dXP9aPsjd=
z3e@%Rg}|0F>~~0m9!Bff9R}=LfnCC|?{jQt9lP9sT`I7X7`A|8Yw6gB4cNH?o5rxC
zIQEb}y3R0Q?-kethHb~OB|5f|0qYdlpL>!X{ziqNY)|XhQwZyNXd|%e8Fnwn=IYoo
z12$G*7cuNAj_s#omm09AzSrww9K+7#*sJ7!$sQ&fusZ~{2g45G*r$@Tk+{QvT_vzF
z4BL`pn-^<z>lv^G0(&rp^zbJt0eZMQ3w<of@C(Aa9_|&`H4M9hW8(&C*bN4(U0{nC
zb~(rXnyFz`1GbsK-pQ~JbL>VPJKlgb3v5S*&EVLlbZm+N`^$H_eoYM9h+{`L<a&_4
zpmBBsd3alNdZA&suSZ3;P8*DoeLZ<N^kDU8u;}3(X{(t$ysH!E70APTIF%dZ;aH5Z
ze(){Frr|z{#`wsWj{9>H_`M7F@47h+H|}55?z0G!i02L9XW;&rcJIM`++dC$j{8>o
zIeqM<vcCBhzrPdrhi>B-tQ=c&HF?K5l^f;Z6A%;ph9Qg3vY969T28!}9~o!;NK3uI
zQ@<oF)RT*^@L<Ddc+f;^hpKfGPaRH*S<W*KPsII?Di;82oz?;^z9H@xYj~W4VO6#J
zrnoN~#}ra*;bfyU{mem9EA4(B?wj-b;(RVl11(s@gE3lgArJnY!)Y$!!E;)$n1XUS
ztoUb&G09IXVF2knEx3#aM{B{CdGN_hl*lCan}Uqp>!WILKMD7Bo{r4ZOP2=f0Y3H7
z=QwFe3M2ZO7oUDbWR>?}UWb7IT*59%AO1oM<~XjG?dbV4AianPh+=XFr04ZptotPq
zmG!h@S9mEpFV^rP)qJ1=(jywyFL`i>{Q=YXWfENi(u7I+8$IK3mmH90g?I!cd9S{{
zGJ)yO9K`cNy{^*q=hDxxmY_HNH}>mIX&p99;vIn$pfS7p?r0QA`@ENrGH9Rox`C3l
z&wDXK+ULEl1}UDsiGkA(oHz>RWF#i?d9QCHk^1MoxM=DoU5?_;`dvG0fk9!m)Qi!U
zSrGU@1On1iAVzu(NJZKmr_~u-U;quEx#iD^F?k2ESCI^FI!6a+2Dw>oKTKQmuUzHe
zqaXUlgD*eV1<2R|oT7gv%7IWonmQiZr^>|nSBya%*4&>$46(BL$YiUtTjFQz&N~G=
z*EbP%;{?0?SnAj0=>RUeJbeXVT?A0yK%uz+EMWj$;6)Tt9f#3Ewfct+NQZ++F|=3U
zs~V&|zMV;%8IksbeGzFt+Nmq2tq?|<I}*)NY;b*5KqLXNK5C#bO#ptTieNP$UBo`#
z2#v7<QYIkQ0R|fF1>iLX(967xRc+GeX!H4x#-c)&B$9!Ak{yc|Pg&`AjbOe*8h)G%
zT`C~HCRxfrFu*JwFyyUm^314Sk)Lm4s_C3AD)Q5>BdU2G_QCaRjmX>z{fu6bvjyNJ
zS%fgGpAiZz=hD?D!LMscgSY_i_Z0%%Z4lrFL4OgW&%O)yx+@~UpQsNm;X@HXTLXoC
z0x+nGg#8d=rP$0(-!T|eIi>a=kWQorp+=X24p$nEo{+4|b4{~bw3VsvOdlcr$6rO%
zcc<XJn=DXh$B$6J_c2@$RgCt%1S}*XV)C>ZwBrPKIHVs3_E+F;%EaVb{JvcT*Vijw
z!Tc4iANFFFea)vC+96tpeoYpOrA-^+vQ(A0I$1f{;pYYw=r1--IYLIYjyxpF-VvPi
z_ZRlwVm1|Sq6Cw-0n!@oM&GTSF#XD625*CoBp;s<EyA9mYrMvN<xE>;4$_ux-W$jO
zxXUWu8_``;7#y#TXBj|;KZTIOWZ<Hc201S6^=m(#cd|?nA7LQA1(nY;rBor_sY<8?
zg>YUrX41KDIaEWLo+1uvvr}op0`AxoDaB~PXcw~-spW9;D;=z>j#20GSc2Y=90It4
zfLtF94V2;q;0aFYrC#J+I#{!-QTiSA%*%FHgwmleBQli>Kq>?1n(fNzK0b^)lW3x=
zN<D}ToXLfwESQ1D&zeG3bx%@I$`tW)Z=r}-gZM)P)2(C#qV_*UsB#SWoOBW4n!2{O
zoUjrhe85neKTt`$xDQq#d_S`__N5SRE*x~ryUb(eF>caz?6hPHD@r5AQCCkrMxHsK
z83z6y!T(ogYdZWGLip?j+DdghUGmDccIqOIywbZHh~FrPt5t~ms)Qb)kSe{4mU?|V
zJqAAqJI&}Ns^{G=A~x{>>Ygj8H77QA2)EO}4_CF*r2=@Fs)dU@!$4_*0DRBtP5PaN
z|FF|fs!<v&fNLX^dKxG-7Jy;~&^5b|)BQG!+v!-Mt4fQA4eWF{4=(S=m2s`h{tm-3
zC?d@+6cI8oU4>faifB@WX#>WzS?*o2mV8Gx{=;;#(Q`!HI7Xr5Td@Om3k~5ok^LLV
zV=_-~WABD)TlnDYu^VL6wDI@zeJybD+P;?Q$<t@>T_Y2x(FeF_*NE3codWG^;hn+(
z-0@D~Anr6z&vz8IW2Sq}r>YtvTJI3b$&k?@T!lq!z`VD%zmM<#6U9F=h57SQPSRsb
zlc$-oj*4M0X<kDAOV}saq)H-ns627rCL+>o&u!3k4(sr6(9hO{;7eqTIb2@>*VhTi
zKo(rl6FAlSI+>uHwI`vnKO(<Q*Cc3a;JumNtl>N|NPxy#8nHH{UHOa^qL`7O(cx?W
zsynWVPnkh<AR)OuU%=>7cg#yr@tjc{gvQca_8@wUcr3w*m)CUA;{x;xSr@0W(?DgY
z0Bi%m`A}l(2`K0y_*V9T(DQb=jB@Gpx(N8v2)(Ba^sb^lxl|qiAeGt!d(f&$6%wFf
z5h_^*D(eNHvq7r;_UlOXf`ErV6Q#5m=uHxULkys|*!>j3cL(}XP1Z*>tjFHy>eb*x
zQ-Q6lOrdJfbG{s5v;xCpT|Z$|1uwq03ZtnARi_);AY@%=An}<XajW1V4YZKg)49AO
zAT|N9-eaIKM*vQf4MF`IOzHZ5S~X>|NdA%~>xBv+R9(vc5h<e#9BvRK7HJ%y$2NK7
zQFSS!1!S^-SW7T&)&XCkZn?7D8ejwVVvFRhBDoz))}?HTP<1Jn<Jn%bZjXV(3_;>J
zRU$Kg>GM>hl=lkARspdl7-)19fHyS229wyEjPnviav@9BrF;yb>QbKnL>Iz(9D`q7
z4?9tbTo36&1gTLKDL)aAW&&b;&_H8>09?^3Y(qX=j?Ur{k^Cb|)}{Ogq3TlJ9+8rs
z6Lb=-1&J4hNl4RKAF4y@3CJS?V%>)EvJN<cs^cXctpPTWi`A3&isai^vMyy8gsMxq
zx<u%5r-4JBAn}JV3F&B0V~sx~AbSPG+T1{+mjJBM02|PFgp?gb@?w^(ODQ8%T}mk;
zWtxG*0aPN_!%!iDw6z=$Eu!^o7myADVx5Drwyvxt0uUzv(ueT25gG*oa)Q;VF6m)}
zs!KX{ozUmI1}>ciiIu`Eq;^##Z6Y8A0%E1-N?p=lQGL9$;{-r5SCRBv0dX*hE@=uv
z)g@i~v5>T(LDC{Y;*zFxI*SqY2IrkZ_Q*x}F;XM#4KfZ8fX@U#D!`W|BiigPATKb8
zF5_Z^s>^7N$hgSB<p^p@v;PQ}?o~ALg@AMy5Nke$+j>!67J&K!AbohNQBtx*&gKlO
zRbA2(2vwIf=bu8GmkeBb3KH)L!;t=V8hfFe1Vk1P>wb)lbxF^m^0*k21VHLmMN+av
z4#{8;T~Y@^)g|5Vk&twfLDEHnL{x;!jUA2pm@6QMBlXhJAgNmbHVc6C0A9?9)IM1v
zm-HnD(Ix!{Le(X;MI<%q;~46Tlen`AiQzSn*tJ#^wgWipDt%RuNUB1D*&F6PHsQ<=
zn&gPXa1!IV&pJoW5P1*BJJx)L$a6sHyQY(T42IYHQ$EL8c1kU5V&ETqQ+ftJCtFda
zN4wxHyYxYL^Y(10?N&CBeSk%cK-4+6I-qvwCLTSUMbkUFXG5)cl!HY*$f8>EsP-&s
zmRZkrX&@%`8U2dTY7RNUqKJNlTfMz@=uIA7+yU=Qq!Y1<Py#;00paGes96G8hoTj!
zE)JK9e3ke)s-S{x^p#b^p>)N?*Zu5#;mLIEycXZ3+8AYP-_^Ub3kJ8^c`d`CIQ=lW
z^p4llb$g(Mt{X8}P3N_Yhk(AYt!NP@QrWpJflRz(f#T)$p*P4bx}#%o_7Tnkd-`r5
z^6lxiC-LIFc7hArime|n#TJVuz#J^vkM50O>_RvF|M**ja_T?Z7H1UBg^y;3xj%Cw
zQt+P0<y%mBIa{;T)^vCvW-X6pM&F?H!p9*Kc`H4QQ&F<yBbm{)&Nr;I;hiu#H^hND
z!{dAuI~Jba|HV--8|Y(qYEw=|ZSw{ZmcP%8PHfG{HRR-81vwljkQr@heZFDnS!6{G
z`<}uTWRG{?WGm+*a0=cF6TD#Y_%wrrNEryy5Y!!=K$N{!M7^iy><`H`Ry~N7Dm5Z>
zbh7h&)7GHnX%)sN`9yh<e(`1_HP1(tn-JMF4Hg!i>O7wvUzy<h!HY#m$<28<<K4=2
z&t4lj!lktNWH+1h$YKS+iNvLO58)}mWZFW*JbVIdOK&`*$`>=EV{u-O@2j~Td#4m3
zi|y4?oQ&o)Zv(G`?b#Vxu>og1@|Y@{$$QQpke%_BiM><q1U8QZdI=!Z0t6}yB)IH;
zk0tD{d=m+M;I#Q%(=KGL?wDu4M-HsncejWq>OK%pcdq^5b9q&*r-^p{v=9r4BfUTu
z0a+>_)+hswt1vlE!=nLQ@==|^Zz6F_B=<o)K<I!{0qDs9dMDGFLhx-k6~rYc!)0lw
zb}*d}{DSFxeS0z*rt=55&S|y>I&aX1%#rE59#r1GcS;g+7*#&G9aDJ>MyRCmCQRez
z$_BktDtAHQWcKX=fx^vn&ZVyJcM-oE9`O45uC<!!d-Baf-@EaMpqKWm4|QF+-xvD6
zx3#g?-69}u1jM@0K;vlvuxJ2-z6(U+395Kjq1Gve+`|RH&j7l<H#0kt_TB`Q8ue{B
zPzUSu(!{pByY;Pt+7KSq4zj1>W?w3drYk;gcYa=f`tnrSG5Bt4Ib!i0P`@QA4wrx{
ziW#{5yr%^Y^T_eD4|Xc`u%wIRdis*B{i^pUD1P4-q`TsVzEh^egv;!^=iTbgDZ}oP
z?uc<K^#hhCsP^zhy~bFGY>r4AK7wOwmD&MIF-!T)dkO>=ff6|vIT)^(bE^~Uz9!SB
z^baoa&XQ=HeN;<HYv>Dm;<z0L@fAI1c$>R$t0lvJ(tCttpi`nua>h0~r)MY6nt?bc
zrddpQ_il4?XMLjWUCOO&Zkw)0ynu)d<%6b8>A><+dADWBzdKPQcticuG{k9b2O#Cs
zR1uzlFa&4~0X!0fsr(8gT7yY-5-!2G8zX^Z5j2u5uOX3H;7^5EuHN&v;nQE?K&U^a
z?ohhu+faEZ-7b`F;TlL5$f&@7l#c!nk*{RQ7ohf^d!ja@ahT{bY=to?bF_8e4fK^g
zWpzwLE?fs)wd(+fYVq0COf_+dGA}BI7gYv6ycO=5s=3)SL{y3Hr+k(i1F9U73y2mO
zFCuS8WM)AinRsXHvS(CyV!{~}p?k&j;{%w1<@xvGEpC+S6L@>}T76G2k-zMax><W;
z|1{p%$2Sw&?X-V8?`8m}5fEmav=`Lniyh+R3+D+VU%*@a?aJ+Y=eOGMqL`jlQ~Ke-
z2qssEM#C98#xRBh+K92vzdoF*A-=d*;gm1p`$kM%nK@;d^7hQKUueX$D1}ZxG7VO<
zuqskgFaMI+o0gfgjao~l+QXy_u=I9XY`*&;P<|h?&4*W$s4X^w>@?iPcYa+;JU;Y0
z0N2(}RIbRslxFk20E=V8LFEamJ$GTSq1(3Qc5G@*ydz8Pu?Gw?Wj5v-tj4D*b1hC~
zc8vYJw;RsLD-702>pJ@uXYV|Vb}lvlV$JFn#1TUZOEEj3DL>5==k?f1Vr`r0M8%az
z?%ku<b3g7UHK6YucpKzjtmCcAbryJ#9UA6xDx<L-NSfUv)`F8HTj5s0Ep^EGed~DZ
zJC(;ZLwk;8@HEgegrIDEp~XkzK~&vnWWpI)ILY26!A6Hvxa0{16qD;LoF_$@y|KB0
zf&>&j)`U@HQ3uMUSdaM8l@x~9$9r*}LY8V_W12x~qFITu_p{_R#mQ1M)`_ISnq!ox
z-u*1|V#A+%kA;pxvv~6zJf&wDwP1WEwmG?TP^y%L%}GT!phBJsr{nWr(sV#Fb4Hr3
z;3zXxPjSeMGj;MWIk1XLV>YTHmy-2_B^1JlCjU~j?U`5623hTtXTqxvR(mAq7BCK+
zd);93-ANK)r1QI5?J?V3c03A04Y0C+l{~W6A1LO<?OHL___{cdZYPZQ=I*4g+Bk+A
z`ZAZx_#m-jgJf2Ga#`BjjE;nZ*NiWADkI~FS_w#i8sx4GR8%}mhWt(@XPmc*W}^Mb
z3T(b@kQ!sDUZHX>es$|ziD+9%t<-YQclnp<U?&B_X>~li(rh*#ZPcnPhuHmev8&dA
zv38QH)ecXi+NnjgQ#nAZn)BO81IDU3)wEjG>;t4q)#T!w2xhC55}y32(Oh%lT#W}N
z7o1GTbCy%Snx#0NJV&QL*LKSp72Qhd)n`<<;>aXvj4v_=C%;0A2dhe<O{_@a|B&%>
zu<2kM?xuRD;{ECh+|8Oe9>-Vg!d=d!<Ox`j!rjCfo=Le_lEQ6rTfc8Vt{87XTr7Xl
zzJxbclCN4`in6e1?HG#1h}M^(exfI9EJHnlIFdm>14E;bYk&p;C8}8r`aUh4@ddP*
z-YIyonqCa=lIxwuU%Srn&`BNi+V!;LTTB`F044TKeLy24(;%e>PS}Bz^jdXz1s9R6
z(6YGGB+h9>>mn|Di;K7qaU1>whMk1L%fj8s#@ngS$f(HdUfUxD-z1XPAG%i=*1#3J
zlurI~REhp^^rV=stgk~I=BGNmb<sA{wYKSb0!HH3e5FgS#5g8X-j-SRGhBDl-Y(1u
z^|O^EraDs-EglKZ*LyQ-)w1@zjk73bQK_dMK8$h)crwchHKPhsrNzk4pLT2|QE9Px
zkJ3}jO>QM6nWQT`jWZtLi{iJ#7y(bL%Y9V4N_=m)lSITQA+(25s{p$RheiGFPnCPL
zR<Wau3O&+{?p^w^5%cCskK#~U^r>k$U=Qc$;n^c;D@&=b^mrmv7b(4)J%w!Z@Hvuq
zapl@S3-clu^trq2Xf*s@MQ2h3PH`M*A?Gn3K$+Mm(r98?7>se7%M>#Xs8w!&3mTai
zW!@t@DGOR4vfv!yh&V5x&D7BLB1ibq;n%1|dB`?Y<lm*nitI~*L`VIX6={uO@|*u<
zMc(qixO*4)ri$%fJZ-bvQd&|T0Te1#iy|+}qe5+~1QJQGRg{9Lpke?)c?k)iP-tl@
z-EOy{g5vXVJU%$bqoM*9g;E~2MNts-h=PjvN(>?*@)GI)yJlujcAAvK`Q3B>pL;JK
zlJ3l&S+i!XHEY(aSu+CzOE6MJot%+9IU^f-QTx*|5VXTh)1@a{EJz~Cr-piIMO$;-
zR{xyPFJP;Oa6L0ydlP8J){mmt3jT|6D3Yy*H-_1oh~XX`j@WuGctq9&_&SLA8tOo=
z7+)Jf;=GJEP>%Sz3x7FZJ3<$j`Ff~l1YcET6ntGkb)E%ZXR}HfKKD1n*HI3-D8ZxB
z1-1)Wg^>GtHd}~;)$}KI$rRQlo!XQ|5a2quy2ZWeTN34SNOs!DI>amk{V}=pWQuRP
z$NR46tzfP7d<;L<{Ct0>Lb`EJ-1{*6C}V39<7a3vz-?(ybV4k%@@o%jKCp4NgvsDU
z-A2VoK>vuW&i@o6qHwsK;e>q*7)flvaHzjy%ouSXdd!FzEr7|(oycV6OzO4#EXEG+
zxG7Wk*pWGY0^%BI?C?#ZA%ljFh#_M-#-bQQ#w|!T^l>`ok))%YV%TajWb{L_OU2|X
z<Fl2d?-QW!147^b7_hNIZ150i?8J@J&xGOc#{8d#hVPIT5tS##8R$?k&frOmGk7w_
z8CIb&!2B3^7Eq``=&(kGguHI5aKK-AgJvOZ-BB7~=qe35=feobyYXuC0OKN%%?>cl
znFTOE)jz=DyMHoqSe%xHaTNW*Gj#^W%&mBu>6?Hdz5!2}cTAyi6i>I0n*vi{C!S`H
zn+fya6FiN(eaZwF0J|w8f)l^MUyFJabK5aEpqeIN=Am}!(^6CfCD>V2<w$0~p}H&K
zR-hq%GRyi384f@V--7gb5~RnIAU&Rl^y(g7-);f>mp~SP5akW|-~<h{HPyG_FP!ox
zo&x2M#Tweb_LwREKJxv~DSs@`9OWIeW|0L0^37y+3sD|%Khr>4B0bUeLrGi9i_x?l
z2*iX5XQu7NNH%Eez>JY-o5r&KFVeQ*$(Xc#3&}=(<IvMc(w{-vy5q5ETkbZ~b~=G<
zR;tYd?r4vCj5M@bw6aijt<aQb*I_7dt-|^wteq8g@o{R&YPVjr139YPx(g@Kxk}yM
zkw{CM)tdBa9L*c$tk?e7MWkBe9hy@CoN8p7f)wP^?Hi$g^Wy#8G*>kYhRL<$#6a>^
zI{XE*p@IuhHP?hs!qyC>>cde=>4oC7Ge^lHIMCUfP?Wp}D0&W62GyN#uBx>|l2e;d
z?P%PNN~Z&;Q{C^Lyo+kltSM@OI}Y<D94M@o)65wMEvZAS_2uNPpnvt{<f5Q|sOqDx
z)CipFT&Q63y~x^;d@0P~1kbST!B>%sd5q}5O~^{dWK2j4b^DVj=FqKu+{-;$Tdf_2
zk<B=f5~dU?ZSc??5C#4bY`_C~7F$*4o5|&kasDh1?h3;EEe^AI>mZDe37&+-grn`P
zLB}Vm6|-o%3#{@uR^{{KQZ2so%1hQ;{2kSj^`W+EF$a_~v7ToJ^BU`%x%Ivzc!x0E
z#_fIk41y;pTfRpiWmPH~r7fYRHNrD89}}?6_0DoegWQjNI7Xd*BC3eJf6xC5)yHq0
zF4SCAn3<Pi9~7n*T1ho$ntvX7bTF_dvLP2aR+i>k{3)d+J1n+k<R^zjt*nY?x$$-d
z-ufcnuE1MJH?9=i*oH9ir<K0L9(Z|2)nfV;OoFFG^RI9G5Jb5sOAO`kL;_#3F0}c{
zsSyp{^&J|_nwmFqJ??`;6);4M^%DU3dn;yKdAwG3-gIexa*D0uuW&6CdJi@g6bRS7
zEPI?ovswqM&X<#$A;|c9n-FB=%F@f55Ts~jRh%Hm$Q5`SNsyuyc>C`Of)@OkX4p3N
z3mHL%d7T%q#(*rz@CER-BDAm_k%+gDWH{Iv;-R_LH`d}T=Sq!{#<gD3(y5^|BUVr5
zQ9)Jnc~u^-({2gFnuU@cZ>>?$Ft7Cj<E1|<IFiAYBnKM(jkmUnfp{6RxxGi-s(-oL
zi`rEe{1uV?6TLlwRm@Zi^iI)o)d_V#ss>!sMlMmEk2c4NFXlGk#Q!eQ1bN0nkFc8u
zMv)V6@%fA!2Hi<CCE)~TIAM{R6DDWn4h&H^Eb;_MV_XKd_XTuoz2MWw4R7T`gQ4?v
zB^6aP!iTz=t7T<xOD4?a`Ag7WuY)GlidLy<b#Ibgzjd@}*_alM9o$HFmmf&?sDFCY
zBW`aJaR%hxo(a^Uz7kSwYx@i;J$<EZ@$2XkgK#@5-bSv~k_!MH63b=yEXC((WQ_Hp
zb*=vwK1SQxqdoM&nl@jm?b#6)+f6CpfcFoaE*S4gxB}h{t{@)(PaC&5a=)}act2<q
z+RHEHrc36<MI0F8JqaZ+Ekuc%P=ejaU0w^0<R^rgb7>bahenimze2Zh)W|Xyp-iwl
z;B)97BCxs{=%+AYhz<Rt^91ySrqIcK6{HnPxA&e@Y9Is<o5*o_%0P+1^OR>L@(8Nv
z!|BG%@Yq(7MT6VK^1118zC;o%|M`GYfC0R8Zkz?Tf_gV&e5^=zs4h#Ra?b0x@~{(2
zn_q!j0uORxUimi+Ov>?9Ev=P%d{@9i`MOYd!Bh4V&@fDW8<rZ-iB5tTZ?`9$aR%RW
ztP?GPka9S~u0$s)-<lpVyEA%4*#Yvws2h5Mac*@@Ci}CjBmL3s?OM{5h;I2qXvc<Z
z_71oF(E|#>%UEv>-1#uVA!=<EpVNrNUiEqlkLAbXY>TJi!L3yiG;Il4FCfC83})<T
ztPU++RcvS=(lg<A=c|=;g<8|q;n5FLqcYxUAy+FqqM2_qEcBeLM~${Vxdh{&ef?_;
zr1BK=;E9_jWT5oXM~vK4kXtN0eghB&xKCw<t62tP>2V1C(lZuxhLx6p74^GOjWc(j
ztzta-N1@(pEQW4JX$i%Q-;c&NZNpNXtnQp+$z+f(pbf`9Oy!J9Z<Ce&>mf4yXQ%U<
z+djlE)TN*<4QEaN`6{k&RDQ!ZtI0Q{X)V1`ivXWv0v{*A&xrs(9lyAkti^?_;KOp5
zyv_4r=L3uc{m=$MxI-(#ZFm~8z=5>^Sk2xaXaZ!(6EXQPP3HcNxXYJ-Zv>tONs45K
zEi8k<hj-X7E~FY0S&hjrulhXnO;oxQCS~*ONapRh3wD;M*llXZCt$SbJE%&tPkDv4
zW6koI?RZh<?i_B%!@%8WN2Sd02bdEMRR0aXoNCwZ47&X#h6{YRrOT;r(J3y<<DfG?
zLNe%qjIH~F`Z;!TQa|5Fvr)ZZr38L^9yL78i!w&A(+CDL*5y<M3^Kq0Mp{pn4L4^}
z&!(F*SyvY~XWmUX>q@DOD=%LbdNipCZ6KmtTGYGtQYQ?xa_j!RoMwxkC7@$>ljUsU
z%M2uIxGt3Ue032`OWZUs`<fRU4xb0==_u;4RZuLDR<f63ty1aHznf=l1br%MZI#DR
zFWxgMvuR4ep+)bKIu8R8I&GOEIsF5sng(lr0>?Pi+aM8I3H$;0$Dr}#gZD>+d|xFl
zvRz%znP5FDVYMSz_RC&oQnT=}m{K!C=KcXDsQ@<u%rsEDR%UpYWiX_F1AcKj5*OHE
zKT}xaB1LCRq9Hn=)~ZtX4^kWJ@f~ah7YG9ENbN_A2y~}fNA+WIW-vJMY6lu32V&kf
zG+uMwhq-P*TbNqs`o&V`ItZE;{erl=0LCOSUX>q$J93XN(N^O+7_#E~7v>6YdW%i@
zfq`mCwd!9jCgnxyyAE8oP<hn$U=?KCt$vJ&C<!KC)W?i`I|iT?LrU`pD7M8}$T9>D
z(E%8qBJOJJh!P%rcH?s`iX$G<l7vsai^g(`Hm@Vi&D@%Q1!wFrh}+fP;sME6qNj-*
z?ozS_;c~HD?R5@-(LHjdh6R+;d6^d9HQLqfa0_-@ZC+<y_IBJB@2GNFLY~rj7g~HB
z@PZ2Pm){1(%bpR*M}8E^_K4&M_VMJ>dFNx;n1uSF*YRar>aqlH#7|qzhzl6<egS_t
ztRJeJmmqVrqLybTlPD_t`KIi?B$1WXVXGvYc8KO1V3jjm@6Rx7_JdyF|Fd@RUrQ%?
zz(p{AkyTKpXeC>)c2$1oZxdPiWn6-a)*(RUT%w25F!Emdnxh<~^-@Qj%Mur)sTS(E
z9CZ|GndS33T6{g5V^txHoTjW|Sg}N6o>u%Y4mB*Uu-28)^f?YD(J8deFo~>iVnJ1w
zpyzNN4ZtN&j0V1rp7Q!EieJ%Ot8-oJDN<v7a0v||<y!|fok^G$<J=w<_7Vh2En4B!
z-lC`)tmyQ3i56ygxR7q2+D_P*;Y9#nnS2k|5iQE;E;ycC%RTzz-2ek1mzdY-(k>ww
z@GWUY)wDFgmg-utI0@1dpz;c*v0Uf)ik1T~t0y9BZ&3^mb*eH>>Ah`v=*%imed%cy
zG3HvWX58~)OEAE-92KkpG)zjb<RlsjH9>w2w){5&x!5c{I1gk6gv10EUgaN%h0GPD
z)y#w8?|~P7s%GRW=FaLx)fBB(lS8zGXp=Aoa2VGht7!?5V`?lTe*OZK=b6`=YLJED
z8pI(bu-47%jm<41E<zd2Ny~d9S3-3zhZcG0Ptwn9ZD|qu3RV*{G%O~PN{C|_riC+%
zLx#MJ8~~xkr;!E%fv3=m&5KX7aPWv}Q85)6#o|*O9?!J+glPe-LrUy^#YJxdyYIME
zy3Zh$@O6fzQguBoC9~_p&zmLl<JSLHGQSm)xg;!^RZKEP@K4%91j8(u#frt(jA*{N
z=S-sM03?d)BGEkYhZN1P{>DUei4e^yDVqPp`iUW$U8|9ci{@f3R(D|w7y|91Me~dF
zuxLI))fl4L)hA&L;V|ArR<<Y#2T*ub^jp3v`ZTSIE?}#o{ZR1CQrfj6!G?TVf<K;7
zO20KNcJF;IN=kz#r5wzL5Ypmk24=-3F|7~hC}v{%AfS+#zKXxRPapX*QcSno3^7#z
zNtu9*LQHSMW3-ss<=QvIl!{0(9Tu+qGcKl4ZWy!jbgLz+NPFUP7pJz7lqXn!1;ZxY
zV=SQVG_Rh{M}(AIJ=Nx)OCCD}5g8u4_fBvl%WF;KUbl3(H?zS^K$D((rfEsbt#X%b
z7TOky&$SZg-|P0p3`D%vALrL9Z?s|pfTh>e?qaEQU}`$V`vfA?C@vg|%c+VWzJ}dw
z9d<TB*4{Am?#sk(oTm;*B;4y!MQ2pu)cQi-t|(N$L3XNrm9aSbDVB3dto=R|d*RP`
zCdKDFO4ny`_1YdjOaN&MfXwRq@Hn8UeUW)Po@lXGS5Breyy16iOUu3>8ejI+=F{&m
z#k|&52AzDV!Q+q@)`t*21gt51=uBFsn_K+@el(BzL6KUI>qxQojcTcpt1-VF0A%R=
zu#wd;>nz$^6i!-sbipXM{&*%HVK44L<Befv-|wQ)mjTSGQ>@XpN^-TzhTAH~<EKUo
zGD>??goEc@)$qXwi;!IB+JVo;xI*3E5VGRQ2np57J5t59{tl=OtL6^PkJ0t(KtI@h
zRjwVO!KLr?AB490I!C<c9p!4sFlEYcsI@U(SHk6p*Nj<Lm6mLT<+h2)rYi^k5G|nV
z&P*+Mj=#Pkl~mAbHagmlK?RMhR@0d+<fu!E)83(2T+FKa0MhdulK(CV#eW-;?Is8x
z92F2kS7B8GO+{1o!+jL!bP(o^=0adsMHa331iu4=-QGhKaR(UBpqx7)8<}})50KHf
ziL#V$?bc*;iMc*peqcBgful?WwlWcz-;#?!H7*0~j|%9pwvp>4`>!|Hul{PV{`=p^
z2+Pm1_;Y~N>XU+Udl>I)n9SQMKVYoKBAe0)6%gy!JJh5g_F5U1ed#;dpc)*(<@na#
zA!Q=i&0E*~Q!+lSS-AE!4`2$7dbo@k^-KUjyj`0@3<6W|JneTP?|LxEO-Q_HbnGpt
z$E`m~3ZzKgSBM7X@tWG9L7~Y~@Xn!aNqB8Y-a3dnAriXE5Ix)|W6r^$?0|5wY+dLr
z6F>t5&yWNOrVN~RP+iL06M}XWf$1nU+Vn6(RN3Dm+@>dwh&F}hNNLLkgv&St|2U(x
zpUziVX)1Y}ELngV6NIfJs7%84DvW+EZ1<6@h0Y5LT7Q&bf_9i=UXHA1vuIm(02e&t
z<}dO{GFx2LtI#70)yh&DTr_15Hi47EQ;Qn<Y=b|7-hyY^GJ0Q!J53F(GaU+Pe{u_}
zOS=dTx~Fjun?oB5?g>>?xsk!ssS-mhulW@kX#>5m_=z-~jtk<FOV_Qjyrt`ecv_L>
zQZI6-V=Y1GJ-lbQXdNBe<0OgdvZn#aspYhO3Ii%!#C+jl1W;nW?E-{2@rXT+12nc;
zNkwq<1^Yw!)ykDfajC!a9RY5gqpeoXMY1%{md&7Ix=yhfZdISeez5>e0Jx3)O52k}
z!$WIeNf0r(#go~LI>Lh+_Jg1m%ZMW6zab<z^Y(wlZ8-QEEOiWnI7j(L>J%2+gYfNu
zs`fd6ueDK^t>D%5JPc`Tq3Yx=#|$9tNq8;!#H3JT$P03!K0;m^c<=ubX2DRfVEIwO
z0>T8y6LMnGVXJ%|X`0S!v>#1`l1R~(QH?10GOp@F|1D$1bS4~ealoYfiI!HHzYcI{
z8%gJi2D`O2BuTuz{|W$v!A^rBPcjkj@A2+M6jwaX(6|mYz|rMN!0pHpusD#10mOp~
zskP2n+1O&lVBvfy;7K>NCZyZerj(vQ&>ij`_NRyXXoIbeyu~zh`Dceh2)x_5oST@4
z2SXgCh^I_#uf^p$tP8S2J)LUK8e|FH3mp}e2jTbgQyh&S5b*t>PY_FqnWR#J{Fu<k
zANP1a0g)c0yAlz1*Lg|sb0RD*EI!An-HuhftzhX4_O^}Ic~S5kymjXFx(vl_50I+i
zfj}bK24W|oZSW+bZSX|VHk!RVwL({Bm9wf4=(CdterOv=P6IDtRYWALVS=k|Ac+ku
zlj(ZSmGi03^Yl4LU-u_kY&b&)GZz_q$q7I5BFGaib@qNB;ym}^m<~+IwBiIZb?<##
zn!3~R7-{Mv%CoJsbU~;Dkb(#`;TK7$RhS*~PGAXMNF7d7hGH{0%<%?yzhs2<?wEsL
zWm`#)oy~|^c3?PZ7j;85;*T8ar--~dwlyODhh1sQ2|i)2&xrq-HV&b3Eb@xQGE?{u
zCp|@8P0PHQ$5)*yYZ?ReW1v4Fh<GQEnNc2#N@N~gh-4!s=M_x$DXj(4C|n3_=C63X
z_VL*)bPj=35ixUnkW7HXfm96edq_3_PZ5AuA#L5YAQ5MywuV|S9m0=f5nYWq=>-J#
zECPPY4vcO|W5+S5-XjD}UxGgvI;!ZGrmWaPaKzo&S|#N{r@%#NlN$$;CP*l_4>`2I
zG;G9+-O!B*Znbg+fzZ3IE+slzv!D$q#jWM@P>(?OJLAYDUC|b8fuQ)}N!H**Tt;<^
zTfxbFQ-!IAzHAjGs>@d5k5-(Ftw#irdIVOSA>ouBc*;-Qf1Jjg^0zG=u^FVA+?@`!
z&S|^m4N7pqs9xySo}ujSvMuDxGwx(ZMxarIDVAPJZ*^sV9AQMhyq8!22|TD6F4<dL
z7@Ha=UuebY=%{J$EhJHgvgp5)B;Yl|1{=+IHP9xs)$85Ri;nWs$qUcLweawi)H#(^
z4(|L)#zo$%VC?_|BRl2+kcd?fNiG4}8iq6gulA9!aEj=D5Jwr#YDP(2kQhklRcHn8
z*WD)*`xw+x+D*^AU^s?Kkj(-_X*Ke1L;-CBk)M})WdPA3;|mMXp`YYT3JYDrSW9H0
zu~uuB?N;0Macj<Om>14IU?LMBx3@LhDwxogu5ahZ#_~Ej`~`ccLNmYJ2?^S8t2#V6
zbdF~4{V4PeU6%RleTEP65Xrixq;H}I8ERuWtWu~A65*z51AB&nyq2ulCjeOPM+@zs
z7TsH>S@M)oNU}XBrktO`aHXX$->}?|7G$k!K^+XD1w!YXB-39nn1#;7@$Pj#TR=`R
z<@pziBhR%mPYdLMOr#vdD2#w6>|s<+9-uw@u@;uT`#C<mi~eJl4ZG-RNmv|KP(#mw
zPH3pyDT~R3yM8l#6P#J6-0DY%Uv(e*2%$Eui!chQ$BYz@?o4iU7g$Oymf6=<(;pbf
zu1oeIXl(&pvU@z3=;_X^M)z{t+V)lL5*%2E_FY<ozF}cUS2orS)~)Bemt$gI+&a#I
z9JmLbHqEvSedp2hI|kmJ8Ap_tA<%(Bb;6-Sb?R}fj%0e&Q|iYK^#iun?@Me9JdWJh
zt$E3A9CEzeQ3q=fDk@N@p@=s1xB%ikT4x;~8tYb1o^sc3l1*jJbT@9R+_qp47Q?WY
z0z>Y|Py)P8*7&N#@)L2sZY1KwkSma^J5J-?<T%?}XJ33-ldABS?pw}%&mS^yK8qUq
z!A^@&LuVwPO$}(Gi7IR=_z42S-Rfz#`dMJn-8ijGcOA(`1i&^zUHv+`&E>)Pw;^+Q
z$@cy{NMk7OeyvWjI^l40l%CAQ2@81dc;^E8F8wnV0ed*F5HiRzymK*<5uh3knGv%X
zuN=&!QKWw39N57>(2?6v($6{Y);NDJ{W{oybq;+{T<+%i8P2LMxto3M)kE0ni`cAx
zIiRRpLo(uWKlK09xXl69Hr6|HH<hf3<}HH%)sy;Q*3=6iWP?f@Q~hm#XM5g|Oon|Z
z9Vv&<FMxR_Lma=4yp?1v9f($Hj0(qMHKgps>4mVaE9ic72X=D8Ik0VEN@$FOWOm#9
zVvl;rrC-<R@opa2IniI>)NhP)<-R}vVyF6r+TgsT;n+?+HCexx#in>aqlTrUVV2w-
zKC5~%^aIMds<JEuP5qqL<$oTXEfy+H-2tN2qMt3ahV1HbeJ=W#+xr<{qMs#JHZBZR
zormbSs?LczHU}=RvnE<XZK@lA|2k@fgFS{C%zbM&qzLopsgNc=`dG<vcMLP=&^yhU
zK{IAj*g1tkPnbBFHgeGu?oH-V(Ee#&oQ_Cl(B$dUD3K!2g*|j&ZnQm=HH}81D0`?a
zk`1%v8T57<4NpvsX%7XEjI9Js?V<OPOn{r%LvJJ506azjUV*fA!$}phHU1{{(4tN>
zU>Nq$Gy;28_7K^i*i|Iv(hl`Am<2S=2~VdVc$;7eo5-o=mN(|x7LOZ_>FaT*BQ|u%
zGfS>P@~cYZXEn0?jve!3aP^q^)25ZhLZ2g$-0PtAXSKFirnbQvEj}~Q#9HiJn1`^X
zOFLLBf8uk?ITp*6=km`@oh+6MF%9}L!(usgp2gDXeAEeDK%Z+avRLAw0LEQnu{_q@
zV!617#j>qu_(M3phKXsvOD&d_{VbN`0T#;@`7oIr7R%_tVcgf?x!n+pWv9zx*>RP{
z^5Ia6<q5aN($ZtGqz$uJ&b!)T>0L-8moayQy+x#RYS`+=Toc+=$!g_#B(aUJb)HQ>
zz<kP>b)2p+Pr#<KM4I-@pUox?uorhCW~v1rdAIE%z-?XHl=fDfHVY8spoI<M%$<^M
z_20yEy*nMb;3jTMZ%XsYt=(`96=aj(iRIN4IUQ%KxCq(-2QXIy3<t)G|1lqv<4Q{9
zSO!mn6_{mEZG4hHvHWcYVs?iZ#n+=aBEJYZ4sT*_LX$NZ&3xb(HIt!+qY>as;4gTJ
zQ$;hPli;P^uv)@v&*4!*Bp_3Y0jNn5xx3$*1@k9cV*pj*WI6$gY0D@x`VW1Z(Ek$e
zoa&FfEq6|%#@XwSQX|@c$b!QDa}2DJpgGf19jdc^YVbN-H7?8Ez{_f^Y+s{nc8af!
z%+eoO9O~B4`(nE>&Msw4#@1-9xNoXjoSho{^DKmmS`r~#?OCN#xVrev!j;6^HU;4w
zVc}wwiy>T-rXp9QaNWf)I+Jh_FkZ>C_lAXwQqM}b!o_bz@d#mPfgnVXo?)wJT>86N
zxZpnFFCvAD<qap1aD|0+U5~J^N+~5kj1S>bv87bG>25Aul-m%lr$I4|@zD^jaC=Je
zPI5nO3KOn7kHiu#hINE+9f7uyWl!G4%JybuV++@3$kIf(I8c*ttpLm@&E@uDKFhZt
zV%_LB!Vb1(YJ%=KlAk(f5^Z77?Ws@_*z>Z;9k;V_pRJ1ps?!41Xt^GrPoNu{e$GWr
z=1+g*b8PI0@6fr9jRY<DD2h2YrqN>+9-X$D6PTZoF6FY6)*ZY;JP5-GlP>0nb9>op
z9wuciF)2f8aZ60fij$Ka<&EuZmGD`kfy)R8&9U{2Q-`I<&^#71_IU7+&#&`$@`|#@
z#aRy9T30ToQrw%1gD3!-sWB=Rncsr^nCAAiEvASPr+O#`eSW~3?P%IJ_?*PYhToL-
zf753a@I^2iXfvA8#-LG9VTtKF5$v#SOaor9=imXf^sw#5$lRYHaiXoa@=<x5<=%MT
zIfrdV$y>rD-#{kKer^R;xpUI-jmgak_?S3@zJ}u<xP-y(`3$eLXG7&SUmA?s-J4E!
zId($b63Wo*d&;T!NBBnZw`K7aD1O-1eT#vA$bHx*;nY^v`fPx+$$<1RL3)@$TFfEM
zkdQ_-fh4R$w1^9jo;C(~nGMGR2FY;+T3G@gc)5KDgOgi$e2&wAWZ_VDd(-*BLm8e!
z5Lw|=AfpfS7EXp<??(tXw1spi1nXd{U^!zdFoujzw5FmLGn3BkjiXTviypuJ0>@GU
zV)3%I;n0d1C#KRUkw7L0BFK3amma1rz*ktjS24d(xQLNgtPv(4FI<G!>B`FvMzEj5
zR`WGhfQ$gn5Cg~7KScX*XdApG$<%yN?1uNyD%?NxJ$Wb)IyV?SIn|es?=;_KGS@Bu
zmn~v`7Y+$76qzRtkb)avxCxVt6dMsqw;w%7B#lSAamQ8gNtR^|^Zh4cnYduUB1lYF
zYcO(k-HbAH`kSQJwkalho#bt9<Y>|A1E~xTuFRq;nahlmi|6}b3{;HM))VuZ#^|{e
z4oSp#{;oT>VRoWZzcVhBij$I<;J~vNKx;VsA++zk2Q>w@iBXHL^kI0R(S|;|jViPC
z1Xp9#)wqqe6{y=$+nkmzeL|xn_Y<eBaKBKn+Ig7naikxBw-s`;?q_mHwrV1$-aTy7
zx@LtQw&DmZC+T5l3JF#qE)@r#edDBU37BJi&7sv`1v*S*55Ez~R+Eo8##cPY1~ZSD
z)I#>$`tW41K!WMkz{JJ+tq_;u@W5cegd;OQ)t8r_<{Kc3JrYqnQIEq$P-+<V_Ie1=
zd|3Zd(ij$?`kDh~0lJZ8d4>s40-TX-WHJ$M#Dzq-UZp7H(TV`g+ymTapxmnqnILj@
z4;J0eg$Pb`S(-Imb!XVHQ@`L;n~#=>ox5mlQ{lo1oX2*$8ygU^z#M)|Evfaq=<B0N
zS(TBBVGjA+TS*-WwIMp$NQ8dCyGe>j67zZT-tuXW=wqG)mxa4FgZY?2iGUqwqWK{Z
zPTk~5NX^1=Q2O8l`3ZBTYB;Y)&$wr@>`xq>l?ZMn9le5$!%_(~+o|TV{ON3=4+Bht
zZE3CTsm<r_gp?6$s^Wvs0c(Bm@A=tt<^h-C3rIQk@-)IRT635qab%K2LIyu{NALs4
zV03DsL*Dp_iGbjRp$moHJazy~P}z3$CAW~j8RQ`xY)cbDnPO(9%}AE<LD$?#6clK}
zmPoZ#S{+R8s1){y+Lp!z4-b-*gb4QK_2Zg1+uCH^ae%QTKVfz&-GK($?hB!<wwhnd
zPs0rQ8qeDGMC5ki_HiN)0ndrZD<g@F3O))(Y8JEpN<%5~?E9`{{{2*ZCt;r*5Dc}!
za|_bir*U%9m6TFMBRs(;rl9eR5RY4e7vN>ASC3+ID_$YDz>3ku_IP~o(3R$7HsiKE
z8W;Q=$<)8*6C;1+4efD<iIIXU;}Bc`zK{NsdX<zX!O#7HSo{=Y+r<>YK<ynw-wQ>1
z$Dv-)-m7?fuceexd=v~k2E9w1=MDagCD@1XWFutYUc5WDb5o#;<a)4e`0W_HW$#!M
ztKx#ku8<`M38-A2o=phu!8<gEs9KkZ&Eh(ryF^aVmO)B(LE=o^RL}V3N8)fE8$0F?
zB!%+(1fm-L=fj(AxFH@V2Lo4XPVFK&2PwLhlKX{cw*D?>n8)S-OIb9Jit6_1tp3>3
zmyXENWctF|Wu6;<Q$QFn@?v`cC`nyZyO$lXqT5?D=xk&pugHQ-(TBCWvAoNs1iS~F
zxEosjF$RhatlF%|_dlTd!P)G+Br@0F8cymFs&hsLbcCMs%nwA-vmF~Tm~OuZI!OIZ
zAVhN%J`nOnHf6$igC7{Z53@BTj`U-Q8YqnAhjr@X8XbBu);GLhxiz6Yke%ORj^a>1
z2?Y>sk1`xU1#LFKI!Gd0DOu35=Hx;WG4XaHy<Ja9@U2qkdZiYm<!jvM5XyR1d?5~K
zPr*yJbYhI^)2@eM%N5@<P{$JB>5UX==SykaQufE7!8VJ3Q{=z`)imyV>VV<JGg;PE
zE9K9a?imYb!LRa~hyYFXv~#h@z?-=n9#N<U1+e+hD`t(je{nx1_01S9EGzbt<5)tr
zgk>09d}qBg8QrM!W@wUDbD>H23=~_$k=lQ=7(aguoVo#nr=Bwl-Bnubmwpc^VWvLE
zt_%G(CbA4APXZfYlNqaJxgnq)dS{m}gpqT(eDfZIV74a&1ik<%^Th!|@b$}ySaLQD
zqX(Vvr*E0w6SnY!EDMh`x`%Zno@*=R68oSrY-2fN&I}MBZBBUXRI10BgjFccgTSxp
z{=-*`i82|jchUmkymT@}AVx&21rQldnIo8NhPS~Tz^_m{xS%68Uin87^@Q1F34WYw
z9v<7qMtIC@6T(R`5H5&;@Sh_X!nf^+LihuWgB;-@5eVlI!X3g0%YlAVG2=K_)|OzG
z2%K--&sbp$=?0Nk`orUzGUB#qBCFp;6WPOY{^y5LIG-bNeh4QLgo(Tuze0#B&8Yqi
zQNy;i-uSv9@p0icK-03$B@SvjHUduWDpFW%ct%KF@VbG~TUs|kApmBUzypiKRKLM+
z9i4>JFChY#KOiDa#bypc;(O{^VHcDEVweO`OLAqHt8~_i?HkZDVs2!=RZuS#R$=&J
zq(lj0K7+wF?yb8cT*>#~C&%+<mciI*Hv+#HBFv6%LZSFR(QJ9+I@yTUsMKggrG)<n
z@l9S-^c(vn34G|XXae6x5cP~L+c~2_;A#Lf0QZ!DpNjzeBz`p|aQiTB?@kPZpmQsD
z+ixWh`UV;b;0&vwc#^=Cl!jQ(7IiF;kVz2B(RAi<>?17b;^3On^$Gz<@lyy0JrU1X
zf56?IHZ&0GdhJZI(D-OPFB#(ruRrT1s@UWbJZWbJ-Nj#%cJH4h=<mj9r8sWJ*d-7h
zuc2p*{EbblNS;OPjhxz(8FX-r>|_YR6P15MBX0NzE$`QajNwx;CM6LQ*i$GX)jRW3
zQZ1OlM$9rNBJ3biD^o5$dy=Gy3m$>XG@|i;wgYrMqx)AR<cL=hgTR^F4xN4D-K_2A
zNhSP7a!z^pX4!T*1L}s&OR}v|Q7&?jc^Z_8Y_D`k0X@cJ?Ca}+hH#P&{gMsN4Ktz;
zf@O65mtd-JPZ3XUGUFu-`X$5zJtOI3uCVNNL+qyRC>=qo1|kNd%4?TRFq{e6Xsd0l
zB|l|>C%+{&%h>-hog9WM@C}FIuW-h3Jf|~0vSmG*-|F_Yd!=F_hVxvr$6(zIJIvOw
z)d1n;_-QPiI7W+1G{oUrKk-CYrsC1Tib4Repi5s|jpzkm%DQuyr=KlT8OuYua`f>e
z9PqQ`6tDPUI7`dff}O=*2>Nr*!ds`?)53^qg%q}>w7rS3SF_hlqqeTbccEr&P(R1J
zzl_FmhEVUF;Oybcf<iX2p~UE?alt$K8ayoDL!x1HRgO@>&6FlAE$*M!?ThxX!A+9f
zW~(`FWEX@ZiWr9E>tiAbM?@tGfpGNL9O3?XyTP<mlgXqo2*;K_bY;V1X2Ole77T-M
z-8B0@rxHb;!*?O#PyvV$<^CJOL`j4rr+K1W-^U=zv@b}obAACRK^wPs2s0ibt@nIE
zga~)IGEkk*xyZ)nBzbEuh7M}4G=e_?ow<lGgWNFGKh2@xB7)QjIC$bVA=l}W$h&W3
z^C=;oawawmtcoq4%;HBhDTsaZ%n9QVMuDgCW9jn920Tq<_XyMRy;Imd!aMN<83uBN
zIIs_=9Ud*D!GfI;ERxwlxZfk0yS(+BhlV2yq9xu(+8H~9Ar##vnR&|QgSrx2YUXLh
zYhj+w;=!;JC$mEZDGY=TzN^Dui78cIC{be0<G^6~ThBRgEt&7X1iB$jv)_LgNk}Qa
zi&V^}zCoY4Yh+kFe#CbB=EZ|T4Z!{{P}<x{xqUr;H|rfz3r`s(g+h)%&q1n~P)Nty
z#?Og+hE740Bop(9t3qGCid_{-+_6=zWF6=Q;wk5>xGI!$k**5Glej7rPvWXjJc+A9
z@g%Ma#S`cIUOWkgvWZRL^suIUXTHRrk!<k&@oPBWKSr8n&$*L`+5_LRU8f=Jxcd{J
znfckot}0<iC<>zpc3wvP7T7+<;xAnU`Uv5Gi$DRuZMq0_<7VX3)0P)e^|%N$xT2TQ
zW7q!+I;H${rmZpn8bx(l`__MfKaumF+fj2Gur_>$N_BBG&kkbaUsF5l)uBWor8Qx#
z&4s`FbHiF&04d`N;D`st_-#!~`lw`tg6~OqMVPpK4J=^d;(i%wGAc1@=qzh^1T}<Z
z2S%4;G7Wodta9^>BM>Oo$5dnE2p2E5aikD-AUaYJEFwMQDpm`(2&uPp2W)N>DnCua
zNnD{zkjh6Z5!%S28o5E}D4nn1to=j>!h=~48TkI0hx2c+Ym*P>5qeLzclnfcqFCzh
z^J1?4v^8@f6jJ?NJ&Jk)H4<F66l(emJT^DB+;+9WofTdn>gA-;?UR;}0$POA<k`*y
z&cIXupvVUz7=n!}yFf3}NsPMk==D-auo}YiZf_qgB&v&qB;!CW@sG_%Ze%@(q*Kos
ziDzE+eI^n#i#}oSc%XdAB#oDT^X9Nc-$7>3S?Mt2?xx?c=D`dE=Use8uH`4D_!UI7
zCK5vP0iHPj8~{*sHSI*#>^DuMu00&z7*WR|3)h(ghKF_Lo1L(hyB4`)nHiSu<|+N4
zkE8k^`5;t)mwm85g2?1xDtr)kei}{Q?oLKteIqBY$p>)~TlqL?XFzp^r(%=vE9R8`
zpp#iZ%)Cvo1Pd=ABPHjz39;0C$u1_LQq5O_5)xf8_P_H9;ORM+-$WD@{<s-ez~8RE
z3lG{&5Q@j|NW~GGMO-;zxRrYI&X1#8I%o*BRQVfpNfT|8E?asZge^3%skTYvB`1rL
z*r#Yn*uTJKPNPB+Q^PSJqSIh^F8e5oRirMz`rgDU^;+3>ImB&@(SU`6Sp)WOh-$#K
z5{-AkPB@6D6EhQ<BUg+&VX$)Qn++-PPE3WPHAdhnLaQD6$T()T{21uAE1H6*9fUx}
zIEFxkzv@HC1h2|T@+7D2`Gn4}ru1CP;hZDjU?ggV1{gG5Bw-yVx=UDx*e~e<_!)tX
z5U-_P>QlY+??}obmZs3w4m)Y;B$le7(=*PyhDa@z_Jx=gqov`o1jpFX5~wU=WEK;x
zi;<bRb%i|c%VY8wF&~|pNE_MygIPGU4I|D1m*<vWoKGZ(TzSM&deq8ecW7A*)_fk%
zR`<<w=QXTPCdLJ;yE3BPdOMwP!6GO@yI(&fDjBP(Alvc6a3qkl#Cu^+BPf{lEfJb6
zFyJBqX3B@l8sR`vjF0a`Au@*qxn94VuLSWGt7UP)i-C|ZGMt(h>wqGp<Ae+8%TZr3
zkP`t%jtwN%EU>e35uPH5e%wl2JlolSBuNctJ6p@u3qFF-a$)`ib|OTBQ<cx(q{Dq`
zmT4VlmO$73!Uu$|Tx;>!vG+$dstCDgDF<tRCg05!gt?w^7b|(T4WNZ>SRE0o*HUN>
z=Qb4@a|@-H;^<4ww$9|GsJxJJNrppSHf<*_6WsIYDSUY*qi&e&SDbRcgV7Y%u@AQ7
zMgHF5u8AvVOeM`rshg<?qBBCB-@XzHBPe(=9jLP(58eF9{B|u00Qs((CVmJ2+2_)I
zS%}j37os!{yK;{#=mqt@(~TiD8~1ne&S2~}w-JNn+F)?i1@x1<aXa#@V8+yHA;mC2
z^6X!{AHhmLL7yq1vo5LS^47lYBydLDL-2Y)cjbQXYiqzP226DeZ3BD4q3$(O?M6*A
zB5U$>q+MgOa0gkq&M0X$N?z8a<b_6#{ew{>&ahBwhjMywM3Wh!OrV`AZZMI)sK1;~
zEs$JB^Y^?bn=jVjzCq)~7|o%jL(af4g!!eNvo5^hsYNvnP_Z^V{f0O4+R*)PQMPzB
zTWod;^uyTB0S|bOxecnvMk#e5Hkc4gh?l0rurOLuS(R?b=oR5Mc;<bxfy-6NM$#v^
zTJX>q8bj>CZOK+A3_+Zg@+Z9+tfgWBQ!aUVc(=}j`^cX*SaY_*_H#0rLy48!TsCI_
zTVLGeaObWsXK}TdWxfVM#jtCu{41-+v@KOkH_?MJd8Fwkp2Tz$Pnd4v8UVH}b%q~r
zX*&kI4A{O(_W{7mAZP99%Ynyeh=|^eQHf+@p4lk;3wI$+vwv_i8KYb9E$yYpJ|G>$
zCOH`YVGA15LH_`nHM4m^xEW~lS<afN8OS}2Hv><i8F*^ij2#$BBi$ryx?F=~qZyN~
zL>Bldo=2KyPh`zFb(5(XJHU3b2i;zrbYOP>wQ6W8%v4To*T4gm(N7NX-(eRJRPsO^
zp3Fny+0rhT%@gpUdekp*6ak+T>dJMiNsx<orn7|rLa-mTg{=iBzwM!EUst3yyAF__
zkm9%2S<$)l3>U6GrX{E5Jh%t3b&5~<mhn+3UPNv5tY^K#sZEOVc>RD7NZ8Eqc+o6O
zjuNBY#Ku)fB4LNyi5{Dq@=Yx;`sOPmp(&cW6Q?aQyPjG+BVA9n%Ce@ie<m*!$#Wfz
zUeWTr2FZpX+zM=n&QBptv;R4o<oP#zd(_>yEgjtaYH)aBbyKUbGm2?#+So63^^2XE
zMO1VnshY6JaA(wK??$ScuZKttC{>NUp{c6rTW=<8q^hX|mQXbd061FJNc9^_)ev`L
zs2avUTjd5r)%<VuY>Bx+7P>%;uG$vK28VRGSBOI=pg%PG%{LH-uERIdcsI)0#xxG0
zPZ|e1bA;|s=tmkyG|OlW)E+brzW=S_gjbdnr|{F^N%-mTB>Z%E;%JK2i~@==<jsX-
zqcy+4G@;h?V6D+dQESTaEn71RLLe2795HDAx237#p>j;|P!l1lbNFvzW@=Z2=Z-g0
z*$7vgZE-p4O<kY;%rt-WI80J0ruqxth0rr9vdI^x`4#=Cr5S&H4f@Kqk#&8y1~;K;
z(yyRL@yzosLuQ%Fw?&+>d?%7ac5Mw||2Bk9<UZWr*qxBi9Pz@iumrC<hxM<YM^gWi
z0xp!+oXwH_YvCYMOT_eS&DN&<YuA?M`&U=ggZ_0M07v&P$(aAc``1>+C-aH{8w%e<
zvLTVZ$gv2Cd;)2j{f`kOk-y?wO5|1u0G$>P)xZ9B>Hp9D>nJ*OjQ;gKl8x3pL|qWA
zc^_$-y%%fEh33{Ag%HU871q+aJ*T#5|Dtl{{?&p1hO1!mCuSLB6Mgj1-!?|d;2#Ci
zGS~+j?%|1A1uuo1%Kp&9@I;MApGq6qj3;VeZH$h%298@YAcP7?|0fv`^LLs(;PcUq
zct<?k7d>upRA;_B62|tI1q_pSYM_MiDqx5?FOI6_Gk>)GSWQz6GiM4KGpIN<>_`md
zOM1v@{rT9HABE692$rc)c?LozxBg3zR^F%#YLuZyphZOT%h}9PWvfuRo?AQOtejQz
zHpakbIN_sby!nsjwOt2^kKTtNFLa{RcJq-O8XMKr-+MFAqnm=pM99fHDX@pUR70G3
zb9=`IpMhkaA(6OgSS6NVI$ROhfAQ9ElGw1k!zzJ$#<8J^SIeD8ED~NVu>oTNNFruH
zV%ykLHEdGl{V1vz#Bg^B<vTD8MR;&V0!r9wj5KamUQ6qN`~RDYx8f-#2>;1S9rmy9
zgx14aC)>)7M>$_QP4?wPCKplKbtIAvee@%_8ljK!kfzz6xrVgsqxhEEbs~Coa72Qb
z-aRI8gk^D-Rtn*W+y;(#jKpy>6R@Zq_OBz^z_EwG@o}VS_7g>f<1hG@IBo{-AcXyp
zPb#fG7eo2um=Bz{mve#nMMwU^k7M@4m~q-P3!HulLXvu6v`4Yu;Dwg(zPTt2Z@>9P
z1Ah?#FKpv=A$VW%PV%O?*uy4x&zWD$jRCJK0Px<kqZ{Dq(UNi(jyj;#`ss6~;f6i7
zraNN-(rC3lbLw>CvfU;VY8P4>!@TW}WP|vvfEx+Oxk%IO^9zaiGx05n??N|`R_yZs
zx_ms>lcR`sFqFhTm4}gRpqNJ*1t`uznr8p}YC>@bz9ov!ZNP-07#!^bcf91Nt!tR0
zndTQqv)BvV<?ZEKQn!zOfsHwv)7kMPY`q~c3f09NskQ2+BlSJN#ynC_<-es@$`Wj0
zBazEkMQBGFk5Ge`1E5KB>5AjB=#gs9+d>V>W-ncbZV_H7Fyhs)dELtVK@Jv##J)hA
zPlw_BH=O5z^W;7N7cIHgzWyX_eqXB#hI!*Acln7F|JOLgeXK*jk>aae&x0i1JwWd-
zD2a=n_IkAW@1_S@z*=Cx>YeYV6CjVb-CkJ#Ie$ZbJ*O4*chv_AKv!-@!Fua%%H*iG
z?xnvbk{rdpV36b)WNJbZjOQ1>6=};{niEZt3DkaL7S{9o(?krmJb*6r1P4Bd0go7V
z0Q|kRk-&HLj|QG>2L5t)^R|zrmf+<84?FA|k7@Ox>nwmZvoYgd1~+nzW>qzfUA<m<
zFRIn1qQ(d)mTKms3@A10>QrmJG8x|!ypyI+tXIb45#cY&t@sPM4=)-%xt1x+o8X3&
z1iBAt=3vL!JkJ&8JhxMtLD98PZI!ixrr4|`^eK3JF3Om6YA5t3Zdl+H+qU7cpB9{h
zAA;#7pHn5YpUJe^hs)@~4kvWoz-A~w;c!~yCWli`q&DYp0xq{8Qz@-m!|#M;>u@N%
zZvS?*?57mc2Lf>&JCKueJk>2U0L>i(mr~VUZpxZMOvbDr!A{G8+_Ml9V}2XnMR`@|
zG<e!|7V7h8sacS5?$P4geVf~nV8T@_)QK=sslmEDL><P6M>Ur7L>Q@_^9RjO^@67_
zO|S(1#Ha^19ZpLscmS@^zzO^gF2!CBBs_`)-tuoLbpfRs23m}*jdOout$E?i|Ex87
z#>ZDNnKpUzOd_o-Q~E^rvgg*A1n#5N_#vBXsI!Rh+Y%Dch-ECQqG|Z;k2<x`>{g^)
zV)Np{7L2G|QN(EeJwev|7vK0#oBxUHjLn~#9o_uDQHzcK*8kr(e*ux}-!?z+z!{of
znoKWEi*{-Nic>FG`#N=&0T2w%zm{i?x2Bv;d?4+z=~DQVg_&Z*C^qfkxD#xq;ajv5
zk~jlG1(L@s?ATV*fT5zp({OWIt5j!SU}0YTg}UxUsL|GLI#&<PH<p0cB%vv~a%xpF
z;$4jmsl)VkINE~nz@kvZDmw5PoL6ii_yhs_HiNSOf$EQ(n4rq4r+`ko`$c}{0<uBv
z51|^3%@L3tzI1kuTiwC?SHX`YJH74%M*qRqBy2Z|SW3kB-&@KG2R!3EwmwxWj5!>2
zfXB35@L(|`iN_d2kjRY{7;+)3Ae~J#xCzCh_^v>5q-v7;ifFl5E~ftd{%G-$TYnvi
z^imA7F?vtl4~znnUNb20AF9G8gc#VX2_f#tAVQ2$ro*7af*m6Wm?;Rd2^uj5LHb_6
z34+OqnIOH894U*j39=kh_(-8N?S;-(4AZ^vRW`DJ;D8#yT`5n|$i^2^D2nQ*^HCXJ
zNcjhHi1@jvQvqYf&&eK-L8jHKL|J|Y0Uy=GPKw)KC*2?xg5@U0mvIO@ACtt||Cx8m
ziJfmIr3&1+2tHC3Ef$7S4NF9jZZL*rR6mH6p>$IUFX?r!L>gW<_K@tAs}K*pCa3#i
zqW(`1wz-LV<CV-ydi<ZUyrfb={pViN*Njz&zf#xWoe48yh}yr6ul)~J3SU4FVT}3N
zQY3Rhg*^=~42Fony-3sSd#|9$&n|q+VdI5W;JY!^H7|HpoQr9WvHV~(16|-OC-(or
zy6socPBHwVA0XLi#vJNvXvUjJ)9iNEjF#qRd<C}4*;ZI?bbH3j(uxzS_f*b2+iEOe
zzhNO?w-MywYXzhUx!|_xESEWjm-5cX%~mI&RY)!1y)zXs&U%^C+%tXuXr^a2yb`Nt
zw*Kb7)iaM*oK?@f4-|21#5@#w$vpn=qw!x^`*$KU4X=FsZ{`f9;Js|pX)5pG<!2k^
z&1P5h8BRe5v)~lloglb80QYgQDE7J8<~!X7;ygo-`nx(3m&oBZ5!XsLu1Wyv<>Qlp
zy2X77qNDAjo`6cpi=Pd5K-x9nvvGFq6^}7}?A9JxP83kn>q$Z&wn{hTlA#<OST>wp
zi-2Vycsbp6T0_r)TM0+qe()>6FZ*fWAiRe6ncwz~z0>KMl9vZLRC4j{z~RoS(gRO`
zKYC>{yC$U?&*_iCuAqBi>h5EA2_PxsS=s??#ett#YmVB$H}V{+Rk09^^v3rf<F72G
zhOqGA=UBhX>4ZOA)F19dRAuj8h10}{Lp+H=lV_NL3=SGSbmhygLia}QoBUAbbuwVa
zw#a-cS-w82CmL?GEhevmL#tpvK@~df%Y1ei85G(06yh@pA4n)dv0W<>(u|u>SlFQm
zk6ZQxd^gi#zq|V>yt_X3yV_^)?y`t?@=mmUf5W?TW54_4pQJ98mtb#ls%Ilaq-j{^
z*Buzu?|)HJeZZrV>ODarOgvwJJaD3Rf}#~vcQe;38jB1SGQ&wQQBeJkte8|EE%Saz
z3<srf&b4nqQ@n-}UYx%NnFE#AbgnGD1f@gyO^c=T=FED8+JM~&dRnci^j>h5H{^OQ
zY#NMTeu?UPfZr6@miE;AjEfjBCTis-U=K-P3I}%63!q_gkD_YA+YrcmWUj9}$`(0I
zVB9i84Q0@k&mKa@0hsk>FnwjN<zX;sCNOa_!yII2+L9A?){-#~OV(b8{05Hif~%Y?
zc?`JG5&F@uGhGu{hBJW>vbJIGACNS4%})BGDd$a~hGJc8WJ8}_=rOOdT5-#AWfe}?
z$0iMSGPoLF&mKT`=qN;C;jZP=;2y=_W7_~uA*5{jA`i;I`#p!W+$3<q&~l?0)K~#)
zgON*Wxjwvd@mpv)(uaY2P+8eYQh2t?XOR$L`iMIpU<8RfAMhmZe83aG^Wn0~n9^H#
zzL0Zq=L0QQyu~CZYPsS?BpYVJaOz4Jj~_tVy3@eOxFr5cauXXf<!RXW6}$;=%TLCK
z(Uhjm*<4NWP!2<LcV;x2=>knOiJ>Jt(v6T71I@paYy-{jk+!ap(BuKPITkaT^;>}E
zn;>HONu1UC4?Jl04!qt;*pHu=ZmU@KpOaXH^eCAz@E*;?If}ePO?dxGvJ1R>5#AQa
zlW{`)B<9=_0WCJ*4Y^8R5|%5=L)1rN$<<GIW5`w7=MPdgTq#UaN>>Uqp%zyPpU3c1
zJbz`wp_0*`ap1JZMnt6z|Jem^X)ISO_ffx5XgYx(0s4V^0#_tk4WZR3Lwy-tFi!vQ
zb_9s3EvZdTvC!RArCagfR?Fxzg?b0eRbNIulm6A0(UmUr52kZ9Iuk$JUoTh)PcQHF
z&&{KkYgXf>wt=$n<OAn3Oy)dbT(padyFY?ZH!T}?GuR$11x!rS7O%mjLmQ||L01k#
zW~_n!wgC9GZQQK3^=L`Bd<3o$@Uq>K8X7(2^t(IN>&3a0`*FCX^4cvVpg46dNpr@Z
z!s%<L=pABhSh}Uo8Q+-dDcee$H01>iPl0)#5m{TKuGXv)We)0gYuRx0lyt_MB-QyC
zAmL~TrHDaFr=&NK1j;GrhJmMG;)S*YLF_DhT09}bjvkwfup0r#F(=m5y%`M&0`1+S
zKf027vpK@<B|ppZPrQTWj&ELaU>5DQqEyTxiPI`J+v*!u$_%?cg^+qHDFGBd{w#@&
zaVBvp9c}}4fVD~bbAjx)tudg}WV~0KNDm1&NCKUaY;^HgA+4me;*kd2Sv_>Vj5y6E
zf@O2=A(nAmDBRA7tjC2*tO3hd18}{lzTtV<fY!VLlwiV~P=?|Oqx=;HKEmVP)&e(i
z+SCl=H!O{KhU+hZQAh)>3}h6pVjBPcT!t&p6M-wogmo*`0V83<3W@6k#O<Piln}<X
z9jam}rmDCaEV!|qApv7}bv$20bsU)BZ9B-tQf&Fxs<vmQSjtaW7j&&3(vhUD{Dguv
zUUm1|@UvJNH`fnBlp|VDUTeke2fx7KL8_s?l+*z4ZE1yog8{ayjz2idgj?uZMI7Dj
z0%4;3D$WBo-njLOxb5^xEhkl>RnoYv4zbpkOJz|mm4z&&JrMWFXV?h1jSz)Pl@O)H
zXdp^x5TYa^6463j-^Hk>?*w>l88Z&FHA1i50|jC1(oe*Fa_})S_2(T7!q_`KO~P$H
z5AytTsW;=laUSIG6y^@Y1W0+IBi(+5hpi7AX50}VqAAb!ZfQ+Wp2Ih+i3j%~t*Jp2
zNQM098CT;*ZeeAvz#6Jy5UqxE@y^-ZhDm%{F(8?(vFGLc6ucJzrkeoFk{N=n06=LA
z0C(*ipP;nD15Rh%$<BGDg6bxt(raazH7Fy1b~gb%Pi9!kG8kss15`ypZLgNr@<v>e
z@(A&QZ(Wz$laM4Dq$Ne_1Ad@WAQdnSeNcl%F6xJe(}+gT)Pk92>);zC8(H5$RvKmN
zk+v?5Mp-7A>?W9B(hVa1{T&)*?Jq7SV&fo&(&dCAj%3i4$H0Jk!VYhg?_ub;wXwKi
zsv~Zgno8A|Z6(o+zAEO6Cun$N<#gqe`$?t{$*(KBkdE6<*>y)Wpaz~GC~Q;3Yk1|x
zJFMJwM`gFM%97tM0+1Tsp9&7N#d^}UD6x?e0tr-B&)EgMwM4fU&U^dG`_Kk8|2^C^
zM%SpmuTssMevDTOEIq;5g3~=9DX4wZj|qYEMAfQtfKuUep?U*1QX?bl^-;Z_K_q#-
z8WYZ(n@sgCGSyqJtN=XGb`QfqEm(#mwct@vy`H}iD8vVzB1mYxs+5^fm=FVnU!nX1
z#S(>Nj>2cC)@XWTWkl06?P$71RkEpKr8mCom2UVZyy}$;<Wpz))LuTN%cm6a1X^~%
zBPcuxe>i9B2k}Oh*CxAjclv)qp6OMnG<)406DLko4;>3`IvKAX+H}0jC7bnjyHtBG
z20`i0GDW^uck0$!Rk0xlzedKmOvZH8OW6UeTVd|rYwT#clEVecxpw!dMHis3pNPH`
za9UY6qL?KfxisRQX<lsl!0$;jrz2WrH=ZWnI}RH`_R<rs=%}yUho=cMXJS3Ol6Dx+
z%&e>Y0e?kr;!77LP;XRYlTJ4U$wsGJK>l@fy6cg)ZW$z%UjxrN-Mx@GuDSYGqtj`w
z-JX6f3wl!*f*W;rPrcIO6|V6)J)Bya1qn{|!^RKi-mInl@=qMStSbk~sOP5R{3CX$
zPEzA0HSH6;syynu%z;B$)zeIH5yQI~IXzmu$Ga0b)2ptEYpiD%%+xt^cldwMowi0*
zc@iaMb<6NWR#(caD~VCvgqYQhIE(6f$m%qE7hXYURsjx(qeBMcs*+$l+O0C1Lp|hZ
zY?wPnOFQ&3YyQur(arx9uUy#COzr1a*P!)Vk<rxpp>eo+hTpH_$o<v-Jx(laLG4FT
z-u|%5uk64iFcRwFn~}sPF?r^k96{2jS1xBlSUH#d5eGNA@k3*8@{}t9)_1|W$4DT=
z9BoP$5~hL)Ee)aQvX+Em1Hs_1lL){v1{&wfJe6$CO9za{rBLZPqdAQ8C5%05Xx;0D
zzo4YF<e$Y4NbL&zv8`Q0uW;FrF^65rUgrEr5(u#^NTx|XYFTc=^ju!cJIKQk^HVLx
z#?mVpgn|O#C&BY<h4jYUpv%yq42tyn2Pk4=0YW@?3$jb}jND4t6b5z*73fsC$M)dO
zDKwwybxe)7@QX+b^)*WYUj`}AK}fc>m6YaCvGsN>d)-*)@#03W<5>8C-JV~K8}@n@
zqp5Ic@LE@*n4@v4r|exQ4T~dpudU(`R^~%5HExkD9LqqzZ(F;Jprgy(4Q;Eot1A7Y
z(Z3rgFRC!1d_8MM!NCfMrMDklddw@j5<tN2$C{>JOzCDKwFUr#NXdU^L;_}l^530g
zM9MVR$V@c7ARo64MAY~JVPb~-7MXlPAYWa{Aj2vUkniV^KP)%3<vuFF$e#k5U^;oc
zDA~%VlY;zgaF&F+88v$J`B~N)8XS1LhqAQwSs1fKN;aTMw#DJKWLrfR#LvV!fJ)|2
zC>!RNuv);QFKrd~!q&y^&)|Frvx!r00<>+diBpR)0-HE>V3DbHE74+V-Ga*@Shv7T
z=R0DX3f8R*rW7ns`MXw#3Ee@sHS`6zzsd}=FEWG6JLjRE^7^^9nttU6&kGB|<@DOj
zk}SeOu%y#Vj3pT61fh-{XUzV%l?mzJPM|<P$lw}EHH`KBjClo5AdS;&JF=nAvmT<q
zu!O|c=u@u~1lF89W#x;ga=7H*V^qq^Iu2?W!fJpbu4Lu0Pm~f8;48HL>h^9BeIbn{
zile>y0guo!2ukQ7n&ArH`jrfsjCogMeZ;_`2Vs%tz^4Ajx=T*Gy+=VLVVu#R_8Q8&
z69iN%wa!engCLASweMeGRHJDbZ~CTVwEo?-*S&1Q%F{M*O8!2~gu&klND~a=xp_#&
z@9+0eV+96_SPKe1DmCakg#emSy4i%%^&BOHC<v5#10_hxlf%f!72d7x45fnm2qm+g
z=s;DOA;*~@AAg=THc3MM<S2u@b*o84cA_?|lln{rxK66mfldy$&wAvkuPj9(sgpu=
zLlqubN5$#=oJ>!lDv!Rg9p<*C9$d*&=~`e@>U5q;_e}G`H=<e;?l#CsaPtIOsWFus
zz{_RJY)g2yJ~Ck;Pv|QXrtyS+GGQ!F=r0orc|vEP$dTC&y14j7+;mlG?mN_G$NDUM
z7izCi%c1d4b+TBl*7JMTP%<y~1OY1Fn&r&>&1Y@g650n=P;PfwJzX}<Gfn5fDWQ4b
zR=jNjJimG1){X}7HpEd`X|hZ|`MWtiRi^JpI$BBzgv<cZQv8%HE&sXQ)%yIdmKsW|
z#>WzP9krmH9gTK=?J27tI0)18Wh6DZ%ScRoEgPA*1j&$wQoDJ+A^p=hE@4Y$EE0?k
zS^ON6QF2D`y0VY3;_J&uVI{$CU*Xn<;tB^WoN7a1Ou1I!FV4GmRck{tRadQT?a-_$
z*VdYFG<pKCHD=;|0;89#aI3#o6H`m``&#@drTLdzY|BuzwhC87;7-c&lU@B^!~aIc
zkBl8zN_gu9GaqKA3cYHq<2e46y~$V#y-nAv8J)BesF#+!Zt*2J)eF&sOFfbAC$RT#
z@%OTtUL4r_B?&Z^@oFT<0eER!t5a&lHtu=HJKI|Frmjm$u;4B;gt#ib=fxY3TX12Z
zNIkwZ8S$ko!_ST+_J|v^eIpog3iXV+002|>*L&mfC+&U|#OX*|P{^&;+173<4?wfA
z3p_86!|_T9^c7EEar9-0L+Gk;q30ginp+wBGX9L&n#p)6TjR@>ExC3`7`qEO>!L6)
z)%FXxa+@nj*knJG>q#%j0|_{H_A+0T$uj;Kx4jth_T68Yyum;bxodw#akB>9Xv)2o
za!=g|Yf|KX1i3?FU^BC^(ipPtM2%s4uMC)|>F=P7CHNiq*EDy2MDDhbP$Tzk=<;q&
zS?QsP!$>$!(lOo3K84vt*;blVG;yBPD{X+^wt?0j^-3z9sK$CF5l{43uUPOzLceXx
zk|iVE>i0Bm>dK-jFc@w)jG&q`F}1NF?l|V^{bx~sYol2giRm;vAG$Ki$onIPo#G_;
zf|ZsmBf=h+m^1c@&bWUjL9}SjC1Q$1qouASMCYuQIg`yWKVK{m4Ojl4%$aJ=`C4?&
z@iJ$+IcH^b&dX)ab|R;0@+9CYU59!EK@%SJUC*ZPVQpkM00Z*wPRN7Nmda)B*NrqA
zOYnG$6(Z6PWL;}GWh`q6QYSj<ok~3MH0r`#b?iReEQ;HArXIr0qU`2gREJyDS&haW
zjXUn68jpz@nFEwp+jbMHmMTb$r<pBbkO&OY#xo3X4=Tfer)u~)WeJ$yIjc|`pOsvw
zP030x)O=YTWy7QIIW0es%`tMQA2OusJ)6J~J>znQRHK1Z*brTS<qOg3q<EqOAw{y2
zwqpkUG$DmliIm7izkN#((ld5<p@utGHQc$X;m%d9#JHqbS2k9XWWd%W?;J^{jfj3X
zgN|8^bqPi8mF6d>(9J7rYenmHWw9uyD=wB7ZV&;%2?%tH94&-+oyn=;et^5ISzb&C
zm7%P>sZ<9lRVGTMr)ti!2wCsI@}sN$Xw{07$WqNnV1hwDaNF7rr6*_lJH1Wz8GMr$
zV7d}`=Qv$Yz|js}$e3Jua*F>Pwvd2K3T1lCl!><um-{;C0#xON3ZhIl1^G}@;tpwU
zRBL~c@u7`dOMTDn9Ztk@PG^W{`AbAzK2I*q$HkCCOYceQ<Hy-Q!Zl&XbP5-l2~kgC
zzxeFO82QH2_*Cm}g;@^V0$Av#{QI5izVIEoy3&H-)|6}SOyd-3hHG5T@5D@qx0L@b
zm%mlgDfMv%RgX8N>UMa;0~3y&nX0c*ra`7mlB&4oHxmXilyX}qbzt)51p4e^wO(h`
z+8>mEW*-_o5q>=kY60~q+0ZYLlaPFkq=Re7!jW^FV+RQ)^CH5M*;iV!Z;HPsWu;s!
zE?Q=tg{)?ueJ{Wc4J7EOkm^Mx5ywzT+acE|DHaBP`<>)$896brPDaH|_jpVm%T|%-
zoo2rnTN4rI7I61V!2t9cl`GpybO^IErsDe3kUQPpc@YE=rv$A{E<MrGR#5~R;Kb$J
z-)t3mcm&TD&Wg9>W!oxx;-{_VBc#whX1V>B*eVdGU@1Kj?`u(dLa|krf+TqRZ6mA{
zoGf*yNXx1-`piN22|%ep1yF=j{%Q|Sq)JhDd$jyI=;oBb(>%T3syH0(nFXQlEstMe
zGpFU~8#A%KZaOlI+l3*837V~@HuyN|FFlb!*d*F2D>ybIBe0?ABs%9Lfz44YT^ZOU
zOKg$@ts<~d%-E=y=de?+zAHT=Ht2*Pjzyr?ye8L`rvRu>>d3;l9ZqeiRl6n`my7#4
z*=lfwt}^;A#B-!B@sU0_bT{t&&a?P)O0R6`%Vw42U1Rl~@Alq6ukFZ6MuX_3gPC$=
z7BomCu;HC%kgbNg<SE<;rdg|bnmbxru&6(hHsH<AgI)w+76y4OX<88mIdob$kYm79
z?zN2$gFGL(j6e>1I?EO-407~uOokROB$}WVOgj$K^I>t@N>8NN7IRP1CWu2z;-zt+
z=)@&U@pA}1^p`#W6!X&)>27ZwX<ZP<B1WFzH{oQDo@xOL@*GxwpVHho^mkpUnM`EG
zfZ|Bi`Y&>Oho)-zi@1s-C0bD%C5=nW0NXKugRTC%FHiAL)vir-YPYA_-WnP|v9fl-
zc=dgRw2wgz%bog^I0V$U$F)eTnk}-HTUaf=KF-{buU{jMNZT6vOf<uTJt+(oz)mH^
z2V42LL>%X10T@rxh_M>uG^`j6R*dEs<FsQWMkROofo^Kab`MM_9`^b`u8H5blI|D$
zzF|t3-$U<ej^BNdOY%FDWsAk{Nxwqf6m55VNv}LyLR|`@@P60?@q=uO$3v6R>Ib+@
z^8m^1C(#)A#x3;Mc&01Pn|{cs{(tqOwhG>X=E=JjGv9<Ur)Lz+CmQzic(G9sS6aBe
zuI<dgh`Q6l<IP777-eSb_~X@N5w-*`KA6Y^9$RtQeUxsmFB$5k{~Hn@Gro*Ium;0X
za5u5YIKcAZHyAoK^Ue|-2A7A}*f#ob@3&sEm-nyTSe0OC055b}ZRB3u)(dk^G>oEQ
z(3J+Ut~6Tx7*5~Tz#UyFE1hlk@%o{@2=Q=dN(8!%TN+(^ow?uovO>Gpy$_?9ujuJH
zBN8#D>IKh3GC2abJdLK5Z|%k=bzDzUcY$l;w|dtBG#c6c2Y6l<XyiJ82oQK-ZWh+b
z4USQ!KDOSie(X?xM>ks!I(NOy)Xk35?Tn(E9hwyGX8Z1FuA9AwT(X<3W7%SLvp857
zT7n9ad0p$7Jm~fd?*(hH?=9{AC8^e2x7Dwd4s5ZYy{#tQr5*rg-;QU4j;(SvYhg(P
zZ(;Q+P{ZrO!hFs*_YiZj<!2wcEZ}5CDy}jkCfRcV6nr893@2vsM9djlxxJV+Q)mz0
zzlY1PQW1VeY(;hka$>zR9aAN(WW8Flm0Pi{il2RmAoFkKsLX^;1g@BXYyPdq0hZU0
zSHRT}+13GsDH%EGr6=S3-AKjZqFKxq-85!?<0V<QX!%tf?ohxDZbhprcKKSBo+SI`
zWP+^{mu6VPvSxemIs7JhE7|U{)f|8de*$nIcjMzhppQLTB5d|T^`z6djOGxePAdTm
z5Hw+bVJ^{*McrUpl#bIr6Sa0rfXu+(VQ!`S@;NF)4#7gNr^b*4G^0r&k{^LPD|_k)
zmGy5Wu}*5-67)mNrQ|wpaoj3L`RM6m*@4@jPCV)<hk6tnAgY$V1}b1-e(ONFFyGLp
zHgL!FXtZ*}gS1G?f<fz95ZufOGbZ2&2^1OUyEPk&?G1RmHNqb55F+&;+~k=IOgj!{
zJ@U#oqhBTYs$^+;+JZSmChX)iM2x@C`fw@xSSKl?U7#Yp1y6s6rQ?1zT?zaK8Op}#
zgs8;0ETcQ9YO7g8EyPhhGO+(zOqetV$e|`-9lt@W<KOTTFmHC68}8icYRO*e+3Lr_
zW^(s6b?#1dzoh8gZ6|~~cLGK^GA*KQrl0XfcJ94i$`-40X8}FUzt`vh{oz%usP)+~
znUFTL8`H304h<K&(qlG}6f;k8w=v&X8|S~+?Y$mnJ+ZjZ9k&73gmkTBuaw@_kfq>Z
z>J+tpmo^M4cQC13+k;<GHy{h<NfaWr8wcqpIJjTg41fYU8n-|+Z51!0Na%C8E%W1S
zizyBq@Q_uQdzv$wY#9Gw#6Do_OC{a|?~FWv$NfSGk(4-<5Cd_V0mAiQ1X<0s-HunG
ztFT~XrKWg4$6do%;rhap&@RiIEf3k)Va#4<f|X<ky$lykk+LWqh&h$!P7UGkimmCw
zqbD@F)aQcb9u={1%uF7cZDM&hx*SumJQMsg;^@<FZ;s_B@kX*dIIcOC_X%Lx19Jvl
z8S4|=+{CfRMXuzoi1S~8m&xq%GK6OFmtJQ!)Lpy9T8c=46Cuv`jhP<j5tmni;1#?4
z4($fRMzuZoG}1`f<*Y{ZE^!&^J{Fh11VI^>eN#hU>Vr??+CPsr6d|)+=TX?NcXu<4
zcp(NO%4SJMWNL$m5nk6`-ptg*%Uk<f3M)OqrFM(vk+5nzqEiaqtm|#!%>$%31#c=q
zXoEMt+nVFeEyyK#Q^c~x>W<5Pz@f{UYp=&!D+FrYOteF-b0_rG3c9KoY!}dAdqv8E
zHnz2`_>_9~SPZuLOZ=%$RY^pa;3uFr)&TsOZto}>qY99LjZsVZz;F&R>NR52Hh+;e
z3XHmncgLp$qk6SO3DanVJ=Xc6Eb&OQ|D}or+B6(wW5yjcX55aYv0b`@n0AA96)~-D
z464P@)0y=`>M2@&0>|KS2IWQ$Wf6yRe$&2GbGKxnLM(g}eCpW5kiweL$7)V02b2py
z6yg?#pS+$+sUGFm#nAL*RV53n%J7wI%4MJzVgr@l_zPS$`#E?}^M!xBF|9p*@_wt?
zQ}E2dR_<DmMzQOf5<*R3CwcS)IFrn^?M3RlMewWY%Br4nlK^}p*K)1^;bI_2{qa(n
zaurYM!BcQ;Sd}t>Cr$d<kfeGg3rS!ZY37eGywgCSbVM40Y&E3|9=OQWE1mERrW<?A
zPs2vdL{i}0Z!MOpj6^&-tGb@PkIsSX)yV$jSkSb3B_7|bhGyN#y7EO2wij(P3+>%@
zfJ9<JJbrlJgTlah7Yx6Lui<T@tpdt;Q~{i)_BN#z^R!%^W?SowYpha+AW_&II2WAP
z^B#f5?u6830`z4D=s19G!NIgKKvUX@N><%he8)aO#{+Z#i9#cb-p-ts>L2W8d0iPa
zohwH@wO?uOmA1uO*?bb~aCTZKlGDj0LoqT^eD{6$e2&j5<csy$g><YL{V#tA&VLKm
z{{$ZdxmwI0@bOD_rx<r|<io+i-O{=>v2<XZzk}O5h#Ve~$-W@(p!3l|gBr-DT?aMf
z;A&_dezVC~1ptfjVhhd3q({SrV!|G{2AM-&YYx&l#e@hSCL+{Ldt`5_U2dDov<oxq
z^K1_x%-T|VGR0PL8tf!(^A-mgM<8P>G1?8m4lpR+MAB>{fMgq4*<2HDc>^|?EDZK@
z>><J5o@j!MY*B%{@wSS^c*RN53Sa@Q3OB)#LxUL?y8ZPj1f56PJJVBxlRyBT|0`IY
zp{x1xE<B@b1<Q<e@PvGSAE<(!*e1|eMS%mM3)W#rh@7u(fjb<!;K+WX@>g{>Urjct
zS!4Q17DEpP7;WS$DthVw);F$%OxV^&_l;p7D)o&=@Y#n?59EvW8HMy~{|g_2^WTE?
z-@peH+cc8c_&@3!3n8`So5nVRi0*-<V%|L_0CwzA+KHm@D^|RRtjua|zyk*8&$v+c
zB&1>sb&4oSF36@`rq`XU%aCz9kGjZua%mdlJG$SexC|_!-)(>>V>&T33`n;JCQCtP
zw~VmGyHNJJdr_g`Mk$039b!3lpCOhVw9}1E+>tbzJH|N18l!XPQp7j!ntOp;%jt?o
zkbZDi+TV+yVa<A9ZbOL`-uf1e@7;5d#U7|T#kitk2~x!pq>3d-6-$t6$#JX)4T8_m
zfdwE<v2-_<gs?j{ub>6C=h-Tp5Hv)RU=0+@GQl@eSj^)_TG!$I@Y7G(+7M|7%yIGU
znmPla<#bHqJ()8x+ik#;*FO_?2GTK!JlvdOYP{3^xPgGe(#K~`!!g?wmhQ{E9VKW*
z2SrhW7K5fwnT<4xN*|v&2j^h~DBq+^ls!Oir{9Gu6v<~WX~MYim{A|WBi%-L6o0YR
zGq3<7y`JO$fx@2?agq2=vH0|3;FUc@`lwALPb1lgXTR!eWWfU1BBWu7suuG@{)$J$
z-)+kJH+a%%>E;Fj6;XTUWv;7?to-!1K(>I0csDb|E=D%^jcybW6_)jtS}ds;5V2ez
zIPygp&nsBgUjknsjqpU=1(<>F@e?M3WLxnxjol{MfG2iHlWre&hm=k_(xWML9s($$
z4hud)w-g(27no}8hB+-!XFSr@%_E^kK4c8v<vR?~V@|bTBbWgBT5&PSmk|fjjVfr?
zU9fHe!DIG^p0gMeYIKs(C5Ewkc=2hmeu||S2=fF8^HdV%Y<MW)jkydpoq3zYMhq$o
z106qR^dfQOdnJaCBS9sh#623I90}#r2_$T6uf){JK8P4eWoEa!%Ki8&M1{-4&7U)x
zHQgaG49T3ydd^<>ONnOLNL#m1wvp|Sm^<HSUmLW~v_s<0-HcRNkU&GVsYc*H%%<nz
zY`-%%J#fLUCau0|oDZFdT0JGRcr<TyVdjLHywx+O({>PQbVOsP5mM3HLB=B4Xl#;b
z>=2}_E2YM^#}_;<V5T<DXl&Q}A{v_>v$5g*2;~RdZq>iS7?{<Pl~8~s;~~uINjPI{
z8wba$uGL7p1hWo0=A#<VH{v}z@<Y1`YP@8-=3iY6R4jqNA{5Q3`L{b7KlFJ2#r--t
z$C#Oo%UViS(2m>`2ybG&GoF;5rJlkY5KIZRh=W|{x$%8<?9-t{$3~KV)U~DyjzQA8
z4beOI$I+c^A`d?~1Bq42{%tka)6Tek?&Z?NBab4=m9Z@8<@s$b{+5o$?T+$OaSQ(*
z>g%d#WJ{W332tsT-_uyta^_B0J^#ERy0yQ1dA)TJp}~;}&Vyh(^CqlbFr3imjqLFx
zD2)9QUh45^)<{r~U-Y4kT^W5m3>9>H;o9R)>XF-NB_Y%s0=c4|Y9eGyuZJ&SpvB)2
z&!=t&aYwFalcLo{Ao|#9wIk-BZs83wIaD$Dn4*KwU(s}r`YD{Lg<98AoQ=lD&zPH=
zh`ND0cA%lQ8eD|?lXQhHC;&!mJCQXD%lkVqAVIIhSiys?h&2H21YjI$<5t%U2kl_I
zdsGn<q+EoS!7_E&)}|)GJF)|feJaD`9hr7LtP9~CnTTaI!#gqxCRJ=_<sjse-jPdL
zwpiYgIcP+qGV7jHD=p_%zC}dWmJxnhJO=k9_444C1CR#G#$GlqLXiW<mr)5E+{Fk{
z+KDO*tZJ`m4y%74m&ED`mJL{KhB7ry-=XKgH*mKAJhcJmCahI<%uTg2oo{n)u2MGP
z7tSCfB<qP;IG`0MQn*AVxCTg!zU5coP>a9eH_Bf-C)JwY(N@t0`SLL{NTDXdcW@i0
zy5>x><|!8-ldbZX%Pf{W<y<`bt?Ct_Q3!FQinx4V4JQladoC*n`DTPN?w{A%+1zS7
zY~C-n!G%%`Z#T!$?ZwG?Vi{)hY;uq%i|rP+Lzt;8K!pP3dWvNi=FZLZ?)LwWx;Fuj
zs#qHSCy)aH5++I_s6--*f`TFtC6Ez<i6#n)0<NH92+CCfaYj)A2b0kpk4JIA6%=>e
zaRG_QjtMST5jRv++^#bY?hA`ZzF&2pb7mpl`@X*K|NB3mk7WAvQr%ruUEN(>T}_&Q
z#ZOqgNE@tyktTm+?t$Ds-aXiV-E;!xkI*IMEVc;<$AH7T5F%^1lspR;P;uaPV~QKJ
zm(O=p2cK_3p3nCq`ErnwOPzm93Uv6*{dhpCGb)VzeZF1%O8So-eZDt3`F#J}*XKK|
z3qF1hNR(T~w^f+<cH#Zs`gMp<X7-B>C{k4Y=xj0i(<1u#7N$J`)IsbTjEa%Wk+J%7
z5xL~^TtTdo)$7bRHI;woE*K|R=Hk;yLt-GZ8_M5eHS<1T$^gSiZNxeg3_6!tkj(Q-
zG~B}d_7uuFepQI0GK6wOGN#Jq^(^;bt5}7AZdFs#(ihqvxy+Ms{u{;2huSm3fmcK5
zje_&yBf~S_@+m?6!oFHi*C|2$uyk}rp)^&?YgprU1#)jka>u0a3hMhbJsh}PL2OG*
zXk6@iqEeXsY)o}&l{L;0=Ko!0AG1!xdF%n;S{jwiB5Y||&?ftIeI_UROGgX(%6A+H
zZ5ljZkRJNXVR>&FxMH}T22O(nzm0`-bA@nfCU{(4inFC_W>y?WrE2u+p+x4PPC*>R
z8!x98yd<e$gYl0b=#Bl@kJc7+yVPAX{KD~NueCLQWchFWla6Qx`IN{~a~1EGOq16$
zhGrCR@ZZE575oLZ5=B*Gs7eI76>ObZFG7kvQ}KZ7v>`~w>ZaGqir0kVH9LU&FsU^=
z+RUo9@?Y15H+Pgvh)S$paeP9oPOAJXu{w%eo>(2GvLRMiCy7-FN3Tab(zd%!)~*7A
zIo?rQIXxn!ii#N&#xc^4WJJa`9U%;J81cT~L@WRIOH?mAY*O-n3`HlL<#brvYc8fm
zbYU<l?G;cAYYwZZ;#kJ`s9234YxJD$d@Y4OWW>Z$$v92$*d(g6^5^MVCY>Peb3$ip
z<R7OD<#W!Zm+pKsvf{50Gl*OsVtT1;%^~KJH^qsAnSZEMD2mXcxo1juT9sPEWfnH}
zA;HX^Q&E+ZrQ1}z510~_aJHo6)zOo#<$4*ofbc04mt|mhIM$^tTlrrc*@C01#&Xda
z_$Ed+`fqFrQ<$%pI@j()>nqH~ePLnDCB7)*Lc_{699(BGNVp&Q6c3)E6;rx8s3O@k
zD&$U2&CK;UlY2xsEP1B7pUY$%(!F_xbfevWXQp!9s&H(`yrsS-Vp%Nq1jTz8sPwyq
zYBZyWGf|zrqH1_9_Q?@xHj5KE{m;B!+8Nv{K2**%+KRzcL#&HRS7N16R=L8PH$x+L
zxtBxZtr1~Uv}CU^r&*x|X5XfqYo~A?Q*pR3$W;V|ZkO__=vMH_>C)krF5S*1LDOv{
zA&@&ekE@mPlBZ>yB56?0YFTbg5QFNZiT=Esq+e-xD`jTaMii2w#Ej!XRZ_Cll<y%y
zSzy>R*CiR9->Z=2iBW)vX@(Y)$!i6Tb8T)x*IyeZw_yen+I5=ds@ihvV&90Wua37n
zi|}A4-s34UX_ZiD9n;JrtE7|Wk&EP(OjWr=I%h^$BH4NEYX<p(g}|KJLC+y;D(ql;
zuAw_#Sc@nYFJ)af@LdjoGH_H;C4h}`>Jge|;6Esn@6V6b^xB8;IB8y}mWMI1dz40-
z1DkR-T@1DE?xTq7Q$3O7eojy7X!;?9rRk;C*fc6^MsupP!OreRi-?LU?P;BNYD(3F
zsr9*n%Q8G)u#0lsvdfyu%`6@qoFip&Ws!^JnM(@S!)`M)`&P!0w~kYQlZoasfeXPg
zlA(v4_Ezfv`nNZ&OeKwTV)wS(w^5|Yc1V-gy{2R@U+^HxZ`w=Kh35~4f#?Al-a+5p
z6pK}0H<=<bDKe&9(ZU}&R1&cn8v{MY)Tv1_GF0f%H<n8hZCXN7^EkiY2G3Ec#-DNx
z>ao5ihZpBEz1x2<*s>y(>ldn_lt8r@!ZpM8E`$UIHxAMA^dY*^Lb`%Hy@4UThIplT
zP#ig65qn>&<W9})vt%9<l&;=_dBGa-@C>8-YsVsO!-3;2%+6#NFq<J`<@e_U$RlB3
zCYPzY{LHUJ(&F|469&!k0~UE>;y{2`S|Jh}Kpt*2rJ}0LYt^xG#)j}fjFJ`|0_yci
zgo@X%KHp8OuAr6*VwPmGT??+?uUDeFn^<Qd6U5>Q1bG-wi*qn8W?8PJ#=X%@%6#M6
z4kn45LvIAOvf)Y*Dv1~^tL>tTkCvgtC=MLAfdStdiJer=k?8w~lHz(0Gh!WiMXvJ|
zTi#20ljE0i2|>|W0Za&rrNbQNyisL0`i>G|af1>T(EyYl^N^VvyF@2`Km;z<AWs{~
z2I1$xv>Ak(XWHjYPf!fEd(Rh{=m}_y*D!0d3oKwF>np3u3}so8A}p$OuGC~LCB$93
zcEH^XbHC1LNtPr3Mdrpv#$n!4Ylh*l#+o05cgKL*mNg}FVA{(S)82AH64TD&1FYP0
zOfu81|D1x_?4}v87YbPJvi}>V{o~-~nD%R8HPgOD1+n)flgG5BC|p76<dYqy)z*U$
zsXMzDA<`arR(!0prKdZH{x9<MX&hW6@un*<(s)`C%`Up)pKxWXX1H0>NpRR%eL4L6
z-9aArc)N(59LKRN@kcgDBIo8KMYPUQqV<r$TC^@EiF1I7ib9K#w~00Dtubg|=RA2d
zP>OxQ{eUnp@K<ZrYsuxUSwkvYb8FV+YxSD-a;Z?(tOcK+l(P0Yj|9E;8LitCX-A`F
z&3d||s5R^4K{C*K(w+qrF0%^ZBP362cd1%ovofvP$ic>Na%vk&%@cWS*Yw)+1~uA}
z7EfBwnzlp&!|Cdg<h2s3O?UaI2#Nx~>gXhyrYl{m)Ya}>lDyo+NMElr<9$+8L-g!u
z!8#g5oU0ixok%auLP9}yA!TOIrktayS)lCbuE=_hL@IRLEE%y=EV@8&wOEdZVeYGm
z)y%8z<rN&IwlXc{GMHWu>Sk__%aHSQHo=p1^p~IN!)<Q$acfRw07?Wk8H(t~b^}_&
zGt$mAufev6E7euAMSNCDr{Yt{@(WHv#8;$qiSNmQBHqASD$IQ~%--R^r4wZDCcvv5
z;A-(=wu&E^vXF@HO_pJ)^%JwbB!R^sRkN5N_AqJ%i<T`2GIIulO9vC8eye?;8)$Wx
zl<jMk$QZ2Jowl@YhC94PS7M?|-jX=W<7W0G_eMk}i_!d@M+r{)CIqyasjJXRAf5c&
zI=nX1%)C9etE(dZdF0l_zil`JrIWK;lOX`<Yl-tn&v+;yck+11{MH>0kEM@?{F>&L
zRLyibWvX!pKxIoV26*>nR|^vNSh%YB*&71kz;)+AYk#DhbPTyD(oON%j9kZv>y(d>
z=$Vq7tVac9dkuC3-8Tm+q?jkLq!!(K8IP1f>DXI3zDPb17q)ReIY3(ywh%?95($Sp
z_g4+Se&Nj1^?VRT=~liTbJbc@@vO|=A5Vir{lr{MEmW+rZcE?&5Jw4X{gL~?YB=z;
z%GXwpr>96t*|j}6TXEQj;s7Lli`Fc<6RhQ8JLUStXb6`;cCxsk--C;Uxt!f?Y-ypO
z3t?#+XR7K^7wUW89aO%Awcp3z$XsA7EKZE4?vwzx#D2;fVj`cCsS+D2u#>ehWSpdn
z`y)eC#m48AE{J<Hh}c0Sp!yztu2y|_<Wp4New}|Y`IUZ3slE>;lRxq+s@%aw7s4Ug
zzRU8TQJ$s(uLui{i$bdW-%)|DJO_d5slc<LVeBd@_OCD=Bc=F9f8-)jDd*qH7ac7_
zH9$jUMHK47cb@*1i@@kNCzDAt!{>+^EB`!Q$e&c`ApeS@lXUc^1_jG0d!$$PVO6%P
z&h(DXWQn#%?zLGJf+^QZC~L5>`)m;8&TeM=_~aBG?1_m9tLQPR6xv9I#)_&ex&341
zub?cQnBp|VxfNKk$8DfwuJfy*n|~ce6L=GMq_Jbr!-oTxkdWt(9La~3KTcIp@ck>&
zQ}q@d#M;j3v&ND*sODJbAS-`>Wb|@;>g8xuIsCQXa2}A-v6E&g!p}HP(D8Q&zh<23
z0HqTXxN|J>gidmfMYg|B-_EE0a9}P8^zBSOto+%0AY1lM>D#(BZr^g8miJMaM@wd}
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

diff --git a/bin.Darwin_i386/verilogc b/bin.Darwin_i386/verilogc
index e8f42c908ccd856a7acbdfc3cf94a36560e7e541..1dcbc303306dc02646fba785070a96ba5f5c0fab 100755
GIT binary patch
delta 66127
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
E50<g<NdN!<

delta 61167
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
UD7--7YYH#!oLO_W$-UP92NI)&F#rGn

diff --git a/cvs/uart16650/raminfr.r106.v b/cvs/uart16650/raminfr.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..b7f3161917955d3882ab93c8994715abf6cd600a
--- /dev/null
+++ b/cvs/uart16650/raminfr.r106.v
@@ -0,0 +1,111 @@
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+module raminfr
+ (clk, we, a, dpra, di, dpo);
+
+parameter addr_width = 4;
+parameter data_width = 8;
+parameter depth = 16;
+
+input clk;
+input we;
+input [addr_width-1:0] a;
+input [addr_width-1:0] dpra;
+input [data_width-1:0] di;
+
+output [data_width-1:0] dpo;
+reg [data_width-1:0] ram [depth-1:0];
+
+wire [data_width-1:0] dpo;
+wire [data_width-1:0] di;
+wire [addr_width-1:0] a;
+wire [addr_width-1:0] dpra;
+
+ always @(posedge clk) begin
+ if (we)
+ ram[a] <= di;
+ end
+
+ assign dpo = ram[dpra];
+endmodule
+
diff --git a/cvs/uart16650/raminfr.r79.v b/cvs/uart16650/raminfr.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..f04201b21c7f8d1436c91449207fdb2ded2a1225
--- /dev/null
+++ b/cvs/uart16650/raminfr.r79.v
@@ -0,0 +1,162 @@
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+module raminfr 
+ (clk, we, a, dpra, di, dpo); 
+
+parameter addr_width = 4;
+parameter data_width = 8;
+parameter depth = 16;
+
+input clk; 
+input we; 
+input [addr_width-1:0] a; 
+input [addr_width-1:0] dpra; 
+input [data_width-1:0] di; 
+
+
+output [data_width-1:0] dpo; 
+reg [data_width-1:0] ram [depth-1:0]; 
+
+wire [data_width-1:0] dpo;
+wire [data_width-1:0] di; 
+wire [addr_width-1:0] a; 
+wire [addr_width-1:0] dpra; 
+ 
+ always @(posedge clk) begin 
+ if (we) 
+ ram[a] <= di; 
+ end 
+
+
+ assign dpo = ram[dpra]; 
+endmodule 
+
diff --git a/cvs/uart16650/raminfr.r84.v b/cvs/uart16650/raminfr.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..b7f3161917955d3882ab93c8994715abf6cd600a
--- /dev/null
+++ b/cvs/uart16650/raminfr.r84.v
@@ -0,0 +1,111 @@
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+module raminfr
+ (clk, we, a, dpra, di, dpo);
+
+parameter addr_width = 4;
+parameter data_width = 8;
+parameter depth = 16;
+
+input clk;
+input we;
+input [addr_width-1:0] a;
+input [addr_width-1:0] dpra;
+input [data_width-1:0] di;
+
+output [data_width-1:0] dpo;
+reg [data_width-1:0] ram [depth-1:0];
+
+wire [data_width-1:0] dpo;
+wire [data_width-1:0] di;
+wire [addr_width-1:0] a;
+wire [addr_width-1:0] dpra;
+
+ always @(posedge clk) begin
+ if (we)
+ ram[a] <= di;
+ end
+
+ assign dpo = ram[dpra];
+endmodule
+
diff --git a/cvs/uart16650/timescale.r106.v b/cvs/uart16650/timescale.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..051ee7a51e94b1a28ca392d521c397287178eef1
--- /dev/null
+++ b/cvs/uart16650/timescale.r106.v
@@ -0,0 +1,64 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  timescale.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+// Timescale define
+
+`timescale 1ns/10ps
diff --git a/cvs/uart16650/timescale.r27.v b/cvs/uart16650/timescale.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..1ba2eeaac1de79ea9c7b284bbf4fea783e2e06e3
--- /dev/null
+++ b/cvs/uart16650/timescale.r27.v
@@ -0,0 +1,3 @@
+// Timescale define
+
+`timescale 1ns/10ps
diff --git a/cvs/uart16650/timescale.r29.v b/cvs/uart16650/timescale.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..051ee7a51e94b1a28ca392d521c397287178eef1
--- /dev/null
+++ b/cvs/uart16650/timescale.r29.v
@@ -0,0 +1,64 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  timescale.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+// Timescale define
+
+`timescale 1ns/10ps
diff --git a/cvs/uart16650/uart_debug_if.r106.v b/cvs/uart16650/uart_debug_if.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..99388d321a1820323084ff932c63f6c44e263999
--- /dev/null
+++ b/cvs/uart16650/uart_debug_if.r106.v
@@ -0,0 +1,126 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_debug_if.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core debug interface.                                  ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/12/02                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.4  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.3  2001/12/19 08:40:03  mohor
+// Warnings fixed (unused signals removed).
+//
+// Revision 1.2  2001/12/12 22:17:30  gorban
+// some synthesis bugs fixed
+//
+// Revision 1.1  2001/12/04 21:14:16  gorban
+// committed the debug interface file
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_debug_if (/*AUTOARG*/
+// Outputs
+wb_dat32_o, 
+// Inputs
+wb_adr_i, ier, iir, fcr, mcr, lcr, msr, 
+lsr, rf_count, tf_count, tstate, rstate
+) ;
+
+input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+output [31:0] 							wb_dat32_o;
+input [3:0] 							ier;
+input [3:0] 							iir;
+input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+input [4:0] 							mcr;
+input [7:0] 							lcr;
+input [7:0] 							msr;
+input [7:0] 							lsr;
+input [`UART_FIFO_COUNTER_W-1:0] rf_count;
+input [`UART_FIFO_COUNTER_W-1:0] tf_count;
+input [2:0] 							tstate;
+input [3:0] 							rstate;
+
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+reg [31:0] 								wb_dat32_o;
+
+always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
+			or rf_count or rstate or tf_count or tstate or wb_adr_i)
+	case (wb_adr_i)
+		                      // 8 + 8 + 4 + 4 + 8
+		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
+		               // 5 + 2 + 5 + 4 + 5 + 3
+		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
+		default: wb_dat32_o = 0;
+	endcase // case(wb_adr_i)
+
+endmodule // uart_debug_if
+
diff --git a/cvs/uart16650/uart_debug_if.r49.v b/cvs/uart16650/uart_debug_if.r49.v
new file mode 100755
index 0000000000000000000000000000000000000000..4d89bd4064b65d6426696963ffca3b8bd827bb2a
--- /dev/null
+++ b/cvs/uart16650/uart_debug_if.r49.v
@@ -0,0 +1,98 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_debug_if.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core debug interface.                                  ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/12/02                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+
+module uart_debug_if (/*AUTOARG*/
+// Outputs
+wb_dat32_o, 
+// Inputs
+wb_clk_i, wb_rst_i, wb_adr_i, re_o, ier, iir, fcr, mcr, lcr, msr, 
+lsr, rf_count, tf_count, tstate, rstate
+) ;
+
+input 									wb_clk_i;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+output [31:0] 							wb_dat32_o;
+input 									re_o;
+input [3:0] 							ier;
+input [3:0] 							iir;
+input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+input [4:0] 							mcr;
+input [7:0] 							lcr;
+input [7:0] 							msr;
+input [7:0] 							lsr;
+input [`UART_FIFO_COUNTER_W-1:0] rf_count;
+input [`UART_FIFO_COUNTER_W-1:0] tf_count;
+input [2:0] 							tstate;
+input [3:0] 							rstate;
+
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+reg [31:0] 								wb_dat32_o;
+
+always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
+			or rf_count or rstate or tf_count or tstate or wb_adr_i)
+	case (wb_adr_i)
+		                      // 8 + 8 + 4 + 4 + 8
+		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
+		               // 5 + 2 + 5 + 4 + 5 + 3
+		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
+		default: wb_dat32_o = 0;
+	endcase // case(wb_adr_i)
+
+endmodule
+
diff --git a/cvs/uart16650/uart_debug_if.r55.v b/cvs/uart16650/uart_debug_if.r55.v
new file mode 100755
index 0000000000000000000000000000000000000000..2de549377e9e04f1f699fb968a5d89317c36b94f
--- /dev/null
+++ b/cvs/uart16650/uart_debug_if.r55.v
@@ -0,0 +1,107 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_debug_if.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core debug interface.                                  ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/12/02                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.1  2001/12/04 21:14:16  gorban
+// committed the debug interface file
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_debug_if (/*AUTOARG*/
+// Outputs
+wb_dat32_o, 
+// Inputs
+wb_clk_i, wb_rst_i, wb_adr_i, re_o, ier, iir, fcr, mcr, lcr, msr, 
+lsr, rf_count, tf_count, tstate, rstate
+) ;
+
+input 									wb_clk_i;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+output [31:0] 							wb_dat32_o;
+input 									re_o;
+input [3:0] 							ier;
+input [3:0] 							iir;
+input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+input [4:0] 							mcr;
+input [7:0] 							lcr;
+input [7:0] 							msr;
+input [7:0] 							lsr;
+input [`UART_FIFO_COUNTER_W-1:0] rf_count;
+input [`UART_FIFO_COUNTER_W-1:0] tf_count;
+input [2:0] 							tstate;
+input [3:0] 							rstate;
+
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+reg [31:0] 								wb_dat32_o;
+
+always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
+			or rf_count or rstate or tf_count or tstate or wb_adr_i)
+	case (wb_adr_i)
+		                      // 8 + 8 + 4 + 4 + 8
+		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
+		               // 5 + 2 + 5 + 4 + 5 + 3
+		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
+		default: wb_dat32_o = 0;
+	endcase // case(wb_adr_i)
+
+endmodule // uart_debug_if
+
diff --git a/cvs/uart16650/uart_debug_if.r65.v b/cvs/uart16650/uart_debug_if.r65.v
new file mode 100755
index 0000000000000000000000000000000000000000..c98ab7c593fc2848f65f9cade81b87fe69ffe959
--- /dev/null
+++ b/cvs/uart16650/uart_debug_if.r65.v
@@ -0,0 +1,107 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_debug_if.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core debug interface.                                  ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/12/02                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.2  2001/12/12 22:17:30  gorban
+// some synthesis bugs fixed
+//
+// Revision 1.1  2001/12/04 21:14:16  gorban
+// committed the debug interface file
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_debug_if (/*AUTOARG*/
+// Outputs
+wb_dat32_o, 
+// Inputs
+wb_adr_i, ier, iir, fcr, mcr, lcr, msr, 
+lsr, rf_count, tf_count, tstate, rstate
+) ;
+
+input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+output [31:0] 							wb_dat32_o;
+input [3:0] 							ier;
+input [3:0] 							iir;
+input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+input [4:0] 							mcr;
+input [7:0] 							lcr;
+input [7:0] 							msr;
+input [7:0] 							lsr;
+input [`UART_FIFO_COUNTER_W-1:0] rf_count;
+input [`UART_FIFO_COUNTER_W-1:0] tf_count;
+input [2:0] 							tstate;
+input [3:0] 							rstate;
+
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
+reg [31:0] 								wb_dat32_o;
+
+always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
+			or rf_count or rstate or tf_count or tstate or wb_adr_i)
+	case (wb_adr_i)
+		                      // 8 + 8 + 4 + 4 + 8
+		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
+		               // 5 + 2 + 5 + 4 + 5 + 3
+		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
+		default: wb_dat32_o = 0;
+	endcase // case(wb_adr_i)
+
+endmodule // uart_debug_if
+
diff --git a/cvs/uart16650/uart_debug_if.r79.v b/cvs/uart16650/uart_debug_if.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..1f896a23f3159abdd1a8702f03757192beabdaa4
--- /dev/null
+++ b/cvs/uart16650/uart_debug_if.r79.v
@@ -0,0 +1,110 @@
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+`include "timescale.v"
+
+
+
+
+module uart_debug_if (
+
+wb_dat32_o,
+
+wb_adr_i, ier, iir, fcr, mcr, lcr, msr,
+lsr, rf_count, tf_count, tstate, rstate
+) ;
+
+input [`UART_ADDR_WIDTH-1:0] wb_adr_i;
+output [31:0] wb_dat32_o;
+input [3:0] ier;
+input [3:0] iir;
+input [1:0] fcr;
+input [4:0] mcr;
+input [7:0] lcr;
+input [7:0] msr;
+input [7:0] lsr;
+input [`UART_FIFO_COUNTER_W-1:0] rf_count;
+input [`UART_FIFO_COUNTER_W-1:0] tf_count;
+input [2:0] tstate;
+input [3:0] rstate;
+
+
+wire [`UART_ADDR_WIDTH-1:0] wb_adr_i;
+reg [31:0] wb_dat32_o;
+
+always @(fcr or ier or iir or lcr or lsr or mcr or msr
+ or rf_count or rstate or tf_count or tstate or wb_adr_i)
+ case (wb_adr_i)
+
+ 5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
+
+ 5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
+ default: wb_dat32_o = 0;
+ endcase
+
+endmodule
+
diff --git a/cvs/uart16650/uart_debug_if.r84.v b/cvs/uart16650/uart_debug_if.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..5d40ad466df4a0c3a50ddea69ac9bb160cdfe8a8
--- /dev/null
+++ b/cvs/uart16650/uart_debug_if.r84.v
@@ -0,0 +1,126 @@
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+`include "timescale.v"
+
+
+`include "uart_defines.v"
+
+module uart_debug_if (
+
+wb_dat32_o,
+
+wb_adr_i, ier, iir, fcr, mcr, lcr, msr,
+lsr, rf_count, tf_count, tstate, rstate
+) ;
+
+input [`UART_ADDR_WIDTH-1:0] wb_adr_i;
+output [31:0] wb_dat32_o;
+input [3:0] ier;
+input [3:0] iir;
+input [1:0] fcr;
+input [4:0] mcr;
+input [7:0] lcr;
+input [7:0] msr;
+input [7:0] lsr;
+input [`UART_FIFO_COUNTER_W-1:0] rf_count;
+input [`UART_FIFO_COUNTER_W-1:0] tf_count;
+input [2:0] tstate;
+input [3:0] rstate;
+
+
+wire [`UART_ADDR_WIDTH-1:0] wb_adr_i;
+reg [31:0] wb_dat32_o;
+
+always @(fcr or ier or iir or lcr or lsr or mcr or msr
+ or rf_count or rstate or tf_count or tstate or wb_adr_i)
+ case (wb_adr_i)
+
+ 5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
+
+ 5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
+ default: wb_dat32_o = 0;
+ endcase
+
+endmodule
+
diff --git a/cvs/uart16650/uart_defines.r106.v b/cvs/uart16650/uart_defines.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..c28cb5e33dac1a55d5b97af68b7b55164b3a6d13
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r106.v
@@ -0,0 +1,247 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.12  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFOs as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  Its disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.10  2001/12/11 08:55:40  mohor
+// Scratch register define added.
+//
+// Revision 1.9  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. Its used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasnt handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First stable# release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore to use the new version with 8 data bit interface
+// in 32bit-bus mode, the wb_sel_i signal is used to put data in correct place
+// also, in 8-bit version therell be no debugging features included
+// CAUTION: doesnt work with current version of OR1200
+//`define DATA_BUS_WIDTH_8
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Uncomment this if you want your UART to have
+// 16xBaudrate output port.
+// If defined, the enable signal will be used to drive baudrate_o signal
+// Its frequency is 16xbaudrate
+
+// `define UART_HAS_BAUDRATE_OUTPUT
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTHd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTHd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTHd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTHd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTHd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTHd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTHd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTHd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTHd6	// Modem status
+`define UART_REG_SR  `UART_ADDR_WIDTHd7	// Scratch register
+`define UART_REG_DL1	`UART_ADDR_WIDTHd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTHd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3b011	// Receiver Line Status
+`define UART_II_RDA	3b010	// Receiver Data available
+`define UART_II_TI	3b110	// Timeout Indication
+`define UART_II_THRE	3b001	// Transmitter Holding Register empty
+`define UART_II_MS	3b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2b00
+`define UART_FC_4		2b01
+`define UART_FC_8		2b10
+`define UART_FC_14	2b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_defines.r27.v b/cvs/uart16650/uart_defines.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..97ea7f212324baf9fc0f261265faffd4c2ce1d89
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r27.v
@@ -0,0 +1,177 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`define UART_ADDR_WIDTH	3
+
+// Register addresses
+`define UART_REG_RB	3'd0	// receiver buffer
+`define UART_REG_TR  3'd0	// transmitter
+`define UART_REG_IE	3'd1	// Interrupt enable
+`define UART_REG_II  3'd2	// Interrupt identification
+`define UART_REG_FC  3'd2	// FIFO control
+`define UART_REG_LC	3'd3	// Line Control
+`define UART_REG_MC	3'd4	// Modem control
+`define UART_REG_LS  3'd5	// Line status
+`define UART_REG_MS  3'd6	// Modem status
+`define UART_REG_DL1	3'd0	// Divisor latch bytes (1-4)
+`define UART_REG_DL2	3'd1
+`define UART_REG_DL3	3'd4
+`define UART_REG_DL4	3'd5
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define	UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1	2'b00
+`define UART_FC_4	2'b01
+`define UART_FC_8	2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define	UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define	UART_MC_OUT2	3
+`define	UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define	UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define	UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define	UART_MS_CDCD	7
+
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 10 because it has parity and framing error bits
+`define UART_FIFO_REC_WIDTH  10
+
+
+
+
+
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
diff --git a/cvs/uart16650/uart_defines.r29.v b/cvs/uart16650/uart_defines.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..722f1944b7070d39fbdad6710dc8a6c5dd848ea6
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r29.v
@@ -0,0 +1,186 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`define UART_ADDR_WIDTH	3
+
+// Register addresses
+`define UART_REG_RB	3'd0	// receiver buffer
+`define UART_REG_TR  3'd0	// transmitter
+`define UART_REG_IE	3'd1	// Interrupt enable
+`define UART_REG_II  3'd2	// Interrupt identification
+`define UART_REG_FC  3'd2	// FIFO control
+`define UART_REG_LC	3'd3	// Line Control
+`define UART_REG_MC	3'd4	// Modem control
+`define UART_REG_LS  3'd5	// Line status
+`define UART_REG_MS  3'd6	// Modem status
+`define UART_REG_DL1	3'd0	// Divisor latch bytes (1-4)
+`define UART_REG_DL2	3'd1
+`define UART_REG_DL3	3'd4
+`define UART_REG_DL4	3'd5
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define	UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1	2'b00
+`define UART_FC_4	2'b01
+`define UART_FC_8	2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define	UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define	UART_MC_OUT2	3
+`define	UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define	UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define	UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define	UART_MS_CDCD	7
+
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 10 because it has parity and framing error bits
+`define UART_FIFO_REC_WIDTH  10
+
+
+
+
+
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
diff --git a/cvs/uart16650/uart_defines.r45.v b/cvs/uart16650/uart_defines.r45.v
new file mode 100755
index 0000000000000000000000000000000000000000..822373879e1410f9f4021ae9bdbfcd9a7f5aa0e4
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r45.v
@@ -0,0 +1,190 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`define UART_ADDR_WIDTH	3
+
+// Register addresses
+`define UART_REG_RB	3'd0	// receiver buffer
+`define UART_REG_TR  3'd0	// transmitter
+`define UART_REG_IE	3'd1	// Interrupt enable
+`define UART_REG_II  3'd2	// Interrupt identification
+`define UART_REG_FC  3'd2	// FIFO control
+`define UART_REG_LC	3'd3	// Line Control
+`define UART_REG_MC	3'd4	// Modem control
+`define UART_REG_LS  3'd5	// Line status
+`define UART_REG_MS  3'd6	// Modem status
+`define UART_REG_DL1	3'd0	// Divisor latch bytes (1-4)
+`define UART_REG_DL2	3'd1
+`define UART_REG_DL3	3'd4
+`define UART_REG_DL4	3'd5
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1	2'b00
+`define UART_FC_4	2'b01
+`define UART_FC_8	2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+
+
+
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
diff --git a/cvs/uart16650/uart_defines.r48.v b/cvs/uart16650/uart_defines.r48.v
new file mode 100755
index 0000000000000000000000000000000000000000..d3787a795e8417a98189787dc62269b9bcb2bcd4
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r48.v
@@ -0,0 +1,207 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore use to the old version with 8 data bit interface
+// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
+// also, in 8-bit version there'll be no debugging features included
+// `define DATA_BUS_WIDTH_8
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
+`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2'b00
+`define UART_FC_4		2'b01
+`define UART_FC_8		2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_defines.r53.v b/cvs/uart16650/uart_defines.r53.v
new file mode 100755
index 0000000000000000000000000000000000000000..e21bf0f809e36866fa14ba6e170ec1bd8361fcbb
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r53.v
@@ -0,0 +1,217 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.9  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore use to the old version with 8 data bit interface
+// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
+// also, in 8-bit version there'll be no debugging features included
+// `define DATA_BUS_WIDTH_8
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
+`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
+`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2'b00
+`define UART_FC_4		2'b01
+`define UART_FC_8		2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_defines.r75.v b/cvs/uart16650/uart_defines.r75.v
new file mode 100755
index 0000000000000000000000000000000000000000..6ad712f0aeacab5526296925c7655daf9700a70d
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r75.v
@@ -0,0 +1,222 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/12/11 08:55:40  mohor
+// Scratch register define added.
+//
+// Revision 1.9  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore use to the old version with 8 data bit interface
+// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
+// also, in 8-bit version there'll be no debugging features included
+// `define DATA_BUS_WIDTH_8
+
+`define BIG_BYTE_ENDIAN     // Defines endian
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
+`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
+`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2'b00
+`define UART_FC_4		2'b01
+`define UART_FC_8		2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_defines.r79.v b/cvs/uart16650/uart_defines.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..8cd9ef956e838f383b27983b31e6c83d4a7c9f95
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r79.v
@@ -0,0 +1,227 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/12/11 08:55:40  mohor
+// Scratch register define added.
+//
+// Revision 1.9  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore use to the old version with 8 data bit interface
+// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
+// also, in 8-bit version there'll be no debugging features included
+//`define DATA_BUS_WIDTH_8
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Uncomment this if you want your UART to have 
+// 16xBaudrate output port.
+// If defined, the enable signal will be used to drive baudrate_o signal
+// It's frequency is 16xbaudrate
+
+// `define UART_HAS_BAUDRATE_OUTPUT
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
+`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
+`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2'b00
+`define UART_FC_4		2'b01
+`define UART_FC_8		2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_defines.r87.v b/cvs/uart16650/uart_defines.r87.v
new file mode 100755
index 0000000000000000000000000000000000000000..9acc852dfe852425f138f95dce498ab8d0a29cc2
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r87.v
@@ -0,0 +1,243 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.10  2001/12/11 08:55:40  mohor
+// Scratch register define added.
+//
+// Revision 1.9  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore use to the old version with 8 data bit interface
+// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
+// also, in 8-bit version there'll be no debugging features included
+`define DATA_BUS_WIDTH_8
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Uncomment this if you want your UART to have 
+// 16xBaudrate output port.
+// If defined, the enable signal will be used to drive baudrate_o signal
+// It's frequency is 16xbaudrate
+
+// `define UART_HAS_BAUDRATE_OUTPUT
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
+`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
+`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2'b00
+`define UART_FC_4		2'b01
+`define UART_FC_8		2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_defines.r89.v b/cvs/uart16650/uart_defines.r89.v
new file mode 100755
index 0000000000000000000000000000000000000000..66b4a1546db3fab6c4b74058c0ab0edf78758de9
--- /dev/null
+++ b/cvs/uart16650/uart_defines.r89.v
@@ -0,0 +1,247 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_defines.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Defines of the Core                                         ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None                                                        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.12  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.10  2001/12/11 08:55:40  mohor
+// Scratch register define added.
+//
+// Revision 1.9  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.8  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.7  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.6  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.5  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.4  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.3  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// remove comments to restore to use the new version with 8 data bit interface
+// in 32bit-bus mode, the wb_sel_i signal is used to put data in correct place
+// also, in 8-bit version there'll be no debugging features included
+// CAUTION: doesn't work with current version of OR1200
+//`define DATA_BUS_WIDTH_8
+
+`ifdef DATA_BUS_WIDTH_8
+ `define UART_ADDR_WIDTH 3
+ `define UART_DATA_WIDTH 8
+`else
+ `define UART_ADDR_WIDTH 5
+ `define UART_DATA_WIDTH 32
+`endif
+
+// Uncomment this if you want your UART to have
+// 16xBaudrate output port.
+// If defined, the enable signal will be used to drive baudrate_o signal
+// It's frequency is 16xbaudrate
+
+// `define UART_HAS_BAUDRATE_OUTPUT
+
+// Register addresses
+`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
+`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
+`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
+`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
+`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
+`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
+`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
+`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
+`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
+`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
+`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
+`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
+
+// Interrupt Enable register bits
+`define UART_IE_RDA	0	// Received Data available interrupt
+`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
+`define UART_IE_RLS	2	// Receiver Line Status Interrupt
+`define UART_IE_MS	3	// Modem Status Interrupt
+
+// Interrupt Identification register bits
+`define UART_II_IP	0	// Interrupt pending when 0
+`define UART_II_II	3:1	// Interrupt identification
+
+// Interrupt identification values for bits 3:1
+`define UART_II_RLS	3'b011	// Receiver Line Status
+`define UART_II_RDA	3'b010	// Receiver Data available
+`define UART_II_TI	3'b110	// Timeout Indication
+`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
+`define UART_II_MS	3'b000	// Modem Status
+
+// FIFO Control Register bits
+`define UART_FC_TL	1:0	// Trigger level
+
+// FIFO trigger level values
+`define UART_FC_1		2'b00
+`define UART_FC_4		2'b01
+`define UART_FC_8		2'b10
+`define UART_FC_14	2'b11
+
+// Line Control register bits
+`define UART_LC_BITS	1:0	// bits in character
+`define UART_LC_SB	2	// stop bits
+`define UART_LC_PE	3	// parity enable
+`define UART_LC_EP	4	// even parity
+`define UART_LC_SP	5	// stick parity
+`define UART_LC_BC	6	// Break control
+`define UART_LC_DL	7	// Divisor Latch access bit
+
+// Modem Control register bits
+`define UART_MC_DTR	0
+`define UART_MC_RTS	1
+`define UART_MC_OUT1	2
+`define UART_MC_OUT2	3
+`define UART_MC_LB	4	// Loopback mode
+
+// Line Status Register bits
+`define UART_LS_DR	0	// Data ready
+`define UART_LS_OE	1	// Overrun Error
+`define UART_LS_PE	2	// Parity Error
+`define UART_LS_FE	3	// Framing Error
+`define UART_LS_BI	4	// Break interrupt
+`define UART_LS_TFE	5	// Transmit FIFO is empty
+`define UART_LS_TE	6	// Transmitter Empty indicator
+`define UART_LS_EI	7	// Error indicator
+
+// Modem Status Register bits
+`define UART_MS_DCTS	0	// Delta signals
+`define UART_MS_DDSR	1
+`define UART_MS_TERI	2
+`define UART_MS_DDCD	3
+`define UART_MS_CCTS	4	// Complement signals
+`define UART_MS_CDSR	5
+`define UART_MS_CRI	6
+`define UART_MS_CDCD	7
+
+// FIFO parameter defines
+
+`define UART_FIFO_WIDTH	8
+`define UART_FIFO_DEPTH	16
+`define UART_FIFO_POINTER_W	4
+`define UART_FIFO_COUNTER_W	5
+// receiver fifo has width 11 because it has break, parity and framing error bits
+`define UART_FIFO_REC_WIDTH  11
+
+
+`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
+`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
+`define FAST_TEST   1           // 64/1024 packets are sent
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_receiver.r100.v b/cvs/uart16650/uart_receiver.r100.v
new file mode 100755
index 0000000000000000000000000000000000000000..65b504883399ce13798be1d4c090bb347a82bcfd
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r100.v
@@ -0,0 +1,482 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.29  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.28  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.27  2001/12/30 20:39:13  mohor
+// More than one character was stored in case of break. End of the break
+// was not detected correctly.
+//
+// Revision 1.26  2001/12/20 13:28:27  mohor
+// Missing declaration of rf_push_q fixed.
+//
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			rcounter16 	  <= #1 4'b1110;
+			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+			end
+		end
+	sr_rec_start :	begin
+  			rf_push 			  <= #1 1'b0;
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_idle;
+          end
+        else
+          begin
+       			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+      			rcounter16 	  <= #1 4'b1110;
+    				rstate 		  <= #1 sr_rec_start;
+          end
+                      
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+	if (srx_pad_i)
+		counter_b <= #1 brc_value; // character time length - 1
+	else
+	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
+		counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r103.v b/cvs/uart16650/uart_receiver.r103.v
new file mode 100755
index 0000000000000000000000000000000000000000..f3ca88c260c6b7c75b9ef4ed632bbfe8c3513fa3
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r103.v
@@ -0,0 +1,482 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.29  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.28  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.27  2001/12/30 20:39:13  mohor
+// More than one character was stored in case of break. End of the break
+// was not detected correctly.
+//
+// Revision 1.26  2001/12/20 13:28:27  mohor
+// Missing declaration of rf_push_q fixed.
+//
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			rcounter16 	  <= #1 4'b1110;
+			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+			end
+		end
+	sr_rec_start :	begin
+  			rf_push 			  <= #1 1'b0;
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_idle;
+          end
+        else if(~rframing_error)  // There's always a framing before break_error -> wait for break or srx_pad_i
+          begin
+       			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+      			rcounter16 	  <= #1 4'b1110;
+    				rstate 		  <= #1 sr_rec_start;
+          end
+                      
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+	if (srx_pad_i)
+		counter_b <= #1 brc_value; // character time length - 1
+	else
+	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
+		counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r106.v b/cvs/uart16650/uart_receiver.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..f3ca88c260c6b7c75b9ef4ed632bbfe8c3513fa3
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r106.v
@@ -0,0 +1,482 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.29  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.28  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.27  2001/12/30 20:39:13  mohor
+// More than one character was stored in case of break. End of the break
+// was not detected correctly.
+//
+// Revision 1.26  2001/12/20 13:28:27  mohor
+// Missing declaration of rf_push_q fixed.
+//
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			rcounter16 	  <= #1 4'b1110;
+			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+			end
+		end
+	sr_rec_start :	begin
+  			rf_push 			  <= #1 1'b0;
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_idle;
+          end
+        else if(~rframing_error)  // There's always a framing before break_error -> wait for break or srx_pad_i
+          begin
+       			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+      			rcounter16 	  <= #1 4'b1110;
+    				rstate 		  <= #1 sr_rec_start;
+          end
+                      
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+	if (srx_pad_i)
+		counter_b <= #1 brc_value; // character time length - 1
+	else
+	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
+		counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r27.v b/cvs/uart16650/uart_receiver.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..0dbad6f003bf14f9a3c5f0f0e3225eed2ed629da
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r27.v
@@ -0,0 +1,341 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       rx_lsr_mask;
+
+output	[5:0]			counter_t;
+output	[3:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(rx_lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rstate <= #1 sr_idle;
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 3'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+//				2'b00: rparity_error <= #1 ~rparity_xor;  // no error if parity 1
+//				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+//				2'b10: rparity_error <= #1 rparity_xor;   // error if parity is odd
+//				2'b11: rparity_error <= #1 rparity;	  // parity should be sticked to 0
+				2'b00: rparity_error <= #1 rparity_xor;  // no error if parity 1
+				2'b01: rparity_error <= #1 1'b1;      // parity should sticked to 1
+				2'b10: rparity_error <= #1 ~rparity_xor;   // error if parity is odd
+				2'b11: rparity_error <= #1 1'b0;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rf_data_in <= #1 {rshift, rparity_error, rframing_error};
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[3:0]	counter_b;	// counts the 1 (idle) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 4'd11;
+	else
+	if (enable)  // only work on enable times
+		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
+			counter_b <= #1 4'd11; // maximum character time length - 1
+		else
+			if (counter_b != 4'b0)            // break reached
+				counter_b <= #1 counter_b - 4'd1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[5:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 6'd44;
+	else
+	if (enable)
+		if(rf_push || rf_pop || rda_int) // counter is reset when RX FIFO is accessed or above trigger level
+			counter_t <= #1 6'd44;
+		else
+			if (counter_t != 6'b0)  // we don't want to underflow
+				counter_t <= #1 counter_t - 6'd1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r29.v b/cvs/uart16650/uart_receiver.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..80b16079d561df5b339f462104e0b163fb8866b8
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r29.v
@@ -0,0 +1,348 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       rx_lsr_mask;
+
+output	[5:0]			counter_t;
+output	[3:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(rx_lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rstate <= #1 sr_idle;
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 3'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+//				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+				2'b00: rparity_error <= #1  rparity_xor != rparity;  // no error if parity 1
+				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+				2'b10: rparity_error <= #1 ~rparity_xor != rparity;   // error if parity is odd
+				2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[3:0]	counter_b;	// counts the 1 (idle) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 4'd11;
+	else
+	if (enable)  // only work on enable times
+		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
+			counter_b <= #1 4'd11; // maximum character time length - 1
+		else
+			if (counter_b != 4'b0)            // break reached
+				counter_b <= #1 counter_b - 4'd1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[5:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 6'd44;
+	else
+	if (enable)
+		if(rf_push || rf_pop || rda_int) // counter is reset when RX FIFO is accessed or above trigger level
+			counter_t <= #1 6'd44;
+		else
+			if (counter_t != 6'b0)  // we don't want to underflow
+				counter_t <= #1 counter_t - 6'd1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r33.v b/cvs/uart16650/uart_receiver.r33.v
new file mode 100755
index 0000000000000000000000000000000000000000..4566e189e6ca2d9dc59c2cacd39bb78ecfcb905a
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r33.v
@@ -0,0 +1,355 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       rx_lsr_mask;
+
+output	[5:0]			counter_t;
+output	[3:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(rx_lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rstate <= #1 sr_idle;
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 3'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+//				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+				2'b00: rparity_error <= #1  rparity_xor != rparity;  // no error if parity 1
+				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+				2'b10: rparity_error <= #1 ~rparity_xor != rparity;   // error if parity is odd
+				2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[3:0]	counter_b;	// counts the 1 (idle) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 4'd11;
+	else
+	if (enable)  // only work on enable times
+		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
+			counter_b <= #1 4'd11; // maximum character time length - 1
+		else
+			if (counter_b != 4'b0)            // break reached
+				counter_b <= #1 counter_b - 4'd1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[5:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 6'd44;
+	else
+	if (enable)
+		if(rf_push || rf_pop || rda_int) // counter is reset when RX FIFO is accessed or above trigger level
+			counter_t <= #1 6'd44;
+		else
+			if (counter_t != 6'b0)  // we don't want to underflow
+				counter_t <= #1 counter_t - 6'd1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r35.v b/cvs/uart16650/uart_receiver.r35.v
new file mode 100755
index 0000000000000000000000000000000000000000..02675a9a06dc3a4edd39c31de6df5afffecb03a3
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r35.v
@@ -0,0 +1,360 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       rx_lsr_mask;
+
+output	[9:0]			counter_t;
+output	[7:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(rx_lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rstate <= #1 sr_idle;
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 3'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+//				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+				2'b00: rparity_error <= #1  rparity_xor != rparity;  // no error if parity 1
+				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+				2'b10: rparity_error <= #1 ~rparity_xor != rparity;   // error if parity is odd
+				2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[7:0]	counter_b;	// counts the 1 (idle) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd191;
+	else
+	if (enable)  // only work on enable times
+		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
+			counter_b <= #1 8'd191; // maximum character time length - 1
+		else
+			if (counter_b != 8'b0 && counter_b != 8'hff)            // break reached
+				counter_b <= #1 counter_b - 8'd1;  // decrement break counter
+			else if (rx_lsr_mask)
+				counter_b <= #1 8'hff; /// this won't generate interrupt status after lsr was read
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd767;
+	else
+	if (enable)
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 10'd767;
+		else
+			if (counter_t != 10'b0)  // we don't want to underflow
+				counter_t <= #1 counter_t - 10'd1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r37.v b/cvs/uart16650/uart_receiver.r37.v
new file mode 100755
index 0000000000000000000000000000000000000000..1c83d03d5abef55efb71b61a243914e8385f7f5b
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r37.v
@@ -0,0 +1,360 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[7:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rstate <= #1 sr_idle;
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 3'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+//				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[7:0]	counter_b;	// counts the 1 (idle) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd191;
+	else
+	if (enable)  // only work on enable times
+		if (!srx_pad_i || rstate == sr_idle)
+			counter_b <= #1 8'd191; // maximum character time length - 1
+		else
+			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 8'd1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd767;
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 10'd767;
+		else
+			if (	enable && counter_t != 10'b0)  // we don't want to underflow
+				counter_t <= #1 counter_t - 10'd1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r39.v b/cvs/uart16650/uart_receiver.r39.v
new file mode 100755
index 0000000000000000000000000000000000000000..e1b3afb83c5dd28b52fc34ee0d9abe9d2ae4ded4
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r39.v
@@ -0,0 +1,363 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[7:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[7:0]	counter_b;	// counts the 1 (idle) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd191;
+	else
+  if(lsr_mask)
+		counter_b <= #1 8'd191;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 8'd191; // maximum character time length - 1
+		else
+  	if (counter_b != 8'b0)            // break not reached it
+		  counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd767;
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 10'd767;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r40.v b/cvs/uart16650/uart_receiver.r40.v
new file mode 100755
index 0000000000000000000000000000000000000000..2edf1389306e6df3db3f79342800256121f02671
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r40.v
@@ -0,0 +1,367 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[7:0]			counter_b;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate <= #1 sr_rec_start;
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd191;
+	else
+  if(lsr_mask)
+		counter_b <= #1 8'd191;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 8'd191; // maximum character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd767;
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 10'd767;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r45.v b/cvs/uart16650/uart_receiver.r45.v
new file mode 100755
index 0000000000000000000000000000000000000000..65683cd872c6f710783993cd254c08e2d8a876e5
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r45.v
@@ -0,0 +1,380 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+	  begin
+		  rstate 		 <= #1 sr_idle;
+		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+		  rf_push 		 <= #1 1'b1;
+	  end
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd191;
+	else
+  if(lsr_mask)
+		counter_b <= #1 8'd191;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 8'd191; // maximum character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd767;
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 10'd767;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r46.v b/cvs/uart16650/uart_receiver.r46.v
new file mode 100755
index 0000000000000000000000000000000000000000..366ff276392aa906c33b8b5d428286e7c81b62f7
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r46.v
@@ -0,0 +1,389 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+	  begin
+		  rstate 		 <= #1 sr_idle;
+		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+		  rf_push 		 <= #1 1'b1;
+	  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd191;
+	else
+  if(lsr_mask)
+		counter_b <= #1 8'd191;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 8'd191; // maximum character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd767;
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 10'd767;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r47.v b/cvs/uart16650/uart_receiver.r47.v
new file mode 100755
index 0000000000000000000000000000000000000000..25cecc8d309c15839ea75c49fababc98ae25a973
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r47.v
@@ -0,0 +1,409 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+	  begin
+		  rstate 		 <= #1 sr_idle;
+		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+		  rf_push 		 <= #1 1'b1;
+	  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+  if(lsr_mask)
+		counter_b <= #1 brc_value;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r48.v b/cvs/uart16650/uart_receiver.r48.v
new file mode 100755
index 0000000000000000000000000000000000000000..2f0fdc22f97564aaf3e7f69347388b1f500992c9
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r48.v
@@ -0,0 +1,413 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+	  begin
+		  rstate 		 <= #1 sr_idle;
+		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+		  rf_push 		 <= #1 1'b1;
+	  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+  if(lsr_mask)
+		counter_b <= #1 brc_value;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r50.v b/cvs/uart16650/uart_receiver.r50.v
new file mode 100755
index 0000000000000000000000000000000000000000..9e024df7bda0a313eac7acbab1a32b63b5a81c78
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r50.v
@@ -0,0 +1,423 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+	  begin
+		  rstate 		 <= #1 sr_idle;
+		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+		  rf_push 		 <= #1 1'b1;
+	  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+				rf_push    <= #1 1'b1;
+				rstate     <= #1 sr_last;
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+  if(lsr_mask)
+		counter_b <= #1 brc_value;
+  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r51.v b/cvs/uart16650/uart_receiver.r51.v
new file mode 100755
index 0000000000000000000000000000000000000000..7d28999b2ab3a9bbf5060f1e85f0807d67793a59
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r51.v
@@ -0,0 +1,436 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r57.v b/cvs/uart16650/uart_receiver.r57.v
new file mode 100755
index 0000000000000000000000000000000000000000..2643cc838bbe98a68f9feae5a2e86c8e3128affc
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r57.v
@@ -0,0 +1,439 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_underrun;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.underrun(	rf_underrun	),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r61.v b/cvs/uart16650/uart_receiver.r61.v
new file mode 100755
index 0000000000000000000000000000000000000000..accd0e37a916a34408a8ec7a9ccee4744de01ede
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r61.v
@@ -0,0 +1,441 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r63.v b/cvs/uart16650/uart_receiver.r63.v
new file mode 100755
index 0000000000000000000000000000000000000000..90990ffa613493ac7669c31fa40d3702f2634f85
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r63.v
@@ -0,0 +1,446 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rda_int;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r64.v b/cvs/uart16650/uart_receiver.r64.v
new file mode 100755
index 0000000000000000000000000000000000000000..8f89e2226b1fc2108f4a683611214cdf8e7bede2
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r64.v
@@ -0,0 +1,448 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r66.v b/cvs/uart16650/uart_receiver.r66.v
new file mode 100755
index 0000000000000000000000000000000000000000..8b9f9add266fe8cb69d2a2d3eb0333384c932445
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r66.v
@@ -0,0 +1,463 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r67.v b/cvs/uart16650/uart_receiver.r67.v
new file mode 100755
index 0000000000000000000000000000000000000000..a65a09527ea84414c0c82d61488a374400834db5
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r67.v
@@ -0,0 +1,467 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
+//	  begin
+//		  rstate 		 <= #1 sr_idle;
+//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+//		  rf_push 		 <= #1 1'b1;
+//	  end
+//  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+//				if (rcounter16_eq_1)
+				if (rcounter16_eq_1 & srx_pad_i)    // igor
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+//  if(lsr_mask)                          igor
+//		counter_b <= #1 brc_value;
+//  else
+	if (enable)  // only work on enable times
+		if (srx_pad_i)
+			counter_b <= #1 brc_value; // character time length - 1
+		else
+  			if (counter_b != 8'b0)            // break not reached it
+				counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r69.v b/cvs/uart16650/uart_receiver.r69.v
new file mode 100755
index 0000000000000000000000000000000000000000..5a2a84e033023802063f2d2a3d035f2f985a65e1
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r69.v
@@ -0,0 +1,458 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.26  2001/12/20 13:28:27  mohor
+// Missing declaration of rf_push_q fixed.
+//
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+parameter  sr_last 					= 4'd11;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+				rcounter16 	  <= #1 4'b1110;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_last;
+          end
+            
+			end
+	sr_last :	begin
+				if (rcounter16_eq_1 & srx_pad_i | break_error)
+					rstate <= #1 sr_idle;
+				rcounter16 <= #1 rcounter16_minus_1;
+				rf_push    <= #1 1'b0;
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+	if (srx_pad_i)
+		counter_b <= #1 brc_value; // character time length - 1
+	else
+	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
+		counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r79.v b/cvs/uart16650/uart_receiver.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..9e516d98ff2712c38ebe3f866c97c6a70f49b8f0
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r79.v
@@ -0,0 +1,455 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.27  2001/12/30 20:39:13  mohor
+// More than one character was stored in case of break. End of the break
+// was not detected correctly.
+//
+// Revision 1.26  2001/12/20 13:28:27  mohor
+// Missing declaration of rf_push_q fixed.
+//
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+//`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			rcounter16 	  <= #1 4'b1110;
+			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_idle;
+          end
+            
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+	if (srx_pad_i)
+		counter_b <= #1 brc_value; // character time length - 1
+	else
+	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
+		counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_receiver.r84.v b/cvs/uart16650/uart_receiver.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..5c018fd0255afb365e3f78b0278115291c1973b8
--- /dev/null
+++ b/cvs/uart16650/uart_receiver.r84.v
@@ -0,0 +1,471 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_receiver.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.28  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.27  2001/12/30 20:39:13  mohor
+// More than one character was stored in case of break. End of the break
+// was not detected correctly.
+//
+// Revision 1.26  2001/12/20 13:28:27  mohor
+// Missing declaration of rf_push_q fixed.
+//
+// Revision 1.25  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.24  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.23  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.22  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.21  2001/12/13 10:31:16  mohor
+// timeout irq must be set regardless of the rda irq (rda irq does not reset the
+// timeout counter).
+//
+// Revision 1.20  2001/12/10 19:52:05  gorban
+// Igor fixed break condition bugs
+//
+// Revision 1.19  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.18  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.17  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.16  2001/11/27 22:17:09  gorban
+// Fixed bug that prevented synthesis in uart_receiver.v
+//
+// Revision 1.15  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.14  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]	lcr;
+input				rf_pop;
+input				srx_pad_i;
+input				enable;
+input				rx_reset;
+input       lsr_mask;
+
+output	[9:0]			counter_t;
+output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+output				rf_overrun;
+output				rf_error_bit;
+output [3:0] 		rstate;
+output 				rf_push_pulse;
+
+reg	[3:0]	rstate;
+reg	[3:0]	rcounter16;
+reg	[2:0]	rbit_counter;
+reg	[7:0]	rshift;			// receiver shift register
+reg		rparity;		// received parity
+reg		rparity_error;
+reg		rframing_error;		// framing error flag
+reg		rbit_in;
+reg		rparity_xor;
+reg	[7:0]	counter_b;	// counts the 0 (low) signals
+reg   rf_push_q;
+
+// RX FIFO signals
+reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire      rf_push_pulse;
+reg				rf_push;
+wire				rf_pop;
+wire				rf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire 				break_error = (counter_b == 0);
+
+// RX FIFO instance
+uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	rf_data_in	),
+	.data_out(	rf_data_out	),
+	.push(		rf_push_pulse		),
+	.pop(		rf_pop		),
+	.overrun(	rf_overrun	),
+	.count(		rf_count	),
+	.error_bit(	rf_error_bit	),
+	.fifo_reset(	rx_reset	),
+	.reset_status(lsr_mask)
+);
+
+wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
+wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
+wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
+
+wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
+
+parameter  sr_idle 					= 4'd0;
+parameter  sr_rec_start 			= 4'd1;
+parameter  sr_rec_bit 				= 4'd2;
+parameter  sr_rec_parity			= 4'd3;
+parameter  sr_rec_stop 				= 4'd4;
+parameter  sr_check_parity 		= 4'd5;
+parameter  sr_rec_prepare 			= 4'd6;
+parameter  sr_end_bit				= 4'd7;
+parameter  sr_ca_lc_parity	      = 4'd8;
+parameter  sr_wait1 					= 4'd9;
+parameter  sr_push 					= 4'd10;
+
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+     rstate 			<= #1 sr_idle;
+	  rbit_in 				<= #1 1'b0;
+	  rcounter16 			<= #1 0;
+	  rbit_counter 		<= #1 0;
+	  rparity_xor 		<= #1 1'b0;
+	  rframing_error 	<= #1 1'b0;
+	  rparity_error 		<= #1 1'b0;
+	  rparity 				<= #1 1'b0;
+	  rshift 				<= #1 0;
+	  rf_push 				<= #1 1'b0;
+	  rf_data_in 			<= #1 0;
+  end
+  else
+  if (enable)
+  begin
+	case (rstate)
+	sr_idle : begin
+			rf_push 			  <= #1 1'b0;
+			rf_data_in 	  <= #1 0;
+			rcounter16 	  <= #1 4'b1110;
+			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
+			begin
+				rstate 		  <= #1 sr_rec_start;
+			end
+		end
+	sr_rec_start :	begin
+				if (rcounter16_eq_7)    // check the pulse
+					if (srx_pad_i==1'b1)   // no start bit
+						rstate <= #1 sr_idle;
+					else            // start bit detected
+						rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_prepare:begin
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : rbit_counter <= #1 3'b100;
+				2'b01 : rbit_counter <= #1 3'b101;
+				2'b10 : rbit_counter <= #1 3'b110;
+				2'b11 : rbit_counter <= #1 3'b111;
+				endcase
+				if (rcounter16_eq_0)
+				begin
+					rstate		<= #1 sr_rec_bit;
+					rcounter16	<= #1 4'b1110;
+					rshift		<= #1 0;
+				end
+				else
+					rstate <= #1 sr_rec_prepare;
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_rec_bit :	begin
+				if (rcounter16_eq_0)
+					rstate <= #1 sr_end_bit;
+				if (rcounter16_eq_7) // read the bit
+					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
+					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
+					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
+					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
+					endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_end_bit :   begin
+				if (rbit_counter==3'b0) // no more bits in word
+					if (lcr[`UART_LC_PE]) // choose state based on parity
+						rstate <= #1 sr_rec_parity;
+					else
+					begin
+						rstate <= #1 sr_rec_stop;
+						rparity_error <= #1 1'b0;  // no parity - no error :)
+					end
+				else		// else we have more bits to read
+				begin
+					rstate <= #1 sr_rec_bit;
+					rbit_counter <= #1 rbit_counter - 1'b1;
+				end
+				rcounter16 <= #1 4'b1110;
+			end
+	sr_rec_parity: begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rparity <= #1 srx_pad_i;
+					rstate <= #1 sr_ca_lc_parity;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_ca_lc_parity : begin    // rcounter equals 6
+				rcounter16  <= #1 rcounter16_minus_1;
+				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
+				rstate      <= #1 sr_check_parity;
+			  end
+	sr_check_parity: begin	  // rcounter equals 5
+				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
+					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
+					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
+					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
+				endcase
+				rcounter16 <= #1 rcounter16_minus_1;
+				rstate <= #1 sr_wait1;
+			  end
+	sr_wait1 :	if (rcounter16_eq_0)
+			begin
+				rstate <= #1 sr_rec_stop;
+				rcounter16 <= #1 4'b1110;
+			end
+			else
+				rcounter16 <= #1 rcounter16_minus_1;
+	sr_rec_stop :	begin
+				if (rcounter16_eq_7)	// read the parity
+				begin
+					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
+					rstate <= #1 sr_push;
+				end
+				rcounter16 <= #1 rcounter16_minus_1;
+			end
+	sr_push :	begin
+///////////////////////////////////////
+//				$display($time, ": received: %b", rf_data_in);
+        if(srx_pad_i | break_error)
+          begin
+            if(break_error)
+        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
+            else
+        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
+      		  rf_push 		  <= #1 1'b1;
+    				rstate        <= #1 sr_idle;
+          end
+            
+			end
+	default : rstate <= #1 sr_idle;
+	endcase
+  end  // if (enable)
+end // always of receiver
+
+always @ (posedge clk or posedge wb_rst_i)
+begin
+  if(wb_rst_i)
+    rf_push_q <= 0;
+  else
+    rf_push_q <= #1 rf_push;
+end
+
+assign rf_push_pulse = rf_push & ~rf_push_q;
+
+  
+//
+// Break condition detection.
+// Works in conjuction with the receiver state machine
+
+reg 	[9:0]	toc_value; // value to be set to timeout counter
+
+always @(lcr)
+	case (lcr[3:0])
+		4'b0000										: toc_value = 447; // 7 bits
+		4'b0100										: toc_value = 479; // 7.5 bits
+		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
+		4'b1100										: toc_value = 543; // 8.5 bits
+		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
+		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
+		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
+		4'b1111										: toc_value = 767; // 12 bits
+	endcase // case(lcr[3:0])
+
+wire [7:0] 	brc_value; // value to be set to break counter
+assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_b <= #1 8'd159;
+	else
+	if (srx_pad_i)
+		counter_b <= #1 brc_value; // character time length - 1
+	else
+	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
+		counter_b <= #1 counter_b - 1;  // decrement break counter
+end // always of break condition detection
+
+///
+/// Timeout condition detection
+reg	[9:0]	counter_t;	// counts the timeout condition clocks
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		counter_t <= #1 10'd639; // 10 bits for the default 8N1
+	else
+		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
+			counter_t <= #1 toc_value;
+		else
+		if (enable && counter_t != 10'b0)  // we don't want to underflow
+			counter_t <= #1 counter_t - 1;		
+end
+	
+endmodule
diff --git a/cvs/uart16650/uart_regs.r105.v b/cvs/uart16650/uart_regs.r105.v
new file mode 100755
index 0000000000000000000000000000000000000000..f906e9abcca2f4387626d3fe52384c8c78f3e898
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r105.v
@@ -0,0 +1,893 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.41  2004/05/21 11:44:41  tadejm
+// Added synchronizer flops for RX input.
+//
+// Revision 1.40  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.39  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.38  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.37  2001/12/27 13:24:09  mohor
+// lsr[7] was not showing overrun errors.
+//
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+assign baud_o = enable; // baud_o is actually the enable signal
+`endif
+
+
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+wire 										srx_pad;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+wire serial_out;
+
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
+
+  // Synchronizing and sampling serial RX input
+  uart_sync_flops    i_uart_sync_flops
+  (
+    .rst_i           (wb_rst_i),
+    .clk_i           (clk),
+    .stage1_rst_i    (1'b0),
+    .stage1_clk_en_i (1'b1),
+    .async_dat_i     (srx_pad_i),
+    .sync_dat_o      (srx_pad)
+  );
+  defparam i_uart_sync_flops.width      = 1;
+  defparam i_uart_sync_flops.init_value = 1'b1;
+
+// handle loopback
+wire serial_in = loopback ? serial_out : srx_pad;
+assign stx_pad_o = loopback ? 1'b1 : serial_out;
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0) && (|rf_count);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r106.v b/cvs/uart16650/uart_regs.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..f906e9abcca2f4387626d3fe52384c8c78f3e898
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r106.v
@@ -0,0 +1,893 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.41  2004/05/21 11:44:41  tadejm
+// Added synchronizer flops for RX input.
+//
+// Revision 1.40  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.39  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.38  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.37  2001/12/27 13:24:09  mohor
+// lsr[7] was not showing overrun errors.
+//
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+assign baud_o = enable; // baud_o is actually the enable signal
+`endif
+
+
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+wire 										srx_pad;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+wire serial_out;
+
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
+
+  // Synchronizing and sampling serial RX input
+  uart_sync_flops    i_uart_sync_flops
+  (
+    .rst_i           (wb_rst_i),
+    .clk_i           (clk),
+    .stage1_rst_i    (1'b0),
+    .stage1_clk_en_i (1'b1),
+    .async_dat_i     (srx_pad_i),
+    .sync_dat_o      (srx_pad)
+  );
+  defparam i_uart_sync_flops.width      = 1;
+  defparam i_uart_sync_flops.init_value = 1'b1;
+
+// handle loopback
+wire serial_in = loopback ? serial_out : srx_pad;
+assign stx_pad_o = loopback ? 1'b1 : serial_out;
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0) && (|rf_count);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r27.v b/cvs/uart16650/uart_regs.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..3ce446a044668012ac9326275c5ae3ada48441c5
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r27.v
@@ -0,0 +1,532 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	enable,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		enable;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[5:0]			counter_t;
+wire	[3:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+/*
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+*/
+
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr[`UART_FC_TL])
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		dlc    <= #1 0;
+		enable <= #1 1'b0;
+	end
+	else
+	begin
+		if (start_dlc)
+		begin
+			enable <= #1 1'b0;
+			dlc    <= #1 dl;
+		end
+		else
+		begin
+			if (dl!=0)
+			begin
+				if ( (dlc-1)==0 )
+				begin
+					enable <= #1 1'b1;
+					dlc <= #1 dl;
+				end
+				else
+				begin
+					enable <= #1 1'b0;
+					dlc <= #1 dlc - 1;
+				end
+			end
+			else
+			begin
+				dlc <= #1 0;
+				enable <= #1 1'b0;
+			end
+		end
+	end
+end
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r29.v b/cvs/uart16650/uart_regs.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..cb3bd43e83082ed7a78cf398edba1b11c37d41e5
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r29.v
@@ -0,0 +1,531 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[5:0]			counter_t;
+wire	[3:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+/*
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+*/
+
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr[`UART_FC_TL])
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r31.v b/cvs/uart16650/uart_regs.r31.v
new file mode 100755
index 0000000000000000000000000000000000000000..27aae6c9cf419f9ddbc98598a47aa6859f57d5c6
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r31.v
@@ -0,0 +1,535 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[5:0]			counter_t;
+wire	[3:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+/*
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+*/
+
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r32.v b/cvs/uart16650/uart_regs.r32.v
new file mode 100755
index 0000000000000000000000000000000000000000..1654db90057b3c420a49d561cd2c43c0a5fb6f75
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r32.v
@@ -0,0 +1,539 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[5:0]			counter_t;
+wire	[3:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+
+/*
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+*/
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r33.v b/cvs/uart16650/uart_regs.r33.v
new file mode 100755
index 0000000000000000000000000000000000000000..bbb8a7d44dfd716b913f2f1546e723ef9f72cdbd
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r33.v
@@ -0,0 +1,545 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[5:0]			counter_t;
+wire	[3:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+
+/*
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+*/
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r34.v b/cvs/uart16650/uart_regs.r34.v
new file mode 100755
index 0000000000000000000000000000000000000000..749053af32e2413c17ab5849a172f64913934299
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r34.v
@@ -0,0 +1,548 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[5:0]			counter_t;
+wire	[3:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+
+/*
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+*/
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r35.v b/cvs/uart16650/uart_regs.r35.v
new file mode 100755
index 0000000000000000000000000000000000000000..f1d539989c2c3b31bde859210a2610d7c998812d
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r35.v
@@ -0,0 +1,551 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[9:0]			counter_t;
+wire	[7:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+
+/*
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+*/
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==8'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 10'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r36.v b/cvs/uart16650/uart_regs.r36.v
new file mode 100755
index 0000000000000000000000000000000000000000..32da00cebadb2eb9abc9972c022b71449b53a150
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r36.v
@@ -0,0 +1,554 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input		clk;
+input		wb_rst_i;
+input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+input	[7:0]	wb_dat_i;
+output	[7:0]	wb_dat_o;
+input		wb_we_i;
+input   wb_re_i;
+
+output		stx_pad_o;
+input		srx_pad_i;
+
+input	[3:0]	modem_inputs;
+output		rts_pad_o;
+output		dtr_pad_o;
+output		int_o;
+
+wire	[3:0]	modem_inputs;
+reg		enable;
+wire		stx_pad_o;		// received from transmitter module
+wire		srx_pad_i;
+
+reg	[7:0]	wb_dat_o;
+
+wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
+wire	[7:0]	wb_dat_i;
+
+
+reg	[3:0]	ier;
+reg	[3:0]	iir;
+reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg	[4:0]	mcr;
+reg	[7:0]	lcr;
+reg	[7:0]	lsr;
+reg	[7:0]	msr;
+reg	[15:0]	dl;  // 32-bit divisor latch
+reg		start_dlc; // activate dlc on writing to UART_DL1
+reg		lsr_mask;
+reg		msi_reset; // reset MSR 4 lower bits indicator
+reg		threi_clear; // THRE interrupt clear flag
+reg	[15:0]	dlc;  // 32-bit divisor latch counter
+reg		int_o;
+
+reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
+reg		rx_reset;
+reg		tx_reset;
+
+wire		dlab;			   // divisor latch access bit
+wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire		loopback;		   // loopback bit (MCR bit 4)
+wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+//
+// ASSINGS
+//
+assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign dlab = lcr[`UART_LC_DL];
+assign loopback = mcr[4];
+
+// assign modem outputs
+assign	rts_pad_o = mcr[`UART_MC_RTS];
+assign	dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+reg	rls_int;  // receiver line status interrupt
+reg	rda_int;  // receiver data available interrupt
+reg	ti_int;   // timeout indicator interrupt
+reg	thre_int; // transmitter holding register empty interrupt
+reg	ms_int;   // modem status interrupt
+
+// FIFO signals
+reg				tf_push;
+reg				rf_pop;
+wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
+wire				rf_error_bit; // an error (parity or framing) is inside the fifo
+wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+wire	[2:0]			state;
+wire	[9:0]			counter_t;
+wire	[7:0]			counter_b;
+wire            rx_lsr_mask;
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase
+    else
+	wb_dat_o <= #1 8'b0;
+end
+
+/*
+always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
+begin
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+        			wb_dat_o <= dl[`UART_DL1];
+		        else
+			        wb_dat_o <= rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= lcr;
+	`UART_REG_LS	: wb_dat_o <= lsr;
+	`UART_REG_MS	: wb_dat_o <= msr;
+	default:  wb_dat_o <= 8'b0; // ??
+	endcase
+end
+*/
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+// lsr_mask signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask <= #1 0;
+	else
+	if (lsr_mask)
+		lsr_mask <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
+		lsr_mask <= #1 1; // reset bits in the Line Status Register
+end
+
+assign rx_lsr_mask = lsr_mask;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin // clear rx_reset, tx_reset signals when not written to
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr <= #1 8'b01100000;
+	else
+	if (lsr_mask)
+		lsr <= #1 lsr & 8'b00000001;
+	else
+	begin
+		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
+		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
+		lsr[2] <= #1 rf_data_out[1]; // parity error bit
+		lsr[3] <= #1 rf_data_out[0]; // framing error bit
+		lsr[4] <= #1 (counter_b==8'b0); // break counter reached 0
+		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
+		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+		lsr[7] <= #1 rf_error_bit;
+	end
+end
+
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+  if (start_dlc | ~ (|dlc))
+  	dlc <= #1 dl - 1;               // preset counter
+	else
+		dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+  if (|dl & ~(|dlc))     // dl>0 & dlc==0
+		enable <= #1 1'b1;
+  else
+		enable <= #1 1'b0;
+end
+
+
+
+
+
+
+
+//
+//	INTERRUPT LOGIC
+//
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		rls_int  <= #1 1'b0;
+		rda_int  <= #1 1'b0;
+		ti_int   <= #1 1'b0;
+		thre_int <= #1 1'b0;
+		ms_int   <= #1 1'b0;
+	end
+	else
+	begin
+		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
+		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 10'b0);
+	end
+end
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
+			int_o <= #1 1'b1;
+		else
+			int_o <= #1 1'b0;
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int)  // interrupt occured and is enabled  (not masked)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end
+	else
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ti_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (thre_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else
+	if (ms_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r37.v b/cvs/uart16650/uart_regs.r37.v
new file mode 100755
index 0000000000000000000000000000000000000000..2faa00acc55609822773f91a64edc6fc1ba6c148
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r37.v
@@ -0,0 +1,681 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+    else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr1r <= #1 wb_rst_i ? 0 : // clear status on read
+				lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr2r <= #1 wb_rst_i ? 0 : // clear status on read
+				lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr3r <= #1 wb_rst_i ? 0 : // clear status on read
+				lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr4r <= #1  wb_rst_i ? 0 :
+			  lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr5r <= #1 wb_rst_i ? 1 :
+			(lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr6r <= #1 wb_rst_i ? 1 :
+				 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr7r <= #1  wb_rst_i ? 0 :
+			  lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r39.v b/cvs/uart16650/uart_regs.r39.v
new file mode 100755
index 0000000000000000000000000000000000000000..69947868255e8b3812f54ee01615cc88754a0c84
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r39.v
@@ -0,0 +1,686 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1; // reset bits in Modem Status Register
+end
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr1r <= #1 wb_rst_i ? 0 : // clear status on read
+				lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr2r <= #1 wb_rst_i ? 0 : // clear status on read
+				lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr3r <= #1 wb_rst_i ? 0 : // clear status on read
+				lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr4r <= #1  wb_rst_i ? 0 :
+			  lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr5r <= #1 wb_rst_i ? 1 :
+			(lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr6r <= #1 wb_rst_i ? 1 :
+				 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	lsr7r <= #1  wb_rst_i ? 0 :
+			  lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 1'b0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r40.v b/cvs/uart16650/uart_regs.r40.v
new file mode 100755
index 0000000000000000000000000000000000000000..68f04a7d94ccc709819955815675497feea8ac82
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r40.v
@@ -0,0 +1,692 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r41.v b/cvs/uart16650/uart_regs.r41.v
new file mode 100755
index 0000000000000000000000000000000000000000..0fe551b105668274d1080fdd0a0d37f2884d1845
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r41.v
@@ -0,0 +1,695 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r42.v b/cvs/uart16650/uart_regs.r42.v
new file mode 100755
index 0000000000000000000000000000000000000000..69524f234c4a7f2cebcc6c3a6c2119ee0073d19c
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r42.v
@@ -0,0 +1,698 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r43.v b/cvs/uart16650/uart_regs.r43.v
new file mode 100755
index 0000000000000000000000000000000000000000..658f6c75c14bc94b3c471b19b7403dfad0b301de
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r43.v
@@ -0,0 +1,701 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r44.v b/cvs/uart16650/uart_regs.r44.v
new file mode 100755
index 0000000000000000000000000000000000000000..2cdee5d75785f995fab05e4beb1c6c7663e8d81e
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r44.v
@@ -0,0 +1,704 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+wire [7:0] 								counter_b;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[9:2];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	thre_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = (counter_b==8'b0); // break counter reached 0
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 lsr0;
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 0;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 0;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 0;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 0;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int			? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(thre_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r45.v b/cvs/uart16650/uart_regs.r45.v
new file mode 100755
index 0000000000000000000000000000000000000000..32b6a8407ccbcc02e768e08544faa1250d64791b
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r45.v
@@ -0,0 +1,727 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[10:3];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_MS)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r47.v b/cvs/uart16650/uart_regs.r47.v
new file mode 100755
index 0000000000000000000000000000000000000000..445c5b7b94bd6745a2430325e391e69b6b84db07
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r47.v
@@ -0,0 +1,735 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								state;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
+
+
+always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
+begin
+    if (wb_rst_i)
+    begin
+	wb_dat_o <= #1 8'b0;
+    end
+    else
+    if (wb_re_i)   //if (we're not writing)
+	case (wb_addr_i)
+	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
+			wb_dat_o <= #1 dl[`UART_DL1];
+		  else
+			wb_dat_o <= #1 rf_data_out[10:3];
+	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+	`UART_REG_LC	: wb_dat_o <= #1 lcr;
+	`UART_REG_LS	: wb_dat_o <= #1 lsr;
+	`UART_REG_MS	: wb_dat_o <= #1 msr;
+	default:  wb_dat_o <= #1 8'b0; // ??
+	endcase // case(wb_addr_i)
+     else
+	wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r48.v b/cvs/uart16650/uart_regs.r48.v
new file mode 100755
index 0000000000000000000000000000000000000000..6f3e4881c1b41742fd2b74f99f0dfecd8e681447
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r48.v
@@ -0,0 +1,761 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(/*AUTOSENSE*/dl or dlab or ier or iir
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+   if (wb_rst_i)
+   begin
+		wb_dat_o <= #1 8'b0;
+   end
+   else
+		if (wb_re_i)   //if (we're not writing)
+			case (wb_addr_i)
+				`UART_REG_RB   : wb_dat_o <= #1 dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+				`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+				`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+				`UART_REG_LC	: wb_dat_o <= #1 lcr;
+				`UART_REG_LS	: wb_dat_o <= #1 lsr;
+				`UART_REG_MS	: wb_dat_o <= #1 msr;
+				default:  wb_dat_o <= #1 8'b0; // ??
+			endcase // case(wb_addr_i)
+		else
+			wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+/*
+// threi_clear signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		threi_clear <= #1 0;
+	else
+	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
+		threi_clear <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_II)
+		threi_clear <= #1 1;
+end
+*/
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+wire tx_fifo_write;
+assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r50.v b/cvs/uart16650/uart_regs.r50.v
new file mode 100755
index 0000000000000000000000000000000000000000..5903d62f452d9fc3133b397fd3485748a7886699
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r50.v
@@ -0,0 +1,754 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(/*AUTOSENSE*/dl or dlab or ier or iir
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+   if (wb_rst_i)
+   begin
+		wb_dat_o <= #1 8'b0;
+   end
+   else
+		if (wb_re_i)   //if (we're not writing)
+			case (wb_addr_i)
+				`UART_REG_RB   : wb_dat_o <= #1 dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+				`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
+				`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
+				`UART_REG_LC	: wb_dat_o <= #1 lcr;
+				`UART_REG_LS	: wb_dat_o <= #1 lsr;
+				`UART_REG_MS	: wb_dat_o <= #1 msr;
+				default:  wb_dat_o <= #1 8'b0; // ??
+			endcase // case(wb_addr_i)
+		else
+			wb_dat_o <= #1 8'b0;
+end // always @ (posedge clk or posedge wb_rst_i)
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r52.v b/cvs/uart16650/uart_regs.r52.v
new file mode 100755
index 0000000000000000000000000000000000000000..6038bb66b7df13b93236fd0e71d4a7018c968fcb
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r52.v
@@ -0,0 +1,762 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r54.v b/cvs/uart16650/uart_regs.r54.v
new file mode 100755
index 0000000000000000000000000000000000000000..112721f8ab5cd3bcd0c1b89637277f76ec9b1bac
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r54.v
@@ -0,0 +1,765 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r56.v b/cvs/uart16650/uart_regs.r56.v
new file mode 100755
index 0000000000000000000000000000000000000000..49b4725a5ef900d5c5048a857c20397bfaa2c08d
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r56.v
@@ -0,0 +1,768 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 0;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r58.v b/cvs/uart16650/uart_regs.r58.v
new file mode 100755
index 0000000000000000000000000000000000000000..d63245dba3501878182097f836b3fab7ea903a32
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r58.v
@@ -0,0 +1,773 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r59.v b/cvs/uart16650/uart_regs.r59.v
new file mode 100755
index 0000000000000000000000000000000000000000..2962a11937c6841001e92a1e48d48ef344935c2e
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r59.v
@@ -0,0 +1,782 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_DTR],mcr[`UART_MC_RTS],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                      :  {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r60.v b/cvs/uart16650/uart_regs.r60.v
new file mode 100755
index 0000000000000000000000000000000000000000..cc20ce65a66f8f91d93a7d976683b7f4136497d2
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r60.v
@@ -0,0 +1,816 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r63.v b/cvs/uart16650/uart_regs.r63.v
new file mode 100755
index 0000000000000000000000000000000000000000..01caf321bed2b2986bd06a3b5141d55847611089
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r63.v
@@ -0,0 +1,821 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msr <= #1 0;
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r64.v b/cvs/uart16650/uart_regs.r64.v
new file mode 100755
index 0000000000000000000000000000000000000000..e03900f11c5a7aba63021f8e8dd08f68fc472826
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r64.v
@@ -0,0 +1,827 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r66.v b/cvs/uart16650/uart_regs.r66.v
new file mode 100755
index 0000000000000000000000000000000000000000..0740a2e61a483d20bd39cfdbbe25433adb91496f
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r66.v
@@ -0,0 +1,830 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r68.v b/cvs/uart16650/uart_regs.r68.v
new file mode 100755
index 0000000000000000000000000000000000000000..d14f6672ecf440b2cb2e9648db6b7bb3f422e088
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r68.v
@@ -0,0 +1,833 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r79.v b/cvs/uart16650/uart_regs.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..5bdddc1e75372b51364476766e5de6c7adde5d98
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r79.v
@@ -0,0 +1,854 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.37  2001/12/27 13:24:09  mohor
+// lsr[7] was not showing overrun errors.
+//
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+//`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+assign baud_o = enable; // baud_o is actually the enable signal
+`endif
+
+
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+wire serial_out;
+
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
+
+// handle loopback
+wire serial_in = loopback ? serial_out : srx_pad_i;
+assign stx_pad_o = loopback ? 1'b1 : serial_out;
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r84.v b/cvs/uart16650/uart_regs.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..92bb03b05bcb9cef67179228129c8b58cadefd41
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r84.v
@@ -0,0 +1,870 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.38  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.37  2001/12/27 13:24:09  mohor
+// lsr[7] was not showing overrun errors.
+//
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+assign baud_o = enable; // baud_o is actually the enable signal
+`endif
+
+
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+wire serial_out;
+
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
+
+// handle loopback
+wire serial_in = loopback ? serial_out : srx_pad_i;
+assign stx_pad_o = loopback ? 1'b1 : serial_out;
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r87.v b/cvs/uart16650/uart_regs.r87.v
new file mode 100755
index 0000000000000000000000000000000000000000..4a8b3fc8c6a9a495665b9156f091e89212c805e6
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r87.v
@@ -0,0 +1,873 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.39  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.38  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.37  2001/12/27 13:24:09  mohor
+// lsr[7] was not showing overrun errors.
+//
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+assign baud_o = enable; // baud_o is actually the enable signal
+`endif
+
+
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+wire serial_out;
+
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
+
+// handle loopback
+wire serial_in = loopback ? serial_out : srx_pad_i;
+assign stx_pad_o = loopback ? 1'b1 : serial_out;
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_regs.r99.v b/cvs/uart16650/uart_regs.r99.v
new file mode 100755
index 0000000000000000000000000000000000000000..b9a931639e61bdc6678146a2f2a33831401b582f
--- /dev/null
+++ b/cvs/uart16650/uart_regs.r99.v
@@ -0,0 +1,890 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_regs.v                                                 ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  Registers of the uart 16550 core                            ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts 1 wait state in all WISHBONE transfers              ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing or verification.                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   (See log for the revision history           ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.40  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.39  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.38  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.37  2001/12/27 13:24:09  mohor
+// lsr[7] was not showing overrun errors.
+//
+// Revision 1.36  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.35  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.34  2001/12/19 07:33:54  mohor
+// Synplicity was having troubles with the comment.
+//
+// Revision 1.33  2001/12/17 10:14:43  mohor
+// Things related to msr register changed. After THRE IRQ occurs, and one
+// character is written to the transmit fifo, the detection of the THRE bit in the
+// LSR is delayed for one character time.
+//
+// Revision 1.32  2001/12/14 13:19:24  mohor
+// MSR register fixed.
+//
+// Revision 1.31  2001/12/14 10:06:58  mohor
+// After reset modem status register MSR should be reset.
+//
+// Revision 1.30  2001/12/13 10:09:13  mohor
+// thre irq should be cleared only when being source of interrupt.
+//
+// Revision 1.29  2001/12/12 09:05:46  mohor
+// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
+//
+// Revision 1.28  2001/12/10 19:52:41  gorban
+// Scratch register added
+//
+// Revision 1.27  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.26  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.25  2001/11/28 19:36:39  gorban
+// Fixed: timeout and break didn't pay attention to current data format when counting time
+//
+// Revision 1.24  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.23  2001/11/12 21:57:29  gorban
+// fixed more typo bugs
+//
+// Revision 1.22  2001/11/12 15:02:28  mohor
+// lsr1r error fixed.
+//
+// Revision 1.21  2001/11/12 14:57:27  mohor
+// ti_int_pnd error fixed.
+//
+// Revision 1.20  2001/11/12 14:50:27  mohor
+// ti_int_d error fixed.
+//
+// Revision 1.19  2001/11/10 12:43:21  gorban
+// Logic Synthesis bugs fixed. Some other minor changes
+//
+// Revision 1.18  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.17  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.16  2001/11/02 09:55:16  mohor
+// no message
+//
+// Revision 1.15  2001/10/31 15:19:22  gorban
+// Fixes to break and timeout conditions
+//
+// Revision 1.14  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/10/19 16:21:40  gorban
+// Changes data_out to be synchronous again as it should have been.
+//
+// Revision 1.11  2001/10/18 20:35:45  gorban
+// small fix
+//
+// Revision 1.10  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.9  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.10  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.9  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.8  2001/05/29 20:05:04  gorban
+// Fixed some bugs and synthesis problems.
+//
+// Revision 1.7  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.6  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.5  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:11+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+`define UART_DL1 7:0
+`define UART_DL2 15:8
+
+module uart_regs (clk,
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
+
+// additional signals
+	modem_inputs,
+	stx_pad_o, srx_pad_i,
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
+`endif				
+	rts_pad_o, dtr_pad_o, int_o
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+
+	);
+
+input 									clk;
+input 									wb_rst_i;
+input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+input [7:0] 							wb_dat_i;
+output [7:0] 							wb_dat_o;
+input 									wb_we_i;
+input 									wb_re_i;
+
+output 									stx_pad_o;
+input 									srx_pad_i;
+
+input [3:0] 							modem_inputs;
+output 									rts_pad_o;
+output 									dtr_pad_o;
+output 									int_o;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// if 32-bit databus and debug interface are enabled
+output [3:0]							ier;
+output [3:0]							iir;
+output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+output [4:0]							mcr;
+output [7:0]							lcr;
+output [7:0]							msr;
+output [7:0] 							lsr;
+output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+output [2:0] 							tstate;
+output [3:0] 							rstate;
+
+`endif
+
+wire [3:0] 								modem_inputs;
+reg 										enable;
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+assign baud_o = enable; // baud_o is actually the enable signal
+`endif
+
+
+wire 										stx_pad_o;		// received from transmitter module
+wire 										srx_pad_i;
+wire 										srx_pad;
+
+reg [7:0] 								wb_dat_o;
+
+wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
+wire [7:0] 								wb_dat_i;
+
+
+reg [3:0] 								ier;
+reg [3:0] 								iir;
+reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
+reg [4:0] 								mcr;
+reg [7:0] 								lcr;
+reg [7:0] 								msr;
+reg [15:0] 								dl;  // 32-bit divisor latch
+reg [7:0] 								scratch; // UART scratch register
+reg 										start_dlc; // activate dlc on writing to UART_DL1
+reg 										lsr_mask_d; // delay for lsr_mask condition
+reg 										msi_reset; // reset MSR 4 lower bits indicator
+//reg 										threi_clear; // THRE interrupt clear flag
+reg [15:0] 								dlc;  // 32-bit divisor latch counter
+reg 										int_o;
+
+reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
+reg 										rx_reset;
+reg 										tx_reset;
+
+wire 										dlab;			   // divisor latch access bit
+wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
+wire 										loopback;		   // loopback bit (MCR bit 4)
+wire 										cts, dsr, ri, dcd;	   // effective signals
+wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
+wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
+
+// LSR bits wires and regs
+wire [7:0] 								lsr;
+wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
+reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
+wire 										lsr_mask; // lsr_mask
+
+//
+// ASSINGS
+//
+
+assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
+
+assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
+assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
+                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
+
+assign 									dlab = lcr[`UART_LC_DL];
+assign 									loopback = mcr[4];
+
+// assign modem outputs
+assign 									rts_pad_o = mcr[`UART_MC_RTS];
+assign 									dtr_pad_o = mcr[`UART_MC_DTR];
+
+// Interrupt signals
+wire 										rls_int;  // receiver line status interrupt
+wire 										rda_int;  // receiver data available interrupt
+wire 										ti_int;   // timeout indicator interrupt
+wire										thre_int; // transmitter holding register empty interrupt
+wire 										ms_int;   // modem status interrupt
+
+// FIFO signals
+reg 										tf_push;
+reg 										rf_pop;
+wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
+wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
+wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
+wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+wire [2:0] 								tstate;
+wire [3:0] 								rstate;
+wire [9:0] 								counter_t;
+
+wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
+reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
+reg  [7:0]                block_value; // One character length minus stop bit
+
+// Transmitter Instance
+wire serial_out;
+
+uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
+
+  // Synchronizing and sampling serial RX input
+  uart_sync_flops    i_uart_sync_flops
+  (
+    .rst_i           (wb_rst_i),
+    .clk_i           (clk),
+    .stage1_rst_i    (1'b0),
+    .stage1_clk_en_i (1'b1),
+    .async_dat_i     (srx_pad_i),
+    .sync_dat_o      (srx_pad)
+  );
+  defparam i_uart_sync_flops.width      = 1;
+  defparam i_uart_sync_flops.init_value = 1'b1;
+
+// handle loopback
+wire serial_in = loopback ? serial_out : srx_pad;
+assign stx_pad_o = loopback ? 1'b1 : serial_out;
+
+// Receiver Instance
+uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
+	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
+
+
+// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
+always @(dl or dlab or ier or iir or scratch
+			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
+begin
+	case (wb_addr_i)
+		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
+		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
+		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
+		`UART_REG_LC	: wb_dat_o = lcr;
+		`UART_REG_LS	: wb_dat_o = lsr;
+		`UART_REG_MS	: wb_dat_o = msr;
+		`UART_REG_SR	: wb_dat_o = scratch;
+		default:  wb_dat_o = 8'b0; // ??
+	endcase // case(wb_addr_i)
+end // always @ (dl or dlab or ier or iir or scratch...
+
+
+// rf_pop signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		rf_pop <= #1 0; 
+	else
+	if (rf_pop)	// restore the signal to 0 after one clock cycle
+		rf_pop <= #1 0;
+	else
+	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
+		rf_pop <= #1 1; // advance read pointer
+end
+
+wire 	lsr_mask_condition;
+wire 	iir_read;
+wire  msr_read;
+wire	fifo_read;
+wire	fifo_write;
+
+assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
+assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
+assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
+assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
+assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
+
+// lsr_mask_d delayed signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		lsr_mask_d <= #1 0;
+	else // reset bits in the Line Status Register
+		lsr_mask_d <= #1 lsr_mask_condition;
+end
+
+// lsr_mask is rise detected
+assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
+
+// msi_reset signal handling
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		msi_reset <= #1 1;
+	else
+	if (msi_reset)
+		msi_reset <= #1 0;
+	else
+	if (msr_read)
+		msi_reset <= #1 1; // reset bits in Modem Status Register
+end
+
+
+//
+//   WRITES AND RESETS   //
+//
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		lcr <= #1 8'b00000011; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_LC)
+		lcr <= #1 wb_dat_i;
+
+// Interrupt Enable Register or UART_DL2
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		ier <= #1 4'b0000; // no interrupts after reset
+		dl[`UART_DL2] <= #1 8'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_IE)
+		if (dlab)
+		begin
+			dl[`UART_DL2] <= #1 wb_dat_i;
+		end
+		else
+			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
+
+
+// FIFO Control Register and rx_reset, tx_reset signals
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		fcr <= #1 2'b11; 
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end else
+	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
+		fcr <= #1 wb_dat_i[7:6];
+		rx_reset <= #1 wb_dat_i[1];
+		tx_reset <= #1 wb_dat_i[2];
+	end else begin
+		rx_reset <= #1 0;
+		tx_reset <= #1 0;
+	end
+
+// Modem Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		mcr <= #1 5'b0; 
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_MC)
+			mcr <= #1 wb_dat_i[4:0];
+
+// Scratch register
+// Line Control Register
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		scratch <= #1 0; // 8n1 setting
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_SR)
+		scratch <= #1 wb_dat_i;
+
+// TX_FIFO or UART_DL1
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+	begin
+		dl[`UART_DL1]  <= #1 8'b0;
+		tf_push   <= #1 1'b0;
+		start_dlc <= #1 1'b0;
+	end
+	else
+	if (wb_we_i && wb_addr_i==`UART_REG_TR)
+		if (dlab)
+		begin
+			dl[`UART_DL1] <= #1 wb_dat_i;
+			start_dlc <= #1 1'b1; // enable DL counter
+			tf_push <= #1 1'b0;
+		end
+		else
+		begin
+			tf_push   <= #1 1'b1;
+			start_dlc <= #1 1'b0;
+		end // else: !if(dlab)
+	else
+	begin
+		start_dlc <= #1 1'b0;
+		tf_push   <= #1 1'b0;
+	end // else: !if(dlab)
+
+// Receiver FIFO trigger level selection logic (asynchronous mux)
+always @(fcr)
+	case (fcr[`UART_FC_TL])
+		2'b00 : trigger_level = 1;
+		2'b01 : trigger_level = 4;
+		2'b10 : trigger_level = 8;
+		2'b11 : trigger_level = 14;
+	endcase // case(fcr[`UART_FC_TL])
+	
+//
+//  STATUS REGISTERS  //
+//
+
+// Modem Status Register
+reg [3:0] delayed_modem_signals;
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	  begin
+  		msr <= #1 0;
+	  	delayed_modem_signals[3:0] <= #1 0;
+	  end
+	else begin
+		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
+			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
+		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
+		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
+	end
+end
+
+
+// Line Status Register
+
+// activation conditions
+assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
+assign lsr1 = rf_overrun;     // Receiver overrun error
+assign lsr2 = rf_data_out[1]; // parity error bit
+assign lsr3 = rf_data_out[0]; // framing error bit
+assign lsr4 = rf_data_out[2]; // break error in the character
+assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
+assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
+assign lsr7 = rf_error_bit | rf_overrun;
+
+// lsr bit0 (receiver data available)
+reg 	 lsr0_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0_d <= #1 0;
+	else lsr0_d <= #1 lsr0;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr0r <= #1 0;
+	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
+					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
+
+// lsr bit 1 (receiver overrun)
+reg lsr1_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1_d <= #1 0;
+	else lsr1_d <= #1 lsr1;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr1r <= #1 0;
+	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
+
+// lsr bit 2 (parity error)
+reg lsr2_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2_d <= #1 0;
+	else lsr2_d <= #1 lsr2;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr2r <= #1 0;
+	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
+
+// lsr bit 3 (framing error)
+reg lsr3_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3_d <= #1 0;
+	else lsr3_d <= #1 lsr3;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr3r <= #1 0;
+	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
+
+// lsr bit 4 (break indicator)
+reg lsr4_d; // delayed
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4_d <= #1 0;
+	else lsr4_d <= #1 lsr4;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr4r <= #1 0;
+	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
+
+// lsr bit 5 (transmitter fifo is empty)
+reg lsr5_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5_d <= #1 1;
+	else lsr5_d <= #1 lsr5;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr5r <= #1 1;
+	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
+
+// lsr bit 6 (transmitter empty indicator)
+reg lsr6_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6_d <= #1 1;
+	else lsr6_d <= #1 lsr6;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr6r <= #1 1;
+	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
+
+// lsr bit 7 (error in fifo)
+reg lsr7_d;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7_d <= #1 0;
+	else lsr7_d <= #1 lsr7;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) lsr7r <= #1 0;
+	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
+
+// Frequency divider
+always @(posedge clk or posedge wb_rst_i) 
+begin
+	if (wb_rst_i)
+		dlc <= #1 0;
+	else
+		if (start_dlc | ~ (|dlc))
+  			dlc <= #1 dl - 1;               // preset counter
+		else
+			dlc <= #1 dlc - 1;              // decrement counter
+end
+
+// Enable signal generation logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		enable <= #1 1'b0;
+	else
+		if (|dl & ~(|dlc))     // dl>0 & dlc==0
+			enable <= #1 1'b1;
+		else
+			enable <= #1 1'b0;
+end
+
+// Delaying THRE status for one character cycle after a character is written to an empty fifo.
+always @(lcr)
+  case (lcr[3:0])
+    4'b0000                             : block_value =  95; // 6 bits
+    4'b0100                             : block_value = 103; // 6.5 bits
+    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
+    4'b1100                             : block_value = 119; // 7.5 bits
+    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
+    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
+    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
+    4'b1111                             : block_value = 175; // 11 bits
+  endcase // case(lcr[3:0])
+
+// Counting time of one character minus stop bit
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+    block_cnt <= #1 8'd0;
+  else
+  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
+    block_cnt <= #1 block_value;
+  else
+  if (enable & block_cnt != 8'b0)  // only work on enable times
+    block_cnt <= #1 block_cnt - 1;  // decrement break counter
+end // always of break condition detection
+
+// Generating THRE status enable signal
+assign thre_set_en = ~(|block_cnt);
+
+
+//
+//	INTERRUPT LOGIC
+//
+
+assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
+assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
+assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
+assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
+assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
+
+reg 	 rls_int_d;
+reg 	 thre_int_d;
+reg 	 ms_int_d;
+reg 	 ti_int_d;
+reg 	 rda_int_d;
+
+// delay lines
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_d <= #1 0;
+	else rls_int_d <= #1 rls_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_d <= #1 0;
+	else rda_int_d <= #1 rda_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_d <= #1 0;
+	else thre_int_d <= #1 thre_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_d <= #1 0;
+	else ms_int_d <= #1 ms_int;
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_d <= #1 0;
+	else ti_int_d <= #1 ti_int;
+
+// rise detection signals
+
+wire 	 rls_int_rise;
+wire 	 thre_int_rise;
+wire 	 ms_int_rise;
+wire 	 ti_int_rise;
+wire 	 rda_int_rise;
+
+assign rda_int_rise    = rda_int & ~rda_int_d;
+assign rls_int_rise 	  = rls_int & ~rls_int_d;
+assign thre_int_rise   = thre_int & ~thre_int_d;
+assign ms_int_rise 	  = ms_int & ~ms_int_d;
+assign ti_int_rise 	  = ti_int & ~ti_int_d;
+
+// interrupt pending flags
+reg 	rls_int_pnd;
+reg	rda_int_pnd;
+reg 	thre_int_pnd;
+reg 	ms_int_pnd;
+reg 	ti_int_pnd;
+
+// interrupt pending flags assignments
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rls_int_pnd <= #1 0; 
+	else 
+		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
+							rls_int_rise ? 1 :						// latch condition
+							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) rda_int_pnd <= #1 0; 
+	else 
+		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
+							rda_int_rise ? 1 :						// latch condition
+							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) thre_int_pnd <= #1 0; 
+	else 
+		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
+							thre_int_rise ? 1 :
+							thre_int_pnd && ier[`UART_IE_THRE];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ms_int_pnd <= #1 0; 
+	else 
+		ms_int_pnd <= #1 msr_read ? 0 : 
+							ms_int_rise ? 1 :
+							ms_int_pnd && ier[`UART_IE_MS];
+
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) ti_int_pnd <= #1 0; 
+	else 
+		ti_int_pnd <= #1 fifo_read ? 0 : 
+							ti_int_rise ? 1 :
+							ti_int_pnd && ier[`UART_IE_RDA];
+// end of pending flags
+
+// INT_O logic
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)	
+		int_o <= #1 1'b0;
+	else
+		int_o <= #1 
+					rls_int_pnd		?	~lsr_mask					:
+					rda_int_pnd		? 1								:
+					ti_int_pnd		? ~fifo_read					:
+					thre_int_pnd	? !(fifo_write & iir_read) :
+					ms_int_pnd		? ~msr_read						:
+					0;	// if no interrupt are pending
+end
+
+
+// Interrupt Identification register
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+		iir <= #1 1;
+	else
+	if (rls_int_pnd)  // interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
+		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
+	end else // the sequence of conditions determines priority of interrupt identification
+	if (rda_int)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_RDA;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ti_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_TI;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (thre_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_THRE;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end
+	else if (ms_int_pnd)
+	begin
+		iir[`UART_II_II] <= #1 `UART_II_MS;
+		iir[`UART_II_IP] <= #1 1'b0;
+	end else	// no interrupt is pending
+	begin
+		iir[`UART_II_II] <= #1 0;
+		iir[`UART_II_IP] <= #1 1'b1;
+	end
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_rfifo.r106.v b/cvs/uart16650/uart_rfifo.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..b949ee5ed9e44ee501baa8cc41bd4c16163b6731
--- /dev/null
+++ b/cvs/uart16650/uart_rfifo.r106.v
@@ -0,0 +1,320 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver FIFO                                     ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.3  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.2  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.1  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_rfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	error_bit,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+output				error_bit;
+
+wire	[fifo_width-1:0]	data_out;
+wire [7:0] data8_out;
+// flags FIFO
+reg	[2:0]	fifo[fifo_depth-1:0];
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in[fifo_width-1:fifo_width-8]), 
+			.dpo(data8_out)
+		); 
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+		fifo[0] <= #1 0;
+		fifo[1] <= #1 0;
+		fifo[2] <= #1 0;
+		fifo[3] <= #1 0;
+		fifo[4] <= #1 0;
+		fifo[5] <= #1 0;
+		fifo[6] <= #1 0;
+		fifo[7] <= #1 0;
+		fifo[8] <= #1 0;
+		fifo[9] <= #1 0;
+		fifo[10] <= #1 0;
+		fifo[11] <= #1 0;
+		fifo[12] <= #1 0;
+		fifo[13] <= #1 0;
+		fifo[14] <= #1 0;
+		fifo[15] <= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+		fifo[0] <= #1 0;
+		fifo[1] <= #1 0;
+		fifo[2] <= #1 0;
+		fifo[3] <= #1 0;
+		fifo[4] <= #1 0;
+		fifo[5] <= #1 0;
+		fifo[6] <= #1 0;
+		fifo[7] <= #1 0;
+		fifo[8] <= #1 0;
+		fifo[9] <= #1 0;
+		fifo[10] <= #1 0;
+		fifo[11] <= #1 0;
+		fifo[12] <= #1 0;
+		fifo[13] <= #1 0;
+		fifo[14] <= #1 0;
+		fifo[15] <= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & ~pop & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+
+// please note though that data_out is only valid one clock after pop signal
+assign data_out = {data8_out,fifo[bottom]};
+
+// Additional logic for detection of error conditions (parity and framing) inside the FIFO
+// for the Line Status Register bit 7
+
+wire	[2:0]	word0 = fifo[0];
+wire	[2:0]	word1 = fifo[1];
+wire	[2:0]	word2 = fifo[2];
+wire	[2:0]	word3 = fifo[3];
+wire	[2:0]	word4 = fifo[4];
+wire	[2:0]	word5 = fifo[5];
+wire	[2:0]	word6 = fifo[6];
+wire	[2:0]	word7 = fifo[7];
+
+wire	[2:0]	word8 = fifo[8];
+wire	[2:0]	word9 = fifo[9];
+wire	[2:0]	word10 = fifo[10];
+wire	[2:0]	word11 = fifo[11];
+wire	[2:0]	word12 = fifo[12];
+wire	[2:0]	word13 = fifo[13];
+wire	[2:0]	word14 = fifo[14];
+wire	[2:0]	word15 = fifo[15];
+
+// a 1 is returned if any of the error bits in the fifo is 1
+assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
+            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
+            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
+            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
+
+endmodule
diff --git a/cvs/uart16650/uart_rfifo.r79.v b/cvs/uart16650/uart_rfifo.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..7d5bd3c6b6645768e282afbe40e6d7cfadb0639e
--- /dev/null
+++ b/cvs/uart16650/uart_rfifo.r79.v
@@ -0,0 +1,267 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver FIFO                                     ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+//`include "uart_defines.v"
+
+module uart_rfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	error_bit,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+output				error_bit;
+
+wire	[fifo_width-1:0]	data_out;
+wire [7:0] data8_out;
+// flags FIFO
+reg	[2:0]	fifo[fifo_depth-1:0];
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in[fifo_width-1:fifo_width-8]), 
+			.dpo(data8_out)
+		); 
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+
+// please note though that data_out is only valid one clock after pop signal
+assign data_out = {data8_out,fifo[bottom]};
+
+// Additional logic for detection of error conditions (parity and framing) inside the FIFO
+// for the Line Status Register bit 7
+
+wire	[2:0]	word0 = fifo[0];
+wire	[2:0]	word1 = fifo[1];
+wire	[2:0]	word2 = fifo[2];
+wire	[2:0]	word3 = fifo[3];
+wire	[2:0]	word4 = fifo[4];
+wire	[2:0]	word5 = fifo[5];
+wire	[2:0]	word6 = fifo[6];
+wire	[2:0]	word7 = fifo[7];
+
+wire	[2:0]	word8 = fifo[8];
+wire	[2:0]	word9 = fifo[9];
+wire	[2:0]	word10 = fifo[10];
+wire	[2:0]	word11 = fifo[11];
+wire	[2:0]	word12 = fifo[12];
+wire	[2:0]	word13 = fifo[13];
+wire	[2:0]	word14 = fifo[14];
+wire	[2:0]	word15 = fifo[15];
+
+// a 1 is returned if any of the error bits in the fifo is 1
+assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
+            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
+            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
+            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
+
+endmodule
diff --git a/cvs/uart16650/uart_rfifo.r84.v b/cvs/uart16650/uart_rfifo.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..41d8ce99e5ac4020c5c221ddc6e3a905a9d316c9
--- /dev/null
+++ b/cvs/uart16650/uart_rfifo.r84.v
@@ -0,0 +1,283 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver FIFO                                     ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.1  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_rfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	error_bit,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+output				error_bit;
+
+wire	[fifo_width-1:0]	data_out;
+wire [7:0] data8_out;
+// flags FIFO
+reg	[2:0]	fifo[fifo_depth-1:0];
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in[fifo_width-1:fifo_width-8]), 
+			.dpo(data8_out)
+		); 
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+
+// please note though that data_out is only valid one clock after pop signal
+assign data_out = {data8_out,fifo[bottom]};
+
+// Additional logic for detection of error conditions (parity and framing) inside the FIFO
+// for the Line Status Register bit 7
+
+wire	[2:0]	word0 = fifo[0];
+wire	[2:0]	word1 = fifo[1];
+wire	[2:0]	word2 = fifo[2];
+wire	[2:0]	word3 = fifo[3];
+wire	[2:0]	word4 = fifo[4];
+wire	[2:0]	word5 = fifo[5];
+wire	[2:0]	word6 = fifo[6];
+wire	[2:0]	word7 = fifo[7];
+
+wire	[2:0]	word8 = fifo[8];
+wire	[2:0]	word9 = fifo[9];
+wire	[2:0]	word10 = fifo[10];
+wire	[2:0]	word11 = fifo[11];
+wire	[2:0]	word12 = fifo[12];
+wire	[2:0]	word13 = fifo[13];
+wire	[2:0]	word14 = fifo[14];
+wire	[2:0]	word15 = fifo[15];
+
+// a 1 is returned if any of the error bits in the fifo is 1
+assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
+            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
+            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
+            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
+
+endmodule
diff --git a/cvs/uart16650/uart_rfifo.r87.v b/cvs/uart16650/uart_rfifo.r87.v
new file mode 100755
index 0000000000000000000000000000000000000000..c37c11b221d60434905d3dbbbe4a4dcd8a64e075
--- /dev/null
+++ b/cvs/uart16650/uart_rfifo.r87.v
@@ -0,0 +1,285 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver FIFO                                     ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.2  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.1  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_rfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	error_bit,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+output				error_bit;
+
+wire	[fifo_width-1:0]	data_out;
+wire [7:0] data8_out;
+// flags FIFO
+reg	[2:0]	fifo[fifo_depth-1:0];
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in[fifo_width-1:fifo_width-8]), 
+			.dpo(data8_out)
+		); 
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & ~pop & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+
+// please note though that data_out is only valid one clock after pop signal
+assign data_out = {data8_out,fifo[bottom]};
+
+// Additional logic for detection of error conditions (parity and framing) inside the FIFO
+// for the Line Status Register bit 7
+
+wire	[2:0]	word0 = fifo[0];
+wire	[2:0]	word1 = fifo[1];
+wire	[2:0]	word2 = fifo[2];
+wire	[2:0]	word3 = fifo[3];
+wire	[2:0]	word4 = fifo[4];
+wire	[2:0]	word5 = fifo[5];
+wire	[2:0]	word6 = fifo[6];
+wire	[2:0]	word7 = fifo[7];
+
+wire	[2:0]	word8 = fifo[8];
+wire	[2:0]	word9 = fifo[9];
+wire	[2:0]	word10 = fifo[10];
+wire	[2:0]	word11 = fifo[11];
+wire	[2:0]	word12 = fifo[12];
+wire	[2:0]	word13 = fifo[13];
+wire	[2:0]	word14 = fifo[14];
+wire	[2:0]	word15 = fifo[15];
+
+// a 1 is returned if any of the error bits in the fifo is 1
+assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
+            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
+            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
+            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
+
+endmodule
diff --git a/cvs/uart16650/uart_rfifo.r88.v b/cvs/uart16650/uart_rfifo.r88.v
new file mode 100755
index 0000000000000000000000000000000000000000..b949ee5ed9e44ee501baa8cc41bd4c16163b6731
--- /dev/null
+++ b/cvs/uart16650/uart_rfifo.r88.v
@@ -0,0 +1,320 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver FIFO                                     ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.3  2003/06/11 16:37:47  gorban
+// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
+//
+// Revision 1.2  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.1  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_rfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	error_bit,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+output				error_bit;
+
+wire	[fifo_width-1:0]	data_out;
+wire [7:0] data8_out;
+// flags FIFO
+reg	[2:0]	fifo[fifo_depth-1:0];
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in[fifo_width-1:fifo_width-8]), 
+			.dpo(data8_out)
+		); 
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+		fifo[0] <= #1 0;
+		fifo[1] <= #1 0;
+		fifo[2] <= #1 0;
+		fifo[3] <= #1 0;
+		fifo[4] <= #1 0;
+		fifo[5] <= #1 0;
+		fifo[6] <= #1 0;
+		fifo[7] <= #1 0;
+		fifo[8] <= #1 0;
+		fifo[9] <= #1 0;
+		fifo[10] <= #1 0;
+		fifo[11] <= #1 0;
+		fifo[12] <= #1 0;
+		fifo[13] <= #1 0;
+		fifo[14] <= #1 0;
+		fifo[15] <= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+		fifo[0] <= #1 0;
+		fifo[1] <= #1 0;
+		fifo[2] <= #1 0;
+		fifo[3] <= #1 0;
+		fifo[4] <= #1 0;
+		fifo[5] <= #1 0;
+		fifo[6] <= #1 0;
+		fifo[7] <= #1 0;
+		fifo[8] <= #1 0;
+		fifo[9] <= #1 0;
+		fifo[10] <= #1 0;
+		fifo[11] <= #1 0;
+		fifo[12] <= #1 0;
+		fifo[13] <= #1 0;
+		fifo[14] <= #1 0;
+		fifo[15] <= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+        fifo[bottom] <= #1 0;
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+				fifo[top] <= #1 data_in[2:0];
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & ~pop & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+
+// please note though that data_out is only valid one clock after pop signal
+assign data_out = {data8_out,fifo[bottom]};
+
+// Additional logic for detection of error conditions (parity and framing) inside the FIFO
+// for the Line Status Register bit 7
+
+wire	[2:0]	word0 = fifo[0];
+wire	[2:0]	word1 = fifo[1];
+wire	[2:0]	word2 = fifo[2];
+wire	[2:0]	word3 = fifo[3];
+wire	[2:0]	word4 = fifo[4];
+wire	[2:0]	word5 = fifo[5];
+wire	[2:0]	word6 = fifo[6];
+wire	[2:0]	word7 = fifo[7];
+
+wire	[2:0]	word8 = fifo[8];
+wire	[2:0]	word9 = fifo[9];
+wire	[2:0]	word10 = fifo[10];
+wire	[2:0]	word11 = fifo[11];
+wire	[2:0]	word12 = fifo[12];
+wire	[2:0]	word13 = fifo[13];
+wire	[2:0]	word14 = fifo[14];
+wire	[2:0]	word15 = fifo[15];
+
+// a 1 is returned if any of the error bits in the fifo is 1
+assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
+            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
+            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
+            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
+
+endmodule
diff --git a/cvs/uart16650/uart_sync_flops.r106.v b/cvs/uart16650/uart_sync_flops.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..1e569be47f194fe286cf529019d9a7474c02b19e
--- /dev/null
+++ b/cvs/uart16650/uart_sync_flops.r106.v
@@ -0,0 +1,122 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_sync_flops.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - Andrej Erzen (andreje@flextronics.si)                 ////
+////      - Tadej Markovic (tadejm@flextronics.si)                ////
+////                                                              ////
+////  Created:        2004/05/20                                  ////
+////  Last Updated:   2004/05/20                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+//
+
+
+`include "timescale.v"
+
+
+module uart_sync_flops
+(
+  // internal signals
+  rst_i,
+  clk_i,
+  stage1_rst_i,
+  stage1_clk_en_i,
+  async_dat_i,
+  sync_dat_o
+);
+
+parameter Tp            = 1;
+parameter width         = 1;
+parameter init_value    = 1'b0;
+
+input                           rst_i;                  // reset input
+input                           clk_i;                  // clock input
+input                           stage1_rst_i;           // synchronous reset for stage 1 FF
+input                           stage1_clk_en_i;        // synchronous clock enable for stage 1 FF
+input   [width-1:0]             async_dat_i;            // asynchronous data input
+output  [width-1:0]             sync_dat_o;             // synchronous data output
+
+
+//
+// Interal signal declarations
+//
+
+reg     [width-1:0]             sync_dat_o;
+reg     [width-1:0]             flop_0;
+
+
+// first stage
+always @ (posedge clk_i or posedge rst_i)
+begin
+    if (rst_i)
+        flop_0 <= #Tp {width{init_value}};
+    else
+        flop_0 <= #Tp async_dat_i;    
+end
+
+// second stage
+always @ (posedge clk_i or posedge rst_i)
+begin
+    if (rst_i)
+        sync_dat_o <= #Tp {width{init_value}};
+    else if (stage1_rst_i)
+        sync_dat_o <= #Tp {width{init_value}};
+    else if (stage1_clk_en_i)
+        sync_dat_o <= #Tp flop_0;       
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_sync_flops.r98.v b/cvs/uart16650/uart_sync_flops.r98.v
new file mode 100755
index 0000000000000000000000000000000000000000..1e569be47f194fe286cf529019d9a7474c02b19e
--- /dev/null
+++ b/cvs/uart16650/uart_sync_flops.r98.v
@@ -0,0 +1,122 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_sync_flops.v                                             ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core receiver logic                                    ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - Andrej Erzen (andreje@flextronics.si)                 ////
+////      - Tadej Markovic (tadejm@flextronics.si)                ////
+////                                                              ////
+////  Created:        2004/05/20                                  ////
+////  Last Updated:   2004/05/20                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+//
+
+
+`include "timescale.v"
+
+
+module uart_sync_flops
+(
+  // internal signals
+  rst_i,
+  clk_i,
+  stage1_rst_i,
+  stage1_clk_en_i,
+  async_dat_i,
+  sync_dat_o
+);
+
+parameter Tp            = 1;
+parameter width         = 1;
+parameter init_value    = 1'b0;
+
+input                           rst_i;                  // reset input
+input                           clk_i;                  // clock input
+input                           stage1_rst_i;           // synchronous reset for stage 1 FF
+input                           stage1_clk_en_i;        // synchronous clock enable for stage 1 FF
+input   [width-1:0]             async_dat_i;            // asynchronous data input
+output  [width-1:0]             sync_dat_o;             // synchronous data output
+
+
+//
+// Interal signal declarations
+//
+
+reg     [width-1:0]             sync_dat_o;
+reg     [width-1:0]             flop_0;
+
+
+// first stage
+always @ (posedge clk_i or posedge rst_i)
+begin
+    if (rst_i)
+        flop_0 <= #Tp {width{init_value}};
+    else
+        flop_0 <= #Tp async_dat_i;    
+end
+
+// second stage
+always @ (posedge clk_i or posedge rst_i)
+begin
+    if (rst_i)
+        sync_dat_o <= #Tp {width{init_value}};
+    else if (stage1_rst_i)
+        sync_dat_o <= #Tp {width{init_value}};
+    else if (stage1_clk_en_i)
+        sync_dat_o <= #Tp flop_0;       
+end
+
+endmodule
diff --git a/cvs/uart16650/uart_tfifo.r106.v b/cvs/uart16650/uart_tfifo.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..222d7f9488d7dc309dfae15fd51862043dac7a7b
--- /dev/null
+++ b/cvs/uart16650/uart_tfifo.r106.v
@@ -0,0 +1,243 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_tfifo.v                                                ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter FIFO                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.1  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_tfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+
+wire	[fifo_width-1:0]	data_out;
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,fifo_width,fifo_depth) tfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in), 
+			.dpo(data_out)
+		); 
+
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+endmodule
diff --git a/cvs/uart16650/uart_tfifo.r79.v b/cvs/uart16650/uart_tfifo.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..913062a81a3cc7351d8233430d3cf51a2cde806e
--- /dev/null
+++ b/cvs/uart16650/uart_tfifo.r79.v
@@ -0,0 +1,227 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_tfifo.v                                                ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter FIFO                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+//`include "uart_defines.v"
+
+module uart_tfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+
+wire	[fifo_width-1:0]	data_out;
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,fifo_width,fifo_depth) tfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in), 
+			.dpo(data_out)
+		); 
+
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+endmodule
diff --git a/cvs/uart16650/uart_tfifo.r84.v b/cvs/uart16650/uart_tfifo.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..222d7f9488d7dc309dfae15fd51862043dac7a7b
--- /dev/null
+++ b/cvs/uart16650/uart_tfifo.r84.v
@@ -0,0 +1,243 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_tfifo.v                                                ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter FIFO                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2002/07/22                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.1  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2001/12/20 13:25:46  mohor
+// rx push changed to be only one cycle wide.
+//
+// Revision 1.15  2001/12/18 09:01:07  mohor
+// Bug that was entered in the last update fixed (rx state machine).
+//
+// Revision 1.14  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.13  2001/11/26 21:38:54  gorban
+// Lots of fixes:
+// Break condition wasn't handled correctly at all.
+// LSR bits could lose their values.
+// LSR value after reset was wrong.
+// Timing of THRE interrupt signal corrected.
+// LSR bit 0 timing corrected.
+//
+// Revision 1.12  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.11  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/24 08:48:10  mohor
+// FIFO was not cleared after the data was read bug fixed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.3  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:48  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_tfifo (clk, 
+	wb_rst_i, data_in, data_out,
+// Control signals
+	push, // push strobe, active high
+	pop,   // pop strobe, active high
+// status signals
+	overrun,
+	count,
+	fifo_reset,
+	reset_status
+	);
+
+
+// FIFO parameters
+parameter fifo_width = `UART_FIFO_WIDTH;
+parameter fifo_depth = `UART_FIFO_DEPTH;
+parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
+parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
+
+input				clk;
+input				wb_rst_i;
+input				push;
+input				pop;
+input	[fifo_width-1:0]	data_in;
+input				fifo_reset;
+input       reset_status;
+
+output	[fifo_width-1:0]	data_out;
+output				overrun;
+output	[fifo_counter_w-1:0]	count;
+
+wire	[fifo_width-1:0]	data_out;
+
+// FIFO pointers
+reg	[fifo_pointer_w-1:0]	top;
+reg	[fifo_pointer_w-1:0]	bottom;
+
+reg	[fifo_counter_w-1:0]	count;
+reg				overrun;
+wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
+
+raminfr #(fifo_pointer_w,fifo_width,fifo_depth) tfifo  
+        (.clk(clk), 
+			.we(push), 
+			.a(top), 
+			.dpra(bottom), 
+			.di(data_in), 
+			.dpo(data_out)
+		); 
+
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+	if (wb_rst_i)
+	begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+	else
+	if (fifo_reset) begin
+		top		<= #1 0;
+		bottom		<= #1 1'b0;
+		count		<= #1 0;
+	end
+  else
+	begin
+		case ({push, pop})
+		2'b10 : if (count<fifo_depth)  // overrun condition
+			begin
+				top       <= #1 top_plus_1;
+				count     <= #1 count + 1'b1;
+			end
+		2'b01 : if(count>0)
+			begin
+				bottom   <= #1 bottom + 1'b1;
+				count	 <= #1 count - 1'b1;
+			end
+		2'b11 : begin
+				bottom   <= #1 bottom + 1'b1;
+				top       <= #1 top_plus_1;
+		        end
+    default: ;
+		endcase
+	end
+end   // always
+
+always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
+begin
+  if (wb_rst_i)
+    overrun   <= #1 1'b0;
+  else
+  if(fifo_reset | reset_status) 
+    overrun   <= #1 1'b0;
+  else
+  if(push & (count==fifo_depth))
+    overrun   <= #1 1'b1;
+end   // always
+
+endmodule
diff --git a/cvs/uart16650/uart_top.r106.v b/cvs/uart16650/uart_top.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..3f5f3868c74f6868a40b52a18e85028099c700c1
--- /dev/null
+++ b/cvs/uart16650/uart_top.r106.v
@@ -0,0 +1,340 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.18  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.17  2001/12/19 08:40:03  mohor
+// Warnings fixed (unused signals removed).
+//
+// Revision 1.16  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.15  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.14  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+	);
+
+parameter 							 uart_data_width = `UART_DATA_WIDTH;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+input [3:0]							 wb_sel_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+// optional baudrate output
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
+wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
+wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
+wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
+wire [uart_addr_width-1:0] 	 wb_adr_int;
+wire 									 we_o;	// Write enable for registers
+wire		          	     re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface wires
+wire	[3:0] ier;
+wire	[3:0] iir;
+wire	[1:0] fcr;
+wire	[4:0] mcr;
+wire	[7:0] lcr;
+wire	[7:0] msr;
+wire	[7:0] lsr;
+wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
+wire	[2:0] tstate;
+wire	[3:0] rstate; 
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_dat32_o(32'b0),								 
+	 .wb_sel_i(4'b0),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`else
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_sel_i(wb_sel_i),
+	 .wb_dat32_o(wb_dat32_o),								 
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`endif
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_int	),
+	.wb_dat_i(	wb_dat8_i	),
+	.wb_dat_o(	wb_dat8_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+//`ifdef DATA_BUS_WIDTH_8
+//`else
+// debug interface signals	enabled
+.ier(ier), 
+.iir(iir), 
+.fcr(fcr), 
+.mcr(mcr), 
+.lcr(lcr), 
+.msr(msr), 
+.lsr(lsr), 
+.rf_count(rf_count),
+.tf_count(tf_count),
+.tstate(tstate),
+.rstate(rstate),
+//`endif					  
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, .baud_o(baud_o)
+`endif
+
+);
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+uart_debug_if dbg(/*AUTOINST*/
+						// Outputs
+						.wb_dat32_o				 (wb_dat32_o[31:0]),
+						// Inputs
+						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
+						.ier						 (ier[3:0]),
+						.iir						 (iir[3:0]),
+						.fcr						 (fcr[1:0]),
+						.mcr						 (mcr[4:0]),
+						.lcr						 (lcr[7:0]),
+						.msr						 (msr[7:0]),
+						.lsr						 (lsr[7:0]),
+						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tstate					 (tstate[2:0]),
+						.rstate					 (rstate[3:0]));
+`endif 
+
+// initial
+begin
+//	`ifdef DATA_BUS_WIDTH_8
+		$display("(%m) UART INFO: Data bus width is 8. No Debug interface.\n");
+//	`else
+		$display("(%m) UART INFO: Data bus width is 32. Debug Interface present.\n");
+//	`endif
+//	`ifdef UART_HAS_BAUDRATE_OUTPUT
+		$display("(%m) UART INFO: Has baudrate output\n");
+//	`else
+		$display("(%m) UART INFO: Doesn't have baudrate output\n");
+//	`endif
+end
+
+endmodule
+
+
diff --git a/cvs/uart16650/uart_top.r27.v b/cvs/uart16650/uart_top.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..80fa0d63afbbc74435563daa3d34984c7741bad9
--- /dev/null
+++ b/cvs/uart16650/uart_top.r27.v
@@ -0,0 +1,170 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_top	(
+	clk, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = 8;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 clk;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_addr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_addr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire 									 we_o;	// Write enable for registers
+wire		               re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		clk		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+
+// Registers
+uart_regs	regs(
+		.clk(		clk		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_addr_i(	wb_addr_i	),
+		.wb_dat_i(	wb_dat_i	),
+		.wb_dat_o(	wb_dat_o	),
+		.wb_we_i(	we_o		),
+    .wb_re_i(re_o),
+		.modem_inputs(	{cts_pad_i, dsr_pad_i,
+				 ri_pad_i,  dcd_pad_i}	),
+		.stx_pad_o(		stx_pad_o		),
+		.srx_pad_i(		srx_pad_i		),
+		.enable(	enable		),
+		.rts_pad_o(		rts_pad_o		),
+		.dtr_pad_o(		dtr_pad_o		),
+		.int_o(		int_o		)
+		);
+
+endmodule
diff --git a/cvs/uart16650/uart_top.r29.v b/cvs/uart16650/uart_top.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..e33bd0c6eaf081e70da92174367b7de0a021591d
--- /dev/null
+++ b/cvs/uart16650/uart_top.r29.v
@@ -0,0 +1,178 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_top	(
+	clk, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = 8;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 clk;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_addr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_addr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire 									 we_o;	// Write enable for registers
+wire		               re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		clk		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+
+// Registers
+uart_regs	regs(
+		.clk(		clk		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_addr_i(	wb_addr_i	),
+		.wb_dat_i(	wb_dat_i	),
+		.wb_dat_o(	wb_dat_o	),
+		.wb_we_i(	we_o		),
+    .wb_re_i(re_o),
+		.modem_inputs(	{cts_pad_i, dsr_pad_i,
+				 ri_pad_i,  dcd_pad_i}	),
+		.stx_pad_o(		stx_pad_o		),
+		.srx_pad_i(		srx_pad_i		),
+		.rts_pad_o(		rts_pad_o		),
+		.dtr_pad_o(		dtr_pad_o		),
+		.int_o(		int_o		)
+		);
+
+endmodule
diff --git a/cvs/uart16650/uart_top.r30.v b/cvs/uart16650/uart_top.r30.v
new file mode 100755
index 0000000000000000000000000000000000000000..71a95975a42f1427650766b2f7a458c493e78c43
--- /dev/null
+++ b/cvs/uart16650/uart_top.r30.v
@@ -0,0 +1,182 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = 8;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire 									 we_o;	// Write enable for registers
+wire		               re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+
+// Registers
+uart_regs	regs(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_addr_i(	wb_adr_i	),
+		.wb_dat_i(	wb_dat_i	),
+		.wb_dat_o(	wb_dat_o	),
+		.wb_we_i(	we_o		),
+    .wb_re_i(re_o),
+		.modem_inputs(	{cts_pad_i, dsr_pad_i,
+				 ri_pad_i,  dcd_pad_i}	),
+		.stx_pad_o(		stx_pad_o		),
+		.srx_pad_i(		srx_pad_i		),
+		.rts_pad_o(		rts_pad_o		),
+		.dtr_pad_o(		dtr_pad_o		),
+		.int_o(		int_o		)
+		);
+
+endmodule
diff --git a/cvs/uart16650/uart_top.r33.v b/cvs/uart16650/uart_top.r33.v
new file mode 100755
index 0000000000000000000000000000000000000000..582febb93917b29c97f27bd5152645197faa759d
--- /dev/null
+++ b/cvs/uart16650/uart_top.r33.v
@@ -0,0 +1,187 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = 8;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire 									 we_o;	// Write enable for registers
+wire		               re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+
+// Registers
+uart_regs	regs(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_addr_i(	wb_adr_i	),
+		.wb_dat_i(	wb_dat_i	),
+		.wb_dat_o(	wb_dat_o	),
+		.wb_we_i(	we_o		),
+    .wb_re_i(re_o),
+		.modem_inputs(	{cts_pad_i, dsr_pad_i,
+				 ri_pad_i,  dcd_pad_i}	),
+		.stx_pad_o(		stx_pad_o		),
+		.srx_pad_i(		srx_pad_i		),
+		.rts_pad_o(		rts_pad_o		),
+		.dtr_pad_o(		dtr_pad_o		),
+		.int_o(		int_o		)
+		);
+
+endmodule
diff --git a/cvs/uart16650/uart_top.r37.v b/cvs/uart16650/uart_top.r37.v
new file mode 100755
index 0000000000000000000000000000000000000000..a3f712351d6812c186eaa3cc246fd8527b2ce235
--- /dev/null
+++ b/cvs/uart16650/uart_top.r37.v
@@ -0,0 +1,190 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = 8;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire 									 we_o;	// Write enable for registers
+wire		               re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_i	),
+	.wb_dat_i(	wb_dat_i	),
+	.wb_dat_o(	wb_dat_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+);
+
+endmodule
diff --git a/cvs/uart16650/uart_top.r48.v b/cvs/uart16650/uart_top.r48.v
new file mode 100755
index 0000000000000000000000000000000000000000..3d0ba75c65ffba1dd17f6e0e180b915406cc55b4
--- /dev/null
+++ b/cvs/uart16650/uart_top.r48.v
@@ -0,0 +1,280 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.14  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = `UART_DATA_WIDTH;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+input [3:0]							 wb_sel_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
+wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
+wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
+wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
+wire 									 we_o;	// Write enable for registers
+wire		          	     re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface wires
+wire	[3:0] ier;
+wire	[3:0] iir;
+wire	[1:0] fcr;
+wire	[4:0] mcr;
+wire	[7:0] lcr;
+wire	[7:0] msr;
+wire	[7:0] lsr;
+wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
+wire	[2:0] tstate;
+wire	[3:0] rstate; 
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_dat32_o(32'b0),								 
+	 .wb_sel_i(4'b0),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`else // !`ifdef DATA_BUS_WIDTH_8
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_sel_i(wb_sel_i),
+	 .wb_dat32_o(wb_dat32_o),								 
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_i	),
+	.wb_dat_i(	wb_dat8_i	),
+	.wb_dat_o(	wb_dat8_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+.ier(ier), 
+.iir(iir), 
+.fcr(fcr), 
+.mcr(mcr), 
+.lcr(lcr), 
+.msr(msr), 
+.lsr(lsr), 
+.rf_count(rf_count),
+.tf_count(tf_count),
+.tstate(tstate),
+.rstate(rstate),
+`endif					  
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+);
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+uart_debug_if dbg(/*AUTOINST*/
+						// Outputs
+						.wb_dat32_o				 (wb_dat32_o[31:0]),
+						// Inputs
+						.wb_clk_i				 (wb_clk_i),
+						.wb_rst_i				 (wb_rst_i),
+						.wb_adr_i				 (wb_adr_i[`UART_ADDR_WIDTH-1:0]),
+						.re_o						 (re_o),
+						.ier						 (ier[3:0]),
+						.iir						 (iir[3:0]),
+						.fcr						 (fcr[1:0]),
+						.mcr						 (mcr[4:0]),
+						.lcr						 (lcr[7:0]),
+						.msr						 (msr[7:0]),
+						.lsr						 (lsr[7:0]),
+						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tstate					 (tstate[2:0]),
+						.rstate					 (rstate[3:0]));
+`endif //  `ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
diff --git a/cvs/uart16650/uart_top.r50.v b/cvs/uart16650/uart_top.r50.v
new file mode 100755
index 0000000000000000000000000000000000000000..6cc422748b0dc7545253402593df0aba73e45edf
--- /dev/null
+++ b/cvs/uart16650/uart_top.r50.v
@@ -0,0 +1,294 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.15  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.14  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = `UART_DATA_WIDTH;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+input [3:0]							 wb_sel_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
+wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
+wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
+wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
+wire [uart_addr_width-1:0] 	 wb_adr_int;
+wire 									 we_o;	// Write enable for registers
+wire		          	     re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface wires
+wire	[3:0] ier;
+wire	[3:0] iir;
+wire	[1:0] fcr;
+wire	[4:0] mcr;
+wire	[7:0] lcr;
+wire	[7:0] msr;
+wire	[7:0] lsr;
+wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
+wire	[2:0] tstate;
+wire	[3:0] rstate; 
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_dat32_o(32'b0),								 
+	 .wb_sel_i(4'b0),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`else // !`ifdef DATA_BUS_WIDTH_8
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_sel_i(wb_sel_i),
+	 .wb_dat32_o(wb_dat32_o),								 
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_int	),
+	.wb_dat_i(	wb_dat8_i	),
+	.wb_dat_o(	wb_dat8_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+.ier(ier), 
+.iir(iir), 
+.fcr(fcr), 
+.mcr(mcr), 
+.lcr(lcr), 
+.msr(msr), 
+.lsr(lsr), 
+.rf_count(rf_count),
+.tf_count(tf_count),
+.tstate(tstate),
+.rstate(rstate),
+`endif					  
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+);
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+uart_debug_if dbg(/*AUTOINST*/
+						// Outputs
+						.wb_dat32_o				 (wb_dat32_o[31:0]),
+						// Inputs
+						.wb_clk_i				 (wb_clk_i),
+						.wb_rst_i				 (wb_rst_i),
+						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
+						.re_o						 (re_o),
+						.ier						 (ier[3:0]),
+						.iir						 (iir[3:0]),
+						.fcr						 (fcr[1:0]),
+						.mcr						 (mcr[4:0]),
+						.lcr						 (lcr[7:0]),
+						.msr						 (msr[7:0]),
+						.lsr						 (lsr[7:0]),
+						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tstate					 (tstate[2:0]),
+						.rstate					 (rstate[3:0]));
+`endif //  `ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
diff --git a/cvs/uart16650/uart_top.r65.v b/cvs/uart16650/uart_top.r65.v
new file mode 100755
index 0000000000000000000000000000000000000000..eed32acf66df4b5ca5810e94fd80c6e21f04d854
--- /dev/null
+++ b/cvs/uart16650/uart_top.r65.v
@@ -0,0 +1,295 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.15  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.14  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+
+	);
+
+parameter 							 uart_data_width = `UART_DATA_WIDTH;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+input [3:0]							 wb_sel_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
+wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
+wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
+wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
+wire [uart_addr_width-1:0] 	 wb_adr_int;
+wire 									 we_o;	// Write enable for registers
+wire		          	     re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface wires
+wire	[3:0] ier;
+wire	[3:0] iir;
+wire	[1:0] fcr;
+wire	[4:0] mcr;
+wire	[7:0] lcr;
+wire	[7:0] msr;
+wire	[7:0] lsr;
+wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
+wire	[2:0] tstate;
+wire	[3:0] rstate; 
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_dat32_o(32'b0),								 
+	 .wb_sel_i(4'b0),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`else // !`ifdef DATA_BUS_WIDTH_8
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_sel_i(wb_sel_i),
+	 .wb_dat32_o(wb_dat32_o),								 
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_int	),
+	.wb_dat_i(	wb_dat8_i	),
+	.wb_dat_o(	wb_dat8_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+.ier(ier), 
+.iir(iir), 
+.fcr(fcr), 
+.mcr(mcr), 
+.lcr(lcr), 
+.msr(msr), 
+.lsr(lsr), 
+.rf_count(rf_count),
+.tf_count(tf_count),
+.tstate(tstate),
+.rstate(rstate),
+`endif					  
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+);
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+uart_debug_if dbg(/*AUTOINST*/
+						// Outputs
+						.wb_dat32_o				 (wb_dat32_o[31:0]),
+						// Inputs
+						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
+						.ier						 (ier[3:0]),
+						.iir						 (iir[3:0]),
+						.fcr						 (fcr[1:0]),
+						.mcr						 (mcr[4:0]),
+						.lcr						 (lcr[7:0]),
+						.msr						 (msr[7:0]),
+						.lsr						 (lsr[7:0]),
+						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tstate					 (tstate[2:0]),
+						.rstate					 (rstate[3:0]));
+`endif //  `ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
diff --git a/cvs/uart16650/uart_top.r79.v b/cvs/uart16650/uart_top.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..03995bc2e71649dbdf6163ce919e317b69c08c76
--- /dev/null
+++ b/cvs/uart16650/uart_top.r79.v
@@ -0,0 +1,324 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.17  2001/12/19 08:40:03  mohor
+// Warnings fixed (unused signals removed).
+//
+// Revision 1.16  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.15  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.14  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+// `include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+	);
+
+parameter 							 uart_data_width = `UART_DATA_WIDTH;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+input [3:0]							 wb_sel_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+// optional baudrate output
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
+wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
+wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
+wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
+wire [uart_addr_width-1:0] 	 wb_adr_int;
+wire 									 we_o;	// Write enable for registers
+wire		          	     re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface wires
+wire	[3:0] ier;
+wire	[3:0] iir;
+wire	[1:0] fcr;
+wire	[4:0] mcr;
+wire	[7:0] lcr;
+wire	[7:0] msr;
+wire	[7:0] lsr;
+wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
+wire	[2:0] tstate;
+wire	[3:0] rstate; 
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_dat32_o(32'b0),								 
+	 .wb_sel_i(4'b0),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`else
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_sel_i(wb_sel_i),
+	 .wb_dat32_o(wb_dat32_o),								 
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`endif
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_int	),
+	.wb_dat_i(	wb_dat8_i	),
+	.wb_dat_o(	wb_dat8_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+.ier(ier), 
+.iir(iir), 
+.fcr(fcr), 
+.mcr(mcr), 
+.lcr(lcr), 
+.msr(msr), 
+.lsr(lsr), 
+.rf_count(rf_count),
+.tf_count(tf_count),
+.tstate(tstate),
+.rstate(rstate),
+`endif					  
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, .baud_o(baud_o)
+`endif
+
+);
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+uart_debug_if dbg(/*AUTOINST*/
+						// Outputs
+						.wb_dat32_o				 (wb_dat32_o[31:0]),
+						// Inputs
+						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
+						.ier						 (ier[3:0]),
+						.iir						 (iir[3:0]),
+						.fcr						 (fcr[1:0]),
+						.mcr						 (mcr[4:0]),
+						.lcr						 (lcr[7:0]),
+						.msr						 (msr[7:0]),
+						.lsr						 (lsr[7:0]),
+						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tstate					 (tstate[2:0]),
+						.rstate					 (rstate[3:0]));
+`endif 
+
+initial
+begin
+	`ifdef DATA_BUS_WIDTH_8
+		$display("(%m) UART INFO: Data bus width is 8. No Debug interface.\n");
+	`else
+		$display("(%m) UART INFO: Data bus width is 32. Debug Interface present.\n");
+	`endif
+	`ifdef UART_HAS_BAUDRATE_OUTPUT
+		$display("(%m) UART INFO: Has baudrate output\n");
+	`else
+		$display("(%m) UART INFO: Doesn't have baudrate output\n");
+	`endif
+end
+
+endmodule
+
+
diff --git a/cvs/uart16650/uart_top.r84.v b/cvs/uart16650/uart_top.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..d3e3e71dd428448fa4fd2bee30ca88c07f17fe16
--- /dev/null
+++ b/cvs/uart16650/uart_top.r84.v
@@ -0,0 +1,340 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_top.v                                                  ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core top level.                                        ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Note that transmitter and receiver instances are inside     ////
+////  the uart_regs.v file.                                       ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing so far.                                             ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.18  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.17  2001/12/19 08:40:03  mohor
+// Warnings fixed (unused signals removed).
+//
+// Revision 1.16  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.15  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.14  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.13  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.12  2001/08/25 15:46:19  gorban
+// Modified port names again
+//
+// Revision 1.11  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.10  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_top	(
+	wb_clk_i, 
+	
+	// Wishbone signals
+	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
+	int_o, // interrupt request
+
+	// UART	signals
+	// serial input/output
+	stx_pad_o, srx_pad_i,
+
+	// modem signals
+	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, baud_o
+`endif
+	);
+
+parameter 							 uart_data_width = `UART_DATA_WIDTH;
+parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
+
+input 								 wb_clk_i;
+
+// WISHBONE interface
+input 								 wb_rst_i;
+input [uart_addr_width-1:0] 	 wb_adr_i;
+input [uart_data_width-1:0] 	 wb_dat_i;
+output [uart_data_width-1:0] 	 wb_dat_o;
+input 								 wb_we_i;
+input 								 wb_stb_i;
+input 								 wb_cyc_i;
+input [3:0]							 wb_sel_i;
+output 								 wb_ack_o;
+output 								 int_o;
+
+// UART	signals
+input 								 srx_pad_i;
+output 								 stx_pad_o;
+output 								 rts_pad_o;
+input 								 cts_pad_i;
+output 								 dtr_pad_o;
+input 								 dsr_pad_i;
+input 								 ri_pad_i;
+input 								 dcd_pad_i;
+
+// optional baudrate output
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+output	baud_o;
+`endif
+
+
+wire 									 stx_pad_o;
+wire 									 rts_pad_o;
+wire 									 dtr_pad_o;
+
+wire [uart_addr_width-1:0] 	 wb_adr_i;
+wire [uart_data_width-1:0] 	 wb_dat_i;
+wire [uart_data_width-1:0] 	 wb_dat_o;
+
+wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
+wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
+wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
+wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
+wire [uart_addr_width-1:0] 	 wb_adr_int;
+wire 									 we_o;	// Write enable for registers
+wire		          	     re_o;	// Read enable for registers
+//
+// MODULE INSTANCES
+//
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface wires
+wire	[3:0] ier;
+wire	[3:0] iir;
+wire	[1:0] fcr;
+wire	[4:0] mcr;
+wire	[7:0] lcr;
+wire	[7:0] msr;
+wire	[7:0] lsr;
+wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
+wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
+wire	[2:0] tstate;
+wire	[3:0] rstate; 
+`endif
+
+`ifdef DATA_BUS_WIDTH_8
+////  WISHBONE interface module
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_dat32_o(32'b0),								 
+	 .wb_sel_i(4'b0),
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`else
+uart_wb		wb_interface(
+		.clk(		wb_clk_i		),
+		.wb_rst_i(	wb_rst_i	),
+	.wb_dat_i(wb_dat_i),
+	.wb_dat_o(wb_dat_o),
+	.wb_dat8_i(wb_dat8_i),
+	.wb_dat8_o(wb_dat8_o),
+	 .wb_sel_i(wb_sel_i),
+	 .wb_dat32_o(wb_dat32_o),								 
+		.wb_we_i(	wb_we_i		),
+		.wb_stb_i(	wb_stb_i	),
+		.wb_cyc_i(	wb_cyc_i	),
+		.wb_ack_o(	wb_ack_o	),
+	.wb_adr_i(wb_adr_i),
+	.wb_adr_int(wb_adr_int),
+		.we_o(		we_o		),
+		.re_o(re_o)
+		);
+`endif
+
+// Registers
+uart_regs	regs(
+	.clk(		wb_clk_i		),
+	.wb_rst_i(	wb_rst_i	),
+	.wb_addr_i(	wb_adr_int	),
+	.wb_dat_i(	wb_dat8_i	),
+	.wb_dat_o(	wb_dat8_o	),
+	.wb_we_i(	we_o		),
+   .wb_re_i(re_o),
+	.modem_inputs(	{cts_pad_i, dsr_pad_i,
+	ri_pad_i,  dcd_pad_i}	),
+	.stx_pad_o(		stx_pad_o		),
+	.srx_pad_i(		srx_pad_i		),
+`ifdef DATA_BUS_WIDTH_8
+`else
+// debug interface signals	enabled
+.ier(ier), 
+.iir(iir), 
+.fcr(fcr), 
+.mcr(mcr), 
+.lcr(lcr), 
+.msr(msr), 
+.lsr(lsr), 
+.rf_count(rf_count),
+.tf_count(tf_count),
+.tstate(tstate),
+.rstate(rstate),
+`endif					  
+	.rts_pad_o(		rts_pad_o		),
+	.dtr_pad_o(		dtr_pad_o		),
+	.int_o(		int_o		)
+`ifdef UART_HAS_BAUDRATE_OUTPUT
+	, .baud_o(baud_o)
+`endif
+
+);
+
+`ifdef DATA_BUS_WIDTH_8
+`else
+uart_debug_if dbg(/*AUTOINST*/
+						// Outputs
+						.wb_dat32_o				 (wb_dat32_o[31:0]),
+						// Inputs
+						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
+						.ier						 (ier[3:0]),
+						.iir						 (iir[3:0]),
+						.fcr						 (fcr[1:0]),
+						.mcr						 (mcr[4:0]),
+						.lcr						 (lcr[7:0]),
+						.msr						 (msr[7:0]),
+						.lsr						 (lsr[7:0]),
+						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
+						.tstate					 (tstate[2:0]),
+						.rstate					 (rstate[3:0]));
+`endif 
+
+initial
+begin
+	`ifdef DATA_BUS_WIDTH_8
+		$display("(%m) UART INFO: Data bus width is 8. No Debug interface.\n");
+	`else
+		$display("(%m) UART INFO: Data bus width is 32. Debug Interface present.\n");
+	`endif
+	`ifdef UART_HAS_BAUDRATE_OUTPUT
+		$display("(%m) UART INFO: Has baudrate output\n");
+	`else
+		$display("(%m) UART INFO: Doesn't have baudrate output\n");
+	`endif
+end
+
+endmodule
+
+
diff --git a/cvs/uart16650/uart_transmitter.r106.v b/cvs/uart16650/uart_transmitter.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..b3c643d41870ff2545416d4846ea9afe0656efde
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r106.v
@@ -0,0 +1,351 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.18  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2002/01/08 11:29:40  mohor
+// tf_pop was too wide. Now it is only 1 clk cycle width.
+//
+// Revision 1.15  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.14  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_tfifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+  else
+    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r27.v b/cvs/uart16650/uart_transmitter.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..c47b69347e9efcae23e1412e5018c323ed09083c
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r27.v
@@ -0,0 +1,288 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				tf_push;
+input	[7:0]			wb_dat_i;
+input				enable;
+input				tx_reset;
+output				stx_pad_o;
+output	[2:0]			state;
+output	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+
+reg	[2:0]	state;
+reg	[4:0]	counter;
+reg	[2:0]	bit_counter;   // counts the bits to be sent
+reg	[6:0]	shift_out;	// output shift register
+reg		stx_o_tmp;
+reg		parity_xor;  // parity of the word
+reg		tf_pop;
+reg		bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire	[`UART_FIFO_WIDTH-1:0]	tf_data_in;
+wire	[`UART_FIFO_WIDTH-1:0]	tf_data_out;
+wire				tf_push;
+wire				tf_underrun;
+wire				tf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+
+assign tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(1'b0)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	state       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (state)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				state <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				state  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				state <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						state <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						state <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 ~parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						state <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					state <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			state <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r29.v b/cvs/uart16650/uart_transmitter.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..7492fef4041628c951146714285d75f0c57d5196
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r29.v
@@ -0,0 +1,297 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+`include "timescale.v"
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				tf_push;
+input	[7:0]			wb_dat_i;
+input				enable;
+input				tx_reset;
+output				stx_pad_o;
+output	[2:0]			state;
+output	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+
+reg	[2:0]	state;
+reg	[4:0]	counter;
+reg	[2:0]	bit_counter;   // counts the bits to be sent
+reg	[6:0]	shift_out;	// output shift register
+reg		stx_o_tmp;
+reg		parity_xor;  // parity of the word
+reg		tf_pop;
+reg		bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire	[`UART_FIFO_WIDTH-1:0]	tf_data_in;
+wire	[`UART_FIFO_WIDTH-1:0]	tf_data_out;
+wire				tf_push;
+wire				tf_underrun;
+wire				tf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+
+assign tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(1'b0)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	state       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (state)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				state <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				state  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				state <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						state <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						state <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 ~parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						state <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					state <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			state <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r33.v b/cvs/uart16650/uart_transmitter.r33.v
new file mode 100755
index 0000000000000000000000000000000000000000..86dbe907980ea750d2857bd206a2e9c11f2170c1
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r33.v
@@ -0,0 +1,304 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset);
+
+input				clk;
+input				wb_rst_i;
+input	[7:0]			lcr;
+input				tf_push;
+input	[7:0]			wb_dat_i;
+input				enable;
+input				tx_reset;
+output				stx_pad_o;
+output	[2:0]			state;
+output	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+
+reg	[2:0]	state;
+reg	[4:0]	counter;
+reg	[2:0]	bit_counter;   // counts the bits to be sent
+reg	[6:0]	shift_out;	// output shift register
+reg		stx_o_tmp;
+reg		parity_xor;  // parity of the word
+reg		tf_pop;
+reg		bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire	[`UART_FIFO_WIDTH-1:0]	tf_data_in;
+wire	[`UART_FIFO_WIDTH-1:0]	tf_data_out;
+wire				tf_push;
+wire				tf_underrun;
+wire				tf_overrun;
+wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
+
+assign tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(1'b0)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	state       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (state)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				state <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				state  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				state <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						state <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						state <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 ~parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						state <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					state <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			state <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r34.v b/cvs/uart16650/uart_transmitter.r34.v
new file mode 100755
index 0000000000000000000000000000000000000000..3a9783ef4d5fc61009fdaffe814c6d32572ad3be
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r34.v
@@ -0,0 +1,308 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										rx_lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								state;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									state;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_underrun;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(rx_lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	state       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (state)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				state <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				state  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				state <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						state <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						state <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						state <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					state <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			state <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r37.v b/cvs/uart16650/uart_transmitter.r37.v
new file mode 100755
index 0000000000000000000000000000000000000000..fc8664410357e6998f0dd14d8daace86a4cd5130
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r37.v
@@ -0,0 +1,311 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								state;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									state;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_underrun;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	state       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (state)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				state <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				state  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				state <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						state <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						state <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						state <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					state <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 5'b00001;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			state <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r39.v b/cvs/uart16650/uart_transmitter.r39.v
new file mode 100755
index 0000000000000000000000000000000000000000..528050e45613960b5500977bc57d69931b515c45
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r39.v
@@ -0,0 +1,315 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								state;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									state;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_underrun;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	state       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (state)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				state <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				state  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				state <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						state <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						state <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						state <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					state <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					state <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			state <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r48.v b/cvs/uart16650/uart_transmitter.r48.v
new file mode 100755
index 0000000000000000000000000000000000000000..df280a8fa98cee86fc31ef9417bbeca5580af8db
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r48.v
@@ -0,0 +1,319 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_underrun;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.underrun(	tf_underrun	),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r61.v b/cvs/uart16650/uart_transmitter.r61.v
new file mode 100755
index 0000000000000000000000000000000000000000..4e82988cb355c79b5cc5eb313a05d02519c362e8
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r61.v
@@ -0,0 +1,326 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.14  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r70.v b/cvs/uart16650/uart_transmitter.r70.v
new file mode 100755
index 0000000000000000000000000000000000000000..35d48c9dbb4308d8d7b344207ae1b86a436d6cae
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r70.v
@@ -0,0 +1,333 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.15  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.14  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+  else
+    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r74.v b/cvs/uart16650/uart_transmitter.r74.v
new file mode 100755
index 0000000000000000000000000000000000000000..6189fda0d07e01044b9e0eb83e0e4f79b370cb46
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r74.v
@@ -0,0 +1,336 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2002/01/08 11:29:40  mohor
+// tf_pop was too wide. Now it is only 1 clk cycle width.
+//
+// Revision 1.15  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.14  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+//wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.overrun(	/*tf_overrun*/	),
+	.count(		tf_count	),
+	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+  else
+    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r79.v b/cvs/uart16650/uart_transmitter.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..8418a3bad214632c3aeddf96e5da0ceec8254cf0
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r79.v
@@ -0,0 +1,335 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2002/01/08 11:29:40  mohor
+// tf_pop was too wide. Now it is only 1 clk cycle width.
+//
+// Revision 1.15  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.14  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+//`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_tfifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+  else
+    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_transmitter.r84.v b/cvs/uart16650/uart_transmitter.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..b3c643d41870ff2545416d4846ea9afe0656efde
--- /dev/null
+++ b/cvs/uart16650/uart_transmitter.r84.v
@@ -0,0 +1,351 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_transmitter.v                                          ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core transmitter logic                                 ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  None known                                                  ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Thourough testing.                                          ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.18  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.16  2002/01/08 11:29:40  mohor
+// tf_pop was too wide. Now it is only 1 clk cycle width.
+//
+// Revision 1.15  2001/12/17 14:46:48  mohor
+// overrun signal was moved to separate block because many sequential lsr
+// reads were preventing data from being written to rx fifo.
+// underrun signal was not used and was removed from the project.
+//
+// Revision 1.14  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.13  2001/11/08 14:54:23  mohor
+// Comments in Slovene language deleted, few small fixes for better work of
+// old tools. IRQs need to be fix.
+//
+// Revision 1.12  2001/11/07 17:51:52  gorban
+// Heavily rewritten interrupt and LSR subsystems.
+// Many bugs hopefully squashed.
+//
+// Revision 1.11  2001/10/29 17:00:46  gorban
+// fixed parity sending and tx_fifo resets over- and underrun
+//
+// Revision 1.10  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.9  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.8  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.6  2001/06/23 11:21:48  gorban
+// DL made 16-bit long. Fixed transmission/reception bugs.
+//
+// Revision 1.5  2001/06/02 14:28:14  gorban
+// Fixed receiver and transmitter. Major bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/27 17:37:49  gorban
+// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
+//
+// Revision 1.2  2001/05/21 19:12:02  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.1  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:12+02  jacob
+// Initial revision
+//
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+`include "uart_defines.v"
+
+module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
+
+input 										clk;
+input 										wb_rst_i;
+input [7:0] 								lcr;
+input 										tf_push;
+input [7:0] 								wb_dat_i;
+input 										enable;
+input 										tx_reset;
+input 										lsr_mask; //reset of fifo
+output 										stx_pad_o;
+output [2:0] 								tstate;
+output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
+
+reg [2:0] 									tstate;
+reg [4:0] 									counter;
+reg [2:0] 									bit_counter;   // counts the bits to be sent
+reg [6:0] 									shift_out;	// output shift register
+reg 											stx_o_tmp;
+reg 											parity_xor;  // parity of the word
+reg 											tf_pop;
+reg 											bit_out;
+
+// TX FIFO instance
+//
+// Transmitter FIFO signals
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
+wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
+wire 											tf_push;
+wire 											tf_overrun;
+wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
+
+assign 										tf_data_in = wb_dat_i;
+
+uart_tfifo fifo_tx(	// error bit signal is not used in transmitter FIFO
+	.clk(		clk		), 
+	.wb_rst_i(	wb_rst_i	),
+	.data_in(	tf_data_in	),
+	.data_out(	tf_data_out	),
+	.push(		tf_push		),
+	.pop(		tf_pop		),
+	.overrun(	tf_overrun	),
+	.count(		tf_count	),
+	.fifo_reset(	tx_reset	),
+	.reset_status(lsr_mask)
+);
+
+// TRANSMITTER FINAL STATE MACHINE
+
+parameter s_idle        = 3'd0;
+parameter s_send_start  = 3'd1;
+parameter s_send_byte   = 3'd2;
+parameter s_send_parity = 3'd3;
+parameter s_send_stop   = 3'd4;
+parameter s_pop_byte    = 3'd5;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+  if (wb_rst_i)
+  begin
+	tstate       <= #1 s_idle;
+	stx_o_tmp       <= #1 1'b1;
+	counter   <= #1 5'b0;
+	shift_out   <= #1 7'b0;
+	bit_out     <= #1 1'b0;
+	parity_xor  <= #1 1'b0;
+	tf_pop      <= #1 1'b0;
+	bit_counter <= #1 3'b0;
+  end
+  else
+  if (enable)
+  begin
+	case (tstate)
+	s_idle	 :	if (~|tf_count) // if tf_count==0
+			begin
+				tstate <= #1 s_idle;
+				stx_o_tmp <= #1 1'b1;
+			end
+			else
+			begin
+				tf_pop <= #1 1'b0;
+				stx_o_tmp  <= #1 1'b1;
+				tstate  <= #1 s_pop_byte;
+			end
+	s_pop_byte :	begin
+				tf_pop <= #1 1'b1;
+				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
+				2'b00 : begin
+					bit_counter <= #1 3'b100;
+					parity_xor  <= #1 ^tf_data_out[4:0];
+				     end
+				2'b01 : begin
+					bit_counter <= #1 3'b101;
+					parity_xor  <= #1 ^tf_data_out[5:0];
+				     end
+				2'b10 : begin
+					bit_counter <= #1 3'b110;
+					parity_xor  <= #1 ^tf_data_out[6:0];
+				     end
+				2'b11 : begin
+					bit_counter <= #1 3'b111;
+					parity_xor  <= #1 ^tf_data_out[7:0];
+				     end
+				endcase
+				{shift_out[6:0], bit_out} <= #1 tf_data_out;
+				tstate <= #1 s_send_start;
+			end
+	s_send_start :	begin
+				tf_pop <= #1 1'b0;
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_send_byte;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b0;
+			end
+	s_send_byte :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					if (bit_counter > 3'b0)
+					begin
+						bit_counter <= #1 bit_counter - 1'b1;
+						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
+						tstate <= #1 s_send_byte;
+					end
+					else   // end of byte
+					if (~lcr[`UART_LC_PE])
+					begin
+						tstate <= #1 s_send_stop;
+					end
+					else
+					begin
+						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
+						2'b00:	bit_out <= #1 ~parity_xor;
+						2'b01:	bit_out <= #1 1'b1;
+						2'b10:	bit_out <= #1 parity_xor;
+						2'b11:	bit_out <= #1 1'b0;
+						endcase
+						tstate <= #1 s_send_parity;
+					end
+					counter <= #1 0;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out; // set output pin
+			end
+	s_send_parity :	begin
+				if (~|counter)
+					counter <= #1 5'b01111;
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 4'b0;
+					tstate <= #1 s_send_stop;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 bit_out;
+			end
+	s_send_stop :  begin
+				if (~|counter)
+				  begin
+						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
+  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
+  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
+  						default:	  counter <= #1 5'b11101;     // 2 stop bits
+						endcase
+					end
+				else
+				if (counter == 5'b00001)
+				begin
+					counter <= #1 0;
+					tstate <= #1 s_idle;
+				end
+				else
+					counter <= #1 counter - 1'b1;
+				stx_o_tmp <= #1 1'b1;
+			end
+
+		default : // should never get here
+			tstate <= #1 s_idle;
+	endcase
+  end // end if enable
+  else
+    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
+end // transmitter logic
+
+assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
+	
+endmodule
diff --git a/cvs/uart16650/uart_wb.r101.v b/cvs/uart16650/uart_wb.r101.v
new file mode 100755
index 0000000000000000000000000000000000000000..373686c70f0984556fbd52142a6bfc1a642e18dd
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r101.v
@@ -0,0 +1,317 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.15  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.12  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+assign wb_adr_int = wb_adr_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+reg [1:0] wb_adr_int_lsb;
+
+always @(wb_sel_is or wb_dat_is)
+begin
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+  `ifdef LITLE_ENDIAN
+	case (wb_sel_is)
+		4'b0001 : wb_adr_int_lsb = 2'h0;
+		4'b0010 : wb_adr_int_lsb = 2'h1;
+		4'b0100 : wb_adr_int_lsb = 2'h2;
+		4'b1000 : wb_adr_int_lsb = 2'h3;
+		default : wb_adr_int_lsb = 2'h0;
+	endcase // case(wb_sel_i)
+  `else
+	case (wb_sel_is)
+		4'b0001 : wb_adr_int_lsb = 2'h3;
+		4'b0010 : wb_adr_int_lsb = 2'h2;
+		4'b0100 : wb_adr_int_lsb = 2'h1;
+		4'b1000 : wb_adr_int_lsb = 2'h0;
+		default : wb_adr_int_lsb = 2'h0;
+	endcase // case(wb_sel_i)
+  `endif
+end
+
+assign wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], wb_adr_int_lsb};
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r106.v b/cvs/uart16650/uart_wb.r106.v
new file mode 100755
index 0000000000000000000000000000000000000000..373686c70f0984556fbd52142a6bfc1a642e18dd
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r106.v
@@ -0,0 +1,317 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.16  2002/07/29 21:16:18  gorban
+// The uart_defines.v file is included again in sources.
+//
+// Revision 1.15  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.12  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+assign wb_adr_int = wb_adr_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+reg [1:0] wb_adr_int_lsb;
+
+always @(wb_sel_is or wb_dat_is)
+begin
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+  `ifdef LITLE_ENDIAN
+	case (wb_sel_is)
+		4'b0001 : wb_adr_int_lsb = 2'h0;
+		4'b0010 : wb_adr_int_lsb = 2'h1;
+		4'b0100 : wb_adr_int_lsb = 2'h2;
+		4'b1000 : wb_adr_int_lsb = 2'h3;
+		default : wb_adr_int_lsb = 2'h0;
+	endcase // case(wb_sel_i)
+  `else
+	case (wb_sel_is)
+		4'b0001 : wb_adr_int_lsb = 2'h3;
+		4'b0010 : wb_adr_int_lsb = 2'h2;
+		4'b0100 : wb_adr_int_lsb = 2'h1;
+		4'b1000 : wb_adr_int_lsb = 2'h0;
+		default : wb_adr_int_lsb = 2'h0;
+	endcase // case(wb_sel_i)
+  `endif
+end
+
+assign wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], wb_adr_int_lsb};
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r27.v b/cvs/uart16650/uart_wb.r27.v
new file mode 100755
index 0000000000000000000000000000000000000000..64be28cf10ebcd21a49f1e00298d0c44b23139b9
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r27.v
@@ -0,0 +1,125 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_TX_FIFO.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+`include "timescale.v"
+
+module uart_wb (clk,
+        wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
+	we_o, re_o // Write and read enable output for the core
+	
+        );
+
+input				clk;
+
+// WISHBONE interface	
+input				wb_rst_i;
+input				wb_we_i;
+input				wb_stb_i;
+input				wb_cyc_i;
+output				wb_ack_o;
+output				we_o;
+output				re_o;
+
+wire				we_o;
+reg				wb_ack_o;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		wb_ack_o <= #1 1'b0;
+	end
+	else
+	begin
+//		wb_ack_o <= #1 wb_stb_i & wb_cyc_i; // 1 clock wait state on all transfers
+		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
+	end
+end
+
+assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
+assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
+
+endmodule
diff --git a/cvs/uart16650/uart_wb.r29.v b/cvs/uart16650/uart_wb.r29.v
new file mode 100755
index 0000000000000000000000000000000000000000..b9cecd5a9f611983061f86e8ee47cd23dc73dba9
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r29.v
@@ -0,0 +1,134 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_TX_FIFO.v                                              ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+`include "timescale.v"
+
+module uart_wb (clk,
+        wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
+	we_o, re_o // Write and read enable output for the core
+	
+        );
+
+input				clk;
+
+// WISHBONE interface	
+input				wb_rst_i;
+input				wb_we_i;
+input				wb_stb_i;
+input				wb_cyc_i;
+output				wb_ack_o;
+output				we_o;
+output				re_o;
+
+wire				we_o;
+reg				wb_ack_o;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		wb_ack_o <= #1 1'b0;
+	end
+	else
+	begin
+//		wb_ack_o <= #1 wb_stb_i & wb_cyc_i; // 1 clock wait state on all transfers
+		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
+	end
+end
+
+assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
+assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
+
+endmodule
diff --git a/cvs/uart16650/uart_wb.r33.v b/cvs/uart16650/uart_wb.r33.v
new file mode 100755
index 0000000000000000000000000000000000000000..2f5d8ac8434b0af9136ec560392b709b391d4149
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r33.v
@@ -0,0 +1,140 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+module uart_wb (clk,
+        wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
+	we_o, re_o // Write and read enable output for the core
+	
+        );
+
+input				clk;
+
+// WISHBONE interface	
+input				wb_rst_i;
+input				wb_we_i;
+input				wb_stb_i;
+input				wb_cyc_i;
+output				wb_ack_o;
+output				we_o;
+output				re_o;
+
+wire				we_o;
+reg				wb_ack_o;
+
+always @(posedge clk or posedge wb_rst_i)
+begin
+	if (wb_rst_i)
+	begin
+		wb_ack_o <= #1 1'b0;
+	end
+	else
+	begin
+//		wb_ack_o <= #1 wb_stb_i & wb_cyc_i; // 1 clock wait state on all transfers
+		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
+	end
+end
+
+assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
+assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
+
+endmodule
diff --git a/cvs/uart16650/uart_wb.r48.v b/cvs/uart16650/uart_wb.r48.v
new file mode 100755
index 0000000000000000000000000000000000000000..51519bb776cb17018fa4e394a9c6e13bcfc43a80
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r48.v
@@ -0,0 +1,201 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
+	wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+`endif
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) 
+		wb_ack_o <= #1 1'b0;
+	else 
+		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
+
+assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
+assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_i)
+	wb_dat8_i = wb_dat_i;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_i)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+			// later add here selects for 16 and 32 bits
+		endcase // case(wb_sel_i)
+
+// handle input (this will add a little timing overhead on input but it should asynchronous
+// or another one clock delay will be introduced)
+always @(wb_sel_i or wb_dat_i)
+	case (wb_sel_i)
+		4'b0001 : wb_dat8_i = wb_dat_i[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_i[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_i[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_i[31:24];
+		default : wb_dat8_i = wb_dat_i[7:0];
+	endcase // case(wb_sel_i)
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r50.v b/cvs/uart16650/uart_wb.r50.v
new file mode 100755
index 0000000000000000000000000000000000000000..37784505e3bee3784b70a3cf7a254a6b7b363b36
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r50.v
@@ -0,0 +1,267 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wb_ack; // wb_ack is sampled to make 2 clock wait state between transfers 
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+assign wb_adr_int = wb_adr_is;
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+always @(wb_sel_is or wb_dat_is)
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r64.v b/cvs/uart16650/uart_wb.r64.v
new file mode 100755
index 0000000000000000000000000000000000000000..008713515af738901b6f42bb897c4cc6b2d9a2b7
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r64.v
@@ -0,0 +1,271 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+assign wb_adr_int = wb_adr_is;
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+always @(wb_sel_is or wb_dat_is)
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r73.v b/cvs/uart16650/uart_wb.r73.v
new file mode 100755
index 0000000000000000000000000000000000000000..34cfcf4ccb970e5dd0c779e40c00e50400c8c6a9
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r73.v
@@ -0,0 +1,285 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+assign wb_adr_int = wb_adr_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+always @(wb_sel_is or wb_dat_is)
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+reg [1:0] adr2 ; // lower 2 bits of regenerated address
+always @(wb_sel_is)
+	case (wb_sel_is)
+		4'b0001 : adr2 = 2'b00;
+		4'b0010 : adr2 = 2'b01;
+		4'b0100 : adr2 = 2'b10;
+		4'b1000 : adr2 = 2'b11;
+		default : adr2 = 2'b0;
+	endcase // case(wb_sel_is)
+		
+assign 	 wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], adr2};
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r75.v b/cvs/uart16650/uart_wb.r75.v
new file mode 100755
index 0000000000000000000000000000000000000000..abe62710e1f30fc98c2c3d942085974137820b7b
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r75.v
@@ -0,0 +1,295 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.13  2002/02/07 16:20:20  gorban
+// major bug in 32-bit mode that prevented register access fixed.
+//
+// Revision 1.12  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+assign wb_adr_int = wb_adr_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+always @(wb_sel_is or wb_dat_is)
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+reg [1:0] adr2 ; // lower 2 bits of regenerated address
+always @(wb_sel_is)
+	case (wb_sel_is)
+    `ifdef BIG_BYTE_ENDIAN
+		4'b0001 : adr2 = 2'b11;
+		4'b0010 : adr2 = 2'b10;
+		4'b0100 : adr2 = 2'b01;
+		4'b1000 : adr2 = 2'b00;
+    `else
+		4'b0001 : adr2 = 2'b00;
+		4'b0010 : adr2 = 2'b01;
+		4'b0100 : adr2 = 2'b10;
+		4'b1000 : adr2 = 2'b11;
+    `endif
+		default : adr2 = 2'b0;
+	endcase // case(wb_sel_is)
+		
+assign 	 wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], adr2};
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r79.v b/cvs/uart16650/uart_wb.r79.v
new file mode 100755
index 0000000000000000000000000000000000000000..7bbb02290b913ff157240716c80e861ff2698852
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r79.v
@@ -0,0 +1,274 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.12  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+//`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+assign wb_adr_int = wb_adr_is;
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+always @(wb_sel_is or wb_dat_is)
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/cvs/uart16650/uart_wb.r84.v b/cvs/uart16650/uart_wb.r84.v
new file mode 100755
index 0000000000000000000000000000000000000000..b0d22433927504184d14babc6552b40c26077a4c
--- /dev/null
+++ b/cvs/uart16650/uart_wb.r84.v
@@ -0,0 +1,290 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+////  uart_wb.v                                                   ////
+////                                                              ////
+////                                                              ////
+////  This file is part of the "UART 16550 compatible" project    ////
+////  http://www.opencores.org/cores/uart16550/                   ////
+////                                                              ////
+////  Documentation related to this project:                      ////
+////  - http://www.opencores.org/cores/uart16550/                 ////
+////                                                              ////
+////  Projects compatibility:                                     ////
+////  - WISHBONE                                                  ////
+////  RS232 Protocol                                              ////
+////  16550D uart (mostly supported)                              ////
+////                                                              ////
+////  Overview (main Features):                                   ////
+////  UART core WISHBONE interface.                               ////
+////                                                              ////
+////  Known problems (limits):                                    ////
+////  Inserts one wait state on all transfers.                    ////
+////  Note affected signals and the way they are affected.        ////
+////                                                              ////
+////  To Do:                                                      ////
+////  Nothing.                                                    ////
+////                                                              ////
+////  Author(s):                                                  ////
+////      - gorban@opencores.org                                  ////
+////      - Jacob Gorban                                          ////
+////      - Igor Mohor (igorm@opencores.org)                      ////
+////                                                              ////
+////  Created:        2001/05/12                                  ////
+////  Last Updated:   2001/05/17                                  ////
+////                  (See log for the revision history)          ////
+////                                                              ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// Copyright (C) 2000, 2001 Authors                             ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+////                                                              ////
+//////////////////////////////////////////////////////////////////////
+//
+// CVS Revision History
+//
+// $Log: not supported by cvs2svn $
+// Revision 1.15  2002/07/22 23:02:23  gorban
+// Bug Fixes:
+//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
+//   Problem reported by Kenny.Tung.
+//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
+//
+// Improvements:
+//  * Made FIFO's as general inferrable memory where possible.
+//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
+//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
+//
+//  * Added optional baudrate output (baud_o).
+//  This is identical to BAUDOUT* signal on 16550 chip.
+//  It outputs 16xbit_clock_rate - the divided clock.
+//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
+//
+// Revision 1.12  2001/12/19 08:03:34  mohor
+// Warnings cleared.
+//
+// Revision 1.11  2001/12/06 14:51:04  gorban
+// Bug in LSR[0] is fixed.
+// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
+//
+// Revision 1.10  2001/12/03 21:44:29  gorban
+// Updated specification documentation.
+// Added full 32-bit data bus interface, now as default.
+// Address is 5-bit wide in 32-bit data bus mode.
+// Added wb_sel_i input to the core. It's used in the 32-bit mode.
+// Added debug interface with two 32-bit read-only registers in 32-bit mode.
+// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
+// My small test bench is modified to work with 32-bit mode.
+//
+// Revision 1.9  2001/10/20 09:58:40  gorban
+// Small synopsis fixes
+//
+// Revision 1.8  2001/08/24 21:01:12  mohor
+// Things connected to parity changed.
+// Clock devider changed.
+//
+// Revision 1.7  2001/08/23 16:05:05  mohor
+// Stop bit bug fixed.
+// Parity bug fixed.
+// WISHBONE read cycle bug fixed,
+// OE indicator (Overrun Error) bug fixed.
+// PE indicator (Parity Error) bug fixed.
+// Register read bug fixed.
+//
+// Revision 1.4  2001/05/31 20:08:01  gorban
+// FIFO changes and other corrections.
+//
+// Revision 1.3  2001/05/21 19:12:01  gorban
+// Corrected some Linter messages.
+//
+// Revision 1.2  2001/05/17 18:34:18  gorban
+// First 'stable' release. Should be sythesizable now. Also added new header.
+//
+// Revision 1.0  2001-05-17 21:27:13+02  jacob
+// Initial revision
+//
+//
+
+// UART core WISHBONE interface 
+//
+// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
+// Company: Flextronics Semiconductor
+//
+
+// synopsys translate_off
+`include "timescale.v"
+// synopsys translate_on
+`include "uart_defines.v"
+ 
+module uart_wb (clk, wb_rst_i, 
+	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
+	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
+	we_o, re_o // Write and read enable output for the core
+);
+
+input 		  clk;
+
+// WISHBONE interface	
+input 		  wb_rst_i;
+input 		  wb_we_i;
+input 		  wb_stb_i;
+input 		  wb_cyc_i;
+input [3:0]   wb_sel_i;
+input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
+
+`ifdef DATA_BUS_WIDTH_8
+input [7:0]  wb_dat_i; //input WISHBONE bus 
+output [7:0] wb_dat_o;
+reg [7:0] 	 wb_dat_o;
+wire [7:0] 	 wb_dat_i;
+reg [7:0] 	 wb_dat_is;
+`else // for 32 data bus mode
+input [31:0]  wb_dat_i; //input WISHBONE bus 
+output [31:0] wb_dat_o;
+reg [31:0] 	  wb_dat_o;
+wire [31:0]   wb_dat_i;
+reg [31:0] 	  wb_dat_is;
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
+output [7:0]  wb_dat8_i;
+input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
+output 		  wb_ack_o;
+output 		  we_o;
+output 		  re_o;
+
+wire 			  we_o;
+reg 			  wb_ack_o;
+reg [7:0] 	  wb_dat8_i;
+wire [7:0] 	  wb_dat8_o;
+wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
+reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
+reg 								wb_we_is;
+reg 								wb_cyc_is;
+reg 								wb_stb_is;
+reg [3:0] 						wb_sel_is;
+wire [3:0]   wb_sel_i;
+reg 			 wre ;// timing control signal for write or read enable
+
+// wb_ack_o FSM
+reg [1:0] 	 wbstate;
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_ack_o <= #1 1'b0;
+		wbstate <= #1 0;
+		wre <= #1 1'b1;
+	end else
+		case (wbstate)
+			0: begin
+				if (wb_stb_is & wb_cyc_is) begin
+					wre <= #1 0;
+					wbstate <= #1 1;
+					wb_ack_o <= #1 1;
+				end else begin
+					wre <= #1 1;
+					wb_ack_o <= #1 0;
+				end
+			end
+			1: begin
+			   wb_ack_o <= #1 0;
+				wbstate <= #1 2;
+				wre <= #1 0;
+			end
+			2,3: begin
+				wb_ack_o <= #1 0;
+				wbstate <= #1 0;
+				wre <= #1 0;
+			end
+		endcase
+
+assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
+assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
+
+// Sample input signals
+always  @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i) begin
+		wb_adr_is <= #1 0;
+		wb_we_is <= #1 0;
+		wb_cyc_is <= #1 0;
+		wb_stb_is <= #1 0;
+		wb_dat_is <= #1 0;
+		wb_sel_is <= #1 0;
+	end else begin
+		wb_adr_is <= #1 wb_adr_i;
+		wb_we_is <= #1 wb_we_i;
+		wb_cyc_is <= #1 wb_cyc_i;
+		wb_stb_is <= #1 wb_stb_i;
+		wb_dat_is <= #1 wb_dat_i;
+		wb_sel_is <= #1 wb_sel_i;
+	end
+
+assign wb_adr_int = wb_adr_is;
+
+`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else
+		wb_dat_o <= #1 wb_dat8_o;
+
+always @(wb_dat_is)
+	wb_dat8_i = wb_dat_is;
+
+`else // 32-bit bus
+// put output to the correct byte in 32 bits using select line
+always @(posedge clk or posedge wb_rst_i)
+	if (wb_rst_i)
+		wb_dat_o <= #1 0;
+	else if (re_o)
+		case (wb_sel_is)
+			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
+			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
+			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
+			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
+			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
+ 			default: wb_dat_o <= #1 0;
+		endcase // case(wb_sel_i)
+
+always @(wb_sel_is or wb_dat_is)
+	case (wb_sel_is)
+		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
+		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
+		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
+		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
+		default : wb_dat8_i = wb_dat_is[7:0];
+	endcase // case(wb_sel_i)
+
+`endif // !`ifdef DATA_BUS_WIDTH_8
+
+endmodule
+
+
+
+
+
+
+
+
+
+
diff --git a/norm/api_clone_java.norm b/norm/api_clone_java.norm
deleted file mode 100644
index 5c45da9ffda9130455fba5b508798345004618b5..0000000000000000000000000000000000000000
--- a/norm/api_clone_java.norm
+++ /dev/null
@@ -1,132 +0,0 @@
-include "java.grm"
-
-redefine method_body
-        [repeat block preferred with '; ] 
-    |  [opt annotation_default] ';             % T.D. Oct 2007
-end define
-
-redefine modifier
-        'abstract
-    |   'final
-    |   'public
-    |   'protected
-    |   'private
-    |   'static
-    |   'transient
-    |   'volatile
-    |   'native
-    |   'synchronized
-    |   'strictfp		% Added strictfp XG July 23, 2002
-    |   [repeat annotation ignored]		% T.D. Oct 2007
-end define
-
-redefine constructor_body
-    [repeat block preferred with '{ '} ]
-end define
-
-redefine program
-    [package_declaration*]
-end define
-
-redefine type_declaration
-        [class_declaration]      [NL][NL]
-    |   [interface_declaration]  [NL][NL]
-    |   [enum_declaration]	    [NL] % T.D. Oct 2007
-end define
-
-redefine enum_body
-    '{                                    [IN]
-       [list enum_element] [opt ',]
-       [repeat class_body_declaration ordered]    [EX]
-    '} [opt ';]                           [NL][NL]
-end define
-
-% remove some extra spaces
-redefine import_declaration
-	'import [opt 'static] [imported_name] '; [NL]
-    | 	'; [NL] 	% JRC Apr 08
-end define
-
-redefine package_declaration
-    [opt package_header kept]
-    [repeat import_declaration ignored] 
-    [repeat type_declaration kept]
-end define
-
-redefine class_header
-    [repeat modifier ordered] 'class [class_name] [opt extends_clause] [opt implements_clause]
-end define
-
-% T.D. Oct 2007 -- added annotation marker 
-redefine interface_header
-    [repeat modifier ordered] [opt annot_marker] 'interface [interface_name] [opt extends_clause] [opt implements_clause]
-end define
-
-redefine enum_header
-    [repeat modifier ordered] [opt id] 'enum [opt declared_name]
-end define
-
-redefine extends_clause
-    'extends [list type_name+ ordered]
-end define
-
-redefine implements_clause
-    'implements [list qualified_name+ ordered]
-end define
-
-redefine class_or_interface_body
-    '{                                    [NL][IN]
-       [repeat class_body_declaration kept ordered ignored when Private]    [EX] [NL]
-    '} [opt ';]                           [NL][NL]
-end define
-
-
-% to match Java Code like:
-% public <T> void someMethod(T t) {
-%	// ...
-% }
-redefine constructor_declaration
-    [NL] [repeat modifier ordered] [opt generic_parameter] [constructor_declarator] [opt throws] [constructor_body] [NL][NL]
-end define
-
-redefine variable_declaration
-    [repeat modifier ordered] [type_specifier] [variable_declarators] '; [NL]
-end define
-
-redefine variable_declarators
-    [list variable_declarator+ ordered]
-end define
-
-% Method declarations 
-
-% generic method declaration (to match generic types used only in a method's declaration and body)
-redefine method_declaration
-    [NL] [repeat modifier ordered] [opt generic_parameter] [type_specifier] [method_declarator] [opt throws] [method_body]
-end define
-
-redefine throws
-    'throws [list qualified_name+ ordered]
-end define
-
-redefine annotation_value_list
-      [single_annotation_value]	% for single value annotation
-    | [list keyed_annotation_value ordered]
-end define
-
-redefine single_annotation_value
-      [expression]					% must be constant
-    | [nested_annotation]
-    | { [list expression_or_nested_annotation ordered] }	% array of annotation values
-end define
-
-function contains Object [any] 
-    match * [any] Object
-end function
-
-function Private A  [class_body_declaration]
-    match  [class_or_interface_body]
-        B  [class_or_interface_body] 
-    construct M  [modifier *] _  [^ A] 
-    construct PublicModifiers [modifier*] 'public 'protected 
-    where not M [contains each PublicModifiers]
-end function
diff --git a/norm/java.norm b/norm/java.norm
deleted file mode 100644
index fdd5e59960156309d91cc1f9375ac6aee3b1463f..0000000000000000000000000000000000000000
--- a/norm/java.norm
+++ /dev/null
@@ -1,123 +0,0 @@
-include "java.grm"
-
-% Yijun Yu, April, 2011
-% The rules are redefined to include annotations
-
-redefine method_body
-        [repeat block preferred with ';] 
-    |  [opt annotation_default] ';             % T.D. Oct 2007
-end define
-
-redefine constructor_body
-    [repeat block preferred with '{ '}]
-end define
-
-redefine program
-    [package_declaration*]
-end define
-
-redefine type_declaration
-        [class_declaration kept]      [NL][NL]
-    |   [interface_declaration kept ordered]  [NL][NL]
-    |   [enum_declaration kept]	    [NL] % T.D. Oct 2007
-end define
-
-redefine enum_body
-    '{                                    [IN]
-       [list enum_element] [opt ',]
-       [repeat class_body_declaration kept ordered]    [EX]
-    '} [opt ';]                           [NL][NL]
-end define
-
-redefine import_declaration
-	'import [opt 'static] [imported_name] '; [NL]
-    | 	'; [NL] 	% JRC Apr 08
-end define
-
-redefine package_declaration
-    [opt package_header kept]
-    [repeat import_declaration kept ordered] 
-    [repeat type_declaration]
-end define
-
-redefine class_header
-    [repeat modifier ordered] 'class [class_name] [opt extends_clause] [opt implements_clause]
-end define
-
-% T.D. Oct 2007 -- added annotation marker 
-redefine interface_header
-    [repeat modifier ordered] [opt annot_marker] 'interface [interface_name] [opt extends_clause] [opt implements_clause]
-end define
-
-redefine enum_header
-    [repeat modifier ordered] [opt id] 'enum [opt declared_name]
-end define
-
-redefine extends_clause
-    'extends [list type_name+ ordered]
-end define
-
-redefine implements_clause
-    'implements [list qualified_name+ ordered]
-end define
-
-redefine class_or_interface_body
-    '{                                    [NL][IN]
-       [repeat class_body_declaration kept ordered ignored when Private]    [EX] [NL]
-    '} [opt ';]                           [NL][NL]
-end define
-
-
-% to match Java Code like:
-% public <T> void someMethod(T t) {
-%	// ...
-% }
-redefine constructor_declaration
-    [NL] [repeat modifier ordered] [opt generic_parameter] [constructor_declarator] [opt throws] [constructor_body] [NL][NL]
-end define
-
-redefine variable_declaration
-    [repeat modifier ordered] [type_specifier] [variable_declarators] '; [NL]
-end define
-
-redefine variable_declarators
-    [list variable_declarator+ ordered]
-end define
-
-% Method declarations 
-
-% generic method declaration (to match generic types used only in a method's declaration and body)
-redefine method_declaration
-    [NL] [repeat modifier ordered] [opt generic_parameter] [type_specifier] [method_declarator] [opt throws] [method_body]
-end define
-
-redefine throws
-    'throws [list qualified_name+ ordered]
-end define
-
-redefine annotation_value_list
-      [single_annotation_value]	% for single value annotation
-    | [list keyed_annotation_value ordered]
-end define
-
-redefine single_annotation_value
-      [expression]					% must be constant
-    | [nested_annotation]
-    | { [list expression_or_nested_annotation ordered] }	% array of annotation values
-end define
-
-redefine catch_clause
-     'catch '( [repeat modifier ordered] [type_specifier] [variable_name] ') [block]  % July 15
-end define
-
-function contains Object [any] 
-    match * [any] Object
-end function
-
-function Private A  [class_body_declaration]
-    match  [class_or_interface_body]
-        B  [class_or_interface_body] 
-    construct M  [modifier *] _  [^ A] 
-    construct PublicModifiers [modifier*] 'public 'protected 
-    where not M [contains each PublicModifiers]
-end function
diff --git a/norm/problem.norm b/norm/problem.norm
deleted file mode 100644
index 88617d89ffd6e14e7c2582cadfe47a7394e1d8f4..0000000000000000000000000000000000000000
--- a/norm/problem.norm
+++ /dev/null
@@ -1,34 +0,0 @@
-include "problem.grm"
-
-redefine problem_description
-   [indent] [repeat E+ ordered by Small] [dedent]
-end define
-
-redefine E
-   [NL] [name] [opt type] [repeat details ignored when Context] [opt ':] [opt stringlit]
- | [NL] [name] [SP] [SPOFF] [rel] [SPON] [name] [repeat details ignored when Context] [opt desc]
-end define
-
-redefine details
-   '{ [indent] 
-   [list phenomena ordered]
-   [NL] [dedent] '} 
-end define
-
-rule Small B [E]
- match [E] A [E]
- construct SA [stringlit] _ [quote A]
- construct SB [stringlit] _ [quote B]
- where SA [< SB] 
-end rule
-
-function Context B [details]
-  match [E] A [E]
-  deconstruct A 
-   N [name] T [opt type]
-   D [repeat details] 
-   C [opt ':] 
-   Desc [opt stringlit]
-  deconstruct not T
-    'M
-end function
diff --git a/norm/verilog.norm b/norm/verilog.norm
deleted file mode 100644
index eda8ac8a1418da720c488c00d47e8cb6db639459..0000000000000000000000000000000000000000
--- a/norm/verilog.norm
+++ /dev/null
@@ -1,51 +0,0 @@
-include "v.grm"
-redefine module
-      [module_declaration] '; [NL]
-      [repeat statement kept ordered] [NL]
-      'endmodule [NL]
-    | [macro_statement]
-end define
-
-redefine declaration
-    [parameter_specification]
-  | [variable_declaration] 
-  | [variable_assignment_statement]
-  | [if_statement]
-  | [case_statement]
-  | [block_statement ignored]
-  | [qualified_expression]
-  | [component_configuration]
-  | [function_decl]
-end define
-
-redefine case_statement
-   [case] '( [expr] ')
-     [case_statement_alternative* kept ordered]
-   'endcase
-end define
-
-redefine case_statement_alternative
-   [list choice ordered]  ': [statement* kept ordered]
-end define
-
-redefine case_statement_alternative
-   [macro_statement*] ...
-end define
-redefine case_statement_alternative
-   ... [macro_statement*] 
-end define
-
-redefine module_declaration
-    'module [id] '( [list part_module_declaration ordered] ') 
-end define
-
-
-define source
-      [module* kept]
-    | [empty]
-end define
-
-redefine program
-      [source] [opt source]
-end define
-
diff --git a/norm/verilog2.norm b/norm/verilog2.norm
deleted file mode 100644
index b18eab1d4dcd10567964b4242848ffb41d7d79cf..0000000000000000000000000000000000000000
--- a/norm/verilog2.norm
+++ /dev/null
@@ -1,21 +0,0 @@
-include "v.grm"
-redefine module
-      [module_declaration] '; [NL]
-      [repeat statement ignored] [NL]
-      'endmodule [NL]
-    | [macro_statement]
-end define
-
-redefine module_declaration
-    'module [id] '( [list part_module_declaration ordered] ') 
-end define
-
-define source
-      [module* kept]
-    | [empty]
-end define
-
-redefine program
-      [source] [opt source]
-end define
-
diff --git a/source/java/HelloWorld-2.java b/source/java/HelloWorld-2.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ec434657a1a2b41dcc3b1e03ddedc2e79060714
--- /dev/null
+++ b/source/java/HelloWorld-2.java
@@ -0,0 +1,11 @@
+/* HelloWorld */
+public class HelloWorld 
+{
+ static String world = "world"; // ending
+
+ static String hello = "Hello"; // beginning
+ public  static void main(String args[]) {
+  System.out.println  (hello + ", " 
+     + world + "!");
+ }
+}
diff --git a/source/java/HelloWorld2.java b/source/java/HelloWorld2.java
deleted file mode 100644
index 8ec434657a1a2b41dcc3b1e03ddedc2e79060714..0000000000000000000000000000000000000000
--- a/source/java/HelloWorld2.java
+++ /dev/null
@@ -1,11 +0,0 @@
-/* HelloWorld */
-public class HelloWorld 
-{
- static String world = "world"; // ending
-
- static String hello = "Hello"; // beginning
- public  static void main(String args[]) {
-  System.out.println  (hello + ", " 
-     + world + "!");
- }
-}
diff --git a/source/java/HelloWorld3.java b/source/java/HelloWorld3.java
deleted file mode 100644
index 91b8fcc48bde1a7e13f7e325c87e90be9a55327f..0000000000000000000000000000000000000000
--- a/source/java/HelloWorld3.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
-* HelloWorld 
-*/
-public class HelloWorld 
-{
- // beginning
- static private String hello = "Hello"; 
- private static String world = "world"; // ending
- static public void main(String args[]) {
-  System.out.println(hello + ", " + world + "!");
- }
-}
-/* HelloWorld */
-public class HelloWorld 
-{
- static String world = "world"; // ending
-
- static String hello = "Hello"; // beginning
- public  static void main(String args[]) {
-  System.out.println  (hello + ", " 
-     + world + "!");
- }
-}
diff --git a/source/java/HelloWorld4.java b/source/java/HelloWorld4.java
deleted file mode 100644
index 3e37ea20b2ed67ba68c6c218a7013f91e65fd41d..0000000000000000000000000000000000000000
--- a/source/java/HelloWorld4.java
+++ /dev/null
@@ -1,14 +0,0 @@
-/**
-* HelloWorld 
-*/
-public class HelloWorld 
-{
- // beginning
- static private String hello = "Hello"; 
- private static String world = "world"; // ending
- static public void main(String args[]) {
-  if (true) {
-  	System.out.println(hello + ", " + world + "!");
-  }
- }
-}
diff --git a/source/java/abc.java b/source/java/abc.java
deleted file mode 100644
index 40eba3ddd8c470d27f5a8f496f7c017e8af941e5..0000000000000000000000000000000000000000
--- a/source/java/abc.java
+++ /dev/null
@@ -1,5 +0,0 @@
-public class abc {
-	static public void main(String args[]) {
-		System.out.println("Hello, world!");
-	}
-}
diff --git a/source/norm/api_clone_java.norm b/source/norm/api_clone_java.norm
new file mode 100644
index 0000000000000000000000000000000000000000..96e9efb2298a56de0169cd61059d52eac993196e
--- /dev/null
+++ b/source/norm/api_clone_java.norm
@@ -0,0 +1,132 @@
+include "java.grm"
+% Yijun Yu: May 2011
+redefine method_body
+        [repeat block preferred with '; ] 
+    |  [opt annotation_default] ';             % T.D. Oct 2007
+end define
+
+redefine modifier
+        'abstract
+    |   'final
+    |   'public
+    |   'protected
+    |   'private
+    |   'static
+    |   'transient
+    |   'volatile
+    |   'native
+    |   'synchronized
+    |   'strictfp		% Added strictfp XG July 23, 2002
+    |   [repeat annotation ignored]		% T.D. Oct 2007
+end define
+
+redefine constructor_body
+    [repeat block preferred with '{ '} ]
+end define
+
+redefine program
+    [package_declaration*]
+end define
+
+redefine type_declaration
+        [class_declaration]      [NL][NL]
+    |   [interface_declaration]  [NL][NL]
+    |   [enum_declaration]	    [NL] % T.D. Oct 2007
+end define
+
+redefine enum_body
+    '{                                    [IN]
+       [list enum_element] [opt ',]
+       [repeat class_body_declaration ordered]    [EX]
+    '} [opt ';]                           [NL][NL]
+end define
+
+% remove some extra spaces
+redefine import_declaration
+	'import [opt 'static] [imported_name] '; [NL]
+    | 	'; [NL] 	% JRC Apr 08
+end define
+
+redefine package_declaration
+    [opt package_header kept]
+    [repeat import_declaration ignored] 
+    [repeat type_declaration kept]
+end define
+
+redefine class_header
+    [repeat modifier ordered] 'class [class_name] [opt extends_clause] [opt implements_clause]
+end define
+
+% T.D. Oct 2007 -- added annotation marker 
+redefine interface_header
+    [repeat modifier ordered] [opt annot_marker] 'interface [interface_name] [opt extends_clause] [opt implements_clause]
+end define
+
+redefine enum_header
+    [repeat modifier ordered] [opt id] 'enum [opt declared_name]
+end define
+
+redefine extends_clause
+    'extends [list type_name+ ordered]
+end define
+
+redefine implements_clause
+    'implements [list qualified_name+ ordered]
+end define
+
+redefine class_or_interface_body
+    '{                                    [NL][IN]
+       [repeat class_body_declaration kept ordered ignored when Private]    [EX] [NL]
+    '} [opt ';]                           [NL][NL]
+end define
+
+
+% to match Java Code like:
+% public <T> void someMethod(T t) {
+%	// ...
+% }
+redefine constructor_declaration
+    [NL] [repeat modifier ordered] [opt generic_parameter] [constructor_declarator] [opt throws] [constructor_body] [NL][NL]
+end define
+
+redefine variable_declaration
+    [repeat modifier ordered] [type_specifier] [variable_declarators] '; [NL]
+end define
+
+redefine variable_declarators
+    [list variable_declarator+ ordered]
+end define
+
+% Method declarations 
+
+% generic method declaration (to match generic types used only in a method's declaration and body)
+redefine method_declaration
+    [NL] [repeat modifier ordered] [opt generic_parameter] [type_specifier] [method_declarator] [opt throws] [method_body]
+end define
+
+redefine throws
+    'throws [list qualified_name+ ordered]
+end define
+
+redefine annotation_value_list
+      [single_annotation_value]	% for single value annotation
+    | [list keyed_annotation_value ordered]
+end define
+
+redefine single_annotation_value
+      [expression]					% must be constant
+    | [nested_annotation]
+    | { [list expression_or_nested_annotation ordered] }	% array of annotation values
+end define
+
+function contains Object [any] 
+    match * [any] Object
+end function
+
+function Private A  [class_body_declaration]
+    match  [class_or_interface_body]
+        B  [class_or_interface_body] 
+    construct M  [modifier *] _  [^ A] 
+    construct PublicModifiers [modifier*] 'public 'protected 
+    where not M [contains each PublicModifiers]
+end function
diff --git a/source/norm/java.norm b/source/norm/java.norm
new file mode 100644
index 0000000000000000000000000000000000000000..1bfd18c7388d6d7dbf6d190fd8f6e28074f768d2
--- /dev/null
+++ b/source/norm/java.norm
@@ -0,0 +1,119 @@
+include "java.grm"
+
+% Yijun Yu, April, 2011
+% The rules are redefined to include annotations
+
+redefine method_body
+        [repeat block preferred with ';] 
+    |  [opt annotation_default] ';             % T.D. Oct 2007
+end define
+
+redefine constructor_body
+    [repeat block preferred with '{ '}]
+end define
+
+redefine type_declaration
+        [class_declaration kept]      [NL][NL]
+    |   [interface_declaration kept ordered]  [NL][NL]
+    |   [enum_declaration kept]	    [NL] % T.D. Oct 2007
+end define
+
+redefine enum_body
+    '{                                    [IN]
+       [list enum_element] [opt ',]
+       [repeat class_body_declaration kept ordered]    [EX]
+    '} [opt ';]                           [NL][NL]
+end define
+
+redefine import_declaration
+	'import [opt 'static] [imported_name] '; [NL]
+    | 	'; [NL] 	% JRC Apr 08
+end define
+
+redefine package_declaration
+    [opt package_header kept]
+    [repeat import_declaration kept ordered] 
+    [repeat type_declaration]
+end define
+
+redefine class_header
+    [repeat modifier ordered] 'class [class_name] [opt extends_clause] [opt implements_clause]
+end define
+
+% T.D. Oct 2007 -- added annotation marker 
+redefine interface_header
+    [repeat modifier ordered] [opt annot_marker] 'interface [interface_name] [opt extends_clause] [opt implements_clause]
+end define
+
+redefine enum_header
+    [repeat modifier ordered] [opt id] 'enum [opt declared_name]
+end define
+
+redefine extends_clause
+    'extends [list type_name+ ordered]
+end define
+
+redefine implements_clause
+    'implements [list qualified_name+ ordered]
+end define
+
+redefine class_or_interface_body
+    '{                                    [NL][IN]
+       [repeat class_body_declaration kept ordered ignored when Private]    [EX] [NL]
+    '} [opt ';]                           [NL][NL]
+end define
+
+
+% to match Java Code like:
+% public <T> void someMethod(T t) {
+%	// ...
+% }
+redefine constructor_declaration
+    [NL] [repeat modifier ordered] [opt generic_parameter] [constructor_declarator] [opt throws] [constructor_body] [NL][NL]
+end define
+
+redefine variable_declaration
+    [repeat modifier ordered] [type_specifier] [variable_declarators] '; [NL]
+end define
+
+redefine variable_declarators
+    [list variable_declarator+ ordered]
+end define
+
+% Method declarations 
+
+% generic method declaration (to match generic types used only in a method's declaration and body)
+redefine method_declaration
+    [NL] [repeat modifier ordered] [opt generic_parameter] [type_specifier] [method_declarator] [opt throws] [method_body]
+end define
+
+redefine throws
+    'throws [list qualified_name+ ordered]
+end define
+
+redefine annotation_value_list
+      [single_annotation_value]	% for single value annotation
+    | [list keyed_annotation_value ordered]
+end define
+
+redefine single_annotation_value
+      [expression]					% must be constant
+    | [nested_annotation]
+    | { [list expression_or_nested_annotation ordered] }	% array of annotation values
+end define
+
+redefine catch_clause
+     'catch '( [repeat modifier ordered] [type_specifier] [variable_name] ') [block]  % July 15
+end define
+
+function contains Object [any] 
+    match * [any] Object
+end function
+
+function Private A  [class_body_declaration]
+    match  [class_or_interface_body]
+        B  [class_or_interface_body] 
+    construct M  [modifier *] _  [^ A] 
+    construct PublicModifiers [modifier*] 'public 'protected 
+    where not M [contains each PublicModifiers]
+end function
diff --git a/source/norm/problem.norm b/source/norm/problem.norm
new file mode 100644
index 0000000000000000000000000000000000000000..88617d89ffd6e14e7c2582cadfe47a7394e1d8f4
--- /dev/null
+++ b/source/norm/problem.norm
@@ -0,0 +1,34 @@
+include "problem.grm"
+
+redefine problem_description
+   [indent] [repeat E+ ordered by Small] [dedent]
+end define
+
+redefine E
+   [NL] [name] [opt type] [repeat details ignored when Context] [opt ':] [opt stringlit]
+ | [NL] [name] [SP] [SPOFF] [rel] [SPON] [name] [repeat details ignored when Context] [opt desc]
+end define
+
+redefine details
+   '{ [indent] 
+   [list phenomena ordered]
+   [NL] [dedent] '} 
+end define
+
+rule Small B [E]
+ match [E] A [E]
+ construct SA [stringlit] _ [quote A]
+ construct SB [stringlit] _ [quote B]
+ where SA [< SB] 
+end rule
+
+function Context B [details]
+  match [E] A [E]
+  deconstruct A 
+   N [name] T [opt type]
+   D [repeat details] 
+   C [opt ':] 
+   Desc [opt stringlit]
+  deconstruct not T
+    'M
+end function
diff --git a/source/norm/verilog.norm b/source/norm/verilog.norm
new file mode 100644
index 0000000000000000000000000000000000000000..eda8ac8a1418da720c488c00d47e8cb6db639459
--- /dev/null
+++ b/source/norm/verilog.norm
@@ -0,0 +1,51 @@
+include "v.grm"
+redefine module
+      [module_declaration] '; [NL]
+      [repeat statement kept ordered] [NL]
+      'endmodule [NL]
+    | [macro_statement]
+end define
+
+redefine declaration
+    [parameter_specification]
+  | [variable_declaration] 
+  | [variable_assignment_statement]
+  | [if_statement]
+  | [case_statement]
+  | [block_statement ignored]
+  | [qualified_expression]
+  | [component_configuration]
+  | [function_decl]
+end define
+
+redefine case_statement
+   [case] '( [expr] ')
+     [case_statement_alternative* kept ordered]
+   'endcase
+end define
+
+redefine case_statement_alternative
+   [list choice ordered]  ': [statement* kept ordered]
+end define
+
+redefine case_statement_alternative
+   [macro_statement*] ...
+end define
+redefine case_statement_alternative
+   ... [macro_statement*] 
+end define
+
+redefine module_declaration
+    'module [id] '( [list part_module_declaration ordered] ') 
+end define
+
+
+define source
+      [module* kept]
+    | [empty]
+end define
+
+redefine program
+      [source] [opt source]
+end define
+
diff --git a/source/norm/verilog2.norm b/source/norm/verilog2.norm
new file mode 100644
index 0000000000000000000000000000000000000000..b18eab1d4dcd10567964b4242848ffb41d7d79cf
--- /dev/null
+++ b/source/norm/verilog2.norm
@@ -0,0 +1,21 @@
+include "v.grm"
+redefine module
+      [module_declaration] '; [NL]
+      [repeat statement ignored] [NL]
+      'endmodule [NL]
+    | [macro_statement]
+end define
+
+redefine module_declaration
+    'module [id] '( [list part_module_declaration ordered] ') 
+end define
+
+define source
+      [module* kept]
+    | [empty]
+end define
+
+redefine program
+      [source] [opt source]
+end define
+
diff --git a/source/v/raminfr.r106.v b/source/v/raminfr.r106.v
deleted file mode 100755
index b7f3161917955d3882ab93c8994715abf6cd600a..0000000000000000000000000000000000000000
--- a/source/v/raminfr.r106.v
+++ /dev/null
@@ -1,111 +0,0 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-module raminfr
- (clk, we, a, dpra, di, dpo);
-
-parameter addr_width = 4;
-parameter data_width = 8;
-parameter depth = 16;
-
-input clk;
-input we;
-input [addr_width-1:0] a;
-input [addr_width-1:0] dpra;
-input [data_width-1:0] di;
-
-output [data_width-1:0] dpo;
-reg [data_width-1:0] ram [depth-1:0];
-
-wire [data_width-1:0] dpo;
-wire [data_width-1:0] di;
-wire [addr_width-1:0] a;
-wire [addr_width-1:0] dpra;
-
- always @(posedge clk) begin
- if (we)
- ram[a] <= di;
- end
-
- assign dpo = ram[dpra];
-endmodule
-
diff --git a/source/v/raminfr.r79.v b/source/v/raminfr.r79.v
deleted file mode 100755
index f04201b21c7f8d1436c91449207fdb2ded2a1225..0000000000000000000000000000000000000000
--- a/source/v/raminfr.r79.v
+++ /dev/null
@@ -1,162 +0,0 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-module raminfr 
- (clk, we, a, dpra, di, dpo); 
-
-parameter addr_width = 4;
-parameter data_width = 8;
-parameter depth = 16;
-
-input clk; 
-input we; 
-input [addr_width-1:0] a; 
-input [addr_width-1:0] dpra; 
-input [data_width-1:0] di; 
-
-
-output [data_width-1:0] dpo; 
-reg [data_width-1:0] ram [depth-1:0]; 
-
-wire [data_width-1:0] dpo;
-wire [data_width-1:0] di; 
-wire [addr_width-1:0] a; 
-wire [addr_width-1:0] dpra; 
- 
- always @(posedge clk) begin 
- if (we) 
- ram[a] <= di; 
- end 
-
-
- assign dpo = ram[dpra]; 
-endmodule 
-
diff --git a/source/v/raminfr.r84.v b/source/v/raminfr.r84.v
deleted file mode 100755
index b7f3161917955d3882ab93c8994715abf6cd600a..0000000000000000000000000000000000000000
--- a/source/v/raminfr.r84.v
+++ /dev/null
@@ -1,111 +0,0 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-module raminfr
- (clk, we, a, dpra, di, dpo);
-
-parameter addr_width = 4;
-parameter data_width = 8;
-parameter depth = 16;
-
-input clk;
-input we;
-input [addr_width-1:0] a;
-input [addr_width-1:0] dpra;
-input [data_width-1:0] di;
-
-output [data_width-1:0] dpo;
-reg [data_width-1:0] ram [depth-1:0];
-
-wire [data_width-1:0] dpo;
-wire [data_width-1:0] di;
-wire [addr_width-1:0] a;
-wire [addr_width-1:0] dpra;
-
- always @(posedge clk) begin
- if (we)
- ram[a] <= di;
- end
-
- assign dpo = ram[dpra];
-endmodule
-
diff --git a/source/v/timescale.r106.v b/source/v/timescale.r106.v
deleted file mode 100755
index 051ee7a51e94b1a28ca392d521c397287178eef1..0000000000000000000000000000000000000000
--- a/source/v/timescale.r106.v
+++ /dev/null
@@ -1,64 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  timescale.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-// Timescale define
-
-`timescale 1ns/10ps
diff --git a/source/v/timescale.r27.v b/source/v/timescale.r27.v
deleted file mode 100755
index 1ba2eeaac1de79ea9c7b284bbf4fea783e2e06e3..0000000000000000000000000000000000000000
--- a/source/v/timescale.r27.v
+++ /dev/null
@@ -1,3 +0,0 @@
-// Timescale define
-
-`timescale 1ns/10ps
diff --git a/source/v/timescale.r29.v b/source/v/timescale.r29.v
deleted file mode 100755
index 051ee7a51e94b1a28ca392d521c397287178eef1..0000000000000000000000000000000000000000
--- a/source/v/timescale.r29.v
+++ /dev/null
@@ -1,64 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  timescale.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-// Timescale define
-
-`timescale 1ns/10ps
diff --git a/source/v/uart_debug_if.r106.v b/source/v/uart_debug_if.r106.v
deleted file mode 100755
index 99388d321a1820323084ff932c63f6c44e263999..0000000000000000000000000000000000000000
--- a/source/v/uart_debug_if.r106.v
+++ /dev/null
@@ -1,126 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_debug_if.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core debug interface.                                  ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/12/02                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.4  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.3  2001/12/19 08:40:03  mohor
-// Warnings fixed (unused signals removed).
-//
-// Revision 1.2  2001/12/12 22:17:30  gorban
-// some synthesis bugs fixed
-//
-// Revision 1.1  2001/12/04 21:14:16  gorban
-// committed the debug interface file
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_debug_if (/*AUTOARG*/
-// Outputs
-wb_dat32_o, 
-// Inputs
-wb_adr_i, ier, iir, fcr, mcr, lcr, msr, 
-lsr, rf_count, tf_count, tstate, rstate
-) ;
-
-input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-output [31:0] 							wb_dat32_o;
-input [3:0] 							ier;
-input [3:0] 							iir;
-input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-input [4:0] 							mcr;
-input [7:0] 							lcr;
-input [7:0] 							msr;
-input [7:0] 							lsr;
-input [`UART_FIFO_COUNTER_W-1:0] rf_count;
-input [`UART_FIFO_COUNTER_W-1:0] tf_count;
-input [2:0] 							tstate;
-input [3:0] 							rstate;
-
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-reg [31:0] 								wb_dat32_o;
-
-always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
-			or rf_count or rstate or tf_count or tstate or wb_adr_i)
-	case (wb_adr_i)
-		                      // 8 + 8 + 4 + 4 + 8
-		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
-		               // 5 + 2 + 5 + 4 + 5 + 3
-		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
-		default: wb_dat32_o = 0;
-	endcase // case(wb_adr_i)
-
-endmodule // uart_debug_if
-
diff --git a/source/v/uart_debug_if.r49.v b/source/v/uart_debug_if.r49.v
deleted file mode 100755
index 4d89bd4064b65d6426696963ffca3b8bd827bb2a..0000000000000000000000000000000000000000
--- a/source/v/uart_debug_if.r49.v
+++ /dev/null
@@ -1,98 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_debug_if.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core debug interface.                                  ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/12/02                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-
-module uart_debug_if (/*AUTOARG*/
-// Outputs
-wb_dat32_o, 
-// Inputs
-wb_clk_i, wb_rst_i, wb_adr_i, re_o, ier, iir, fcr, mcr, lcr, msr, 
-lsr, rf_count, tf_count, tstate, rstate
-) ;
-
-input 									wb_clk_i;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-output [31:0] 							wb_dat32_o;
-input 									re_o;
-input [3:0] 							ier;
-input [3:0] 							iir;
-input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-input [4:0] 							mcr;
-input [7:0] 							lcr;
-input [7:0] 							msr;
-input [7:0] 							lsr;
-input [`UART_FIFO_COUNTER_W-1:0] rf_count;
-input [`UART_FIFO_COUNTER_W-1:0] tf_count;
-input [2:0] 							tstate;
-input [3:0] 							rstate;
-
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-reg [31:0] 								wb_dat32_o;
-
-always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
-			or rf_count or rstate or tf_count or tstate or wb_adr_i)
-	case (wb_adr_i)
-		                      // 8 + 8 + 4 + 4 + 8
-		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
-		               // 5 + 2 + 5 + 4 + 5 + 3
-		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
-		default: wb_dat32_o = 0;
-	endcase // case(wb_adr_i)
-
-endmodule
-
diff --git a/source/v/uart_debug_if.r55.v b/source/v/uart_debug_if.r55.v
deleted file mode 100755
index 2de549377e9e04f1f699fb968a5d89317c36b94f..0000000000000000000000000000000000000000
--- a/source/v/uart_debug_if.r55.v
+++ /dev/null
@@ -1,107 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_debug_if.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core debug interface.                                  ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/12/02                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.1  2001/12/04 21:14:16  gorban
-// committed the debug interface file
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_debug_if (/*AUTOARG*/
-// Outputs
-wb_dat32_o, 
-// Inputs
-wb_clk_i, wb_rst_i, wb_adr_i, re_o, ier, iir, fcr, mcr, lcr, msr, 
-lsr, rf_count, tf_count, tstate, rstate
-) ;
-
-input 									wb_clk_i;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-output [31:0] 							wb_dat32_o;
-input 									re_o;
-input [3:0] 							ier;
-input [3:0] 							iir;
-input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-input [4:0] 							mcr;
-input [7:0] 							lcr;
-input [7:0] 							msr;
-input [7:0] 							lsr;
-input [`UART_FIFO_COUNTER_W-1:0] rf_count;
-input [`UART_FIFO_COUNTER_W-1:0] tf_count;
-input [2:0] 							tstate;
-input [3:0] 							rstate;
-
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-reg [31:0] 								wb_dat32_o;
-
-always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
-			or rf_count or rstate or tf_count or tstate or wb_adr_i)
-	case (wb_adr_i)
-		                      // 8 + 8 + 4 + 4 + 8
-		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
-		               // 5 + 2 + 5 + 4 + 5 + 3
-		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
-		default: wb_dat32_o = 0;
-	endcase // case(wb_adr_i)
-
-endmodule // uart_debug_if
-
diff --git a/source/v/uart_debug_if.r65.v b/source/v/uart_debug_if.r65.v
deleted file mode 100755
index c98ab7c593fc2848f65f9cade81b87fe69ffe959..0000000000000000000000000000000000000000
--- a/source/v/uart_debug_if.r65.v
+++ /dev/null
@@ -1,107 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_debug_if.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core debug interface.                                  ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/12/02                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.2  2001/12/12 22:17:30  gorban
-// some synthesis bugs fixed
-//
-// Revision 1.1  2001/12/04 21:14:16  gorban
-// committed the debug interface file
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_debug_if (/*AUTOARG*/
-// Outputs
-wb_dat32_o, 
-// Inputs
-wb_adr_i, ier, iir, fcr, mcr, lcr, msr, 
-lsr, rf_count, tf_count, tstate, rstate
-) ;
-
-input [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-output [31:0] 							wb_dat32_o;
-input [3:0] 							ier;
-input [3:0] 							iir;
-input [1:0] 							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-input [4:0] 							mcr;
-input [7:0] 							lcr;
-input [7:0] 							msr;
-input [7:0] 							lsr;
-input [`UART_FIFO_COUNTER_W-1:0] rf_count;
-input [`UART_FIFO_COUNTER_W-1:0] tf_count;
-input [2:0] 							tstate;
-input [3:0] 							rstate;
-
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_adr_i;
-reg [31:0] 								wb_dat32_o;
-
-always @(/*AUTOSENSE*/fcr or ier or iir or lcr or lsr or mcr or msr
-			or rf_count or rstate or tf_count or tstate or wb_adr_i)
-	case (wb_adr_i)
-		                      // 8 + 8 + 4 + 4 + 8
-		5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
-		               // 5 + 2 + 5 + 4 + 5 + 3
-		5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
-		default: wb_dat32_o = 0;
-	endcase // case(wb_adr_i)
-
-endmodule // uart_debug_if
-
diff --git a/source/v/uart_debug_if.r79.v b/source/v/uart_debug_if.r79.v
deleted file mode 100755
index 1f896a23f3159abdd1a8702f03757192beabdaa4..0000000000000000000000000000000000000000
--- a/source/v/uart_debug_if.r79.v
+++ /dev/null
@@ -1,110 +0,0 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-`include "timescale.v"
-
-
-
-
-module uart_debug_if (
-
-wb_dat32_o,
-
-wb_adr_i, ier, iir, fcr, mcr, lcr, msr,
-lsr, rf_count, tf_count, tstate, rstate
-) ;
-
-input [`UART_ADDR_WIDTH-1:0] wb_adr_i;
-output [31:0] wb_dat32_o;
-input [3:0] ier;
-input [3:0] iir;
-input [1:0] fcr;
-input [4:0] mcr;
-input [7:0] lcr;
-input [7:0] msr;
-input [7:0] lsr;
-input [`UART_FIFO_COUNTER_W-1:0] rf_count;
-input [`UART_FIFO_COUNTER_W-1:0] tf_count;
-input [2:0] tstate;
-input [3:0] rstate;
-
-
-wire [`UART_ADDR_WIDTH-1:0] wb_adr_i;
-reg [31:0] wb_dat32_o;
-
-always @(fcr or ier or iir or lcr or lsr or mcr or msr
- or rf_count or rstate or tf_count or tstate or wb_adr_i)
- case (wb_adr_i)
-
- 5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
-
- 5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
- default: wb_dat32_o = 0;
- endcase
-
-endmodule
-
diff --git a/source/v/uart_debug_if.r84.v b/source/v/uart_debug_if.r84.v
deleted file mode 100755
index 5d40ad466df4a0c3a50ddea69ac9bb160cdfe8a8..0000000000000000000000000000000000000000
--- a/source/v/uart_debug_if.r84.v
+++ /dev/null
@@ -1,126 +0,0 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-`include "timescale.v"
-
-
-`include "uart_defines.v"
-
-module uart_debug_if (
-
-wb_dat32_o,
-
-wb_adr_i, ier, iir, fcr, mcr, lcr, msr,
-lsr, rf_count, tf_count, tstate, rstate
-) ;
-
-input [`UART_ADDR_WIDTH-1:0] wb_adr_i;
-output [31:0] wb_dat32_o;
-input [3:0] ier;
-input [3:0] iir;
-input [1:0] fcr;
-input [4:0] mcr;
-input [7:0] lcr;
-input [7:0] msr;
-input [7:0] lsr;
-input [`UART_FIFO_COUNTER_W-1:0] rf_count;
-input [`UART_FIFO_COUNTER_W-1:0] tf_count;
-input [2:0] tstate;
-input [3:0] rstate;
-
-
-wire [`UART_ADDR_WIDTH-1:0] wb_adr_i;
-reg [31:0] wb_dat32_o;
-
-always @(fcr or ier or iir or lcr or lsr or mcr or msr
- or rf_count or rstate or tf_count or tstate or wb_adr_i)
- case (wb_adr_i)
-
- 5'b01000: wb_dat32_o = {msr,lcr,iir,ier,lsr};
-
- 5'b01100: wb_dat32_o = {8'b0, fcr,mcr, rf_count, rstate, tf_count, tstate};
- default: wb_dat32_o = 0;
- endcase
-
-endmodule
-
diff --git a/source/v/uart_defines.r106.v b/source/v/uart_defines.r106.v
deleted file mode 100755
index c28cb5e33dac1a55d5b97af68b7b55164b3a6d13..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r106.v
+++ /dev/null
@@ -1,247 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.12  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFOs as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  Its disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.10  2001/12/11 08:55:40  mohor
-// Scratch register define added.
-//
-// Revision 1.9  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. Its used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasnt handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First stable# release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore to use the new version with 8 data bit interface
-// in 32bit-bus mode, the wb_sel_i signal is used to put data in correct place
-// also, in 8-bit version therell be no debugging features included
-// CAUTION: doesnt work with current version of OR1200
-//`define DATA_BUS_WIDTH_8
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Uncomment this if you want your UART to have
-// 16xBaudrate output port.
-// If defined, the enable signal will be used to drive baudrate_o signal
-// Its frequency is 16xbaudrate
-
-// `define UART_HAS_BAUDRATE_OUTPUT
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTHd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTHd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTHd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTHd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTHd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTHd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTHd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTHd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTHd6	// Modem status
-`define UART_REG_SR  `UART_ADDR_WIDTHd7	// Scratch register
-`define UART_REG_DL1	`UART_ADDR_WIDTHd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTHd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3b011	// Receiver Line Status
-`define UART_II_RDA	3b010	// Receiver Data available
-`define UART_II_TI	3b110	// Timeout Indication
-`define UART_II_THRE	3b001	// Transmitter Holding Register empty
-`define UART_II_MS	3b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2b00
-`define UART_FC_4		2b01
-`define UART_FC_8		2b10
-`define UART_FC_14	2b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_defines.r27.v b/source/v/uart_defines.r27.v
deleted file mode 100755
index 97ea7f212324baf9fc0f261265faffd4c2ce1d89..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r27.v
+++ /dev/null
@@ -1,177 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`define UART_ADDR_WIDTH	3
-
-// Register addresses
-`define UART_REG_RB	3'd0	// receiver buffer
-`define UART_REG_TR  3'd0	// transmitter
-`define UART_REG_IE	3'd1	// Interrupt enable
-`define UART_REG_II  3'd2	// Interrupt identification
-`define UART_REG_FC  3'd2	// FIFO control
-`define UART_REG_LC	3'd3	// Line Control
-`define UART_REG_MC	3'd4	// Modem control
-`define UART_REG_LS  3'd5	// Line status
-`define UART_REG_MS  3'd6	// Modem status
-`define UART_REG_DL1	3'd0	// Divisor latch bytes (1-4)
-`define UART_REG_DL2	3'd1
-`define UART_REG_DL3	3'd4
-`define UART_REG_DL4	3'd5
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define	UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1	2'b00
-`define UART_FC_4	2'b01
-`define UART_FC_8	2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define	UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define	UART_MC_OUT2	3
-`define	UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define	UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define	UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define	UART_MS_CDCD	7
-
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 10 because it has parity and framing error bits
-`define UART_FIFO_REC_WIDTH  10
-
-
-
-
-
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
diff --git a/source/v/uart_defines.r29.v b/source/v/uart_defines.r29.v
deleted file mode 100755
index 722f1944b7070d39fbdad6710dc8a6c5dd848ea6..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r29.v
+++ /dev/null
@@ -1,186 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`define UART_ADDR_WIDTH	3
-
-// Register addresses
-`define UART_REG_RB	3'd0	// receiver buffer
-`define UART_REG_TR  3'd0	// transmitter
-`define UART_REG_IE	3'd1	// Interrupt enable
-`define UART_REG_II  3'd2	// Interrupt identification
-`define UART_REG_FC  3'd2	// FIFO control
-`define UART_REG_LC	3'd3	// Line Control
-`define UART_REG_MC	3'd4	// Modem control
-`define UART_REG_LS  3'd5	// Line status
-`define UART_REG_MS  3'd6	// Modem status
-`define UART_REG_DL1	3'd0	// Divisor latch bytes (1-4)
-`define UART_REG_DL2	3'd1
-`define UART_REG_DL3	3'd4
-`define UART_REG_DL4	3'd5
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define	UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1	2'b00
-`define UART_FC_4	2'b01
-`define UART_FC_8	2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define	UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define	UART_MC_OUT2	3
-`define	UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define	UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define	UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define	UART_MS_CDCD	7
-
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 10 because it has parity and framing error bits
-`define UART_FIFO_REC_WIDTH  10
-
-
-
-
-
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
diff --git a/source/v/uart_defines.r45.v b/source/v/uart_defines.r45.v
deleted file mode 100755
index 822373879e1410f9f4021ae9bdbfcd9a7f5aa0e4..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r45.v
+++ /dev/null
@@ -1,190 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`define UART_ADDR_WIDTH	3
-
-// Register addresses
-`define UART_REG_RB	3'd0	// receiver buffer
-`define UART_REG_TR  3'd0	// transmitter
-`define UART_REG_IE	3'd1	// Interrupt enable
-`define UART_REG_II  3'd2	// Interrupt identification
-`define UART_REG_FC  3'd2	// FIFO control
-`define UART_REG_LC	3'd3	// Line Control
-`define UART_REG_MC	3'd4	// Modem control
-`define UART_REG_LS  3'd5	// Line status
-`define UART_REG_MS  3'd6	// Modem status
-`define UART_REG_DL1	3'd0	// Divisor latch bytes (1-4)
-`define UART_REG_DL2	3'd1
-`define UART_REG_DL3	3'd4
-`define UART_REG_DL4	3'd5
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1	2'b00
-`define UART_FC_4	2'b01
-`define UART_FC_8	2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-
-
-
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
diff --git a/source/v/uart_defines.r48.v b/source/v/uart_defines.r48.v
deleted file mode 100755
index d3787a795e8417a98189787dc62269b9bcb2bcd4..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r48.v
+++ /dev/null
@@ -1,207 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore use to the old version with 8 data bit interface
-// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
-// also, in 8-bit version there'll be no debugging features included
-// `define DATA_BUS_WIDTH_8
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
-`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2'b00
-`define UART_FC_4		2'b01
-`define UART_FC_8		2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_defines.r53.v b/source/v/uart_defines.r53.v
deleted file mode 100755
index e21bf0f809e36866fa14ba6e170ec1bd8361fcbb..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r53.v
+++ /dev/null
@@ -1,217 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.9  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore use to the old version with 8 data bit interface
-// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
-// also, in 8-bit version there'll be no debugging features included
-// `define DATA_BUS_WIDTH_8
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
-`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
-`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2'b00
-`define UART_FC_4		2'b01
-`define UART_FC_8		2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_defines.r75.v b/source/v/uart_defines.r75.v
deleted file mode 100755
index 6ad712f0aeacab5526296925c7655daf9700a70d..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r75.v
+++ /dev/null
@@ -1,222 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/12/11 08:55:40  mohor
-// Scratch register define added.
-//
-// Revision 1.9  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore use to the old version with 8 data bit interface
-// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
-// also, in 8-bit version there'll be no debugging features included
-// `define DATA_BUS_WIDTH_8
-
-`define BIG_BYTE_ENDIAN     // Defines endian
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
-`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
-`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2'b00
-`define UART_FC_4		2'b01
-`define UART_FC_8		2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_defines.r79.v b/source/v/uart_defines.r79.v
deleted file mode 100755
index 8cd9ef956e838f383b27983b31e6c83d4a7c9f95..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r79.v
+++ /dev/null
@@ -1,227 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/12/11 08:55:40  mohor
-// Scratch register define added.
-//
-// Revision 1.9  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore use to the old version with 8 data bit interface
-// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
-// also, in 8-bit version there'll be no debugging features included
-//`define DATA_BUS_WIDTH_8
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Uncomment this if you want your UART to have 
-// 16xBaudrate output port.
-// If defined, the enable signal will be used to drive baudrate_o signal
-// It's frequency is 16xbaudrate
-
-// `define UART_HAS_BAUDRATE_OUTPUT
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
-`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
-`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2'b00
-`define UART_FC_4		2'b01
-`define UART_FC_8		2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_defines.r87.v b/source/v/uart_defines.r87.v
deleted file mode 100755
index 9acc852dfe852425f138f95dce498ab8d0a29cc2..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r87.v
+++ /dev/null
@@ -1,243 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.10  2001/12/11 08:55:40  mohor
-// Scratch register define added.
-//
-// Revision 1.9  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore use to the old version with 8 data bit interface
-// in new mode (32bit bus), the wb_sel_i signal is used to pus data in correct place
-// also, in 8-bit version there'll be no debugging features included
-`define DATA_BUS_WIDTH_8
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Uncomment this if you want your UART to have 
-// 16xBaudrate output port.
-// If defined, the enable signal will be used to drive baudrate_o signal
-// It's frequency is 16xbaudrate
-
-// `define UART_HAS_BAUDRATE_OUTPUT
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
-`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
-`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2'b00
-`define UART_FC_4		2'b01
-`define UART_FC_8		2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_defines.r89.v b/source/v/uart_defines.r89.v
deleted file mode 100755
index 66b4a1546db3fab6c4b74058c0ab0edf78758de9..0000000000000000000000000000000000000000
--- a/source/v/uart_defines.r89.v
+++ /dev/null
@@ -1,247 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_defines.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Defines of the Core                                         ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None                                                        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.12  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.10  2001/12/11 08:55:40  mohor
-// Scratch register define added.
-//
-// Revision 1.9  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.8  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.7  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.6  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.5  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.4  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.3  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// remove comments to restore to use the new version with 8 data bit interface
-// in 32bit-bus mode, the wb_sel_i signal is used to put data in correct place
-// also, in 8-bit version there'll be no debugging features included
-// CAUTION: doesn't work with current version of OR1200
-//`define DATA_BUS_WIDTH_8
-
-`ifdef DATA_BUS_WIDTH_8
- `define UART_ADDR_WIDTH 3
- `define UART_DATA_WIDTH 8
-`else
- `define UART_ADDR_WIDTH 5
- `define UART_DATA_WIDTH 32
-`endif
-
-// Uncomment this if you want your UART to have
-// 16xBaudrate output port.
-// If defined, the enable signal will be used to drive baudrate_o signal
-// It's frequency is 16xbaudrate
-
-// `define UART_HAS_BAUDRATE_OUTPUT
-
-// Register addresses
-`define UART_REG_RB	`UART_ADDR_WIDTH'd0	// receiver buffer
-`define UART_REG_TR  `UART_ADDR_WIDTH'd0	// transmitter
-`define UART_REG_IE	`UART_ADDR_WIDTH'd1	// Interrupt enable
-`define UART_REG_II  `UART_ADDR_WIDTH'd2	// Interrupt identification
-`define UART_REG_FC  `UART_ADDR_WIDTH'd2	// FIFO control
-`define UART_REG_LC	`UART_ADDR_WIDTH'd3	// Line Control
-`define UART_REG_MC	`UART_ADDR_WIDTH'd4	// Modem control
-`define UART_REG_LS  `UART_ADDR_WIDTH'd5	// Line status
-`define UART_REG_MS  `UART_ADDR_WIDTH'd6	// Modem status
-`define UART_REG_SR  `UART_ADDR_WIDTH'd7	// Scratch register
-`define UART_REG_DL1	`UART_ADDR_WIDTH'd0	// Divisor latch bytes (1-2)
-`define UART_REG_DL2	`UART_ADDR_WIDTH'd1
-
-// Interrupt Enable register bits
-`define UART_IE_RDA	0	// Received Data available interrupt
-`define UART_IE_THRE	1	// Transmitter Holding Register empty interrupt
-`define UART_IE_RLS	2	// Receiver Line Status Interrupt
-`define UART_IE_MS	3	// Modem Status Interrupt
-
-// Interrupt Identification register bits
-`define UART_II_IP	0	// Interrupt pending when 0
-`define UART_II_II	3:1	// Interrupt identification
-
-// Interrupt identification values for bits 3:1
-`define UART_II_RLS	3'b011	// Receiver Line Status
-`define UART_II_RDA	3'b010	// Receiver Data available
-`define UART_II_TI	3'b110	// Timeout Indication
-`define UART_II_THRE	3'b001	// Transmitter Holding Register empty
-`define UART_II_MS	3'b000	// Modem Status
-
-// FIFO Control Register bits
-`define UART_FC_TL	1:0	// Trigger level
-
-// FIFO trigger level values
-`define UART_FC_1		2'b00
-`define UART_FC_4		2'b01
-`define UART_FC_8		2'b10
-`define UART_FC_14	2'b11
-
-// Line Control register bits
-`define UART_LC_BITS	1:0	// bits in character
-`define UART_LC_SB	2	// stop bits
-`define UART_LC_PE	3	// parity enable
-`define UART_LC_EP	4	// even parity
-`define UART_LC_SP	5	// stick parity
-`define UART_LC_BC	6	// Break control
-`define UART_LC_DL	7	// Divisor Latch access bit
-
-// Modem Control register bits
-`define UART_MC_DTR	0
-`define UART_MC_RTS	1
-`define UART_MC_OUT1	2
-`define UART_MC_OUT2	3
-`define UART_MC_LB	4	// Loopback mode
-
-// Line Status Register bits
-`define UART_LS_DR	0	// Data ready
-`define UART_LS_OE	1	// Overrun Error
-`define UART_LS_PE	2	// Parity Error
-`define UART_LS_FE	3	// Framing Error
-`define UART_LS_BI	4	// Break interrupt
-`define UART_LS_TFE	5	// Transmit FIFO is empty
-`define UART_LS_TE	6	// Transmitter Empty indicator
-`define UART_LS_EI	7	// Error indicator
-
-// Modem Status Register bits
-`define UART_MS_DCTS	0	// Delta signals
-`define UART_MS_DDSR	1
-`define UART_MS_TERI	2
-`define UART_MS_DDCD	3
-`define UART_MS_CCTS	4	// Complement signals
-`define UART_MS_CDSR	5
-`define UART_MS_CRI	6
-`define UART_MS_CDCD	7
-
-// FIFO parameter defines
-
-`define UART_FIFO_WIDTH	8
-`define UART_FIFO_DEPTH	16
-`define UART_FIFO_POINTER_W	4
-`define UART_FIFO_COUNTER_W	5
-// receiver fifo has width 11 because it has break, parity and framing error bits
-`define UART_FIFO_REC_WIDTH  11
-
-
-`define VERBOSE_WB  0           // All activity on the WISHBONE is recorded
-`define VERBOSE_LINE_STATUS 0   // Details about the lsr (line status register)
-`define FAST_TEST   1           // 64/1024 packets are sent
-
-
-
-
-
-
-
diff --git a/source/v/uart_receiver.r100.v b/source/v/uart_receiver.r100.v
deleted file mode 100755
index 65b504883399ce13798be1d4c090bb347a82bcfd..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r100.v
+++ /dev/null
@@ -1,482 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.29  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.28  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.27  2001/12/30 20:39:13  mohor
-// More than one character was stored in case of break. End of the break
-// was not detected correctly.
-//
-// Revision 1.26  2001/12/20 13:28:27  mohor
-// Missing declaration of rf_push_q fixed.
-//
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			rcounter16 	  <= #1 4'b1110;
-			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-			end
-		end
-	sr_rec_start :	begin
-  			rf_push 			  <= #1 1'b0;
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_idle;
-          end
-        else
-          begin
-       			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-      			rcounter16 	  <= #1 4'b1110;
-    				rstate 		  <= #1 sr_rec_start;
-          end
-                      
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-	if (srx_pad_i)
-		counter_b <= #1 brc_value; // character time length - 1
-	else
-	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
-		counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r103.v b/source/v/uart_receiver.r103.v
deleted file mode 100755
index f3ca88c260c6b7c75b9ef4ed632bbfe8c3513fa3..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r103.v
+++ /dev/null
@@ -1,482 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.29  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.28  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.27  2001/12/30 20:39:13  mohor
-// More than one character was stored in case of break. End of the break
-// was not detected correctly.
-//
-// Revision 1.26  2001/12/20 13:28:27  mohor
-// Missing declaration of rf_push_q fixed.
-//
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			rcounter16 	  <= #1 4'b1110;
-			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-			end
-		end
-	sr_rec_start :	begin
-  			rf_push 			  <= #1 1'b0;
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_idle;
-          end
-        else if(~rframing_error)  // There's always a framing before break_error -> wait for break or srx_pad_i
-          begin
-       			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-      			rcounter16 	  <= #1 4'b1110;
-    				rstate 		  <= #1 sr_rec_start;
-          end
-                      
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-	if (srx_pad_i)
-		counter_b <= #1 brc_value; // character time length - 1
-	else
-	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
-		counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r106.v b/source/v/uart_receiver.r106.v
deleted file mode 100755
index f3ca88c260c6b7c75b9ef4ed632bbfe8c3513fa3..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r106.v
+++ /dev/null
@@ -1,482 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.29  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.28  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.27  2001/12/30 20:39:13  mohor
-// More than one character was stored in case of break. End of the break
-// was not detected correctly.
-//
-// Revision 1.26  2001/12/20 13:28:27  mohor
-// Missing declaration of rf_push_q fixed.
-//
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			rcounter16 	  <= #1 4'b1110;
-			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-			end
-		end
-	sr_rec_start :	begin
-  			rf_push 			  <= #1 1'b0;
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_idle;
-          end
-        else if(~rframing_error)  // There's always a framing before break_error -> wait for break or srx_pad_i
-          begin
-       			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-      			rcounter16 	  <= #1 4'b1110;
-    				rstate 		  <= #1 sr_rec_start;
-          end
-                      
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-	if (srx_pad_i)
-		counter_b <= #1 brc_value; // character time length - 1
-	else
-	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
-		counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r27.v b/source/v/uart_receiver.r27.v
deleted file mode 100755
index 0dbad6f003bf14f9a3c5f0f0e3225eed2ed629da..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r27.v
+++ /dev/null
@@ -1,341 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       rx_lsr_mask;
-
-output	[5:0]			counter_t;
-output	[3:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(rx_lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rstate <= #1 sr_idle;
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 3'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-//				2'b00: rparity_error <= #1 ~rparity_xor;  // no error if parity 1
-//				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-//				2'b10: rparity_error <= #1 rparity_xor;   // error if parity is odd
-//				2'b11: rparity_error <= #1 rparity;	  // parity should be sticked to 0
-				2'b00: rparity_error <= #1 rparity_xor;  // no error if parity 1
-				2'b01: rparity_error <= #1 1'b1;      // parity should sticked to 1
-				2'b10: rparity_error <= #1 ~rparity_xor;   // error if parity is odd
-				2'b11: rparity_error <= #1 1'b0;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rf_data_in <= #1 {rshift, rparity_error, rframing_error};
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[3:0]	counter_b;	// counts the 1 (idle) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 4'd11;
-	else
-	if (enable)  // only work on enable times
-		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
-			counter_b <= #1 4'd11; // maximum character time length - 1
-		else
-			if (counter_b != 4'b0)            // break reached
-				counter_b <= #1 counter_b - 4'd1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[5:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 6'd44;
-	else
-	if (enable)
-		if(rf_push || rf_pop || rda_int) // counter is reset when RX FIFO is accessed or above trigger level
-			counter_t <= #1 6'd44;
-		else
-			if (counter_t != 6'b0)  // we don't want to underflow
-				counter_t <= #1 counter_t - 6'd1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r29.v b/source/v/uart_receiver.r29.v
deleted file mode 100755
index 80b16079d561df5b339f462104e0b163fb8866b8..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r29.v
+++ /dev/null
@@ -1,348 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       rx_lsr_mask;
-
-output	[5:0]			counter_t;
-output	[3:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(rx_lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rstate <= #1 sr_idle;
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 3'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-//				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-				2'b00: rparity_error <= #1  rparity_xor != rparity;  // no error if parity 1
-				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-				2'b10: rparity_error <= #1 ~rparity_xor != rparity;   // error if parity is odd
-				2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[3:0]	counter_b;	// counts the 1 (idle) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 4'd11;
-	else
-	if (enable)  // only work on enable times
-		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
-			counter_b <= #1 4'd11; // maximum character time length - 1
-		else
-			if (counter_b != 4'b0)            // break reached
-				counter_b <= #1 counter_b - 4'd1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[5:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 6'd44;
-	else
-	if (enable)
-		if(rf_push || rf_pop || rda_int) // counter is reset when RX FIFO is accessed or above trigger level
-			counter_t <= #1 6'd44;
-		else
-			if (counter_t != 6'b0)  // we don't want to underflow
-				counter_t <= #1 counter_t - 6'd1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r33.v b/source/v/uart_receiver.r33.v
deleted file mode 100755
index 4566e189e6ca2d9dc59c2cacd39bb78ecfcb905a..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r33.v
+++ /dev/null
@@ -1,355 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       rx_lsr_mask;
-
-output	[5:0]			counter_t;
-output	[3:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(rx_lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rstate <= #1 sr_idle;
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 3'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-//				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-				2'b00: rparity_error <= #1  rparity_xor != rparity;  // no error if parity 1
-				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-				2'b10: rparity_error <= #1 ~rparity_xor != rparity;   // error if parity is odd
-				2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[3:0]	counter_b;	// counts the 1 (idle) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 4'd11;
-	else
-	if (enable)  // only work on enable times
-		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
-			counter_b <= #1 4'd11; // maximum character time length - 1
-		else
-			if (counter_b != 4'b0)            // break reached
-				counter_b <= #1 counter_b - 4'd1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[5:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 6'd44;
-	else
-	if (enable)
-		if(rf_push || rf_pop || rda_int) // counter is reset when RX FIFO is accessed or above trigger level
-			counter_t <= #1 6'd44;
-		else
-			if (counter_t != 6'b0)  // we don't want to underflow
-				counter_t <= #1 counter_t - 6'd1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r35.v b/source/v/uart_receiver.r35.v
deleted file mode 100755
index 02675a9a06dc3a4edd39c31de6df5afffecb03a3..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r35.v
+++ /dev/null
@@ -1,360 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       rx_lsr_mask;
-
-output	[9:0]			counter_t;
-output	[7:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(rx_lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rstate <= #1 sr_idle;
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 3'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-//				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-				2'b00: rparity_error <= #1  rparity_xor != rparity;  // no error if parity 1
-				2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-				2'b10: rparity_error <= #1 ~rparity_xor != rparity;   // error if parity is odd
-				2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[7:0]	counter_b;	// counts the 1 (idle) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd191;
-	else
-	if (enable)  // only work on enable times
-		if (!srx_pad_i)                                                       // Ta vrstica je bila spremenjena igor !!!
-			counter_b <= #1 8'd191; // maximum character time length - 1
-		else
-			if (counter_b != 8'b0 && counter_b != 8'hff)            // break reached
-				counter_b <= #1 counter_b - 8'd1;  // decrement break counter
-			else if (rx_lsr_mask)
-				counter_b <= #1 8'hff; /// this won't generate interrupt status after lsr was read
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd767;
-	else
-	if (enable)
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 10'd767;
-		else
-			if (counter_t != 10'b0)  // we don't want to underflow
-				counter_t <= #1 counter_t - 10'd1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r37.v b/source/v/uart_receiver.r37.v
deleted file mode 100755
index 1c83d03d5abef55efb71b61a243914e8385f7f5b..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r37.v
+++ /dev/null
@@ -1,360 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[7:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 4'd1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rstate <= #1 sr_idle;
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 3'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-//				rparity_xor <= #1 ^rshift; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-//					rf_data_in <= #1 {rshift, rparity_error, rframing_error};         prestavljeno navzdol
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};   // igor !!! Nisem preprican, da sem to prestavil sem OK.
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[7:0]	counter_b;	// counts the 1 (idle) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd191;
-	else
-	if (enable)  // only work on enable times
-		if (!srx_pad_i || rstate == sr_idle)
-			counter_b <= #1 8'd191; // maximum character time length - 1
-		else
-			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 8'd1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd767;
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 10'd767;
-		else
-			if (	enable && counter_t != 10'b0)  // we don't want to underflow
-				counter_t <= #1 counter_t - 10'd1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r39.v b/source/v/uart_receiver.r39.v
deleted file mode 100755
index e1b3afb83c5dd28b52fc34ee0d9abe9d2ae4ded4..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r39.v
+++ /dev/null
@@ -1,363 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[7:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[7:0]	counter_b;	// counts the 1 (idle) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd191;
-	else
-  if(lsr_mask)
-		counter_b <= #1 8'd191;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 8'd191; // maximum character time length - 1
-		else
-  	if (counter_b != 8'b0)            // break not reached it
-		  counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd767;
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 10'd767;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r40.v b/source/v/uart_receiver.r40.v
deleted file mode 100755
index 2edf1389306e6df3db3f79342800256121f02671..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r40.v
+++ /dev/null
@@ -1,367 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[7:0]			counter_b;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle :	if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate <= #1 sr_rec_start;
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd191;
-	else
-  if(lsr_mask)
-		counter_b <= #1 8'd191;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 8'd191; // maximum character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd767;
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 10'd767;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r45.v b/source/v/uart_receiver.r45.v
deleted file mode 100755
index 65683cd872c6f710783993cd254c08e2d8a876e5..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r45.v
+++ /dev/null
@@ -1,380 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-	  begin
-		  rstate 		 <= #1 sr_idle;
-		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-		  rf_push 		 <= #1 1'b1;
-	  end
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd191;
-	else
-  if(lsr_mask)
-		counter_b <= #1 8'd191;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 8'd191; // maximum character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd767;
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 10'd767;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r46.v b/source/v/uart_receiver.r46.v
deleted file mode 100755
index 366ff276392aa906c33b8b5d428286e7c81b62f7..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r46.v
+++ /dev/null
@@ -1,389 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-	  begin
-		  rstate 		 <= #1 sr_idle;
-		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-		  rf_push 		 <= #1 1'b1;
-	  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd191;
-	else
-  if(lsr_mask)
-		counter_b <= #1 8'd191;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 8'd191; // maximum character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd767;
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 10'd767;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r47.v b/source/v/uart_receiver.r47.v
deleted file mode 100755
index 25cecc8d309c15839ea75c49fababc98ae25a973..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r47.v
+++ /dev/null
@@ -1,409 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-	  begin
-		  rstate 		 <= #1 sr_idle;
-		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-		  rf_push 		 <= #1 1'b1;
-	  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-  if(lsr_mask)
-		counter_b <= #1 brc_value;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r48.v b/source/v/uart_receiver.r48.v
deleted file mode 100755
index 2f0fdc22f97564aaf3e7f69347388b1f500992c9..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r48.v
+++ /dev/null
@@ -1,413 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-	  begin
-		  rstate 		 <= #1 sr_idle;
-		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-		  rf_push 		 <= #1 1'b1;
-	  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-  if(lsr_mask)
-		counter_b <= #1 brc_value;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r50.v b/source/v/uart_receiver.r50.v
deleted file mode 100755
index 9e024df7bda0a313eac7acbab1a32b63b5a81c78..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r50.v
+++ /dev/null
@@ -1,423 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-	  begin
-		  rstate 		 <= #1 sr_idle;
-		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-		  rf_push 		 <= #1 1'b1;
-	  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-  			rf_data_in <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-				rf_push    <= #1 1'b1;
-				rstate     <= #1 sr_last;
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-  if(lsr_mask)
-		counter_b <= #1 brc_value;
-  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r51.v b/source/v/uart_receiver.r51.v
deleted file mode 100755
index 7d28999b2ab3a9bbf5060f1e85f0807d67793a59..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r51.v
+++ /dev/null
@@ -1,436 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rda_int || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r57.v b/source/v/uart_receiver.r57.v
deleted file mode 100755
index 2643cc838bbe98a68f9feae5a2e86c8e3128affc..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r57.v
+++ /dev/null
@@ -1,439 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_underrun;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.underrun(	rf_underrun	),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r61.v b/source/v/uart_receiver.r61.v
deleted file mode 100755
index accd0e37a916a34408a8ec7a9ccee4744de01ede..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r61.v
+++ /dev/null
@@ -1,441 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r63.v b/source/v/uart_receiver.r63.v
deleted file mode 100755
index 90990ffa613493ac7669c31fa40d3702f2634f85..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r63.v
+++ /dev/null
@@ -1,446 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rda_int;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r64.v b/source/v/uart_receiver.r64.v
deleted file mode 100755
index 8f89e2226b1fc2108f4a683611214cdf8e7bede2..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r64.v
+++ /dev/null
@@ -1,448 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r66.v b/source/v/uart_receiver.r66.v
deleted file mode 100755
index 8b9f9add266fe8cb69d2a2d3eb0333384c932445..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r66.v
+++ /dev/null
@@ -1,463 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r67.v b/source/v/uart_receiver.r67.v
deleted file mode 100755
index a65a09527ea84414c0c82d61488a374400834db5..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r67.v
+++ /dev/null
@@ -1,467 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-//	  if (break_error && rstate != sr_idle) // break condition met while receiver is not idle
-//	  begin
-//		  rstate 		 <= #1 sr_idle;
-//		  rf_data_in 	 <= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-//		  rf_push 		 <= #1 1'b1;
-//	  end
-//  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-//				if (rcounter16_eq_1)
-				if (rcounter16_eq_1 & srx_pad_i)    // igor
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-//  if(lsr_mask)                          igor
-//		counter_b <= #1 brc_value;
-//  else
-	if (enable)  // only work on enable times
-		if (srx_pad_i)
-			counter_b <= #1 brc_value; // character time length - 1
-		else
-  			if (counter_b != 8'b0)            // break not reached it
-				counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r69.v b/source/v/uart_receiver.r69.v
deleted file mode 100755
index 5a2a84e033023802063f2d2a3d035f2f985a65e1..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r69.v
+++ /dev/null
@@ -1,458 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.26  2001/12/20 13:28:27  mohor
-// Missing declaration of rf_push_q fixed.
-//
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_fifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-parameter  sr_last 					= 4'd11;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-				rcounter16 	  <= #1 4'b1110;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_last;
-          end
-            
-			end
-	sr_last :	begin
-				if (rcounter16_eq_1 & srx_pad_i | break_error)
-					rstate <= #1 sr_idle;
-				rcounter16 <= #1 rcounter16_minus_1;
-				rf_push    <= #1 1'b0;
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-	if (srx_pad_i)
-		counter_b <= #1 brc_value; // character time length - 1
-	else
-	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
-		counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r79.v b/source/v/uart_receiver.r79.v
deleted file mode 100755
index 9e516d98ff2712c38ebe3f866c97c6a70f49b8f0..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r79.v
+++ /dev/null
@@ -1,455 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.27  2001/12/30 20:39:13  mohor
-// More than one character was stored in case of break. End of the break
-// was not detected correctly.
-//
-// Revision 1.26  2001/12/20 13:28:27  mohor
-// Missing declaration of rf_push_q fixed.
-//
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-//`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			rcounter16 	  <= #1 4'b1110;
-			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_idle;
-          end
-            
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-	if (srx_pad_i)
-		counter_b <= #1 brc_value; // character time length - 1
-	else
-	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
-		counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_receiver.r84.v b/source/v/uart_receiver.r84.v
deleted file mode 100755
index 5c018fd0255afb365e3f78b0278115291c1973b8..0000000000000000000000000000000000000000
--- a/source/v/uart_receiver.r84.v
+++ /dev/null
@@ -1,471 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_receiver.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.28  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.27  2001/12/30 20:39:13  mohor
-// More than one character was stored in case of break. End of the break
-// was not detected correctly.
-//
-// Revision 1.26  2001/12/20 13:28:27  mohor
-// Missing declaration of rf_push_q fixed.
-//
-// Revision 1.25  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.24  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.23  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.22  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.21  2001/12/13 10:31:16  mohor
-// timeout irq must be set regardless of the rda irq (rda irq does not reset the
-// timeout counter).
-//
-// Revision 1.20  2001/12/10 19:52:05  gorban
-// Igor fixed break condition bugs
-//
-// Revision 1.19  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.18  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.17  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.16  2001/11/27 22:17:09  gorban
-// Fixed bug that prevented synthesis in uart_receiver.v
-//
-// Revision 1.15  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.14  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_receiver (clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]	lcr;
-input				rf_pop;
-input				srx_pad_i;
-input				enable;
-input				rx_reset;
-input       lsr_mask;
-
-output	[9:0]			counter_t;
-output	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-output	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-output				rf_overrun;
-output				rf_error_bit;
-output [3:0] 		rstate;
-output 				rf_push_pulse;
-
-reg	[3:0]	rstate;
-reg	[3:0]	rcounter16;
-reg	[2:0]	rbit_counter;
-reg	[7:0]	rshift;			// receiver shift register
-reg		rparity;		// received parity
-reg		rparity_error;
-reg		rframing_error;		// framing error flag
-reg		rbit_in;
-reg		rparity_xor;
-reg	[7:0]	counter_b;	// counts the 0 (low) signals
-reg   rf_push_q;
-
-// RX FIFO signals
-reg	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_in;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire      rf_push_pulse;
-reg				rf_push;
-wire				rf_pop;
-wire				rf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire 				break_error = (counter_b == 0);
-
-// RX FIFO instance
-uart_rfifo #(`UART_FIFO_REC_WIDTH) fifo_rx(
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	rf_data_in	),
-	.data_out(	rf_data_out	),
-	.push(		rf_push_pulse		),
-	.pop(		rf_pop		),
-	.overrun(	rf_overrun	),
-	.count(		rf_count	),
-	.error_bit(	rf_error_bit	),
-	.fifo_reset(	rx_reset	),
-	.reset_status(lsr_mask)
-);
-
-wire 		rcounter16_eq_7 = (rcounter16 == 4'd7);
-wire		rcounter16_eq_0 = (rcounter16 == 4'd0);
-wire		rcounter16_eq_1 = (rcounter16 == 4'd1);
-
-wire [3:0] rcounter16_minus_1 = rcounter16 - 1'b1;
-
-parameter  sr_idle 					= 4'd0;
-parameter  sr_rec_start 			= 4'd1;
-parameter  sr_rec_bit 				= 4'd2;
-parameter  sr_rec_parity			= 4'd3;
-parameter  sr_rec_stop 				= 4'd4;
-parameter  sr_check_parity 		= 4'd5;
-parameter  sr_rec_prepare 			= 4'd6;
-parameter  sr_end_bit				= 4'd7;
-parameter  sr_ca_lc_parity	      = 4'd8;
-parameter  sr_wait1 					= 4'd9;
-parameter  sr_push 					= 4'd10;
-
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-     rstate 			<= #1 sr_idle;
-	  rbit_in 				<= #1 1'b0;
-	  rcounter16 			<= #1 0;
-	  rbit_counter 		<= #1 0;
-	  rparity_xor 		<= #1 1'b0;
-	  rframing_error 	<= #1 1'b0;
-	  rparity_error 		<= #1 1'b0;
-	  rparity 				<= #1 1'b0;
-	  rshift 				<= #1 0;
-	  rf_push 				<= #1 1'b0;
-	  rf_data_in 			<= #1 0;
-  end
-  else
-  if (enable)
-  begin
-	case (rstate)
-	sr_idle : begin
-			rf_push 			  <= #1 1'b0;
-			rf_data_in 	  <= #1 0;
-			rcounter16 	  <= #1 4'b1110;
-			if (srx_pad_i==1'b0 & ~break_error)   // detected a pulse (start bit?)
-			begin
-				rstate 		  <= #1 sr_rec_start;
-			end
-		end
-	sr_rec_start :	begin
-				if (rcounter16_eq_7)    // check the pulse
-					if (srx_pad_i==1'b1)   // no start bit
-						rstate <= #1 sr_idle;
-					else            // start bit detected
-						rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_prepare:begin
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : rbit_counter <= #1 3'b100;
-				2'b01 : rbit_counter <= #1 3'b101;
-				2'b10 : rbit_counter <= #1 3'b110;
-				2'b11 : rbit_counter <= #1 3'b111;
-				endcase
-				if (rcounter16_eq_0)
-				begin
-					rstate		<= #1 sr_rec_bit;
-					rcounter16	<= #1 4'b1110;
-					rshift		<= #1 0;
-				end
-				else
-					rstate <= #1 sr_rec_prepare;
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_rec_bit :	begin
-				if (rcounter16_eq_0)
-					rstate <= #1 sr_end_bit;
-				if (rcounter16_eq_7) // read the bit
-					case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-					2'b00 : rshift[4:0]  <= #1 {srx_pad_i, rshift[4:1]};
-					2'b01 : rshift[5:0]  <= #1 {srx_pad_i, rshift[5:1]};
-					2'b10 : rshift[6:0]  <= #1 {srx_pad_i, rshift[6:1]};
-					2'b11 : rshift[7:0]  <= #1 {srx_pad_i, rshift[7:1]};
-					endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_end_bit :   begin
-				if (rbit_counter==3'b0) // no more bits in word
-					if (lcr[`UART_LC_PE]) // choose state based on parity
-						rstate <= #1 sr_rec_parity;
-					else
-					begin
-						rstate <= #1 sr_rec_stop;
-						rparity_error <= #1 1'b0;  // no parity - no error :)
-					end
-				else		// else we have more bits to read
-				begin
-					rstate <= #1 sr_rec_bit;
-					rbit_counter <= #1 rbit_counter - 1'b1;
-				end
-				rcounter16 <= #1 4'b1110;
-			end
-	sr_rec_parity: begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rparity <= #1 srx_pad_i;
-					rstate <= #1 sr_ca_lc_parity;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_ca_lc_parity : begin    // rcounter equals 6
-				rcounter16  <= #1 rcounter16_minus_1;
-				rparity_xor <= #1 ^{rshift,rparity}; // calculate parity on all incoming data
-				rstate      <= #1 sr_check_parity;
-			  end
-	sr_check_parity: begin	  // rcounter equals 5
-				case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-					2'b00: rparity_error <= #1  rparity_xor == 0;  // no error if parity 1
-					2'b01: rparity_error <= #1 ~rparity;      // parity should sticked to 1
-					2'b10: rparity_error <= #1  rparity_xor == 1;   // error if parity is odd
-					2'b11: rparity_error <= #1  rparity;	  // parity should be sticked to 0
-				endcase
-				rcounter16 <= #1 rcounter16_minus_1;
-				rstate <= #1 sr_wait1;
-			  end
-	sr_wait1 :	if (rcounter16_eq_0)
-			begin
-				rstate <= #1 sr_rec_stop;
-				rcounter16 <= #1 4'b1110;
-			end
-			else
-				rcounter16 <= #1 rcounter16_minus_1;
-	sr_rec_stop :	begin
-				if (rcounter16_eq_7)	// read the parity
-				begin
-					rframing_error <= #1 !srx_pad_i; // no framing error if input is 1 (stop bit)
-					rstate <= #1 sr_push;
-				end
-				rcounter16 <= #1 rcounter16_minus_1;
-			end
-	sr_push :	begin
-///////////////////////////////////////
-//				$display($time, ": received: %b", rf_data_in);
-        if(srx_pad_i | break_error)
-          begin
-            if(break_error)
-        		  rf_data_in 	<= #1 {8'b0, 3'b100}; // break input (empty character) to receiver FIFO
-            else
-        			rf_data_in  <= #1 {rshift, 1'b0, rparity_error, rframing_error};
-      		  rf_push 		  <= #1 1'b1;
-    				rstate        <= #1 sr_idle;
-          end
-            
-			end
-	default : rstate <= #1 sr_idle;
-	endcase
-  end  // if (enable)
-end // always of receiver
-
-always @ (posedge clk or posedge wb_rst_i)
-begin
-  if(wb_rst_i)
-    rf_push_q <= 0;
-  else
-    rf_push_q <= #1 rf_push;
-end
-
-assign rf_push_pulse = rf_push & ~rf_push_q;
-
-  
-//
-// Break condition detection.
-// Works in conjuction with the receiver state machine
-
-reg 	[9:0]	toc_value; // value to be set to timeout counter
-
-always @(lcr)
-	case (lcr[3:0])
-		4'b0000										: toc_value = 447; // 7 bits
-		4'b0100										: toc_value = 479; // 7.5 bits
-		4'b0001,	4'b1000							: toc_value = 511; // 8 bits
-		4'b1100										: toc_value = 543; // 8.5 bits
-		4'b0010, 4'b0101, 4'b1001				: toc_value = 575; // 9 bits
-		4'b0011, 4'b0110, 4'b1010, 4'b1101	: toc_value = 639; // 10 bits
-		4'b0111, 4'b1011, 4'b1110				: toc_value = 703; // 11 bits
-		4'b1111										: toc_value = 767; // 12 bits
-	endcase // case(lcr[3:0])
-
-wire [7:0] 	brc_value; // value to be set to break counter
-assign 		brc_value = toc_value[9:2]; // the same as timeout but 1 insead of 4 character times
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_b <= #1 8'd159;
-	else
-	if (srx_pad_i)
-		counter_b <= #1 brc_value; // character time length - 1
-	else
-	if(enable & counter_b != 8'b0)            // only work on enable times  break not reached.
-		counter_b <= #1 counter_b - 1;  // decrement break counter
-end // always of break condition detection
-
-///
-/// Timeout condition detection
-reg	[9:0]	counter_t;	// counts the timeout condition clocks
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		counter_t <= #1 10'd639; // 10 bits for the default 8N1
-	else
-		if(rf_push_pulse || rf_pop || rf_count == 0) // counter is reset when RX FIFO is empty, accessed or above trigger level
-			counter_t <= #1 toc_value;
-		else
-		if (enable && counter_t != 10'b0)  // we don't want to underflow
-			counter_t <= #1 counter_t - 1;		
-end
-	
-endmodule
diff --git a/source/v/uart_regs.r105.v b/source/v/uart_regs.r105.v
deleted file mode 100755
index f906e9abcca2f4387626d3fe52384c8c78f3e898..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r105.v
+++ /dev/null
@@ -1,893 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.41  2004/05/21 11:44:41  tadejm
-// Added synchronizer flops for RX input.
-//
-// Revision 1.40  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.39  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.38  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.37  2001/12/27 13:24:09  mohor
-// lsr[7] was not showing overrun errors.
-//
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-assign baud_o = enable; // baud_o is actually the enable signal
-`endif
-
-
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-wire 										srx_pad;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-wire serial_out;
-
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
-
-  // Synchronizing and sampling serial RX input
-  uart_sync_flops    i_uart_sync_flops
-  (
-    .rst_i           (wb_rst_i),
-    .clk_i           (clk),
-    .stage1_rst_i    (1'b0),
-    .stage1_clk_en_i (1'b1),
-    .async_dat_i     (srx_pad_i),
-    .sync_dat_o      (srx_pad)
-  );
-  defparam i_uart_sync_flops.width      = 1;
-  defparam i_uart_sync_flops.init_value = 1'b1;
-
-// handle loopback
-wire serial_in = loopback ? serial_out : srx_pad;
-assign stx_pad_o = loopback ? 1'b1 : serial_out;
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0) && (|rf_count);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r106.v b/source/v/uart_regs.r106.v
deleted file mode 100755
index f906e9abcca2f4387626d3fe52384c8c78f3e898..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r106.v
+++ /dev/null
@@ -1,893 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.41  2004/05/21 11:44:41  tadejm
-// Added synchronizer flops for RX input.
-//
-// Revision 1.40  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.39  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.38  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.37  2001/12/27 13:24:09  mohor
-// lsr[7] was not showing overrun errors.
-//
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-assign baud_o = enable; // baud_o is actually the enable signal
-`endif
-
-
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-wire 										srx_pad;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-wire serial_out;
-
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
-
-  // Synchronizing and sampling serial RX input
-  uart_sync_flops    i_uart_sync_flops
-  (
-    .rst_i           (wb_rst_i),
-    .clk_i           (clk),
-    .stage1_rst_i    (1'b0),
-    .stage1_clk_en_i (1'b1),
-    .async_dat_i     (srx_pad_i),
-    .sync_dat_o      (srx_pad)
-  );
-  defparam i_uart_sync_flops.width      = 1;
-  defparam i_uart_sync_flops.init_value = 1'b1;
-
-// handle loopback
-wire serial_in = loopback ? serial_out : srx_pad;
-assign stx_pad_o = loopback ? 1'b1 : serial_out;
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0) && (|rf_count);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r27.v b/source/v/uart_regs.r27.v
deleted file mode 100755
index 3ce446a044668012ac9326275c5ae3ada48441c5..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r27.v
+++ /dev/null
@@ -1,532 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	enable,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		enable;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[5:0]			counter_t;
-wire	[3:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-/*
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-*/
-
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr[`UART_FC_TL])
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		dlc    <= #1 0;
-		enable <= #1 1'b0;
-	end
-	else
-	begin
-		if (start_dlc)
-		begin
-			enable <= #1 1'b0;
-			dlc    <= #1 dl;
-		end
-		else
-		begin
-			if (dl!=0)
-			begin
-				if ( (dlc-1)==0 )
-				begin
-					enable <= #1 1'b1;
-					dlc <= #1 dl;
-				end
-				else
-				begin
-					enable <= #1 1'b0;
-					dlc <= #1 dlc - 1;
-				end
-			end
-			else
-			begin
-				dlc <= #1 0;
-				enable <= #1 1'b0;
-			end
-		end
-	end
-end
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r29.v b/source/v/uart_regs.r29.v
deleted file mode 100755
index cb3bd43e83082ed7a78cf398edba1b11c37d41e5..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r29.v
+++ /dev/null
@@ -1,531 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[5:0]			counter_t;
-wire	[3:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-/*
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-*/
-
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr[`UART_FC_TL])
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r31.v b/source/v/uart_regs.r31.v
deleted file mode 100755
index 27aae6c9cf419f9ddbc98598a47aa6859f57d5c6..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r31.v
+++ /dev/null
@@ -1,535 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[5:0]			counter_t;
-wire	[3:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-/*
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-*/
-
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r32.v b/source/v/uart_regs.r32.v
deleted file mode 100755
index 1654db90057b3c420a49d561cd2c43c0a5fb6f75..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r32.v
+++ /dev/null
@@ -1,539 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[5:0]			counter_t;
-wire	[3:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-
-/*
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-*/
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r33.v b/source/v/uart_regs.r33.v
deleted file mode 100755
index bbb8a7d44dfd716b913f2f1546e723ef9f72cdbd..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r33.v
+++ /dev/null
@@ -1,545 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[5:0]			counter_t;
-wire	[3:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-
-/*
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-*/
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r34.v b/source/v/uart_regs.r34.v
deleted file mode 100755
index 749053af32e2413c17ab5849a172f64913934299..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r34.v
+++ /dev/null
@@ -1,548 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[5:0]			counter_t;
-wire	[3:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-
-/*
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-*/
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==4'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 6'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r35.v b/source/v/uart_regs.r35.v
deleted file mode 100755
index f1d539989c2c3b31bde859210a2610d7c998812d..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r35.v
+++ /dev/null
@@ -1,551 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[9:0]			counter_t;
-wire	[7:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-
-/*
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-*/
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==8'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 10'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r36.v b/source/v/uart_regs.r36.v
deleted file mode 100755
index 32da00cebadb2eb9abc9972c022b71449b53a150..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r36.v
+++ /dev/null
@@ -1,554 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input		clk;
-input		wb_rst_i;
-input	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-input	[7:0]	wb_dat_i;
-output	[7:0]	wb_dat_o;
-input		wb_we_i;
-input   wb_re_i;
-
-output		stx_pad_o;
-input		srx_pad_i;
-
-input	[3:0]	modem_inputs;
-output		rts_pad_o;
-output		dtr_pad_o;
-output		int_o;
-
-wire	[3:0]	modem_inputs;
-reg		enable;
-wire		stx_pad_o;		// received from transmitter module
-wire		srx_pad_i;
-
-reg	[7:0]	wb_dat_o;
-
-wire	[`UART_ADDR_WIDTH-1:0]	wb_addr_i;
-wire	[7:0]	wb_dat_i;
-
-
-reg	[3:0]	ier;
-reg	[3:0]	iir;
-reg	[1:0]	fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg	[4:0]	mcr;
-reg	[7:0]	lcr;
-reg	[7:0]	lsr;
-reg	[7:0]	msr;
-reg	[15:0]	dl;  // 32-bit divisor latch
-reg		start_dlc; // activate dlc on writing to UART_DL1
-reg		lsr_mask;
-reg		msi_reset; // reset MSR 4 lower bits indicator
-reg		threi_clear; // THRE interrupt clear flag
-reg	[15:0]	dlc;  // 32-bit divisor latch counter
-reg		int_o;
-
-reg	[3:0]	trigger_level; // trigger level of the receiver FIFO
-reg		rx_reset;
-reg		tx_reset;
-
-wire		dlab;			   // divisor latch access bit
-wire		cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire		loopback;		   // loopback bit (MCR bit 4)
-wire		cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire		rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-//
-// ASSINGS
-//
-assign {cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign {cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-		 : ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign dlab = lcr[`UART_LC_DL];
-assign loopback = mcr[4];
-
-// assign modem outputs
-assign	rts_pad_o = mcr[`UART_MC_RTS];
-assign	dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-reg	rls_int;  // receiver line status interrupt
-reg	rda_int;  // receiver data available interrupt
-reg	ti_int;   // timeout indicator interrupt
-reg	thre_int; // transmitter holding register empty interrupt
-reg	ms_int;   // modem status interrupt
-
-// FIFO signals
-reg				tf_push;
-reg				rf_pop;
-wire	[`UART_FIFO_REC_WIDTH-1:0]	rf_data_out;
-wire				rf_error_bit; // an error (parity or framing) is inside the fifo
-wire	[`UART_FIFO_COUNTER_W-1:0]	rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-wire	[2:0]			state;
-wire	[9:0]			counter_t;
-wire	[7:0]			counter_b;
-wire            rx_lsr_mask;
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, rx_lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase
-    else
-	wb_dat_o <= #1 8'b0;
-end
-
-/*
-always @(wb_addr_i or dlab or dl or rf_data_out or ier or iir or lcr or lsr or msr)
-begin
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-        			wb_dat_o <= dl[`UART_DL1];
-		        else
-			        wb_dat_o <= rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= lcr;
-	`UART_REG_LS	: wb_dat_o <= lsr;
-	`UART_REG_MS	: wb_dat_o <= msr;
-	default:  wb_dat_o <= 8'b0; // ??
-	endcase
-end
-*/
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-// lsr_mask signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask <= #1 0;
-	else
-	if (lsr_mask)
-		lsr_mask <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab)
-		lsr_mask <= #1 1; // reset bits in the Line Status Register
-end
-
-assign rx_lsr_mask = lsr_mask;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (threi_clear && !lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin // clear rx_reset, tx_reset signals when not written to
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr <= #1 8'b01100000;
-	else
-	if (lsr_mask)
-		lsr <= #1 lsr & 8'b00000001;
-	else
-	begin
-		lsr[0] <= #1 (rf_count!=4'b0);  // data in receiver fifo available
-		lsr[1] <= #1 rf_overrun;     // Receiver overrun error
-		lsr[2] <= #1 rf_data_out[1]; // parity error bit
-		lsr[3] <= #1 rf_data_out[0]; // framing error bit
-		lsr[4] <= #1 (counter_b==8'b0); // break counter reached 0
-		lsr[5] <= #1 (tf_count==5'b0);  // transmitter fifo is empty
-		lsr[6] <= #1 (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-		lsr[7] <= #1 rf_error_bit;
-	end
-end
-
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-  if (start_dlc | ~ (|dlc))
-  	dlc <= #1 dl - 1;               // preset counter
-	else
-		dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-  if (|dl & ~(|dlc))     // dl>0 & dlc==0
-		enable <= #1 1'b1;
-  else
-		enable <= #1 1'b0;
-end
-
-
-
-
-
-
-
-//
-//	INTERRUPT LOGIC
-//
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		rls_int  <= #1 1'b0;
-		rda_int  <= #1 1'b0;
-		ti_int   <= #1 1'b0;
-		thre_int <= #1 1'b0;
-		ms_int   <= #1 1'b0;
-	end
-	else
-	begin
-		rls_int  <= #1 ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-		rda_int  <= #1 ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-		thre_int <= #1 threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-		ms_int   <= #1 ier[`UART_IE_MS] && (| msr[3:0]);
-		ti_int   <= #1 ier[`UART_IE_RDA] && (counter_t == 10'b0);
-	end
-end
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		if (| {rls_int,rda_int,thre_int,ms_int,ti_int})
-			int_o <= #1 1'b1;
-		else
-			int_o <= #1 1'b0;
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int)  // interrupt occured and is enabled  (not masked)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end
-	else
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ti_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (thre_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else
-	if (ms_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r37.v b/source/v/uart_regs.r37.v
deleted file mode 100755
index 2faa00acc55609822773f91a64edc6fc1ba6c148..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r37.v
+++ /dev/null
@@ -1,681 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-    else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr1r <= #1 wb_rst_i ? 0 : // clear status on read
-				lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr2r <= #1 wb_rst_i ? 0 : // clear status on read
-				lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr3r <= #1 wb_rst_i ? 0 : // clear status on read
-				lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr4r <= #1  wb_rst_i ? 0 :
-			  lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr5r <= #1 wb_rst_i ? 1 :
-			(lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr6r <= #1 wb_rst_i ? 1 :
-				 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr7r <= #1  wb_rst_i ? 0 :
-			  lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r39.v b/source/v/uart_regs.r39.v
deleted file mode 100755
index 69947868255e8b3812f54ee01615cc88754a0c84..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r39.v
+++ /dev/null
@@ -1,686 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1; // reset bits in Modem Status Register
-end
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr1r <= #1 wb_rst_i ? 0 : // clear status on read
-				lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr2r <= #1 wb_rst_i ? 0 : // clear status on read
-				lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr3r <= #1 wb_rst_i ? 0 : // clear status on read
-				lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr4r <= #1  wb_rst_i ? 0 :
-			  lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr5r <= #1 wb_rst_i ? 1 :
-			(lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr6r <= #1 wb_rst_i ? 1 :
-				 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	lsr7r <= #1  wb_rst_i ? 0 :
-			  lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 1'b0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r40.v b/source/v/uart_regs.r40.v
deleted file mode 100755
index 68f04a7d94ccc709819955815675497feea8ac82..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r40.v
+++ /dev/null
@@ -1,692 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r41.v b/source/v/uart_regs.r41.v
deleted file mode 100755
index 0fe551b105668274d1080fdd0a0d37f2884d1845..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r41.v
+++ /dev/null
@@ -1,695 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r42.v b/source/v/uart_regs.r42.v
deleted file mode 100755
index 69524f234c4a7f2cebcc6c3a6c2119ee0073d19c..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r42.v
+++ /dev/null
@@ -1,698 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r43.v b/source/v/uart_regs.r43.v
deleted file mode 100755
index 658f6c75c14bc94b3c471b19b7403dfad0b301de..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r43.v
+++ /dev/null
@@ -1,701 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r44.v b/source/v/uart_regs.r44.v
deleted file mode 100755
index 2cdee5d75785f995fab05e4beb1c6c7663e8d81e..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r44.v
+++ /dev/null
@@ -1,704 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-wire [7:0] 								counter_b;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, counter_b, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[9:2];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	thre_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign thre_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count!=4'b0);  // data in receiver fifo available
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = (counter_b==8'b0); // break counter reached 0
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 lsr0;
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1 && ~lsr1_d; // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2 && ~lsr2_d; // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3 && ~lsr3_d; // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4 && ~lsr4_d;
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 0;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 0;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5 && ~lsr5_d;
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 0;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 0;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6 && ~lsr6_d;
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7 && ~lsr7_d;
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-//assign thre_int = threi_clear ? 0 : ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 thre_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int			? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(thre_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r45.v b/source/v/uart_regs.r45.v
deleted file mode 100755
index 32b6a8407ccbcc02e768e08544faa1250d64791b..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r45.v
+++ /dev/null
@@ -1,727 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[10:3];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_MS)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r47.v b/source/v/uart_regs.r47.v
deleted file mode 100755
index 445c5b7b94bd6745a2430325e391e69b6b84db07..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r47.v
+++ /dev/null
@@ -1,735 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								state;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask);
-
-
-always @(posedge clk or posedge wb_rst_i)   // synchrounous reading
-begin
-    if (wb_rst_i)
-    begin
-	wb_dat_o <= #1 8'b0;
-    end
-    else
-    if (wb_re_i)   //if (we're not writing)
-	case (wb_addr_i)
-	`UART_REG_RB : if (dlab) // Receiver FIFO or DL byte 1
-			wb_dat_o <= #1 dl[`UART_DL1];
-		  else
-			wb_dat_o <= #1 rf_data_out[10:3];
-	`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-	`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-	`UART_REG_LC	: wb_dat_o <= #1 lcr;
-	`UART_REG_LS	: wb_dat_o <= #1 lsr;
-	`UART_REG_MS	: wb_dat_o <= #1 msr;
-	default:  wb_dat_o <= #1 8'b0; // ??
-	endcase // case(wb_addr_i)
-     else
-	wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (state == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (lsr_mask || iir_read || tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (lsr_mask || tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r48.v b/source/v/uart_regs.r48.v
deleted file mode 100755
index 6f3e4881c1b41742fd2b74f99f0dfecd8e681447..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r48.v
+++ /dev/null
@@ -1,761 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(/*AUTOSENSE*/dl or dlab or ier or iir
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-   if (wb_rst_i)
-   begin
-		wb_dat_o <= #1 8'b0;
-   end
-   else
-		if (wb_re_i)   //if (we're not writing)
-			case (wb_addr_i)
-				`UART_REG_RB   : wb_dat_o <= #1 dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-				`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-				`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-				`UART_REG_LC	: wb_dat_o <= #1 lcr;
-				`UART_REG_LS	: wb_dat_o <= #1 lsr;
-				`UART_REG_MS	: wb_dat_o <= #1 msr;
-				default:  wb_dat_o <= #1 8'b0; // ??
-			endcase // case(wb_addr_i)
-		else
-			wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-/*
-// threi_clear signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		threi_clear <= #1 0;
-	else
-	if (!lsr[`UART_LS_TFE] && (tf_count==0)) // reset clear flag when tx fifo clears
-		threi_clear <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_II)
-		threi_clear <= #1 1;
-end
-*/
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && fifo_write);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-wire tx_fifo_write;
-assign tx_fifo_write = (wb_we_i && ~dlab && wb_addr_i==`UART_REG_TR);
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (tx_fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (tx_fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r50.v b/source/v/uart_regs.r50.v
deleted file mode 100755
index 5903d62f452d9fc3133b397fd3485748a7886699..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r50.v
+++ /dev/null
@@ -1,754 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(/*AUTOSENSE*/dl or dlab or ier or iir
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-   if (wb_rst_i)
-   begin
-		wb_dat_o <= #1 8'b0;
-   end
-   else
-		if (wb_re_i)   //if (we're not writing)
-			case (wb_addr_i)
-				`UART_REG_RB   : wb_dat_o <= #1 dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-				`UART_REG_IE	: wb_dat_o <= #1 dlab ? dl[`UART_DL2] : ier;
-				`UART_REG_II	: wb_dat_o <= #1 {4'b1100,iir};
-				`UART_REG_LC	: wb_dat_o <= #1 lcr;
-				`UART_REG_LS	: wb_dat_o <= #1 lsr;
-				`UART_REG_MS	: wb_dat_o <= #1 msr;
-				default:  wb_dat_o <= #1 8'b0; // ??
-			endcase // case(wb_addr_i)
-		else
-			wb_dat_o <= #1 8'b0;
-end // always @ (posedge clk or posedge wb_rst_i)
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r52.v b/source/v/uart_regs.r52.v
deleted file mode 100755
index 6038bb66b7df13b93236fd0e71d4a7018c968fcb..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r52.v
+++ /dev/null
@@ -1,762 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r54.v b/source/v/uart_regs.r54.v
deleted file mode 100755
index 112721f8ab5cd3bcd0c1b89637277f76ec9b1bac..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r54.v
+++ /dev/null
@@ -1,765 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || iir_read ? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r56.v b/source/v/uart_regs.r56.v
deleted file mode 100755
index 49b4725a5ef900d5c5048a857c20397bfaa2c08d..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r56.v
+++ /dev/null
@@ -1,768 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 0;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r58.v b/source/v/uart_regs.r58.v
deleted file mode 100755
index d63245dba3501878182097f836b3fab7ea903a32..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r58.v
+++ /dev/null
@@ -1,773 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ msr[`UART_MS_CDCD:`UART_MS_CCTS]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r59.v b/source/v/uart_regs.r59.v
deleted file mode 100755
index 2962a11937c6841001e92a1e48d48ef344935c2e..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r59.v
+++ /dev/null
@@ -1,782 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals (considering loopback)
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = loopback ? {mcr[`UART_MC_DTR],mcr[`UART_MC_RTS],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-											: ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                      :  {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r60.v b/source/v/uart_regs.r60.v
deleted file mode 100755
index cc20ce65a66f8f91d93a7d976683b7f4136497d2..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r60.v
+++ /dev/null
@@ -1,816 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r63.v b/source/v/uart_regs.r63.v
deleted file mode 100755
index 01caf321bed2b2986bd06a3b5141d55847611089..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r63.v
+++ /dev/null
@@ -1,821 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, rda_int,
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msr <= #1 0;
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r64.v b/source/v/uart_regs.r64.v
deleted file mode 100755
index e03900f11c5a7aba63021f8e8dd08f68fc472826..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r64.v
+++ /dev/null
@@ -1,827 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r66.v b/source/v/uart_regs.r66.v
deleted file mode 100755
index 0740a2e61a483d20bd39cfdbbe25433adb91496f..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r66.v
+++ /dev/null
@@ -1,830 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r68.v b/source/v/uart_regs.r68.v
deleted file mode 100755
index d14f6672ecf440b2cb2e9648db6b7bb3f422e088..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r68.v
+++ /dev/null
@@ -1,833 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, srx_pad_i, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r79.v b/source/v/uart_regs.r79.v
deleted file mode 100755
index 5bdddc1e75372b51364476766e5de6c7adde5d98..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r79.v
+++ /dev/null
@@ -1,854 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.37  2001/12/27 13:24:09  mohor
-// lsr[7] was not showing overrun errors.
-//
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-//`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-assign baud_o = enable; // baud_o is actually the enable signal
-`endif
-
-
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-wire serial_out;
-
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
-
-// handle loopback
-wire serial_in = loopback ? serial_out : srx_pad_i;
-assign stx_pad_o = loopback ? 1'b1 : serial_out;
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r84.v b/source/v/uart_regs.r84.v
deleted file mode 100755
index 92bb03b05bcb9cef67179228129c8b58cadefd41..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r84.v
+++ /dev/null
@@ -1,870 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.38  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.37  2001/12/27 13:24:09  mohor
-// lsr[7] was not showing overrun errors.
-//
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-assign baud_o = enable; // baud_o is actually the enable signal
-`endif
-
-
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-wire serial_out;
-
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
-
-// handle loopback
-wire serial_in = loopback ? serial_out : srx_pad_i;
-assign stx_pad_o = loopback ? 1'b1 : serial_out;
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && fifo_read || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r87.v b/source/v/uart_regs.r87.v
deleted file mode 100755
index 4a8b3fc8c6a9a495665b9156f091e89212c805e6..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r87.v
+++ /dev/null
@@ -1,873 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.39  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.38  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.37  2001/12/27 13:24:09  mohor
-// lsr[7] was not showing overrun errors.
-//
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-assign baud_o = enable; // baud_o is actually the enable signal
-`endif
-
-
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-wire serial_out;
-
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
-
-// handle loopback
-wire serial_in = loopback ? serial_out : srx_pad_i;
-assign stx_pad_o = loopback ? 1'b1 : serial_out;
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_regs.r99.v b/source/v/uart_regs.r99.v
deleted file mode 100755
index b9a931639e61bdc6678146a2f2a33831401b582f..0000000000000000000000000000000000000000
--- a/source/v/uart_regs.r99.v
+++ /dev/null
@@ -1,890 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_regs.v                                                 ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  Registers of the uart 16550 core                            ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts 1 wait state in all WISHBONE transfers              ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing or verification.                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   (See log for the revision history           ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.40  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.39  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.38  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.37  2001/12/27 13:24:09  mohor
-// lsr[7] was not showing overrun errors.
-//
-// Revision 1.36  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.35  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.34  2001/12/19 07:33:54  mohor
-// Synplicity was having troubles with the comment.
-//
-// Revision 1.33  2001/12/17 10:14:43  mohor
-// Things related to msr register changed. After THRE IRQ occurs, and one
-// character is written to the transmit fifo, the detection of the THRE bit in the
-// LSR is delayed for one character time.
-//
-// Revision 1.32  2001/12/14 13:19:24  mohor
-// MSR register fixed.
-//
-// Revision 1.31  2001/12/14 10:06:58  mohor
-// After reset modem status register MSR should be reset.
-//
-// Revision 1.30  2001/12/13 10:09:13  mohor
-// thre irq should be cleared only when being source of interrupt.
-//
-// Revision 1.29  2001/12/12 09:05:46  mohor
-// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
-//
-// Revision 1.28  2001/12/10 19:52:41  gorban
-// Scratch register added
-//
-// Revision 1.27  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.26  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.25  2001/11/28 19:36:39  gorban
-// Fixed: timeout and break didn't pay attention to current data format when counting time
-//
-// Revision 1.24  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.23  2001/11/12 21:57:29  gorban
-// fixed more typo bugs
-//
-// Revision 1.22  2001/11/12 15:02:28  mohor
-// lsr1r error fixed.
-//
-// Revision 1.21  2001/11/12 14:57:27  mohor
-// ti_int_pnd error fixed.
-//
-// Revision 1.20  2001/11/12 14:50:27  mohor
-// ti_int_d error fixed.
-//
-// Revision 1.19  2001/11/10 12:43:21  gorban
-// Logic Synthesis bugs fixed. Some other minor changes
-//
-// Revision 1.18  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.17  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.16  2001/11/02 09:55:16  mohor
-// no message
-//
-// Revision 1.15  2001/10/31 15:19:22  gorban
-// Fixes to break and timeout conditions
-//
-// Revision 1.14  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/10/19 16:21:40  gorban
-// Changes data_out to be synchronous again as it should have been.
-//
-// Revision 1.11  2001/10/18 20:35:45  gorban
-// small fix
-//
-// Revision 1.10  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.9  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.10  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.9  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.8  2001/05/29 20:05:04  gorban
-// Fixed some bugs and synthesis problems.
-//
-// Revision 1.7  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.6  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.5  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:11+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-`define UART_DL1 7:0
-`define UART_DL2 15:8
-
-module uart_regs (clk,
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_re_i, 
-
-// additional signals
-	modem_inputs,
-	stx_pad_o, srx_pad_i,
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-ier, iir, fcr, mcr, lcr, msr, lsr, rf_count, tf_count, tstate, rstate,
-`endif				
-	rts_pad_o, dtr_pad_o, int_o
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-
-	);
-
-input 									clk;
-input 									wb_rst_i;
-input [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-input [7:0] 							wb_dat_i;
-output [7:0] 							wb_dat_o;
-input 									wb_we_i;
-input 									wb_re_i;
-
-output 									stx_pad_o;
-input 									srx_pad_i;
-
-input [3:0] 							modem_inputs;
-output 									rts_pad_o;
-output 									dtr_pad_o;
-output 									int_o;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// if 32-bit databus and debug interface are enabled
-output [3:0]							ier;
-output [3:0]							iir;
-output [1:0]							fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-output [4:0]							mcr;
-output [7:0]							lcr;
-output [7:0]							msr;
-output [7:0] 							lsr;
-output [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-output [2:0] 							tstate;
-output [3:0] 							rstate;
-
-`endif
-
-wire [3:0] 								modem_inputs;
-reg 										enable;
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-assign baud_o = enable; // baud_o is actually the enable signal
-`endif
-
-
-wire 										stx_pad_o;		// received from transmitter module
-wire 										srx_pad_i;
-wire 										srx_pad;
-
-reg [7:0] 								wb_dat_o;
-
-wire [`UART_ADDR_WIDTH-1:0] 		wb_addr_i;
-wire [7:0] 								wb_dat_i;
-
-
-reg [3:0] 								ier;
-reg [3:0] 								iir;
-reg [1:0] 								fcr;  /// bits 7 and 6 of fcr. Other bits are ignored
-reg [4:0] 								mcr;
-reg [7:0] 								lcr;
-reg [7:0] 								msr;
-reg [15:0] 								dl;  // 32-bit divisor latch
-reg [7:0] 								scratch; // UART scratch register
-reg 										start_dlc; // activate dlc on writing to UART_DL1
-reg 										lsr_mask_d; // delay for lsr_mask condition
-reg 										msi_reset; // reset MSR 4 lower bits indicator
-//reg 										threi_clear; // THRE interrupt clear flag
-reg [15:0] 								dlc;  // 32-bit divisor latch counter
-reg 										int_o;
-
-reg [3:0] 								trigger_level; // trigger level of the receiver FIFO
-reg 										rx_reset;
-reg 										tx_reset;
-
-wire 										dlab;			   // divisor latch access bit
-wire 										cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i; // modem status bits
-wire 										loopback;		   // loopback bit (MCR bit 4)
-wire 										cts, dsr, ri, dcd;	   // effective signals
-wire                    cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)
-wire 										rts_pad_o, dtr_pad_o;		   // modem control outputs
-
-// LSR bits wires and regs
-wire [7:0] 								lsr;
-wire 										lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
-reg										lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
-wire 										lsr_mask; // lsr_mask
-
-//
-// ASSINGS
-//
-
-assign 									lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };
-
-assign 									{cts_pad_i, dsr_pad_i, ri_pad_i, dcd_pad_i} = modem_inputs;
-assign 									{cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
-                                                               : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};
-
-assign 									dlab = lcr[`UART_LC_DL];
-assign 									loopback = mcr[4];
-
-// assign modem outputs
-assign 									rts_pad_o = mcr[`UART_MC_RTS];
-assign 									dtr_pad_o = mcr[`UART_MC_DTR];
-
-// Interrupt signals
-wire 										rls_int;  // receiver line status interrupt
-wire 										rda_int;  // receiver data available interrupt
-wire 										ti_int;   // timeout indicator interrupt
-wire										thre_int; // transmitter holding register empty interrupt
-wire 										ms_int;   // modem status interrupt
-
-// FIFO signals
-reg 										tf_push;
-reg 										rf_pop;
-wire [`UART_FIFO_REC_WIDTH-1:0] 	rf_data_out;
-wire 										rf_error_bit; // an error (parity or framing) is inside the fifo
-wire [`UART_FIFO_COUNTER_W-1:0] 	rf_count;
-wire [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-wire [2:0] 								tstate;
-wire [3:0] 								rstate;
-wire [9:0] 								counter_t;
-
-wire                      thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
-reg  [7:0]                block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
-reg  [7:0]                block_value; // One character length minus stop bit
-
-// Transmitter Instance
-wire serial_out;
-
-uart_transmitter transmitter(clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable, serial_out, tstate, tf_count, tx_reset, lsr_mask);
-
-  // Synchronizing and sampling serial RX input
-  uart_sync_flops    i_uart_sync_flops
-  (
-    .rst_i           (wb_rst_i),
-    .clk_i           (clk),
-    .stage1_rst_i    (1'b0),
-    .stage1_clk_en_i (1'b1),
-    .async_dat_i     (srx_pad_i),
-    .sync_dat_o      (srx_pad)
-  );
-  defparam i_uart_sync_flops.width      = 1;
-  defparam i_uart_sync_flops.init_value = 1'b1;
-
-// handle loopback
-wire serial_in = loopback ? serial_out : srx_pad;
-assign stx_pad_o = loopback ? 1'b1 : serial_out;
-
-// Receiver Instance
-uart_receiver receiver(clk, wb_rst_i, lcr, rf_pop, serial_in, enable, 
-	counter_t, rf_count, rf_data_out, rf_error_bit, rf_overrun, rx_reset, lsr_mask, rstate, rf_push_pulse);
-
-
-// Asynchronous reading here because the outputs are sampled in uart_wb.v file 
-always @(dl or dlab or ier or iir or scratch
-			or lcr or lsr or msr or rf_data_out or wb_addr_i or wb_re_i)   // asynchrounous reading
-begin
-	case (wb_addr_i)
-		`UART_REG_RB   : wb_dat_o = dlab ? dl[`UART_DL1] : rf_data_out[10:3];
-		`UART_REG_IE	: wb_dat_o = dlab ? dl[`UART_DL2] : ier;
-		`UART_REG_II	: wb_dat_o = {4'b1100,iir};
-		`UART_REG_LC	: wb_dat_o = lcr;
-		`UART_REG_LS	: wb_dat_o = lsr;
-		`UART_REG_MS	: wb_dat_o = msr;
-		`UART_REG_SR	: wb_dat_o = scratch;
-		default:  wb_dat_o = 8'b0; // ??
-	endcase // case(wb_addr_i)
-end // always @ (dl or dlab or ier or iir or scratch...
-
-
-// rf_pop signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		rf_pop <= #1 0; 
-	else
-	if (rf_pop)	// restore the signal to 0 after one clock cycle
-		rf_pop <= #1 0;
-	else
-	if (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab)
-		rf_pop <= #1 1; // advance read pointer
-end
-
-wire 	lsr_mask_condition;
-wire 	iir_read;
-wire  msr_read;
-wire	fifo_read;
-wire	fifo_write;
-
-assign lsr_mask_condition = (wb_re_i && wb_addr_i == `UART_REG_LS && !dlab);
-assign iir_read = (wb_re_i && wb_addr_i == `UART_REG_II && !dlab);
-assign msr_read = (wb_re_i && wb_addr_i == `UART_REG_MS && !dlab);
-assign fifo_read = (wb_re_i && wb_addr_i == `UART_REG_RB && !dlab);
-assign fifo_write = (wb_we_i && wb_addr_i == `UART_REG_TR && !dlab);
-
-// lsr_mask_d delayed signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		lsr_mask_d <= #1 0;
-	else // reset bits in the Line Status Register
-		lsr_mask_d <= #1 lsr_mask_condition;
-end
-
-// lsr_mask is rise detected
-assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;
-
-// msi_reset signal handling
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		msi_reset <= #1 1;
-	else
-	if (msi_reset)
-		msi_reset <= #1 0;
-	else
-	if (msr_read)
-		msi_reset <= #1 1; // reset bits in Modem Status Register
-end
-
-
-//
-//   WRITES AND RESETS   //
-//
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		lcr <= #1 8'b00000011; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_LC)
-		lcr <= #1 wb_dat_i;
-
-// Interrupt Enable Register or UART_DL2
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		ier <= #1 4'b0000; // no interrupts after reset
-		dl[`UART_DL2] <= #1 8'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_IE)
-		if (dlab)
-		begin
-			dl[`UART_DL2] <= #1 wb_dat_i;
-		end
-		else
-			ier <= #1 wb_dat_i[3:0]; // ier uses only 4 lsb
-
-
-// FIFO Control Register and rx_reset, tx_reset signals
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		fcr <= #1 2'b11; 
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end else
-	if (wb_we_i && wb_addr_i==`UART_REG_FC) begin
-		fcr <= #1 wb_dat_i[7:6];
-		rx_reset <= #1 wb_dat_i[1];
-		tx_reset <= #1 wb_dat_i[2];
-	end else begin
-		rx_reset <= #1 0;
-		tx_reset <= #1 0;
-	end
-
-// Modem Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		mcr <= #1 5'b0; 
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_MC)
-			mcr <= #1 wb_dat_i[4:0];
-
-// Scratch register
-// Line Control Register
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		scratch <= #1 0; // 8n1 setting
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_SR)
-		scratch <= #1 wb_dat_i;
-
-// TX_FIFO or UART_DL1
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-	begin
-		dl[`UART_DL1]  <= #1 8'b0;
-		tf_push   <= #1 1'b0;
-		start_dlc <= #1 1'b0;
-	end
-	else
-	if (wb_we_i && wb_addr_i==`UART_REG_TR)
-		if (dlab)
-		begin
-			dl[`UART_DL1] <= #1 wb_dat_i;
-			start_dlc <= #1 1'b1; // enable DL counter
-			tf_push <= #1 1'b0;
-		end
-		else
-		begin
-			tf_push   <= #1 1'b1;
-			start_dlc <= #1 1'b0;
-		end // else: !if(dlab)
-	else
-	begin
-		start_dlc <= #1 1'b0;
-		tf_push   <= #1 1'b0;
-	end // else: !if(dlab)
-
-// Receiver FIFO trigger level selection logic (asynchronous mux)
-always @(fcr)
-	case (fcr[`UART_FC_TL])
-		2'b00 : trigger_level = 1;
-		2'b01 : trigger_level = 4;
-		2'b10 : trigger_level = 8;
-		2'b11 : trigger_level = 14;
-	endcase // case(fcr[`UART_FC_TL])
-	
-//
-//  STATUS REGISTERS  //
-//
-
-// Modem Status Register
-reg [3:0] delayed_modem_signals;
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	  begin
-  		msr <= #1 0;
-	  	delayed_modem_signals[3:0] <= #1 0;
-	  end
-	else begin
-		msr[`UART_MS_DDCD:`UART_MS_DCTS] <= #1 msi_reset ? 4'b0 :
-			msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
-		msr[`UART_MS_CDCD:`UART_MS_CCTS] <= #1 {dcd_c, ri_c, dsr_c, cts_c};
-		delayed_modem_signals[3:0] <= #1 {dcd, ri, dsr, cts};
-	end
-end
-
-
-// Line Status Register
-
-// activation conditions
-assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
-assign lsr1 = rf_overrun;     // Receiver overrun error
-assign lsr2 = rf_data_out[1]; // parity error bit
-assign lsr3 = rf_data_out[0]; // framing error bit
-assign lsr4 = rf_data_out[2]; // break error in the character
-assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
-assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
-assign lsr7 = rf_error_bit | rf_overrun;
-
-// lsr bit0 (receiver data available)
-reg 	 lsr0_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0_d <= #1 0;
-	else lsr0_d <= #1 lsr0;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr0r <= #1 0;
-	else lsr0r <= #1 (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
-					  lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 
-
-// lsr bit 1 (receiver overrun)
-reg lsr1_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1_d <= #1 0;
-	else lsr1_d <= #1 lsr1;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr1r <= #1 0;
-	else	lsr1r <= #1	lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise
-
-// lsr bit 2 (parity error)
-reg lsr2_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2_d <= #1 0;
-	else lsr2_d <= #1 lsr2;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr2r <= #1 0;
-	else lsr2r <= #1 lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise
-
-// lsr bit 3 (framing error)
-reg lsr3_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3_d <= #1 0;
-	else lsr3_d <= #1 lsr3;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr3r <= #1 0;
-	else lsr3r <= #1 lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise
-
-// lsr bit 4 (break indicator)
-reg lsr4_d; // delayed
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4_d <= #1 0;
-	else lsr4_d <= #1 lsr4;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr4r <= #1 0;
-	else lsr4r <= #1 lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);
-
-// lsr bit 5 (transmitter fifo is empty)
-reg lsr5_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5_d <= #1 1;
-	else lsr5_d <= #1 lsr5;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr5r <= #1 1;
-	else lsr5r <= #1 (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);
-
-// lsr bit 6 (transmitter empty indicator)
-reg lsr6_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6_d <= #1 1;
-	else lsr6_d <= #1 lsr6;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr6r <= #1 1;
-	else lsr6r <= #1 (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);
-
-// lsr bit 7 (error in fifo)
-reg lsr7_d;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7_d <= #1 0;
-	else lsr7_d <= #1 lsr7;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) lsr7r <= #1 0;
-	else lsr7r <= #1 lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);
-
-// Frequency divider
-always @(posedge clk or posedge wb_rst_i) 
-begin
-	if (wb_rst_i)
-		dlc <= #1 0;
-	else
-		if (start_dlc | ~ (|dlc))
-  			dlc <= #1 dl - 1;               // preset counter
-		else
-			dlc <= #1 dlc - 1;              // decrement counter
-end
-
-// Enable signal generation logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		enable <= #1 1'b0;
-	else
-		if (|dl & ~(|dlc))     // dl>0 & dlc==0
-			enable <= #1 1'b1;
-		else
-			enable <= #1 1'b0;
-end
-
-// Delaying THRE status for one character cycle after a character is written to an empty fifo.
-always @(lcr)
-  case (lcr[3:0])
-    4'b0000                             : block_value =  95; // 6 bits
-    4'b0100                             : block_value = 103; // 6.5 bits
-    4'b0001, 4'b1000                    : block_value = 111; // 7 bits
-    4'b1100                             : block_value = 119; // 7.5 bits
-    4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
-    4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
-    4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
-    4'b1111                             : block_value = 175; // 11 bits
-  endcase // case(lcr[3:0])
-
-// Counting time of one character minus stop bit
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-    block_cnt <= #1 8'd0;
-  else
-  if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
-    block_cnt <= #1 block_value;
-  else
-  if (enable & block_cnt != 8'b0)  // only work on enable times
-    block_cnt <= #1 block_cnt - 1;  // decrement break counter
-end // always of break condition detection
-
-// Generating THRE status enable signal
-assign thre_set_en = ~(|block_cnt);
-
-
-//
-//	INTERRUPT LOGIC
-//
-
-assign rls_int  = ier[`UART_IE_RLS] && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
-assign rda_int  = ier[`UART_IE_RDA] && (rf_count >= {1'b0,trigger_level});
-assign thre_int = ier[`UART_IE_THRE] && lsr[`UART_LS_TFE];
-assign ms_int   = ier[`UART_IE_MS] && (| msr[3:0]);
-assign ti_int   = ier[`UART_IE_RDA] && (counter_t == 10'b0);
-
-reg 	 rls_int_d;
-reg 	 thre_int_d;
-reg 	 ms_int_d;
-reg 	 ti_int_d;
-reg 	 rda_int_d;
-
-// delay lines
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_d <= #1 0;
-	else rls_int_d <= #1 rls_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_d <= #1 0;
-	else rda_int_d <= #1 rda_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_d <= #1 0;
-	else thre_int_d <= #1 thre_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_d <= #1 0;
-	else ms_int_d <= #1 ms_int;
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_d <= #1 0;
-	else ti_int_d <= #1 ti_int;
-
-// rise detection signals
-
-wire 	 rls_int_rise;
-wire 	 thre_int_rise;
-wire 	 ms_int_rise;
-wire 	 ti_int_rise;
-wire 	 rda_int_rise;
-
-assign rda_int_rise    = rda_int & ~rda_int_d;
-assign rls_int_rise 	  = rls_int & ~rls_int_d;
-assign thre_int_rise   = thre_int & ~thre_int_d;
-assign ms_int_rise 	  = ms_int & ~ms_int_d;
-assign ti_int_rise 	  = ti_int & ~ti_int_d;
-
-// interrupt pending flags
-reg 	rls_int_pnd;
-reg	rda_int_pnd;
-reg 	thre_int_pnd;
-reg 	ms_int_pnd;
-reg 	ti_int_pnd;
-
-// interrupt pending flags assignments
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rls_int_pnd <= #1 0; 
-	else 
-		rls_int_pnd <= #1 lsr_mask ? 0 :  						// reset condition
-							rls_int_rise ? 1 :						// latch condition
-							rls_int_pnd && ier[`UART_IE_RLS];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) rda_int_pnd <= #1 0; 
-	else 
-		rda_int_pnd <= #1 ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :  	// reset condition
-							rda_int_rise ? 1 :						// latch condition
-							rda_int_pnd && ier[`UART_IE_RDA];	// default operation: remove if masked
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) thre_int_pnd <= #1 0; 
-	else 
-		thre_int_pnd <= #1 fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
-							thre_int_rise ? 1 :
-							thre_int_pnd && ier[`UART_IE_THRE];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ms_int_pnd <= #1 0; 
-	else 
-		ms_int_pnd <= #1 msr_read ? 0 : 
-							ms_int_rise ? 1 :
-							ms_int_pnd && ier[`UART_IE_MS];
-
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) ti_int_pnd <= #1 0; 
-	else 
-		ti_int_pnd <= #1 fifo_read ? 0 : 
-							ti_int_rise ? 1 :
-							ti_int_pnd && ier[`UART_IE_RDA];
-// end of pending flags
-
-// INT_O logic
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)	
-		int_o <= #1 1'b0;
-	else
-		int_o <= #1 
-					rls_int_pnd		?	~lsr_mask					:
-					rda_int_pnd		? 1								:
-					ti_int_pnd		? ~fifo_read					:
-					thre_int_pnd	? !(fifo_write & iir_read) :
-					ms_int_pnd		? ~msr_read						:
-					0;	// if no interrupt are pending
-end
-
-
-// Interrupt Identification register
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-		iir <= #1 1;
-	else
-	if (rls_int_pnd)  // interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RLS;	// set identification register to correct value
-		iir[`UART_II_IP] <= #1 1'b0;		// and clear the IIR bit 0 (interrupt pending)
-	end else // the sequence of conditions determines priority of interrupt identification
-	if (rda_int)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_RDA;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ti_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_TI;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (thre_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_THRE;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end
-	else if (ms_int_pnd)
-	begin
-		iir[`UART_II_II] <= #1 `UART_II_MS;
-		iir[`UART_II_IP] <= #1 1'b0;
-	end else	// no interrupt is pending
-	begin
-		iir[`UART_II_II] <= #1 0;
-		iir[`UART_II_IP] <= #1 1'b1;
-	end
-end
-
-endmodule
diff --git a/source/v/uart_rfifo.r106.v b/source/v/uart_rfifo.r106.v
deleted file mode 100755
index b949ee5ed9e44ee501baa8cc41bd4c16163b6731..0000000000000000000000000000000000000000
--- a/source/v/uart_rfifo.r106.v
+++ /dev/null
@@ -1,320 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver FIFO                                     ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.3  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.2  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.1  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_rfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	error_bit,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-output				error_bit;
-
-wire	[fifo_width-1:0]	data_out;
-wire [7:0] data8_out;
-// flags FIFO
-reg	[2:0]	fifo[fifo_depth-1:0];
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in[fifo_width-1:fifo_width-8]), 
-			.dpo(data8_out)
-		); 
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-		fifo[0] <= #1 0;
-		fifo[1] <= #1 0;
-		fifo[2] <= #1 0;
-		fifo[3] <= #1 0;
-		fifo[4] <= #1 0;
-		fifo[5] <= #1 0;
-		fifo[6] <= #1 0;
-		fifo[7] <= #1 0;
-		fifo[8] <= #1 0;
-		fifo[9] <= #1 0;
-		fifo[10] <= #1 0;
-		fifo[11] <= #1 0;
-		fifo[12] <= #1 0;
-		fifo[13] <= #1 0;
-		fifo[14] <= #1 0;
-		fifo[15] <= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-		fifo[0] <= #1 0;
-		fifo[1] <= #1 0;
-		fifo[2] <= #1 0;
-		fifo[3] <= #1 0;
-		fifo[4] <= #1 0;
-		fifo[5] <= #1 0;
-		fifo[6] <= #1 0;
-		fifo[7] <= #1 0;
-		fifo[8] <= #1 0;
-		fifo[9] <= #1 0;
-		fifo[10] <= #1 0;
-		fifo[11] <= #1 0;
-		fifo[12] <= #1 0;
-		fifo[13] <= #1 0;
-		fifo[14] <= #1 0;
-		fifo[15] <= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & ~pop & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-
-// please note though that data_out is only valid one clock after pop signal
-assign data_out = {data8_out,fifo[bottom]};
-
-// Additional logic for detection of error conditions (parity and framing) inside the FIFO
-// for the Line Status Register bit 7
-
-wire	[2:0]	word0 = fifo[0];
-wire	[2:0]	word1 = fifo[1];
-wire	[2:0]	word2 = fifo[2];
-wire	[2:0]	word3 = fifo[3];
-wire	[2:0]	word4 = fifo[4];
-wire	[2:0]	word5 = fifo[5];
-wire	[2:0]	word6 = fifo[6];
-wire	[2:0]	word7 = fifo[7];
-
-wire	[2:0]	word8 = fifo[8];
-wire	[2:0]	word9 = fifo[9];
-wire	[2:0]	word10 = fifo[10];
-wire	[2:0]	word11 = fifo[11];
-wire	[2:0]	word12 = fifo[12];
-wire	[2:0]	word13 = fifo[13];
-wire	[2:0]	word14 = fifo[14];
-wire	[2:0]	word15 = fifo[15];
-
-// a 1 is returned if any of the error bits in the fifo is 1
-assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
-            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
-            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
-            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
-
-endmodule
diff --git a/source/v/uart_rfifo.r79.v b/source/v/uart_rfifo.r79.v
deleted file mode 100755
index 7d5bd3c6b6645768e282afbe40e6d7cfadb0639e..0000000000000000000000000000000000000000
--- a/source/v/uart_rfifo.r79.v
+++ /dev/null
@@ -1,267 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver FIFO                                     ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-//`include "uart_defines.v"
-
-module uart_rfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	error_bit,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-output				error_bit;
-
-wire	[fifo_width-1:0]	data_out;
-wire [7:0] data8_out;
-// flags FIFO
-reg	[2:0]	fifo[fifo_depth-1:0];
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in[fifo_width-1:fifo_width-8]), 
-			.dpo(data8_out)
-		); 
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-
-// please note though that data_out is only valid one clock after pop signal
-assign data_out = {data8_out,fifo[bottom]};
-
-// Additional logic for detection of error conditions (parity and framing) inside the FIFO
-// for the Line Status Register bit 7
-
-wire	[2:0]	word0 = fifo[0];
-wire	[2:0]	word1 = fifo[1];
-wire	[2:0]	word2 = fifo[2];
-wire	[2:0]	word3 = fifo[3];
-wire	[2:0]	word4 = fifo[4];
-wire	[2:0]	word5 = fifo[5];
-wire	[2:0]	word6 = fifo[6];
-wire	[2:0]	word7 = fifo[7];
-
-wire	[2:0]	word8 = fifo[8];
-wire	[2:0]	word9 = fifo[9];
-wire	[2:0]	word10 = fifo[10];
-wire	[2:0]	word11 = fifo[11];
-wire	[2:0]	word12 = fifo[12];
-wire	[2:0]	word13 = fifo[13];
-wire	[2:0]	word14 = fifo[14];
-wire	[2:0]	word15 = fifo[15];
-
-// a 1 is returned if any of the error bits in the fifo is 1
-assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
-            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
-            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
-            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
-
-endmodule
diff --git a/source/v/uart_rfifo.r84.v b/source/v/uart_rfifo.r84.v
deleted file mode 100755
index 41d8ce99e5ac4020c5c221ddc6e3a905a9d316c9..0000000000000000000000000000000000000000
--- a/source/v/uart_rfifo.r84.v
+++ /dev/null
@@ -1,283 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver FIFO                                     ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.1  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_rfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	error_bit,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-output				error_bit;
-
-wire	[fifo_width-1:0]	data_out;
-wire [7:0] data8_out;
-// flags FIFO
-reg	[2:0]	fifo[fifo_depth-1:0];
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in[fifo_width-1:fifo_width-8]), 
-			.dpo(data8_out)
-		); 
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-
-// please note though that data_out is only valid one clock after pop signal
-assign data_out = {data8_out,fifo[bottom]};
-
-// Additional logic for detection of error conditions (parity and framing) inside the FIFO
-// for the Line Status Register bit 7
-
-wire	[2:0]	word0 = fifo[0];
-wire	[2:0]	word1 = fifo[1];
-wire	[2:0]	word2 = fifo[2];
-wire	[2:0]	word3 = fifo[3];
-wire	[2:0]	word4 = fifo[4];
-wire	[2:0]	word5 = fifo[5];
-wire	[2:0]	word6 = fifo[6];
-wire	[2:0]	word7 = fifo[7];
-
-wire	[2:0]	word8 = fifo[8];
-wire	[2:0]	word9 = fifo[9];
-wire	[2:0]	word10 = fifo[10];
-wire	[2:0]	word11 = fifo[11];
-wire	[2:0]	word12 = fifo[12];
-wire	[2:0]	word13 = fifo[13];
-wire	[2:0]	word14 = fifo[14];
-wire	[2:0]	word15 = fifo[15];
-
-// a 1 is returned if any of the error bits in the fifo is 1
-assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
-            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
-            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
-            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
-
-endmodule
diff --git a/source/v/uart_rfifo.r87.v b/source/v/uart_rfifo.r87.v
deleted file mode 100755
index c37c11b221d60434905d3dbbbe4a4dcd8a64e075..0000000000000000000000000000000000000000
--- a/source/v/uart_rfifo.r87.v
+++ /dev/null
@@ -1,285 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver FIFO                                     ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.2  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.1  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_rfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	error_bit,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-output				error_bit;
-
-wire	[fifo_width-1:0]	data_out;
-wire [7:0] data8_out;
-// flags FIFO
-reg	[2:0]	fifo[fifo_depth-1:0];
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in[fifo_width-1:fifo_width-8]), 
-			.dpo(data8_out)
-		); 
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & ~pop & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-
-// please note though that data_out is only valid one clock after pop signal
-assign data_out = {data8_out,fifo[bottom]};
-
-// Additional logic for detection of error conditions (parity and framing) inside the FIFO
-// for the Line Status Register bit 7
-
-wire	[2:0]	word0 = fifo[0];
-wire	[2:0]	word1 = fifo[1];
-wire	[2:0]	word2 = fifo[2];
-wire	[2:0]	word3 = fifo[3];
-wire	[2:0]	word4 = fifo[4];
-wire	[2:0]	word5 = fifo[5];
-wire	[2:0]	word6 = fifo[6];
-wire	[2:0]	word7 = fifo[7];
-
-wire	[2:0]	word8 = fifo[8];
-wire	[2:0]	word9 = fifo[9];
-wire	[2:0]	word10 = fifo[10];
-wire	[2:0]	word11 = fifo[11];
-wire	[2:0]	word12 = fifo[12];
-wire	[2:0]	word13 = fifo[13];
-wire	[2:0]	word14 = fifo[14];
-wire	[2:0]	word15 = fifo[15];
-
-// a 1 is returned if any of the error bits in the fifo is 1
-assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
-            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
-            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
-            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
-
-endmodule
diff --git a/source/v/uart_rfifo.r88.v b/source/v/uart_rfifo.r88.v
deleted file mode 100755
index b949ee5ed9e44ee501baa8cc41bd4c16163b6731..0000000000000000000000000000000000000000
--- a/source/v/uart_rfifo.r88.v
+++ /dev/null
@@ -1,320 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_rfifo.v (Modified from uart_fifo.v)                    ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver FIFO                                     ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.3  2003/06/11 16:37:47  gorban
-// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
-//
-// Revision 1.2  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.1  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_rfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	error_bit,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-output				error_bit;
-
-wire	[fifo_width-1:0]	data_out;
-wire [7:0] data8_out;
-// flags FIFO
-reg	[2:0]	fifo[fifo_depth-1:0];
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,8,fifo_depth) rfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in[fifo_width-1:fifo_width-8]), 
-			.dpo(data8_out)
-		); 
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-		fifo[0] <= #1 0;
-		fifo[1] <= #1 0;
-		fifo[2] <= #1 0;
-		fifo[3] <= #1 0;
-		fifo[4] <= #1 0;
-		fifo[5] <= #1 0;
-		fifo[6] <= #1 0;
-		fifo[7] <= #1 0;
-		fifo[8] <= #1 0;
-		fifo[9] <= #1 0;
-		fifo[10] <= #1 0;
-		fifo[11] <= #1 0;
-		fifo[12] <= #1 0;
-		fifo[13] <= #1 0;
-		fifo[14] <= #1 0;
-		fifo[15] <= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-		fifo[0] <= #1 0;
-		fifo[1] <= #1 0;
-		fifo[2] <= #1 0;
-		fifo[3] <= #1 0;
-		fifo[4] <= #1 0;
-		fifo[5] <= #1 0;
-		fifo[6] <= #1 0;
-		fifo[7] <= #1 0;
-		fifo[8] <= #1 0;
-		fifo[9] <= #1 0;
-		fifo[10] <= #1 0;
-		fifo[11] <= #1 0;
-		fifo[12] <= #1 0;
-		fifo[13] <= #1 0;
-		fifo[14] <= #1 0;
-		fifo[15] <= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-        fifo[bottom] <= #1 0;
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-				fifo[top] <= #1 data_in[2:0];
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & ~pop & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-
-// please note though that data_out is only valid one clock after pop signal
-assign data_out = {data8_out,fifo[bottom]};
-
-// Additional logic for detection of error conditions (parity and framing) inside the FIFO
-// for the Line Status Register bit 7
-
-wire	[2:0]	word0 = fifo[0];
-wire	[2:0]	word1 = fifo[1];
-wire	[2:0]	word2 = fifo[2];
-wire	[2:0]	word3 = fifo[3];
-wire	[2:0]	word4 = fifo[4];
-wire	[2:0]	word5 = fifo[5];
-wire	[2:0]	word6 = fifo[6];
-wire	[2:0]	word7 = fifo[7];
-
-wire	[2:0]	word8 = fifo[8];
-wire	[2:0]	word9 = fifo[9];
-wire	[2:0]	word10 = fifo[10];
-wire	[2:0]	word11 = fifo[11];
-wire	[2:0]	word12 = fifo[12];
-wire	[2:0]	word13 = fifo[13];
-wire	[2:0]	word14 = fifo[14];
-wire	[2:0]	word15 = fifo[15];
-
-// a 1 is returned if any of the error bits in the fifo is 1
-assign	error_bit = |(word0[2:0]  | word1[2:0]  | word2[2:0]  | word3[2:0]  |
-            		      word4[2:0]  | word5[2:0]  | word6[2:0]  | word7[2:0]  |
-            		      word8[2:0]  | word9[2:0]  | word10[2:0] | word11[2:0] |
-            		      word12[2:0] | word13[2:0] | word14[2:0] | word15[2:0] );
-
-endmodule
diff --git a/source/v/uart_sync_flops.r106.v b/source/v/uart_sync_flops.r106.v
deleted file mode 100755
index 1e569be47f194fe286cf529019d9a7474c02b19e..0000000000000000000000000000000000000000
--- a/source/v/uart_sync_flops.r106.v
+++ /dev/null
@@ -1,122 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_sync_flops.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - Andrej Erzen (andreje@flextronics.si)                 ////
-////      - Tadej Markovic (tadejm@flextronics.si)                ////
-////                                                              ////
-////  Created:        2004/05/20                                  ////
-////  Last Updated:   2004/05/20                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-//
-
-
-`include "timescale.v"
-
-
-module uart_sync_flops
-(
-  // internal signals
-  rst_i,
-  clk_i,
-  stage1_rst_i,
-  stage1_clk_en_i,
-  async_dat_i,
-  sync_dat_o
-);
-
-parameter Tp            = 1;
-parameter width         = 1;
-parameter init_value    = 1'b0;
-
-input                           rst_i;                  // reset input
-input                           clk_i;                  // clock input
-input                           stage1_rst_i;           // synchronous reset for stage 1 FF
-input                           stage1_clk_en_i;        // synchronous clock enable for stage 1 FF
-input   [width-1:0]             async_dat_i;            // asynchronous data input
-output  [width-1:0]             sync_dat_o;             // synchronous data output
-
-
-//
-// Interal signal declarations
-//
-
-reg     [width-1:0]             sync_dat_o;
-reg     [width-1:0]             flop_0;
-
-
-// first stage
-always @ (posedge clk_i or posedge rst_i)
-begin
-    if (rst_i)
-        flop_0 <= #Tp {width{init_value}};
-    else
-        flop_0 <= #Tp async_dat_i;    
-end
-
-// second stage
-always @ (posedge clk_i or posedge rst_i)
-begin
-    if (rst_i)
-        sync_dat_o <= #Tp {width{init_value}};
-    else if (stage1_rst_i)
-        sync_dat_o <= #Tp {width{init_value}};
-    else if (stage1_clk_en_i)
-        sync_dat_o <= #Tp flop_0;       
-end
-
-endmodule
diff --git a/source/v/uart_sync_flops.r98.v b/source/v/uart_sync_flops.r98.v
deleted file mode 100755
index 1e569be47f194fe286cf529019d9a7474c02b19e..0000000000000000000000000000000000000000
--- a/source/v/uart_sync_flops.r98.v
+++ /dev/null
@@ -1,122 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_sync_flops.v                                             ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core receiver logic                                    ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - Andrej Erzen (andreje@flextronics.si)                 ////
-////      - Tadej Markovic (tadejm@flextronics.si)                ////
-////                                                              ////
-////  Created:        2004/05/20                                  ////
-////  Last Updated:   2004/05/20                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-//
-
-
-`include "timescale.v"
-
-
-module uart_sync_flops
-(
-  // internal signals
-  rst_i,
-  clk_i,
-  stage1_rst_i,
-  stage1_clk_en_i,
-  async_dat_i,
-  sync_dat_o
-);
-
-parameter Tp            = 1;
-parameter width         = 1;
-parameter init_value    = 1'b0;
-
-input                           rst_i;                  // reset input
-input                           clk_i;                  // clock input
-input                           stage1_rst_i;           // synchronous reset for stage 1 FF
-input                           stage1_clk_en_i;        // synchronous clock enable for stage 1 FF
-input   [width-1:0]             async_dat_i;            // asynchronous data input
-output  [width-1:0]             sync_dat_o;             // synchronous data output
-
-
-//
-// Interal signal declarations
-//
-
-reg     [width-1:0]             sync_dat_o;
-reg     [width-1:0]             flop_0;
-
-
-// first stage
-always @ (posedge clk_i or posedge rst_i)
-begin
-    if (rst_i)
-        flop_0 <= #Tp {width{init_value}};
-    else
-        flop_0 <= #Tp async_dat_i;    
-end
-
-// second stage
-always @ (posedge clk_i or posedge rst_i)
-begin
-    if (rst_i)
-        sync_dat_o <= #Tp {width{init_value}};
-    else if (stage1_rst_i)
-        sync_dat_o <= #Tp {width{init_value}};
-    else if (stage1_clk_en_i)
-        sync_dat_o <= #Tp flop_0;       
-end
-
-endmodule
diff --git a/source/v/uart_tfifo.r106.v b/source/v/uart_tfifo.r106.v
deleted file mode 100755
index 222d7f9488d7dc309dfae15fd51862043dac7a7b..0000000000000000000000000000000000000000
--- a/source/v/uart_tfifo.r106.v
+++ /dev/null
@@ -1,243 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_tfifo.v                                                ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter FIFO                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.1  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_tfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-
-wire	[fifo_width-1:0]	data_out;
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,fifo_width,fifo_depth) tfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in), 
-			.dpo(data_out)
-		); 
-
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-endmodule
diff --git a/source/v/uart_tfifo.r79.v b/source/v/uart_tfifo.r79.v
deleted file mode 100755
index 913062a81a3cc7351d8233430d3cf51a2cde806e..0000000000000000000000000000000000000000
--- a/source/v/uart_tfifo.r79.v
+++ /dev/null
@@ -1,227 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_tfifo.v                                                ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter FIFO                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-//`include "uart_defines.v"
-
-module uart_tfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-
-wire	[fifo_width-1:0]	data_out;
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,fifo_width,fifo_depth) tfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in), 
-			.dpo(data_out)
-		); 
-
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-endmodule
diff --git a/source/v/uart_tfifo.r84.v b/source/v/uart_tfifo.r84.v
deleted file mode 100755
index 222d7f9488d7dc309dfae15fd51862043dac7a7b..0000000000000000000000000000000000000000
--- a/source/v/uart_tfifo.r84.v
+++ /dev/null
@@ -1,243 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_tfifo.v                                                ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter FIFO                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2002/07/22                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.1  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2001/12/20 13:25:46  mohor
-// rx push changed to be only one cycle wide.
-//
-// Revision 1.15  2001/12/18 09:01:07  mohor
-// Bug that was entered in the last update fixed (rx state machine).
-//
-// Revision 1.14  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.13  2001/11/26 21:38:54  gorban
-// Lots of fixes:
-// Break condition wasn't handled correctly at all.
-// LSR bits could lose their values.
-// LSR value after reset was wrong.
-// Timing of THRE interrupt signal corrected.
-// LSR bit 0 timing corrected.
-//
-// Revision 1.12  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.11  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/24 08:48:10  mohor
-// FIFO was not cleared after the data was read bug fixed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.3  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:48  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_tfifo (clk, 
-	wb_rst_i, data_in, data_out,
-// Control signals
-	push, // push strobe, active high
-	pop,   // pop strobe, active high
-// status signals
-	overrun,
-	count,
-	fifo_reset,
-	reset_status
-	);
-
-
-// FIFO parameters
-parameter fifo_width = `UART_FIFO_WIDTH;
-parameter fifo_depth = `UART_FIFO_DEPTH;
-parameter fifo_pointer_w = `UART_FIFO_POINTER_W;
-parameter fifo_counter_w = `UART_FIFO_COUNTER_W;
-
-input				clk;
-input				wb_rst_i;
-input				push;
-input				pop;
-input	[fifo_width-1:0]	data_in;
-input				fifo_reset;
-input       reset_status;
-
-output	[fifo_width-1:0]	data_out;
-output				overrun;
-output	[fifo_counter_w-1:0]	count;
-
-wire	[fifo_width-1:0]	data_out;
-
-// FIFO pointers
-reg	[fifo_pointer_w-1:0]	top;
-reg	[fifo_pointer_w-1:0]	bottom;
-
-reg	[fifo_counter_w-1:0]	count;
-reg				overrun;
-wire [fifo_pointer_w-1:0] top_plus_1 = top + 1'b1;
-
-raminfr #(fifo_pointer_w,fifo_width,fifo_depth) tfifo  
-        (.clk(clk), 
-			.we(push), 
-			.a(top), 
-			.dpra(bottom), 
-			.di(data_in), 
-			.dpo(data_out)
-		); 
-
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-	if (wb_rst_i)
-	begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-	else
-	if (fifo_reset) begin
-		top		<= #1 0;
-		bottom		<= #1 1'b0;
-		count		<= #1 0;
-	end
-  else
-	begin
-		case ({push, pop})
-		2'b10 : if (count<fifo_depth)  // overrun condition
-			begin
-				top       <= #1 top_plus_1;
-				count     <= #1 count + 1'b1;
-			end
-		2'b01 : if(count>0)
-			begin
-				bottom   <= #1 bottom + 1'b1;
-				count	 <= #1 count - 1'b1;
-			end
-		2'b11 : begin
-				bottom   <= #1 bottom + 1'b1;
-				top       <= #1 top_plus_1;
-		        end
-    default: ;
-		endcase
-	end
-end   // always
-
-always @(posedge clk or posedge wb_rst_i) // synchronous FIFO
-begin
-  if (wb_rst_i)
-    overrun   <= #1 1'b0;
-  else
-  if(fifo_reset | reset_status) 
-    overrun   <= #1 1'b0;
-  else
-  if(push & (count==fifo_depth))
-    overrun   <= #1 1'b1;
-end   // always
-
-endmodule
diff --git a/source/v/uart_top.r106.v b/source/v/uart_top.r106.v
deleted file mode 100755
index 3f5f3868c74f6868a40b52a18e85028099c700c1..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r106.v
+++ /dev/null
@@ -1,340 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.18  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.17  2001/12/19 08:40:03  mohor
-// Warnings fixed (unused signals removed).
-//
-// Revision 1.16  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.15  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.14  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-	);
-
-parameter 							 uart_data_width = `UART_DATA_WIDTH;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-input [3:0]							 wb_sel_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-// optional baudrate output
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
-wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
-wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
-wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
-wire [uart_addr_width-1:0] 	 wb_adr_int;
-wire 									 we_o;	// Write enable for registers
-wire		          	     re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface wires
-wire	[3:0] ier;
-wire	[3:0] iir;
-wire	[1:0] fcr;
-wire	[4:0] mcr;
-wire	[7:0] lcr;
-wire	[7:0] msr;
-wire	[7:0] lsr;
-wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
-wire	[2:0] tstate;
-wire	[3:0] rstate; 
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_dat32_o(32'b0),								 
-	 .wb_sel_i(4'b0),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`else
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_sel_i(wb_sel_i),
-	 .wb_dat32_o(wb_dat32_o),								 
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`endif
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_int	),
-	.wb_dat_i(	wb_dat8_i	),
-	.wb_dat_o(	wb_dat8_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-//`ifdef DATA_BUS_WIDTH_8
-//`else
-// debug interface signals	enabled
-.ier(ier), 
-.iir(iir), 
-.fcr(fcr), 
-.mcr(mcr), 
-.lcr(lcr), 
-.msr(msr), 
-.lsr(lsr), 
-.rf_count(rf_count),
-.tf_count(tf_count),
-.tstate(tstate),
-.rstate(rstate),
-//`endif					  
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, .baud_o(baud_o)
-`endif
-
-);
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-uart_debug_if dbg(/*AUTOINST*/
-						// Outputs
-						.wb_dat32_o				 (wb_dat32_o[31:0]),
-						// Inputs
-						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
-						.ier						 (ier[3:0]),
-						.iir						 (iir[3:0]),
-						.fcr						 (fcr[1:0]),
-						.mcr						 (mcr[4:0]),
-						.lcr						 (lcr[7:0]),
-						.msr						 (msr[7:0]),
-						.lsr						 (lsr[7:0]),
-						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tstate					 (tstate[2:0]),
-						.rstate					 (rstate[3:0]));
-`endif 
-
-// initial
-begin
-//	`ifdef DATA_BUS_WIDTH_8
-		$display("(%m) UART INFO: Data bus width is 8. No Debug interface.\n");
-//	`else
-		$display("(%m) UART INFO: Data bus width is 32. Debug Interface present.\n");
-//	`endif
-//	`ifdef UART_HAS_BAUDRATE_OUTPUT
-		$display("(%m) UART INFO: Has baudrate output\n");
-//	`else
-		$display("(%m) UART INFO: Doesn't have baudrate output\n");
-//	`endif
-end
-
-endmodule
-
-
diff --git a/source/v/uart_top.r27.v b/source/v/uart_top.r27.v
deleted file mode 100755
index 80fa0d63afbbc74435563daa3d34984c7741bad9..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r27.v
+++ /dev/null
@@ -1,170 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_top	(
-	clk, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = 8;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 clk;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_addr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_addr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire 									 we_o;	// Write enable for registers
-wire		               re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		clk		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-
-// Registers
-uart_regs	regs(
-		.clk(		clk		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_addr_i(	wb_addr_i	),
-		.wb_dat_i(	wb_dat_i	),
-		.wb_dat_o(	wb_dat_o	),
-		.wb_we_i(	we_o		),
-    .wb_re_i(re_o),
-		.modem_inputs(	{cts_pad_i, dsr_pad_i,
-				 ri_pad_i,  dcd_pad_i}	),
-		.stx_pad_o(		stx_pad_o		),
-		.srx_pad_i(		srx_pad_i		),
-		.enable(	enable		),
-		.rts_pad_o(		rts_pad_o		),
-		.dtr_pad_o(		dtr_pad_o		),
-		.int_o(		int_o		)
-		);
-
-endmodule
diff --git a/source/v/uart_top.r29.v b/source/v/uart_top.r29.v
deleted file mode 100755
index e33bd0c6eaf081e70da92174367b7de0a021591d..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r29.v
+++ /dev/null
@@ -1,178 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_top	(
-	clk, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_addr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = 8;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 clk;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_addr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_addr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire 									 we_o;	// Write enable for registers
-wire		               re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		clk		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-
-// Registers
-uart_regs	regs(
-		.clk(		clk		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_addr_i(	wb_addr_i	),
-		.wb_dat_i(	wb_dat_i	),
-		.wb_dat_o(	wb_dat_o	),
-		.wb_we_i(	we_o		),
-    .wb_re_i(re_o),
-		.modem_inputs(	{cts_pad_i, dsr_pad_i,
-				 ri_pad_i,  dcd_pad_i}	),
-		.stx_pad_o(		stx_pad_o		),
-		.srx_pad_i(		srx_pad_i		),
-		.rts_pad_o(		rts_pad_o		),
-		.dtr_pad_o(		dtr_pad_o		),
-		.int_o(		int_o		)
-		);
-
-endmodule
diff --git a/source/v/uart_top.r30.v b/source/v/uart_top.r30.v
deleted file mode 100755
index 71a95975a42f1427650766b2f7a458c493e78c43..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r30.v
+++ /dev/null
@@ -1,182 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = 8;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire 									 we_o;	// Write enable for registers
-wire		               re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-
-// Registers
-uart_regs	regs(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_addr_i(	wb_adr_i	),
-		.wb_dat_i(	wb_dat_i	),
-		.wb_dat_o(	wb_dat_o	),
-		.wb_we_i(	we_o		),
-    .wb_re_i(re_o),
-		.modem_inputs(	{cts_pad_i, dsr_pad_i,
-				 ri_pad_i,  dcd_pad_i}	),
-		.stx_pad_o(		stx_pad_o		),
-		.srx_pad_i(		srx_pad_i		),
-		.rts_pad_o(		rts_pad_o		),
-		.dtr_pad_o(		dtr_pad_o		),
-		.int_o(		int_o		)
-		);
-
-endmodule
diff --git a/source/v/uart_top.r33.v b/source/v/uart_top.r33.v
deleted file mode 100755
index 582febb93917b29c97f27bd5152645197faa759d..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r33.v
+++ /dev/null
@@ -1,187 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = 8;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire 									 we_o;	// Write enable for registers
-wire		               re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-
-// Registers
-uart_regs	regs(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_addr_i(	wb_adr_i	),
-		.wb_dat_i(	wb_dat_i	),
-		.wb_dat_o(	wb_dat_o	),
-		.wb_we_i(	we_o		),
-    .wb_re_i(re_o),
-		.modem_inputs(	{cts_pad_i, dsr_pad_i,
-				 ri_pad_i,  dcd_pad_i}	),
-		.stx_pad_o(		stx_pad_o		),
-		.srx_pad_i(		srx_pad_i		),
-		.rts_pad_o(		rts_pad_o		),
-		.dtr_pad_o(		dtr_pad_o		),
-		.int_o(		int_o		)
-		);
-
-endmodule
diff --git a/source/v/uart_top.r37.v b/source/v/uart_top.r37.v
deleted file mode 100755
index a3f712351d6812c186eaa3cc246fd8527b2ce235..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r37.v
+++ /dev/null
@@ -1,190 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,	
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = 8;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire 									 we_o;	// Write enable for registers
-wire		               re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_i	),
-	.wb_dat_i(	wb_dat_i	),
-	.wb_dat_o(	wb_dat_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-);
-
-endmodule
diff --git a/source/v/uart_top.r48.v b/source/v/uart_top.r48.v
deleted file mode 100755
index 3d0ba75c65ffba1dd17f6e0e180b915406cc55b4..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r48.v
+++ /dev/null
@@ -1,280 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.14  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = `UART_DATA_WIDTH;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-input [3:0]							 wb_sel_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
-wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
-wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
-wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
-wire 									 we_o;	// Write enable for registers
-wire		          	     re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface wires
-wire	[3:0] ier;
-wire	[3:0] iir;
-wire	[1:0] fcr;
-wire	[4:0] mcr;
-wire	[7:0] lcr;
-wire	[7:0] msr;
-wire	[7:0] lsr;
-wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
-wire	[2:0] tstate;
-wire	[3:0] rstate; 
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_dat32_o(32'b0),								 
-	 .wb_sel_i(4'b0),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`else // !`ifdef DATA_BUS_WIDTH_8
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_sel_i(wb_sel_i),
-	 .wb_dat32_o(wb_dat32_o),								 
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_i	),
-	.wb_dat_i(	wb_dat8_i	),
-	.wb_dat_o(	wb_dat8_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-.ier(ier), 
-.iir(iir), 
-.fcr(fcr), 
-.mcr(mcr), 
-.lcr(lcr), 
-.msr(msr), 
-.lsr(lsr), 
-.rf_count(rf_count),
-.tf_count(tf_count),
-.tstate(tstate),
-.rstate(rstate),
-`endif					  
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-);
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-uart_debug_if dbg(/*AUTOINST*/
-						// Outputs
-						.wb_dat32_o				 (wb_dat32_o[31:0]),
-						// Inputs
-						.wb_clk_i				 (wb_clk_i),
-						.wb_rst_i				 (wb_rst_i),
-						.wb_adr_i				 (wb_adr_i[`UART_ADDR_WIDTH-1:0]),
-						.re_o						 (re_o),
-						.ier						 (ier[3:0]),
-						.iir						 (iir[3:0]),
-						.fcr						 (fcr[1:0]),
-						.mcr						 (mcr[4:0]),
-						.lcr						 (lcr[7:0]),
-						.msr						 (msr[7:0]),
-						.lsr						 (lsr[7:0]),
-						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tstate					 (tstate[2:0]),
-						.rstate					 (rstate[3:0]));
-`endif //  `ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
diff --git a/source/v/uart_top.r50.v b/source/v/uart_top.r50.v
deleted file mode 100755
index 6cc422748b0dc7545253402593df0aba73e45edf..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r50.v
+++ /dev/null
@@ -1,294 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.15  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.14  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = `UART_DATA_WIDTH;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-input [3:0]							 wb_sel_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
-wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
-wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
-wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
-wire [uart_addr_width-1:0] 	 wb_adr_int;
-wire 									 we_o;	// Write enable for registers
-wire		          	     re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface wires
-wire	[3:0] ier;
-wire	[3:0] iir;
-wire	[1:0] fcr;
-wire	[4:0] mcr;
-wire	[7:0] lcr;
-wire	[7:0] msr;
-wire	[7:0] lsr;
-wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
-wire	[2:0] tstate;
-wire	[3:0] rstate; 
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_dat32_o(32'b0),								 
-	 .wb_sel_i(4'b0),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`else // !`ifdef DATA_BUS_WIDTH_8
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_sel_i(wb_sel_i),
-	 .wb_dat32_o(wb_dat32_o),								 
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_int	),
-	.wb_dat_i(	wb_dat8_i	),
-	.wb_dat_o(	wb_dat8_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-.ier(ier), 
-.iir(iir), 
-.fcr(fcr), 
-.mcr(mcr), 
-.lcr(lcr), 
-.msr(msr), 
-.lsr(lsr), 
-.rf_count(rf_count),
-.tf_count(tf_count),
-.tstate(tstate),
-.rstate(rstate),
-`endif					  
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-);
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-uart_debug_if dbg(/*AUTOINST*/
-						// Outputs
-						.wb_dat32_o				 (wb_dat32_o[31:0]),
-						// Inputs
-						.wb_clk_i				 (wb_clk_i),
-						.wb_rst_i				 (wb_rst_i),
-						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
-						.re_o						 (re_o),
-						.ier						 (ier[3:0]),
-						.iir						 (iir[3:0]),
-						.fcr						 (fcr[1:0]),
-						.mcr						 (mcr[4:0]),
-						.lcr						 (lcr[7:0]),
-						.msr						 (msr[7:0]),
-						.lsr						 (lsr[7:0]),
-						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tstate					 (tstate[2:0]),
-						.rstate					 (rstate[3:0]));
-`endif //  `ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
diff --git a/source/v/uart_top.r65.v b/source/v/uart_top.r65.v
deleted file mode 100755
index eed32acf66df4b5ca5810e94fd80c6e21f04d854..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r65.v
+++ /dev/null
@@ -1,295 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.15  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.14  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-
-	);
-
-parameter 							 uart_data_width = `UART_DATA_WIDTH;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-input [3:0]							 wb_sel_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
-wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
-wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
-wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
-wire [uart_addr_width-1:0] 	 wb_adr_int;
-wire 									 we_o;	// Write enable for registers
-wire		          	     re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface wires
-wire	[3:0] ier;
-wire	[3:0] iir;
-wire	[1:0] fcr;
-wire	[4:0] mcr;
-wire	[7:0] lcr;
-wire	[7:0] msr;
-wire	[7:0] lsr;
-wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
-wire	[2:0] tstate;
-wire	[3:0] rstate; 
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_dat32_o(32'b0),								 
-	 .wb_sel_i(4'b0),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`else // !`ifdef DATA_BUS_WIDTH_8
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_sel_i(wb_sel_i),
-	 .wb_dat32_o(wb_dat32_o),								 
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_int	),
-	.wb_dat_i(	wb_dat8_i	),
-	.wb_dat_o(	wb_dat8_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-.ier(ier), 
-.iir(iir), 
-.fcr(fcr), 
-.mcr(mcr), 
-.lcr(lcr), 
-.msr(msr), 
-.lsr(lsr), 
-.rf_count(rf_count),
-.tf_count(tf_count),
-.tstate(tstate),
-.rstate(rstate),
-`endif					  
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-);
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-uart_debug_if dbg(/*AUTOINST*/
-						// Outputs
-						.wb_dat32_o				 (wb_dat32_o[31:0]),
-						// Inputs
-						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
-						.ier						 (ier[3:0]),
-						.iir						 (iir[3:0]),
-						.fcr						 (fcr[1:0]),
-						.mcr						 (mcr[4:0]),
-						.lcr						 (lcr[7:0]),
-						.msr						 (msr[7:0]),
-						.lsr						 (lsr[7:0]),
-						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tstate					 (tstate[2:0]),
-						.rstate					 (rstate[3:0]));
-`endif //  `ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
diff --git a/source/v/uart_top.r79.v b/source/v/uart_top.r79.v
deleted file mode 100755
index 03995bc2e71649dbdf6163ce919e317b69c08c76..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r79.v
+++ /dev/null
@@ -1,324 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.17  2001/12/19 08:40:03  mohor
-// Warnings fixed (unused signals removed).
-//
-// Revision 1.16  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.15  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.14  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-// `include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-	);
-
-parameter 							 uart_data_width = `UART_DATA_WIDTH;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-input [3:0]							 wb_sel_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-// optional baudrate output
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
-wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
-wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
-wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
-wire [uart_addr_width-1:0] 	 wb_adr_int;
-wire 									 we_o;	// Write enable for registers
-wire		          	     re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface wires
-wire	[3:0] ier;
-wire	[3:0] iir;
-wire	[1:0] fcr;
-wire	[4:0] mcr;
-wire	[7:0] lcr;
-wire	[7:0] msr;
-wire	[7:0] lsr;
-wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
-wire	[2:0] tstate;
-wire	[3:0] rstate; 
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_dat32_o(32'b0),								 
-	 .wb_sel_i(4'b0),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`else
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_sel_i(wb_sel_i),
-	 .wb_dat32_o(wb_dat32_o),								 
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`endif
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_int	),
-	.wb_dat_i(	wb_dat8_i	),
-	.wb_dat_o(	wb_dat8_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-.ier(ier), 
-.iir(iir), 
-.fcr(fcr), 
-.mcr(mcr), 
-.lcr(lcr), 
-.msr(msr), 
-.lsr(lsr), 
-.rf_count(rf_count),
-.tf_count(tf_count),
-.tstate(tstate),
-.rstate(rstate),
-`endif					  
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, .baud_o(baud_o)
-`endif
-
-);
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-uart_debug_if dbg(/*AUTOINST*/
-						// Outputs
-						.wb_dat32_o				 (wb_dat32_o[31:0]),
-						// Inputs
-						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
-						.ier						 (ier[3:0]),
-						.iir						 (iir[3:0]),
-						.fcr						 (fcr[1:0]),
-						.mcr						 (mcr[4:0]),
-						.lcr						 (lcr[7:0]),
-						.msr						 (msr[7:0]),
-						.lsr						 (lsr[7:0]),
-						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tstate					 (tstate[2:0]),
-						.rstate					 (rstate[3:0]));
-`endif 
-
-initial
-begin
-	`ifdef DATA_BUS_WIDTH_8
-		$display("(%m) UART INFO: Data bus width is 8. No Debug interface.\n");
-	`else
-		$display("(%m) UART INFO: Data bus width is 32. Debug Interface present.\n");
-	`endif
-	`ifdef UART_HAS_BAUDRATE_OUTPUT
-		$display("(%m) UART INFO: Has baudrate output\n");
-	`else
-		$display("(%m) UART INFO: Doesn't have baudrate output\n");
-	`endif
-end
-
-endmodule
-
-
diff --git a/source/v/uart_top.r84.v b/source/v/uart_top.r84.v
deleted file mode 100755
index d3e3e71dd428448fa4fd2bee30ca88c07f17fe16..0000000000000000000000000000000000000000
--- a/source/v/uart_top.r84.v
+++ /dev/null
@@ -1,340 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_top.v                                                  ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core top level.                                        ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Note that transmitter and receiver instances are inside     ////
-////  the uart_regs.v file.                                       ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing so far.                                             ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.18  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.17  2001/12/19 08:40:03  mohor
-// Warnings fixed (unused signals removed).
-//
-// Revision 1.16  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.15  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.14  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.13  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.12  2001/08/25 15:46:19  gorban
-// Modified port names again
-//
-// Revision 1.11  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.10  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_top	(
-	wb_clk_i, 
-	
-	// Wishbone signals
-	wb_rst_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_sel_i,
-	int_o, // interrupt request
-
-	// UART	signals
-	// serial input/output
-	stx_pad_o, srx_pad_i,
-
-	// modem signals
-	rts_pad_o, cts_pad_i, dtr_pad_o, dsr_pad_i, ri_pad_i, dcd_pad_i
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, baud_o
-`endif
-	);
-
-parameter 							 uart_data_width = `UART_DATA_WIDTH;
-parameter 							 uart_addr_width = `UART_ADDR_WIDTH;
-
-input 								 wb_clk_i;
-
-// WISHBONE interface
-input 								 wb_rst_i;
-input [uart_addr_width-1:0] 	 wb_adr_i;
-input [uart_data_width-1:0] 	 wb_dat_i;
-output [uart_data_width-1:0] 	 wb_dat_o;
-input 								 wb_we_i;
-input 								 wb_stb_i;
-input 								 wb_cyc_i;
-input [3:0]							 wb_sel_i;
-output 								 wb_ack_o;
-output 								 int_o;
-
-// UART	signals
-input 								 srx_pad_i;
-output 								 stx_pad_o;
-output 								 rts_pad_o;
-input 								 cts_pad_i;
-output 								 dtr_pad_o;
-input 								 dsr_pad_i;
-input 								 ri_pad_i;
-input 								 dcd_pad_i;
-
-// optional baudrate output
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-output	baud_o;
-`endif
-
-
-wire 									 stx_pad_o;
-wire 									 rts_pad_o;
-wire 									 dtr_pad_o;
-
-wire [uart_addr_width-1:0] 	 wb_adr_i;
-wire [uart_data_width-1:0] 	 wb_dat_i;
-wire [uart_data_width-1:0] 	 wb_dat_o;
-
-wire [7:0] 							 wb_dat8_i; // 8-bit internal data input
-wire [7:0] 							 wb_dat8_o; // 8-bit internal data output
-wire [31:0] 						 wb_dat32_o; // debug interface 32-bit output
-wire [3:0] 							 wb_sel_i;  // WISHBONE select signal
-wire [uart_addr_width-1:0] 	 wb_adr_int;
-wire 									 we_o;	// Write enable for registers
-wire		          	     re_o;	// Read enable for registers
-//
-// MODULE INSTANCES
-//
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface wires
-wire	[3:0] ier;
-wire	[3:0] iir;
-wire	[1:0] fcr;
-wire	[4:0] mcr;
-wire	[7:0] lcr;
-wire	[7:0] msr;
-wire	[7:0] lsr;
-wire	[`UART_FIFO_COUNTER_W-1:0] rf_count;
-wire	[`UART_FIFO_COUNTER_W-1:0] tf_count;
-wire	[2:0] tstate;
-wire	[3:0] rstate; 
-`endif
-
-`ifdef DATA_BUS_WIDTH_8
-////  WISHBONE interface module
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_dat32_o(32'b0),								 
-	 .wb_sel_i(4'b0),
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`else
-uart_wb		wb_interface(
-		.clk(		wb_clk_i		),
-		.wb_rst_i(	wb_rst_i	),
-	.wb_dat_i(wb_dat_i),
-	.wb_dat_o(wb_dat_o),
-	.wb_dat8_i(wb_dat8_i),
-	.wb_dat8_o(wb_dat8_o),
-	 .wb_sel_i(wb_sel_i),
-	 .wb_dat32_o(wb_dat32_o),								 
-		.wb_we_i(	wb_we_i		),
-		.wb_stb_i(	wb_stb_i	),
-		.wb_cyc_i(	wb_cyc_i	),
-		.wb_ack_o(	wb_ack_o	),
-	.wb_adr_i(wb_adr_i),
-	.wb_adr_int(wb_adr_int),
-		.we_o(		we_o		),
-		.re_o(re_o)
-		);
-`endif
-
-// Registers
-uart_regs	regs(
-	.clk(		wb_clk_i		),
-	.wb_rst_i(	wb_rst_i	),
-	.wb_addr_i(	wb_adr_int	),
-	.wb_dat_i(	wb_dat8_i	),
-	.wb_dat_o(	wb_dat8_o	),
-	.wb_we_i(	we_o		),
-   .wb_re_i(re_o),
-	.modem_inputs(	{cts_pad_i, dsr_pad_i,
-	ri_pad_i,  dcd_pad_i}	),
-	.stx_pad_o(		stx_pad_o		),
-	.srx_pad_i(		srx_pad_i		),
-`ifdef DATA_BUS_WIDTH_8
-`else
-// debug interface signals	enabled
-.ier(ier), 
-.iir(iir), 
-.fcr(fcr), 
-.mcr(mcr), 
-.lcr(lcr), 
-.msr(msr), 
-.lsr(lsr), 
-.rf_count(rf_count),
-.tf_count(tf_count),
-.tstate(tstate),
-.rstate(rstate),
-`endif					  
-	.rts_pad_o(		rts_pad_o		),
-	.dtr_pad_o(		dtr_pad_o		),
-	.int_o(		int_o		)
-`ifdef UART_HAS_BAUDRATE_OUTPUT
-	, .baud_o(baud_o)
-`endif
-
-);
-
-`ifdef DATA_BUS_WIDTH_8
-`else
-uart_debug_if dbg(/*AUTOINST*/
-						// Outputs
-						.wb_dat32_o				 (wb_dat32_o[31:0]),
-						// Inputs
-						.wb_adr_i				 (wb_adr_int[`UART_ADDR_WIDTH-1:0]),
-						.ier						 (ier[3:0]),
-						.iir						 (iir[3:0]),
-						.fcr						 (fcr[1:0]),
-						.mcr						 (mcr[4:0]),
-						.lcr						 (lcr[7:0]),
-						.msr						 (msr[7:0]),
-						.lsr						 (lsr[7:0]),
-						.rf_count				 (rf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tf_count				 (tf_count[`UART_FIFO_COUNTER_W-1:0]),
-						.tstate					 (tstate[2:0]),
-						.rstate					 (rstate[3:0]));
-`endif 
-
-initial
-begin
-	`ifdef DATA_BUS_WIDTH_8
-		$display("(%m) UART INFO: Data bus width is 8. No Debug interface.\n");
-	`else
-		$display("(%m) UART INFO: Data bus width is 32. Debug Interface present.\n");
-	`endif
-	`ifdef UART_HAS_BAUDRATE_OUTPUT
-		$display("(%m) UART INFO: Has baudrate output\n");
-	`else
-		$display("(%m) UART INFO: Doesn't have baudrate output\n");
-	`endif
-end
-
-endmodule
-
-
diff --git a/source/v/uart_transmitter.r106.v b/source/v/uart_transmitter.r106.v
deleted file mode 100755
index b3c643d41870ff2545416d4846ea9afe0656efde..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r106.v
+++ /dev/null
@@ -1,351 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.18  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2002/01/08 11:29:40  mohor
-// tf_pop was too wide. Now it is only 1 clk cycle width.
-//
-// Revision 1.15  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.14  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_tfifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-  else
-    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r27.v b/source/v/uart_transmitter.r27.v
deleted file mode 100755
index c47b69347e9efcae23e1412e5018c323ed09083c..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r27.v
+++ /dev/null
@@ -1,288 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				tf_push;
-input	[7:0]			wb_dat_i;
-input				enable;
-input				tx_reset;
-output				stx_pad_o;
-output	[2:0]			state;
-output	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-
-reg	[2:0]	state;
-reg	[4:0]	counter;
-reg	[2:0]	bit_counter;   // counts the bits to be sent
-reg	[6:0]	shift_out;	// output shift register
-reg		stx_o_tmp;
-reg		parity_xor;  // parity of the word
-reg		tf_pop;
-reg		bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire	[`UART_FIFO_WIDTH-1:0]	tf_data_in;
-wire	[`UART_FIFO_WIDTH-1:0]	tf_data_out;
-wire				tf_push;
-wire				tf_underrun;
-wire				tf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-
-assign tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(1'b0)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	state       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (state)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				state <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				state  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				state <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						state <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						state <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 ~parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						state <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					state <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			state <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r29.v b/source/v/uart_transmitter.r29.v
deleted file mode 100755
index 7492fef4041628c951146714285d75f0c57d5196..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r29.v
+++ /dev/null
@@ -1,297 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-`include "timescale.v"
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				tf_push;
-input	[7:0]			wb_dat_i;
-input				enable;
-input				tx_reset;
-output				stx_pad_o;
-output	[2:0]			state;
-output	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-
-reg	[2:0]	state;
-reg	[4:0]	counter;
-reg	[2:0]	bit_counter;   // counts the bits to be sent
-reg	[6:0]	shift_out;	// output shift register
-reg		stx_o_tmp;
-reg		parity_xor;  // parity of the word
-reg		tf_pop;
-reg		bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire	[`UART_FIFO_WIDTH-1:0]	tf_data_in;
-wire	[`UART_FIFO_WIDTH-1:0]	tf_data_out;
-wire				tf_push;
-wire				tf_underrun;
-wire				tf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-
-assign tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(1'b0)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	state       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (state)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				state <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				state  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				state <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						state <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						state <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 ~parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						state <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					state <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			state <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r33.v b/source/v/uart_transmitter.r33.v
deleted file mode 100755
index 86dbe907980ea750d2857bd206a2e9c11f2170c1..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r33.v
+++ /dev/null
@@ -1,304 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset);
-
-input				clk;
-input				wb_rst_i;
-input	[7:0]			lcr;
-input				tf_push;
-input	[7:0]			wb_dat_i;
-input				enable;
-input				tx_reset;
-output				stx_pad_o;
-output	[2:0]			state;
-output	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-
-reg	[2:0]	state;
-reg	[4:0]	counter;
-reg	[2:0]	bit_counter;   // counts the bits to be sent
-reg	[6:0]	shift_out;	// output shift register
-reg		stx_o_tmp;
-reg		parity_xor;  // parity of the word
-reg		tf_pop;
-reg		bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire	[`UART_FIFO_WIDTH-1:0]	tf_data_in;
-wire	[`UART_FIFO_WIDTH-1:0]	tf_data_out;
-wire				tf_push;
-wire				tf_underrun;
-wire				tf_overrun;
-wire	[`UART_FIFO_COUNTER_W-1:0]	tf_count;
-
-assign tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(1'b0)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	state       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (state)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				state <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				state  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				state <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						state <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						state <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 ~parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						state <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					state <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			state <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r34.v b/source/v/uart_transmitter.r34.v
deleted file mode 100755
index 3a9783ef4d5fc61009fdaffe814c6d32572ad3be..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r34.v
+++ /dev/null
@@ -1,308 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset, rx_lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										rx_lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								state;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									state;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_underrun;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(rx_lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	state       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (state)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				state <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				state  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				state <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						state <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						state <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						state <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					state <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			state <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r37.v b/source/v/uart_transmitter.r37.v
deleted file mode 100755
index fc8664410357e6998f0dd14d8daace86a4cd5130..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r37.v
+++ /dev/null
@@ -1,311 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								state;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									state;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_underrun;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	state       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (state)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				state <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				state  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				state <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						state <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						state <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						state <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					state <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 5'b00001;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			state <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r39.v b/source/v/uart_transmitter.r39.v
deleted file mode 100755
index 528050e45613960b5500977bc57d69931b515c45..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r39.v
+++ /dev/null
@@ -1,315 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, state, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								state;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									state;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_underrun;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	state       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (state)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				state <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				state  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				state <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						state <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						state <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						state <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					state <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						3'b1xx:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					state <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			state <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r48.v b/source/v/uart_transmitter.r48.v
deleted file mode 100755
index df280a8fa98cee86fc31ef9417bbeca5580af8db..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r48.v
+++ /dev/null
@@ -1,319 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_underrun;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.underrun(	tf_underrun	),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r61.v b/source/v/uart_transmitter.r61.v
deleted file mode 100755
index 4e82988cb355c79b5cc5eb313a05d02519c362e8..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r61.v
+++ /dev/null
@@ -1,326 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.14  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r70.v b/source/v/uart_transmitter.r70.v
deleted file mode 100755
index 35d48c9dbb4308d8d7b344207ae1b86a436d6cae..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r70.v
+++ /dev/null
@@ -1,333 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.15  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.14  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-  else
-    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r74.v b/source/v/uart_transmitter.r74.v
deleted file mode 100755
index 6189fda0d07e01044b9e0eb83e0e4f79b370cb46..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r74.v
+++ /dev/null
@@ -1,336 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2002/01/08 11:29:40  mohor
-// tf_pop was too wide. Now it is only 1 clk cycle width.
-//
-// Revision 1.15  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.14  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-//wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_fifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.overrun(	/*tf_overrun*/	),
-	.count(		tf_count	),
-	.error_bit(),                 // Ta ni priklopljen. Prej je manjkal, dodal Igor
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-  else
-    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r79.v b/source/v/uart_transmitter.r79.v
deleted file mode 100755
index 8418a3bad214632c3aeddf96e5da0ceec8254cf0..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r79.v
+++ /dev/null
@@ -1,335 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2002/01/08 11:29:40  mohor
-// tf_pop was too wide. Now it is only 1 clk cycle width.
-//
-// Revision 1.15  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.14  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-//`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_tfifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-  else
-    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_transmitter.r84.v b/source/v/uart_transmitter.r84.v
deleted file mode 100755
index b3c643d41870ff2545416d4846ea9afe0656efde..0000000000000000000000000000000000000000
--- a/source/v/uart_transmitter.r84.v
+++ /dev/null
@@ -1,351 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_transmitter.v                                          ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core transmitter logic                                 ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  None known                                                  ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Thourough testing.                                          ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.18  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.16  2002/01/08 11:29:40  mohor
-// tf_pop was too wide. Now it is only 1 clk cycle width.
-//
-// Revision 1.15  2001/12/17 14:46:48  mohor
-// overrun signal was moved to separate block because many sequential lsr
-// reads were preventing data from being written to rx fifo.
-// underrun signal was not used and was removed from the project.
-//
-// Revision 1.14  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.13  2001/11/08 14:54:23  mohor
-// Comments in Slovene language deleted, few small fixes for better work of
-// old tools. IRQs need to be fix.
-//
-// Revision 1.12  2001/11/07 17:51:52  gorban
-// Heavily rewritten interrupt and LSR subsystems.
-// Many bugs hopefully squashed.
-//
-// Revision 1.11  2001/10/29 17:00:46  gorban
-// fixed parity sending and tx_fifo resets over- and underrun
-//
-// Revision 1.10  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.9  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.8  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.6  2001/06/23 11:21:48  gorban
-// DL made 16-bit long. Fixed transmission/reception bugs.
-//
-// Revision 1.5  2001/06/02 14:28:14  gorban
-// Fixed receiver and transmitter. Major bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/27 17:37:49  gorban
-// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
-//
-// Revision 1.2  2001/05/21 19:12:02  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.1  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:12+02  jacob
-// Initial revision
-//
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-`include "uart_defines.v"
-
-module uart_transmitter (clk, wb_rst_i, lcr, tf_push, wb_dat_i, enable,	stx_pad_o, tstate, tf_count, tx_reset, lsr_mask);
-
-input 										clk;
-input 										wb_rst_i;
-input [7:0] 								lcr;
-input 										tf_push;
-input [7:0] 								wb_dat_i;
-input 										enable;
-input 										tx_reset;
-input 										lsr_mask; //reset of fifo
-output 										stx_pad_o;
-output [2:0] 								tstate;
-output [`UART_FIFO_COUNTER_W-1:0] 	tf_count;
-
-reg [2:0] 									tstate;
-reg [4:0] 									counter;
-reg [2:0] 									bit_counter;   // counts the bits to be sent
-reg [6:0] 									shift_out;	// output shift register
-reg 											stx_o_tmp;
-reg 											parity_xor;  // parity of the word
-reg 											tf_pop;
-reg 											bit_out;
-
-// TX FIFO instance
-//
-// Transmitter FIFO signals
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_in;
-wire [`UART_FIFO_WIDTH-1:0] 			tf_data_out;
-wire 											tf_push;
-wire 											tf_overrun;
-wire [`UART_FIFO_COUNTER_W-1:0] 		tf_count;
-
-assign 										tf_data_in = wb_dat_i;
-
-uart_tfifo fifo_tx(	// error bit signal is not used in transmitter FIFO
-	.clk(		clk		), 
-	.wb_rst_i(	wb_rst_i	),
-	.data_in(	tf_data_in	),
-	.data_out(	tf_data_out	),
-	.push(		tf_push		),
-	.pop(		tf_pop		),
-	.overrun(	tf_overrun	),
-	.count(		tf_count	),
-	.fifo_reset(	tx_reset	),
-	.reset_status(lsr_mask)
-);
-
-// TRANSMITTER FINAL STATE MACHINE
-
-parameter s_idle        = 3'd0;
-parameter s_send_start  = 3'd1;
-parameter s_send_byte   = 3'd2;
-parameter s_send_parity = 3'd3;
-parameter s_send_stop   = 3'd4;
-parameter s_pop_byte    = 3'd5;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-  if (wb_rst_i)
-  begin
-	tstate       <= #1 s_idle;
-	stx_o_tmp       <= #1 1'b1;
-	counter   <= #1 5'b0;
-	shift_out   <= #1 7'b0;
-	bit_out     <= #1 1'b0;
-	parity_xor  <= #1 1'b0;
-	tf_pop      <= #1 1'b0;
-	bit_counter <= #1 3'b0;
-  end
-  else
-  if (enable)
-  begin
-	case (tstate)
-	s_idle	 :	if (~|tf_count) // if tf_count==0
-			begin
-				tstate <= #1 s_idle;
-				stx_o_tmp <= #1 1'b1;
-			end
-			else
-			begin
-				tf_pop <= #1 1'b0;
-				stx_o_tmp  <= #1 1'b1;
-				tstate  <= #1 s_pop_byte;
-			end
-	s_pop_byte :	begin
-				tf_pop <= #1 1'b1;
-				case (lcr[/*`UART_LC_BITS*/1:0])  // number of bits in a word
-				2'b00 : begin
-					bit_counter <= #1 3'b100;
-					parity_xor  <= #1 ^tf_data_out[4:0];
-				     end
-				2'b01 : begin
-					bit_counter <= #1 3'b101;
-					parity_xor  <= #1 ^tf_data_out[5:0];
-				     end
-				2'b10 : begin
-					bit_counter <= #1 3'b110;
-					parity_xor  <= #1 ^tf_data_out[6:0];
-				     end
-				2'b11 : begin
-					bit_counter <= #1 3'b111;
-					parity_xor  <= #1 ^tf_data_out[7:0];
-				     end
-				endcase
-				{shift_out[6:0], bit_out} <= #1 tf_data_out;
-				tstate <= #1 s_send_start;
-			end
-	s_send_start :	begin
-				tf_pop <= #1 1'b0;
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_send_byte;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b0;
-			end
-	s_send_byte :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					if (bit_counter > 3'b0)
-					begin
-						bit_counter <= #1 bit_counter - 1'b1;
-						{shift_out[5:0],bit_out  } <= #1 {shift_out[6:1], shift_out[0]};
-						tstate <= #1 s_send_byte;
-					end
-					else   // end of byte
-					if (~lcr[`UART_LC_PE])
-					begin
-						tstate <= #1 s_send_stop;
-					end
-					else
-					begin
-						case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})
-						2'b00:	bit_out <= #1 ~parity_xor;
-						2'b01:	bit_out <= #1 1'b1;
-						2'b10:	bit_out <= #1 parity_xor;
-						2'b11:	bit_out <= #1 1'b0;
-						endcase
-						tstate <= #1 s_send_parity;
-					end
-					counter <= #1 0;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out; // set output pin
-			end
-	s_send_parity :	begin
-				if (~|counter)
-					counter <= #1 5'b01111;
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 4'b0;
-					tstate <= #1 s_send_stop;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 bit_out;
-			end
-	s_send_stop :  begin
-				if (~|counter)
-				  begin
-						casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})
-  						3'b0xx:	  counter <= #1 5'b01101;     // 1 stop bit ok igor
-  						3'b100:	  counter <= #1 5'b10101;     // 1.5 stop bit
-  						default:	  counter <= #1 5'b11101;     // 2 stop bits
-						endcase
-					end
-				else
-				if (counter == 5'b00001)
-				begin
-					counter <= #1 0;
-					tstate <= #1 s_idle;
-				end
-				else
-					counter <= #1 counter - 1'b1;
-				stx_o_tmp <= #1 1'b1;
-			end
-
-		default : // should never get here
-			tstate <= #1 s_idle;
-	endcase
-  end // end if enable
-  else
-    tf_pop <= #1 1'b0;  // tf_pop must be 1 cycle width
-end // transmitter logic
-
-assign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;    // Break condition
-	
-endmodule
diff --git a/source/v/uart_wb.r101.v b/source/v/uart_wb.r101.v
deleted file mode 100755
index 373686c70f0984556fbd52142a6bfc1a642e18dd..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r101.v
+++ /dev/null
@@ -1,317 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.15  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.12  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-assign wb_adr_int = wb_adr_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-reg [1:0] wb_adr_int_lsb;
-
-always @(wb_sel_is or wb_dat_is)
-begin
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-  `ifdef LITLE_ENDIAN
-	case (wb_sel_is)
-		4'b0001 : wb_adr_int_lsb = 2'h0;
-		4'b0010 : wb_adr_int_lsb = 2'h1;
-		4'b0100 : wb_adr_int_lsb = 2'h2;
-		4'b1000 : wb_adr_int_lsb = 2'h3;
-		default : wb_adr_int_lsb = 2'h0;
-	endcase // case(wb_sel_i)
-  `else
-	case (wb_sel_is)
-		4'b0001 : wb_adr_int_lsb = 2'h3;
-		4'b0010 : wb_adr_int_lsb = 2'h2;
-		4'b0100 : wb_adr_int_lsb = 2'h1;
-		4'b1000 : wb_adr_int_lsb = 2'h0;
-		default : wb_adr_int_lsb = 2'h0;
-	endcase // case(wb_sel_i)
-  `endif
-end
-
-assign wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], wb_adr_int_lsb};
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r106.v b/source/v/uart_wb.r106.v
deleted file mode 100755
index 373686c70f0984556fbd52142a6bfc1a642e18dd..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r106.v
+++ /dev/null
@@ -1,317 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.16  2002/07/29 21:16:18  gorban
-// The uart_defines.v file is included again in sources.
-//
-// Revision 1.15  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.12  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-assign wb_adr_int = wb_adr_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-reg [1:0] wb_adr_int_lsb;
-
-always @(wb_sel_is or wb_dat_is)
-begin
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-  `ifdef LITLE_ENDIAN
-	case (wb_sel_is)
-		4'b0001 : wb_adr_int_lsb = 2'h0;
-		4'b0010 : wb_adr_int_lsb = 2'h1;
-		4'b0100 : wb_adr_int_lsb = 2'h2;
-		4'b1000 : wb_adr_int_lsb = 2'h3;
-		default : wb_adr_int_lsb = 2'h0;
-	endcase // case(wb_sel_i)
-  `else
-	case (wb_sel_is)
-		4'b0001 : wb_adr_int_lsb = 2'h3;
-		4'b0010 : wb_adr_int_lsb = 2'h2;
-		4'b0100 : wb_adr_int_lsb = 2'h1;
-		4'b1000 : wb_adr_int_lsb = 2'h0;
-		default : wb_adr_int_lsb = 2'h0;
-	endcase // case(wb_sel_i)
-  `endif
-end
-
-assign wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], wb_adr_int_lsb};
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r27.v b/source/v/uart_wb.r27.v
deleted file mode 100755
index 64be28cf10ebcd21a49f1e00298d0c44b23139b9..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r27.v
+++ /dev/null
@@ -1,125 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_TX_FIFO.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 Jacob Gorban, gorban@opencores.org        ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-`include "timescale.v"
-
-module uart_wb (clk,
-        wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
-	we_o, re_o // Write and read enable output for the core
-	
-        );
-
-input				clk;
-
-// WISHBONE interface	
-input				wb_rst_i;
-input				wb_we_i;
-input				wb_stb_i;
-input				wb_cyc_i;
-output				wb_ack_o;
-output				we_o;
-output				re_o;
-
-wire				we_o;
-reg				wb_ack_o;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		wb_ack_o <= #1 1'b0;
-	end
-	else
-	begin
-//		wb_ack_o <= #1 wb_stb_i & wb_cyc_i; // 1 clock wait state on all transfers
-		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
-	end
-end
-
-assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
-assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
-
-endmodule
diff --git a/source/v/uart_wb.r29.v b/source/v/uart_wb.r29.v
deleted file mode 100755
index b9cecd5a9f611983061f86e8ee47cd23dc73dba9..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r29.v
+++ /dev/null
@@ -1,134 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_TX_FIFO.v                                              ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-`include "timescale.v"
-
-module uart_wb (clk,
-        wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
-	we_o, re_o // Write and read enable output for the core
-	
-        );
-
-input				clk;
-
-// WISHBONE interface	
-input				wb_rst_i;
-input				wb_we_i;
-input				wb_stb_i;
-input				wb_cyc_i;
-output				wb_ack_o;
-output				we_o;
-output				re_o;
-
-wire				we_o;
-reg				wb_ack_o;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		wb_ack_o <= #1 1'b0;
-	end
-	else
-	begin
-//		wb_ack_o <= #1 wb_stb_i & wb_cyc_i; // 1 clock wait state on all transfers
-		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
-	end
-end
-
-assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
-assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
-
-endmodule
diff --git a/source/v/uart_wb.r33.v b/source/v/uart_wb.r33.v
deleted file mode 100755
index 2f5d8ac8434b0af9136ec560392b709b391d4149..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r33.v
+++ /dev/null
@@ -1,140 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-module uart_wb (clk,
-        wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
-	we_o, re_o // Write and read enable output for the core
-	
-        );
-
-input				clk;
-
-// WISHBONE interface	
-input				wb_rst_i;
-input				wb_we_i;
-input				wb_stb_i;
-input				wb_cyc_i;
-output				wb_ack_o;
-output				we_o;
-output				re_o;
-
-wire				we_o;
-reg				wb_ack_o;
-
-always @(posedge clk or posedge wb_rst_i)
-begin
-	if (wb_rst_i)
-	begin
-		wb_ack_o <= #1 1'b0;
-	end
-	else
-	begin
-//		wb_ack_o <= #1 wb_stb_i & wb_cyc_i; // 1 clock wait state on all transfers
-		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
-	end
-end
-
-assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
-assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
-
-endmodule
diff --git a/source/v/uart_wb.r48.v b/source/v/uart_wb.r48.v
deleted file mode 100755
index 51519bb776cb17018fa4e394a9c6e13bcfc43a80..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r48.v
+++ /dev/null
@@ -1,201 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o,
-	wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-`endif
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) 
-		wb_ack_o <= #1 1'b0;
-	else 
-		wb_ack_o <= #1 wb_stb_i & wb_cyc_i & ~wb_ack_o; // 1 clock wait state on all transfers
-
-assign we_o =  wb_we_i & wb_cyc_i & wb_stb_i; //WE for registers	
-assign re_o = ~wb_we_i & wb_cyc_i & wb_stb_i; //RE for registers	
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_i)
-	wb_dat8_i = wb_dat_i;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_i)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-			// later add here selects for 16 and 32 bits
-		endcase // case(wb_sel_i)
-
-// handle input (this will add a little timing overhead on input but it should asynchronous
-// or another one clock delay will be introduced)
-always @(wb_sel_i or wb_dat_i)
-	case (wb_sel_i)
-		4'b0001 : wb_dat8_i = wb_dat_i[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_i[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_i[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_i[31:24];
-		default : wb_dat8_i = wb_dat_i[7:0];
-	endcase // case(wb_sel_i)
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r50.v b/source/v/uart_wb.r50.v
deleted file mode 100755
index 37784505e3bee3784b70a3cf7a254a6b7b363b36..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r50.v
+++ /dev/null
@@ -1,267 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wb_ack; // wb_ack is sampled to make 2 clock wait state between transfers 
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-assign wb_adr_int = wb_adr_is;
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-always @(wb_sel_is or wb_dat_is)
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r64.v b/source/v/uart_wb.r64.v
deleted file mode 100755
index 008713515af738901b6f42bb897c4cc6b2d9a2b7..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r64.v
+++ /dev/null
@@ -1,271 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-assign wb_adr_int = wb_adr_is;
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-always @(wb_sel_is or wb_dat_is)
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r73.v b/source/v/uart_wb.r73.v
deleted file mode 100755
index 34cfcf4ccb970e5dd0c779e40c00e50400c8c6a9..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r73.v
+++ /dev/null
@@ -1,285 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-assign wb_adr_int = wb_adr_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-always @(wb_sel_is or wb_dat_is)
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-reg [1:0] adr2 ; // lower 2 bits of regenerated address
-always @(wb_sel_is)
-	case (wb_sel_is)
-		4'b0001 : adr2 = 2'b00;
-		4'b0010 : adr2 = 2'b01;
-		4'b0100 : adr2 = 2'b10;
-		4'b1000 : adr2 = 2'b11;
-		default : adr2 = 2'b0;
-	endcase // case(wb_sel_is)
-		
-assign 	 wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], adr2};
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r75.v b/source/v/uart_wb.r75.v
deleted file mode 100755
index abe62710e1f30fc98c2c3d942085974137820b7b..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r75.v
+++ /dev/null
@@ -1,295 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.13  2002/02/07 16:20:20  gorban
-// major bug in 32-bit mode that prevented register access fixed.
-//
-// Revision 1.12  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-assign wb_adr_int = wb_adr_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-always @(wb_sel_is or wb_dat_is)
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-reg [1:0] adr2 ; // lower 2 bits of regenerated address
-always @(wb_sel_is)
-	case (wb_sel_is)
-    `ifdef BIG_BYTE_ENDIAN
-		4'b0001 : adr2 = 2'b11;
-		4'b0010 : adr2 = 2'b10;
-		4'b0100 : adr2 = 2'b01;
-		4'b1000 : adr2 = 2'b00;
-    `else
-		4'b0001 : adr2 = 2'b00;
-		4'b0010 : adr2 = 2'b01;
-		4'b0100 : adr2 = 2'b10;
-		4'b1000 : adr2 = 2'b11;
-    `endif
-		default : adr2 = 2'b0;
-	endcase // case(wb_sel_is)
-		
-assign 	 wb_adr_int = {wb_adr_is[`UART_ADDR_WIDTH-1:2], adr2};
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r79.v b/source/v/uart_wb.r79.v
deleted file mode 100755
index 7bbb02290b913ff157240716c80e861ff2698852..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r79.v
+++ /dev/null
@@ -1,274 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.12  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-//`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-assign wb_adr_int = wb_adr_is;
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-always @(wb_sel_is or wb_dat_is)
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/source/v/uart_wb.r84.v b/source/v/uart_wb.r84.v
deleted file mode 100755
index b0d22433927504184d14babc6552b40c26077a4c..0000000000000000000000000000000000000000
--- a/source/v/uart_wb.r84.v
+++ /dev/null
@@ -1,290 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  uart_wb.v                                                   ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the "UART 16550 compatible" project    ////
-////  http://www.opencores.org/cores/uart16550/                   ////
-////                                                              ////
-////  Documentation related to this project:                      ////
-////  - http://www.opencores.org/cores/uart16550/                 ////
-////                                                              ////
-////  Projects compatibility:                                     ////
-////  - WISHBONE                                                  ////
-////  RS232 Protocol                                              ////
-////  16550D uart (mostly supported)                              ////
-////                                                              ////
-////  Overview (main Features):                                   ////
-////  UART core WISHBONE interface.                               ////
-////                                                              ////
-////  Known problems (limits):                                    ////
-////  Inserts one wait state on all transfers.                    ////
-////  Note affected signals and the way they are affected.        ////
-////                                                              ////
-////  To Do:                                                      ////
-////  Nothing.                                                    ////
-////                                                              ////
-////  Author(s):                                                  ////
-////      - gorban@opencores.org                                  ////
-////      - Jacob Gorban                                          ////
-////      - Igor Mohor (igorm@opencores.org)                      ////
-////                                                              ////
-////  Created:        2001/05/12                                  ////
-////  Last Updated:   2001/05/17                                  ////
-////                  (See log for the revision history)          ////
-////                                                              ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000, 2001 Authors                             ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.15  2002/07/22 23:02:23  gorban
-// Bug Fixes:
-//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
-//   Problem reported by Kenny.Tung.
-//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
-//
-// Improvements:
-//  * Made FIFO's as general inferrable memory where possible.
-//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
-//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
-//
-//  * Added optional baudrate output (baud_o).
-//  This is identical to BAUDOUT* signal on 16550 chip.
-//  It outputs 16xbit_clock_rate - the divided clock.
-//  It's disabled by default. Define UART_HAS_BAUDRATE_OUTPUT to use.
-//
-// Revision 1.12  2001/12/19 08:03:34  mohor
-// Warnings cleared.
-//
-// Revision 1.11  2001/12/06 14:51:04  gorban
-// Bug in LSR[0] is fixed.
-// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
-//
-// Revision 1.10  2001/12/03 21:44:29  gorban
-// Updated specification documentation.
-// Added full 32-bit data bus interface, now as default.
-// Address is 5-bit wide in 32-bit data bus mode.
-// Added wb_sel_i input to the core. It's used in the 32-bit mode.
-// Added debug interface with two 32-bit read-only registers in 32-bit mode.
-// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
-// My small test bench is modified to work with 32-bit mode.
-//
-// Revision 1.9  2001/10/20 09:58:40  gorban
-// Small synopsis fixes
-//
-// Revision 1.8  2001/08/24 21:01:12  mohor
-// Things connected to parity changed.
-// Clock devider changed.
-//
-// Revision 1.7  2001/08/23 16:05:05  mohor
-// Stop bit bug fixed.
-// Parity bug fixed.
-// WISHBONE read cycle bug fixed,
-// OE indicator (Overrun Error) bug fixed.
-// PE indicator (Parity Error) bug fixed.
-// Register read bug fixed.
-//
-// Revision 1.4  2001/05/31 20:08:01  gorban
-// FIFO changes and other corrections.
-//
-// Revision 1.3  2001/05/21 19:12:01  gorban
-// Corrected some Linter messages.
-//
-// Revision 1.2  2001/05/17 18:34:18  gorban
-// First 'stable' release. Should be sythesizable now. Also added new header.
-//
-// Revision 1.0  2001-05-17 21:27:13+02  jacob
-// Initial revision
-//
-//
-
-// UART core WISHBONE interface 
-//
-// Author: Jacob Gorban   (jacob.gorban@flextronicssemi.com)
-// Company: Flextronics Semiconductor
-//
-
-// synopsys translate_off
-`include "timescale.v"
-// synopsys translate_on
-`include "uart_defines.v"
- 
-module uart_wb (clk, wb_rst_i, 
-	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_adr_i,
-	wb_adr_int, wb_dat_i, wb_dat_o, wb_dat8_i, wb_dat8_o, wb_dat32_o, wb_sel_i,
-	we_o, re_o // Write and read enable output for the core
-);
-
-input 		  clk;
-
-// WISHBONE interface	
-input 		  wb_rst_i;
-input 		  wb_we_i;
-input 		  wb_stb_i;
-input 		  wb_cyc_i;
-input [3:0]   wb_sel_i;
-input [`UART_ADDR_WIDTH-1:0] 	wb_adr_i; //WISHBONE address line
-
-`ifdef DATA_BUS_WIDTH_8
-input [7:0]  wb_dat_i; //input WISHBONE bus 
-output [7:0] wb_dat_o;
-reg [7:0] 	 wb_dat_o;
-wire [7:0] 	 wb_dat_i;
-reg [7:0] 	 wb_dat_is;
-`else // for 32 data bus mode
-input [31:0]  wb_dat_i; //input WISHBONE bus 
-output [31:0] wb_dat_o;
-reg [31:0] 	  wb_dat_o;
-wire [31:0]   wb_dat_i;
-reg [31:0] 	  wb_dat_is;
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-output [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-input [7:0]   wb_dat8_o; // internal 8 bit output to be put into wb_dat_o
-output [7:0]  wb_dat8_i;
-input [31:0]  wb_dat32_o; // 32 bit data output (for debug interface)
-output 		  wb_ack_o;
-output 		  we_o;
-output 		  re_o;
-
-wire 			  we_o;
-reg 			  wb_ack_o;
-reg [7:0] 	  wb_dat8_i;
-wire [7:0] 	  wb_dat8_o;
-wire [`UART_ADDR_WIDTH-1:0]	wb_adr_int; // internal signal for address bus
-reg [`UART_ADDR_WIDTH-1:0]	wb_adr_is;
-reg 								wb_we_is;
-reg 								wb_cyc_is;
-reg 								wb_stb_is;
-reg [3:0] 						wb_sel_is;
-wire [3:0]   wb_sel_i;
-reg 			 wre ;// timing control signal for write or read enable
-
-// wb_ack_o FSM
-reg [1:0] 	 wbstate;
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_ack_o <= #1 1'b0;
-		wbstate <= #1 0;
-		wre <= #1 1'b1;
-	end else
-		case (wbstate)
-			0: begin
-				if (wb_stb_is & wb_cyc_is) begin
-					wre <= #1 0;
-					wbstate <= #1 1;
-					wb_ack_o <= #1 1;
-				end else begin
-					wre <= #1 1;
-					wb_ack_o <= #1 0;
-				end
-			end
-			1: begin
-			   wb_ack_o <= #1 0;
-				wbstate <= #1 2;
-				wre <= #1 0;
-			end
-			2,3: begin
-				wb_ack_o <= #1 0;
-				wbstate <= #1 0;
-				wre <= #1 0;
-			end
-		endcase
-
-assign we_o =  wb_we_is & wb_stb_is & wb_cyc_is & wre ; //WE for registers	
-assign re_o = ~wb_we_is & wb_stb_is & wb_cyc_is & wre ; //RE for registers	
-
-// Sample input signals
-always  @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i) begin
-		wb_adr_is <= #1 0;
-		wb_we_is <= #1 0;
-		wb_cyc_is <= #1 0;
-		wb_stb_is <= #1 0;
-		wb_dat_is <= #1 0;
-		wb_sel_is <= #1 0;
-	end else begin
-		wb_adr_is <= #1 wb_adr_i;
-		wb_we_is <= #1 wb_we_i;
-		wb_cyc_is <= #1 wb_cyc_i;
-		wb_stb_is <= #1 wb_stb_i;
-		wb_dat_is <= #1 wb_dat_i;
-		wb_sel_is <= #1 wb_sel_i;
-	end
-
-assign wb_adr_int = wb_adr_is;
-
-`ifdef DATA_BUS_WIDTH_8 // 8-bit data bus
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else
-		wb_dat_o <= #1 wb_dat8_o;
-
-always @(wb_dat_is)
-	wb_dat8_i = wb_dat_is;
-
-`else // 32-bit bus
-// put output to the correct byte in 32 bits using select line
-always @(posedge clk or posedge wb_rst_i)
-	if (wb_rst_i)
-		wb_dat_o <= #1 0;
-	else if (re_o)
-		case (wb_sel_is)
-			4'b0001: wb_dat_o <= #1 {24'b0, wb_dat8_o};
-			4'b0010: wb_dat_o <= #1 {16'b0, wb_dat8_o, 8'b0};
-			4'b0100: wb_dat_o <= #1 {8'b0, wb_dat8_o, 16'b0};
-			4'b1000: wb_dat_o <= #1 {wb_dat8_o, 24'b0};
-			4'b1111: wb_dat_o <= #1 wb_dat32_o; // debug interface output
- 			default: wb_dat_o <= #1 0;
-		endcase // case(wb_sel_i)
-
-always @(wb_sel_is or wb_dat_is)
-	case (wb_sel_is)
-		4'b0001 : wb_dat8_i = wb_dat_is[7:0];
-		4'b0010 : wb_dat8_i = wb_dat_is[15:8];
-		4'b0100 : wb_dat8_i = wb_dat_is[23:16];
-		4'b1000 : wb_dat8_i = wb_dat_is[31:24];
-		default : wb_dat8_i = wb_dat_is[7:0];
-	endcase // case(wb_sel_i)
-
-`endif // !`ifdef DATA_BUS_WIDTH_8
-
-endmodule
-
-
-
-
-
-
-
-
-
-
diff --git a/test/java/HelloWorld.java b/test/java/HelloWorld.java
deleted file mode 100644
index 49731c7ec8915efa84ecb2f4fd5860f14d80a7a4..0000000000000000000000000000000000000000
--- a/test/java/HelloWorld.java
+++ /dev/null
@@ -1,5 +0,0 @@
-public class HelloWorld {
-
-    public static void main (String args []);
-}
-
diff --git a/test/java/HelloWorld2.java b/test/java/HelloWorld2.java
deleted file mode 100644
index 49731c7ec8915efa84ecb2f4fd5860f14d80a7a4..0000000000000000000000000000000000000000
--- a/test/java/HelloWorld2.java
+++ /dev/null
@@ -1,5 +0,0 @@
-public class HelloWorld {
-
-    public static void main (String args []);
-}
-
diff --git a/test/java/HelloWorld3.java b/test/java/HelloWorld3.java
deleted file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0000000000000000000000000000000000000000
diff --git a/test/java/HelloWorld4.java b/test/java/HelloWorld4.java
deleted file mode 100644
index 49731c7ec8915efa84ecb2f4fd5860f14d80a7a4..0000000000000000000000000000000000000000
--- a/test/java/HelloWorld4.java
+++ /dev/null
@@ -1,5 +0,0 @@
-public class HelloWorld {
-
-    public static void main (String args []);
-}
-
diff --git a/test/java/LabelImpl-2.java b/test/java/LabelImpl-2.java
deleted file mode 100644
index a38be19c404ee8c8cc94348a7bf268b1fd9008b2..0000000000000000000000000000000000000000
--- a/test/java/LabelImpl-2.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.eclipse.gmf.gmfgraph.impl;
-
-import java.util.Collection;
-import org.eclipse.emf.common.notify.Notification;
-import org.eclipse.emf.common.notify.NotificationChain;
-import org.eclipse.emf.common.util.EList;
-import org.eclipse.emf.ecore.EClass;
-import org.eclipse.emf.ecore.EStructuralFeature;
-import org.eclipse.emf.ecore.InternalEObject;
-import org.eclipse.emf.ecore.impl.ENotificationImpl;
-import org.eclipse.emf.ecore.impl.EObjectImpl;
-import org.eclipse.emf.ecore.util.EObjectContainmentEList;
-import org.eclipse.emf.ecore.util.InternalEList;
-import org.eclipse.gmf.gmfgraph.ColorStyle;
-import org.eclipse.gmf.gmfgraph.Figure;
-import org.eclipse.gmf.gmfgraph.FigureMarker;
-import org.eclipse.gmf.gmfgraph.FontStyle;
-import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
-import org.eclipse.gmf.gmfgraph.Identity;
-import org.eclipse.gmf.gmfgraph.Label;
-import org.eclipse.gmf.gmfgraph.Point;
-import org.eclipse.gmf.gmfgraph.SizeStyle;
-public class LabelImpl extends EObjectImpl implements Label {
-    protected ColorStyle colorStyle = null;
-
-    protected EClass eStaticClass (); protected EList children = null;
-    protected FontStyle fontStyle = null;
-
-    protected LabelImpl () {
-    }
-
-    protected Point location = null;
-    protected Point size = null;
-    protected SizeStyle sizeStyle = null;
-    protected String layoutManager = LAYOUT_MANAGER_EDEFAULT;
-    protected String name = NAME_EDEFAULT;
-    protected String text = TEXT_EDEFAULT;
-    final protected static String LAYOUT_MANAGER_EDEFAULT = null;
-    final protected static String NAME_EDEFAULT = null;
-    final protected static String TEXT_EDEFAULT = null;
-
-    public ColorStyle getColorStyle ();
-    public EList getChildren ();
-    public Figure getParent ();
-    public FontStyle getFontStyle ();
-    public NotificationChain basicSetColorStyle (ColorStyle newColorStyle, NotificationChain msgs);
-    public NotificationChain basicSetFontStyle (FontStyle newFontStyle, NotificationChain msgs);
-    public NotificationChain basicSetLocation (Point newLocation, NotificationChain msgs);
-    public NotificationChain basicSetSize (Point newSize, NotificationChain msgs);
-    public NotificationChain basicSetSizeStyle (SizeStyle newSizeStyle, NotificationChain msgs);
-    public NotificationChain eBasicRemoveFromContainer (NotificationChain msgs);
-    public NotificationChain eInverseAdd (InternalEObject otherEnd, int featureID, Class baseClass, NotificationChain msgs);
-    public NotificationChain eInverseRemove (InternalEObject otherEnd, int featureID, Class baseClass, NotificationChain msgs);
-    public Object eGet (EStructuralFeature eFeature, boolean resolve);
-    public Point getLocation ();
-    public Point getSize ();
-    public SizeStyle getSizeStyle ();
-    public String getLayoutManager ();
-    public String getName ();
-    public String getText ();
-    public String toString ();
-    public boolean eIsSet (EStructuralFeature eFeature);
-    public int eBaseStructuralFeatureID (int derivedFeatureID, Class baseClass);
-    public int eDerivedStructuralFeatureID (int baseFeatureID, Class baseClass);
-    public void eSet (EStructuralFeature eFeature, Object newValue);
-    public void eUnset (EStructuralFeature eFeature);
-    public void setColorStyle (ColorStyle newColorStyle);
-    public void setFontStyle (FontStyle newFontStyle);
-    public void setLayoutManager (String newLayoutManager);
-    public void setLocation (Point newLocation);
-    public void setName (String newName);
-    public void setSize (Point newSize);
-    public void setSizeStyle (SizeStyle newSizeStyle);
-    public void setText (String newText);
-}
-
diff --git a/test/java/abc.java b/test/java/abc.java
deleted file mode 100644
index 2797c43238ea63d510f893c727b2918df450eede..0000000000000000000000000000000000000000
--- a/test/java/abc.java
+++ /dev/null
@@ -1,5 +0,0 @@
-public class abc {
-
-    public static void main (String args []);
-}
-
-- 
1.7.3.5


